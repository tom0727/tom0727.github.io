+++
title = '换根DP'
date = 2021-04-22T21:49:20+08:00
draft = false
categories = ['算法']
tags = ['树形DP', '换根DP']
+++

## 介绍

换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。

第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，**仅考虑 $u$ 的subtree**，求出这样的答案 $dp[u]$。

第二次DFS：令最终答案为 $ans[u]$，则可知 $ans[1] = dp[1]$。然后我们需要通过已知的 $ans[u]$，来推出它的child $ans[to]$ 的值。一般我们由 $ans[u]$ 来推导 $ans[to]$ 时，需要考虑到换根时 $to$ **子树内的贡献，和子树外的贡献** 变化。

## 例题

### 例1 [洛谷P3478 [POI2008]STA-Station](https://www.luogu.com.cn/problem/P3478)

{{% question 题意 %}}

给定 $n$ 个节点的树，求一个节点 $u$ 使得 $u$ 到其他节点的距离和最大。

即，求出 $u$，使得 $\sum\limits_v d(u,v)$ 最大。

{{% /question %}}

{{% fold "题解" %}}

首先固定 $1$ 为根，进行一次DFS。

令 `dp[u]` 为第一次DFS，只考虑 $u$ 的子树内的答案。（考虑深度和即可）

令 `ans[u]` 为最终答案，那么有 `ans[1] = dp[1]`。

<hr>

现在我们要从 $1$ 开始换根。

比如说，我们已知了 $u$ 的答案 $ans[u]$，我们就可以理解成：整棵树，以 $u$ 作为root的答案已经求出来了，怎么求出 $to$ 的答案？

![img](/images/045/1.jpg)

换根的过程是一个旋转的过程。我们把 $to$ 的子树向上旋转，将 $to$ 外面的部分（$u$ 和其他的子树）向下旋转。

则，向上旋转的部分，对于答案贡献了 `-sz[to]`（因为深度减少了），而向下旋转的部分，对于答案贡献了 `(n-sz[to])`。

所以，$ans[to] = ans[u] - sz[to] + (n - sz[to]);$

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6+5;

struct Edge {
    int to, nxt;
} edges[maxn<<1];
int n, head[maxn], ecnt = 1;

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

ll sz[maxn], dp[maxn];
void dfs1(int u, int p) {
    sz[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        sz[u] += sz[to];
        dp[u] += dp[to] + sz[to];
    }
}

ll ans[maxn];
void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ans[to] = ans[u] - sz[to] + ((ll)n - sz[to]);
        dfs2(to, u);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n-1; i++) {
        int u,v; cin >> u >> v;
        addEdge(u,v); addEdge(v,u);
    }
    dfs1(1, 0);
    ans[1] = dp[1];
    dfs2(1, 0);

    ll maxans = 0, idx = 0;
    for (int i = 1; i <= n; i++) {
        if (ans[i] > maxans) {
            maxans = ans[i];
            idx = i;
        }
    }
    cout << idx << endl;
}
```

{{% /fold %}}


### 例2 [CF1324F Maximum White Subtree](https://codeforces.com/contest/1324/problem/F)

{{% question 题意 %}}

给定 $n$ 个节点的树，每个节点有一个值 $1$ 或者 $-1$。

对于每一个节点 $i$，求 $i$ 所在的连通块中，最大的节点权值和？

{{% /question %}}

{{% fold "题解" %}}

首先固定 $1$ 为 root，进行一次DFS。

这样可以求出一个 `dp[u]`：代表以 $1$ 为root时，每个节点仅考虑其subtree，得到的最大值。

在第一次DFS的过程中，再维护一个数组 `bool used[]`，其中 `used[u] = 1` 代表 $u$ 的parent $p$ 的答案用到了 $u$ 的这个subtree。

<hr>

然后进行第二次DFS，计算出最终答案 `ans[]`。

首先有，`ans[1] = dp[1]`。

当我们在 `dfs2(u)` 时，在求一个child `to` 的答案 `ans[to]` 时，我们有两种选择：

1. `to` 不使用外面的节点：$ans[to] = \max(ans[to], dp[to])$
2. `to` 使用外面的节点：分两种情况讨论
   
   1. 如果 `to` 已经被包含在 $u$ 的答案中了（`used[to] = 1`），则 $ans[to] = \max(ans[to], ans[u])$
   2. 如果 `to` 并没有被包含在 $u$ 的答案中，（`used[to] = 0`），那么 `to` 的最终答案，就是由 $to$ 的subtree 和 外面节点的合并而来。即 $ans[to] = \max(ans[to], ans[u] + dp[to])$

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+5;

struct Edge {
    int to, nxt;
} edges[maxn<<1];
int n, head[maxn], ecnt = 1, val[maxn];

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

int dp[maxn];
bool used[maxn];  // when calculating answer, whether used[u] is taken into consideration
void dfs1(int u, int p) {
    dp[u] = val[u];
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        if (dp[to] > 0) dp[u] += dp[to], used[to] = 1;
    }
}

int ans[maxn];
void dfs2(int u, int p) {
    ans[u] = max(ans[u], dp[u]);
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        if (used[to]) ans[to] = max(ans[to], ans[u]);
        else ans[to] = max(ans[to], ans[u] + dp[to]);
        dfs2(to, u);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
        if (val[i] == 0) val[i] = -1;
    }
    for (int i = 1; i <= n-1; i++) {
        int u,v; cin >> u >> v;
        addEdge(u,v); addEdge(v,u);
    }
    fill(ans, ans+maxn, -1e9);
    dfs1(1,0);
    dfs2(1,0);
    for (int i = 1; i <= n; i++) cout << ans[i] << " ";
    cout << endl;
}
```

{{% /fold %}}
