+++
title = '换根DP'
date = 2021-04-22T21:49:20+08:00
draft = false
categories = ['算法']
tags = ['树形DP', '换根DP']
+++

## 介绍

换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。

第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，**仅考虑 $u$ 的subtree**，求出这样的答案 $dp[u]$。

第二次DFS：令最终答案为 $ans[u]$，则可知 $ans[1] = dp[1]$。然后我们需要通过已知的 $ans[u]$，来推出它的child $ans[to]$ 的值。一般我们由 $ans[u]$ 来推导 $ans[to]$ 时，需要考虑到换根时 $to$ **子树内的贡献，和子树外的贡献** 变化。

## 例题

### 例1 [洛谷P3478 [POI2008]STA-Station](https://www.luogu.com.cn/problem/P3478)

{{% question 题意 %}}

给定 $n$ 个节点的树，求一个节点 $u$ 使得 $u$ 到其他节点的距离和最大。

即，求出 $u$，使得 $\sum\limits_v d(u,v)$ 最大。

{{% /question %}}

{{% fold "题解" %}}

首先固定 $1$ 为根，进行一次DFS。

令 `dp[u]` 为第一次DFS，只考虑 $u$ 的子树内的答案。（考虑深度和即可）

令 `ans[u]` 为最终答案，那么有 `ans[1] = dp[1]`。

<hr>

现在我们要从 $1$ 开始换根。

比如说，我们已知了 $u$ 的答案 $ans[u]$，我们就可以理解成：整棵树，以 $u$ 作为root的答案已经求出来了，怎么求出 $to$ 的答案？

![img](/images/045/1.jpg)

换根的过程是一个旋转的过程。我们把 $to$ 的子树向上旋转，将 $to$ 外面的部分（$u$ 和其他的子树）向下旋转。

则，向上旋转的部分，对于答案贡献了 `-sz[to]`（因为深度减少了），而向下旋转的部分，对于答案贡献了 `(n-sz[to])`。

所以，$ans[to] = ans[u] - sz[to] + (n - sz[to]);$

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6+5;

struct Edge {
    int to, nxt;
} edges[maxn<<1];
int n, head[maxn], ecnt = 1;

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

ll sz[maxn], dp[maxn];
void dfs1(int u, int p) {
    sz[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        sz[u] += sz[to];
        dp[u] += dp[to] + sz[to];
    }
}

ll ans[maxn];
void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ans[to] = ans[u] - sz[to] + ((ll)n - sz[to]);
        dfs2(to, u);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n-1; i++) {
        int u,v; cin >> u >> v;
        addEdge(u,v); addEdge(v,u);
    }
    dfs1(1, 0);
    ans[1] = dp[1];
    dfs2(1, 0);

    ll maxans = 0, idx = 0;
    for (int i = 1; i <= n; i++) {
        if (ans[i] > maxans) {
            maxans = ans[i];
            idx = i;
        }
    }
    cout << idx << endl;
}
```

{{% /fold %}}


### 例2 [CF1324F Maximum White Subtree](https://codeforces.com/contest/1324/problem/F)

{{% question 题意 %}}

给定 $n$ 个节点的树，每个节点有一个值 $1$ 或者 $-1$。

对于每一个节点 $i$，求 $i$ 所在的连通块中，最大的节点权值和？

{{% /question %}}

{{% fold "题解" %}}

首先固定 $1$ 为 root，进行一次DFS。

这样可以求出一个 `dp[u]`：代表以 $1$ 为root时，每个节点仅考虑其subtree，得到的最大值。

在第一次DFS的过程中，再维护一个数组 `bool used[]`，其中 `used[u] = 1` 代表 $u$ 的parent $p$ 的答案用到了 $u$ 的这个subtree。

<hr>

然后进行第二次DFS，计算出最终答案 `ans[]`。

首先有，`ans[1] = dp[1]`。

当我们在 `dfs2(u)` 时，在求一个child `to` 的答案 `ans[to]` 时，我们有两种选择：

1. `to` 不使用外面的节点：$ans[to] = \max(ans[to], dp[to])$
2. `to` 使用外面的节点：分两种情况讨论
   
   1. 如果 `to` 已经被包含在 $u$ 的答案中了（`used[to] = 1`），则 $ans[to] = \max(ans[to], ans[u])$
   2. 如果 `to` 并没有被包含在 $u$ 的答案中，（`used[to] = 0`），那么 `to` 的最终答案，就是由 $to$ 的subtree 和 外面节点的合并而来。即 $ans[to] = \max(ans[to], ans[u] + dp[to])$

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+5;

struct Edge {
    int to, nxt;
} edges[maxn<<1];
int n, head[maxn], ecnt = 1, val[maxn];

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

int dp[maxn];
bool used[maxn];  // when calculating answer, whether used[u] is taken into consideration
void dfs1(int u, int p) {
    dp[u] = val[u];
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        if (dp[to] > 0) dp[u] += dp[to], used[to] = 1;
    }
}

int ans[maxn];
void dfs2(int u, int p) {
    ans[u] = max(ans[u], dp[u]);
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        if (used[to]) ans[to] = max(ans[to], ans[u]);
        else ans[to] = max(ans[to], ans[u] + dp[to]);
        dfs2(to, u);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
        if (val[i] == 0) val[i] = -1;
    }
    for (int i = 1; i <= n-1; i++) {
        int u,v; cin >> u >> v;
        addEdge(u,v); addEdge(v,u);
    }
    fill(ans, ans+maxn, -1e9);
    dfs1(1,0);
    dfs2(1,0);
    for (int i = 1; i <= n; i++) cout << ans[i] << " ";
    cout << endl;
}
```

{{% /fold %}}

### 例3 [洛谷P6419 [COCI2014-2015#1] Kamp](https://www.luogu.com.cn/problem/P6419)

{{% question 题意 %}}

给定 $n$ 个节点的树。经过每条边都需要时间 $w_i$。

有 $K$ 个人，初始在 $K$ 个不同的点，他们要集中在一个点聚会。

聚会结束后，一辆车从聚会点出发（装上所有人），把这 $K$ 个人分别送回去。

求：如果聚会点在 $i$，则将这些人都送回去，所需最少的时间？

输出对于所有 $i = 1$ ~ $n$ 的结果。

其中，$1 \leq K \leq n \leq 5 \times 10^5, 1 \leq w \leq 10^8$。

{{% /question %}}


{{% fold "题解" %}}

换根DP首先考虑：如果以 $1$ 作为根，怎么求出 $1$ 的答案？

• 以下，所有初始点我们都打上标记。

令 $sz[u]$ 为：$u$ 的 subtree（以 $1$ 为根的版本）中，标记点的数量。

令 $dp[u]$ 为：从 $u$ 出发，**经过 $u$ 的 subtree（以 $1$ 为根的版本） 所有标记点**，**再回到 $u$**，所需的最少时间（如果子树内无标记，则为0）。

那么通过第一次DFS，我们可以求出整个dp数组。

```cpp
if (sz[to])
    dp[u] += dp[to] + 2*w;
```

<hr>

有了 $dp[1]$，我们还需要一个 $d[u]$，代表以 $u$ 为根的子树（以 $1$ 为根的版本）**最长的链的长度**。

同时我们再记录 $f[u]$：代表以u为根，包含了最长链的直接child $to$ 的编号。

最后 $1$ 对应的答案是：$dp[1] - d[1]$。（因为送到最长链，就不用再回到 $1$ 了）。

<hr>

现在问题是，已知 $1$ 的答案，我们需要求出其他点的答案。

令 $ans[u]$ 为：从 $u$ 出发，**经过整棵树的所有标记点**，**再回到 $u$**，所需的最少时间。

易证 $ans[1] = dp[1]$。

然后进行第二次DFS，我们需要改变 $d[u]$ 的意义：此时 $d[u]$ 代表从 $u$ 出发的最长链的长度（**以整棵树而言**）。

同时，我们再维护一个数组 $s[u]$，代表从 $u$ 出发的**第二长链的长度**（**以整棵树而言**），并且第二长链必须和最长链 **不在同一个子树内**（这里的子树指，以 $u$ 为根的判断标准）。

我们在从 $u$ 转移到 $to$ 的时候，就有以下的几种情况：

1. $to$ 内无标记：
   
   先从 $to$ 走到 $u$，访问所有的点，再从 $u$ 回到 $to$。
   ```cpp
   ans[to] = ans[u] + 2LL * w;
   d[to] = d[u] + w;  // 现在，d[] 表示全局的链
   ```
2. $to$ 里面包含了整棵树的所有标记点：
   
   最终答案就 等于 以 $to$ 为根，subtree的答案。
   ```cpp
   ans[to] = dp[to];
   ```
3. $to$ 里面包含了标记，外面也包含了标记：

   那么对于整棵树而言，从 $to$ 出发，还是从 $u$ 出发都一样。所以 `ans[to] = ans[u]`。

   但是我们需要更新最长链和次长链。这个时候，我们就要分类讨论 `f[u] = to` 与否。

   如果 $u$ 原本的最长链就不在 $to$ 的子树内，那么换根以后（旋转），$to$ 的最长链必然是 $to \rightarrow u \rightarrow f[u]$。

   如果 $u$ 原本用到的最长链是 $to$，而旋转后，$to$ 的最长链就有可能用到 $u$ 的其他子树（除了 $to$ 以外的子树），所以我们需要维护次长链 $s[u]$，并且进行比较。

   相应的，换根过程中，我们也要更新次长链 $s[to]$。

   ```cpp
    ans[to] = ans[u];
    if (f[u] != to) {  // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然继承 u 原来的最长链
        s[to] = d[to];
        d[to] = w + d[u];
        f[to] = u;
    } else {
        if (s[u] + w >= d[to]) {
            s[to] = d[to];
            d[to] = s[u] + w;
            f[to] = u;
        } else if (s[u] + w > s[to]) {
            s[to] = s[u] + w;
        }
    }

   ```



{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5+5;

int n, K, head[maxn], ecnt = 1;
bool tag[maxn];
struct Edge {
    int to, nxt, w;
} edges[maxn<<1];

void addEdge(int u, int v, int w) {
    Edge e = {v, head[u], w};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

ll dp[maxn];  // dp[u]: 从u出发，只考虑其subtree中有标记的点，再回到u，得到的答案（如果子树内无标记，则为0）
ll ans[maxn];  // 从u出发，送完所有人，再回到u得到的答案
ll d[maxn];  // d[u]: 以u为根的子树内，最长的链的长度
ll s[maxn];  // s[u]: 以u为根的子树内，次长的链的长度 (不能和d所在的子树相同)
ll f[maxn];  // f[u]: 以u为根，包含了最深的有标记节点的to编号
int sz[maxn];  // sz[u]: 以u为根的subtree里的标记点数量

void chmax(int u, ll val) {
    if (val > d[u]) {
        s[u] = d[u];
        d[u] = val;
    } else {
        if (val > s[u]) s[u] = val;
    }
}

void dfs1(int u, int p) {
    if (tag[u]) {
        sz[u] = 1;
        d[u] = 0;
        s[u] = -1e15;
    } else {
        d[u] = s[u] = -1e15;
    }
    
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ll w = edges[e].w;

        dfs1(to, u);
        if (!sz[to]) continue;  // 子树内无标记

        dp[u] += dp[to] + 2LL*w;
        sz[u] += sz[to];

        if (d[to] + w >= d[u]) {
            s[u] = d[u];
            d[u] = d[to] + w;
            f[u] = to;
        } else if (d[to] + w > s[u]) {
            s[u] = d[to] + w;
        }
    }
}

void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        ll w = edges[e].w;
        if (to == p) continue;
        if (!sz[to]) {  // to 里面没有标记点
            ans[to] = ans[u] + 2LL * w;
            d[to] = d[u] + w;  // 现在，d[] 表示全局的链
        } else if (K - sz[to] == 0) {  // to 里面全是标记点
            ans[to] = dp[to];
            // 无需更新最长/次长链
        } else {  // 里外都有标记
            ans[to] = ans[u];
            if (f[u] != to) {  // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然出现在 u 所在的子树里
                s[to] = d[to];
                d[to] = w + d[u];
                f[to] = u;
            } else {
                if (s[u] + w >= d[to]) {
                    s[to] = d[to];
                    d[to] = s[u] + w;
                    f[to] = u;
                } else if (s[u] + w > s[to]) {
                    s[to] = s[u] + w;
                }
            }
        }
        dfs2(to, u);
    }
}

int main() {
    cin >> n >> K;
    for (int i = 1; i <= n-1; i++) {
        int u,v,w; cin >> u >> v >> w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    for (int i = 1; i <= K; i++) {
        int a; cin >> a;
        tag[a] = 1;
    }
    dfs1(1,0);
    ans[1] = dp[1];
    dfs2(1,0);

    for (int i = 1; i <= n; i++) cout << ans[i] - d[i] << "\n";
}
```

{{% /fold %}}
