+++
title = '二分图'
date = 2021-05-30T22:31:30+08:00
draft = false
categories = ['算法']
tags = ['二分图']
+++

## 定义

二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。

## 性质

1. 二分图 $\iff$ 图中**没有奇环**（指节点个数为奇数的环） $\iff$ 可以进行二分图染色



## 二分图染色

给定一个二分图，我们可以仅用两种颜色将每个节点染上色，并且保证每个 edge 的两端颜色一定不同。

同理，如果一个图可以进行二分图染色，那么它就是一个二分图（这用于 **判断一个图是否为二分图**）

染色的方法：用 DFS 即可。（记得要从每个节点都开始 DFS 一次）

1. 随机选择一个点 $u$ 作为出发点，它的颜色为 $c_u = 0$。
2. 看它的 neighbor $v$ 的颜色，如果等于 $c_u$ ^ $1$，或者没染色，就染成 $c_u$ ^ $1$。否则的话产生冲突，说明这不是二分图。

## 例题

### 例1 [CF741C Arpa’s overnight party and Mehrdad’s silent entering](https://www.luogu.com.cn/problem/CF741C)

{{% question 题意 %}}

给定 $n$ 对情侣 $(a_i, b_i)$（$a_i, b_i \in [1,2n]$），总共有 $2n$ 个人，每个人的编号是从 $1$ 到 $2n$。现在有 $2$ 种食物（$1$ 或者 $2$），求一种分配方式使得：

1. 每对情侣 $(a_i, b_i)$ 不能吃同一种食物。
2. 相邻的 $3$ 个编号，食物不能完全相同。（编号是环形的，这意味着 $2n, 1, 2$ 也算是相邻的 $3$ 个人）。

如果无解，输出 $-1$。

其中，$1 \leq n \leq 10^5$。

{{% /question %}}

{{% fold "题解" %}}

每对情侣 $(a_i, b_i)$ 的食物不同，让我们想到二分图。但是第二个条件怎么办？

直觉上来说，这个题一定是有解的。

所以，我们可以做一个特殊的限制，直接强制 $2i-1, 2i$ 的食物不同，这个条件就满足了。

接下来我们要证明，将第二个限制条件转化以后，仍然有解。

<hr>

对于这个模型建图，将每个人作为一个节点，每对情侣 $(a_i, b_i)$ 作为一条边连起来。然后再将 $(2i-1, 2i)$ 作为一条边连起来。

那么只要这个图是**二分图**，就有解。（因为二分图保证了每条边两端的颜色不同）

如果图中有环，那么必然是由 $x$ 对情侣组成的一个环。所以环的节点数量为 $2x$。所以不可能有奇环。所以这个图是二分图。

所以建完图以后，跑一个二分图染色即可。

• 注意，二分图染色的 DFS 要从每一个节点都开始一次。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5+5;
const int maxm = 1e6;

int n;
struct Edge {
    int to, nxt;
} edges[maxn<<1];
int head[maxn], ecnt = 1;
int color[maxn];

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    edges[ecnt] = e;
    head[u] = ecnt++;
}
int a[maxn], b[maxn];
bool vis[maxn];
void dfs(int u) {
    if (vis[u]) return;
    vis[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        color[to] = color[u] ^ 1;
        dfs(to);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i] >> b[i];
        addEdge(a[i], b[i]);
        addEdge(b[i], a[i]);
    }
    for (int i = 1; i <= 2*n; i+=2) {
        addEdge(i, i+1);
        addEdge(i+1, i);
    }
    vis[1] = 1;
    for (int i = 1; i <= 2*n; i++) dfs(i);
    for (int i = 1; i <= n; i++) {
        if (!color[a[i]]) cout << 2 << " ";
        else cout << 1 << " ";

        if (!color[b[i]]) cout << 2 << "\n";
        else cout << 1 << "\n";
    }
}
```

{{% /fold %}}
