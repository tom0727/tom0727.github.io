+++
title = '网络流'
date = 2021-06-04T12:03:44+08:00
draft = false
categories = ['算法']
tags = ['网络流', '最大流']
+++


```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 203;
const int maxm = 5005;

int n,m,s,t;
ll adj[maxn][maxn];
int head[maxn], ecnt = 2, cur[maxn];  // ecnt 从 2 开始，方便取反向边
struct Edge {
    int to, nxt;
    ll w;
} edges[maxm<<1];

void addEdge(int u, int v, ll w) {
    Edge e = {v, head[u], w};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

int dis[maxn];
bool bfs() {
    queue<int> q;
    memset(dis, -1, sizeof(dis));
    memcpy(cur, head, sizeof(head));
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int e = head[u]; e; e = edges[e].nxt) {
            int to = edges[e].to;
            ll w = edges[e].w;
            if (dis[to] >= 0 || w == 0) continue;  // visited 或者 edge 已经不存在
            dis[to] = dis[u] + 1;
            q.push(to);
            if (to == t) return 1;  // 仍然存在增广路，直接返回
        }
    }
    return 0;
}

ll dfs(int u, ll in) {
    if (u == t) return in;  // 如果已经运到了终点，直接返回入量
    ll out = 0;
    for (int e = cur[u]; e; e = edges[e].nxt) {
        cur[u] = e;
        int to = edges[e].to;
        ll w = edges[e].w;
        if (dis[to] != dis[u] + 1 || w == 0) continue;  // 不是下一层 或者 edge已经不存在

        // 否则，可以往外运输流量
        ll res = dfs(to, min(in, w));
        in -= res;
        out += res;
        edges[e].w -= res;
        edges[e^1].w += res;

        if (in == 0) break;  // 如果已经没有可以向外流的了，直接 break
    }
    if (out == 0) dis[u] = -1;  // 说明当前节点已经不能向外运输流量了，忽略不计
    return out;
}

void add(int u, int v, ll w) {
    addEdge(u, v, w);
    addEdge(v, u, 0);
}

int main() {
    cin >> n >> m >> s >> t;
    for (int i = 1; i <= m; i++) {
        int u,v; ll w;
        cin >> u >> v >> w;
        adj[u][v] += w;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j) continue;
            if (adj[i][j]) {
                add(i, j, adj[i][j]);
            }
        }
    }
    ll ans = 0;
    while (bfs()) {
        ans += dfs(s, 1e18);
    }
    cout << ans << endl;
}
```


```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e3+5;
const int maxm = 5e4+5;

int n,m,s,t;
struct Edge {
    int to, nxt;
    ll w, c;
} edges[maxm<<1];
int head[maxn], ecnt = 2, cur[maxn];  // ecnt 从 2 开始，方便取反向边

void addEdge(int u, int v, ll w, ll c) {
    Edge e = {v, head[u], w, c};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll dis[maxn];
bool inq[maxn], vis[maxn];
bool spfa() {
    queue<int> q;
    memset(vis, 0, sizeof(vis));  // 这里一定要记得清空 vis (dfs要用)
    memset(inq, 0, sizeof(inq));
    fill(dis, dis+maxn, 1e18);
    memcpy(cur, head, sizeof(head));  // 当前弧优化用到的数组 cur
    dis[s] = 0;
    inq[s] = 1;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        for (int e = head[u]; e; e = edges[e].nxt) {
            int to = edges[e].to;
            ll w = edges[e].w, c = edges[e].c;
            if (w == 0) continue;
            if (dis[u] + c < dis[to]) {
                dis[to] = dis[u] + c;
                if (!inq[to]) {
                    inq[to] = 1;
                    q.push(to);
                }
            }
        }
    }
    return dis[t] != 1e18;
}

ll dfs(int u, ll in) {
    if (u == t) return in;  // 如果已经运到了终点，直接返回入量
    vis[u] = 1;
    ll out = 0;
    for (int e = cur[u]; e; e = edges[e].nxt) {
        cur[u] = e;
        int to = edges[e].to;
        ll w = edges[e].w, c = edges[e].c;
        if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue;
        // 检测: 1. 是否vis过  2. 这条边是否存在  3. 是否是最短路径

        ll res = dfs(to, min(in, w));

        in -= res;
        out += res;
        edges[e].w -= res;
        edges[e^1].w += res;

        if (in == 0) break;
    }
    if (out == 0) dis[u] = -1e18;
    return out;
}

ll mincost = 0;
ll mcmf() {
    ll maxflow = 0;
    while (spfa()) {
        ll res = dfs(s, 1e18);
        maxflow += res;
        mincost += res * dis[t];  // cost += (流量 * 最短路长度)
    }
    return maxflow;
}

void add(int u, int v, ll w, ll c) {
    addEdge(u,v,w,c);
    addEdge(v,u,0,-c);
}

int main() {
    cin >> n >> m >> s >> t;
    for (int i = 1; i <= m; i++) {
        int u,v,w,c;
        cin >> u >> v >> w >> c;
        add(u,v,w,c);
    }
    ll maxflow = mcmf();
    cout << maxflow << " " << mincost << endl;
}
```



## 例题

### 例1 [洛谷P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)

{{% question 题意 %}}

有 $n$ 个环形排列的仓库，给定每个仓库初始的储存量 $a_i$。

我们只能在相邻的仓库之间搬运。

求最少的搬运量，使得 $n$ 个仓库的库存数量相同。（保证储存量的平均数是一个整数）。

其中，$1 \leq n \leq 100$。

{{% /question %}}


{{% fold "题解（贪心）" %}}

正解实际上是 $O(n\log n)$ 的贪心，一个标准的均分纸牌问题。（加强版的在这：[洛谷P2512 HAOI2008 糖果传递](https://www.luogu.com.cn/problem/P2512)）。

设第 $i$ 个人 **向右传递** 了 $x_i$。注意到这里 $x_i$ 可正可负可零。

则目标是求 $\min \\{ |x_1| + |x_2| + ... + |x_n|\\}$。

因为最后每个人都获得了 $a$（$a$ 就是平均数）。

则有：$a_1 + x_1 - x_2 = a, a_2 + x_2 - x_3 = a$，以此类推。

进行代换，可得：

$$x_2 = x_1 - (a-a_1)$$
$$x_3 = x_1 - (2a-a_1-a_2)$$
$$x_4 = x_1 - (3a-a_1-a_2-a_3)$$
$$...$$
$$x_n = x_1 - ((n-1)a - a_1 - a_2 - ... - a_{n-1})$$

所以就只剩下一个变量 $x_1$ 了。

因为 $x_1$ 的值可以随便选，由上面的表达式可以看出，这相当于在一个直线上，有 $n$ 个点，坐标为：

$$0,(a-a_1 ),(2a-a_1-a_2 ),(3a-a_1-a_2-a_3 ),…,((n-1)a-a_1-a_2-…-a_{n-1} )$$


选择直线上一个点，使得它到这 $n$ 个点距离之和最短？很明显，选这些点的**中位数**即可。

{{% /fold %}}

{{% fold "题解（网络流）" %}}

需要最小化搬运数量。很明显是一个费用流。

> 网络流的常见套路 $1$：创建超级源点 $s$ 和 超级汇点 $t$。

对于相邻的节点，我们链接一个双向的边，费用为 $1$，容量无限。

同时创建超级源点 $s$，超级汇点 $t$，使得：

$s$ 向每个节点 $i$ 连接一个 费用为 $0$，容量等于 $a_i$ 的边。

每个节点 $i$ 向汇点 $t$ 连接一个 费用为 $0$，容量等于 $avg$（储存量的平均数）的边。

答案就是最小费用。

{{% /fold %}}

{{% fold "网络流代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 105;
const int maxm = 5e4+5;

int n, s, t, mincost = 0;
int arr[maxn];

struct Edge {
    int to, nxt, w, c;
} edges[maxn<<4];

int head[maxn], ecnt = 2, cur[maxn];
void addEdge(int u, int v, int w, int c) {
    Edge e = {v, head[u], w, c};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

bool inq[maxn];
int dis[maxn];
bool spfa() {
    fill(dis, dis+maxn, 1e9);
    memset(inq, 0, sizeof(inq));
    memcpy(cur, head, sizeof(head));

    queue<int> q;
    q.push(s);
    dis[s] = 0;
    inq[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        for (int e = head[u]; e; e = edges[e].nxt) {
            int to = edges[e].to, w = edges[e].w, c = edges[e].c;
            if (w == 0) continue;
            if (dis[u] + c < dis[to]) {
                dis[to] = dis[u] + c;
                if (!inq[to]) {
                    inq[to] = 1;
                    q.push(to);
                }
            }
        }
    }
    return dis[t] != 1e9;
}

bool vis[maxn];
int dfs(int u, int in) {
    if (u == t) return in;
    vis[u] = 1;
    int out = 0;
    for (int e = cur[u]; e; e = edges[e].nxt) {
        cur[u] = e;
        int to = edges[e].to, w = edges[e].w, c = edges[e].c;
        if (w == 0 || vis[to] || dis[u] + c != dis[to]) continue;

        int res = dfs(to, min(in, w));
        in -= res;
        out += res;
        edges[e].w -= res;
        edges[e^1].w += res;

        if (in == 0) break;
    }
    if (out == 0) dis[u] = -1e9;
    return out;
}

int mcmf() {
    int maxflow = 0;
    while (spfa()) {
        memset(vis, 0, sizeof(vis));  // 这里一定要记得清空 vis
        int res = dfs(s, 1e9);
        maxflow += res;
        mincost += res * dis[t];  // cost += (流量 * 最短路长度)
    }
    return maxflow;
}

int main() {
    fastio;
    cin >> n;
    int sum = 0;
    for (int i = 1; i <= n; i++) cin >> arr[i], sum += arr[i];
    sum /= n;
    s = n+1, t = n+2;
    for (int i = 1; i <= n; i++) {
        addEdge(s, i, arr[i], 0);
        addEdge(i, s, 0, 0);

        addEdge(i, t, sum, 0);
        addEdge(t, i, 0, 0);

        if (i != n) {
            addEdge(i, i+1, 1e9, 1);
            addEdge(i+1, i, 0, -1);

            addEdge(i+1, i, 1e9, 1);
            addEdge(i, i+1, 0, -1);
        }
    }
    addEdge(n, 1, 1e9, 1);
    addEdge(1, n, 0, -1);

    addEdge(1, n, 1e9, 1);
    addEdge(n, 1, 0, -1);

    mcmf();
    cout << mincost << endl;
}
```

{{% /fold %}}




## 参考链接

1. https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic