+++
title = '概率期望'
date = 2021-07-27T17:57:28+08:00
draft = false
categories = ['算法']
tags = ['概率', '期望', '数学']
+++


### 例1 [洛谷P1850 [NOIP2016 提高组] 换教室](https://www.luogu.com.cn/problem/P1850)

{{% question 题意 %}}

有 $n$ 个时间段，每个时间段有 $2$ 节课程。其中在时间段 $i$ 的两节课，分别在教室 $c_i, d_i$ 上。

对于所有的时间段 $i$，牛牛预先被安排在 $c_i$ 上课。

对于一个时间段 $i$，牛牛可以申请转到教室 $d_i$ 上课。但这个申请只有 $k_i$ 的概率被批准。

牛牛最多可以申请 $m$ 个时间段，但是**所有申请必须一次性提交**。

同时，校园可以看作是一个图，教室为节点（共 $v$ 个教室），教室之间有双向边（共 $e$ 个边），边有长度。

每当一节课结束后，牛牛会沿着最短路径走到下一节课所在的教室。

现在牛牛想知道，怎么申请时间段，使得他在教室间移动的路程长度期望值最小，求出这个最小期望。

其中，$1 \leq n \leq 2000, 0 \leq m \leq 2000, 1 \leq v \leq 300, 0 \leq e \leq 90000$。

{{% /question %}}


{{% fold "题解" %}}

首先用 floyd $O(n^3)$ 求出每两个节点之间的最短路长度。

然后一个很明显的 DP 思路：

设 $dp[i][j][k]$ 为：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前在哪个教室。

这个思路看起来很有道理，但是不正确。因为题目提到 **所有申请必须一次性提交**。

而 $k=0/1$ 如果代表当前在哪个教室，就说明我们已经知道了当前的申请结果，来考虑后面的时间段是否申请。这会导致我们的决策更加的精明，从而使得答案小于正确答案。

<hr>

正确的状态为：$dp[i][j][k]$：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前 **是否申请过**，$dp$ 数组的值代表路径长度期望值。

然后转移的时候，就要分类讨论 **是否申请下一个时间段**，得到两个结果，取 $\min$ 就得到了当前状态的答案。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2002;

int n,m,v,e, c[maxn], d[maxn];
double k[maxn];
int adj[302][302], dis[302][302];
double dp[maxn][maxn][2];

// K = 1: 已申请， K = 0: 未申请
double dfs(int i, int j, int K) {
    if (i >= n) return 0.0;
    if (dp[i][j][K] >= 0.0) return dp[i][j][K];
    double r1 = 1e18, r2 = 1e18;

    // next: 申请/不申请
    if (K) {
        r1 = k[i] * (dfs(i+1, j, 0) + dis[d[i]][c[i+1]]) + (1.0 - k[i]) * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]);
        if (j > 0)
            r2 = k[i] * (k[i+1] * (dfs(i+1, j-1, 1) + dis[d[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[d[i]][c[i+1]])) 
            + (1.0 - k[i]) * (k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]]));
    } else {
        r1 = 1.0 * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]);
        if (j > 0) r2 = k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]]);
    }

    return dp[i][j][K] = min(r1, r2);
}

int main() {
    scanf("%d%d%d%d",&n,&m,&v,&e);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
    for (int i = 1; i <= n; i++) scanf("%lf", &k[i]);

    for (int i = 1; i <= e; i++) {
        int u,v,w; scanf("%d%d%d",&u,&v,&w);
        if (adj[u][v]) {
            if (adj[u][v] > w) adj[u][v] = adj[v][u] = w;
        } else adj[u][v] = adj[v][u] = w;
    }
    memset(dis, 0x3f3f3f3f, sizeof(dis));
    for (int i = 1; i <= v; i++) {
        for (int j = 1; j <= v; j++) {
            if (adj[i][j])
                dis[i][j] = dis[j][i] = adj[i][j];
        }
    }
    for (int i = 1; i <= v; i++) dis[i][i] = 0;
    for (int k = 1; k <= v; k++) {
        for (int i = 1; i <= v; i++) {
            for (int j = 1; j <= v; j++) {
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
            }
        }
    }



    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            dp[i][j][0] = dp[i][j][1] = -1;
        }
    }

    double ans1 = 1.0 * dfs(1, m, 0), ans2 = 1e18;
    if (m > 0) {
        ans2 = 1.0 * dfs(1, m-1, 1);
    }
    
    double ans = min(ans1, ans2);
    printf("%.2lf\n", ans);
    
}
```

{{% /fold %}}
