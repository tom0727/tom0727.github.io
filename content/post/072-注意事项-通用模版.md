+++
title = '[置顶]竞赛注意事项/通用模版'
date = 2022-09-19T10:26:35-05:00
draft = false
categories = ['']
tags = ['', '']
weight = 1
+++

## Set中的Comparator定义

在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如：

```cpp
int cnt[maxn];
struct Cmp {
    bool operator()(int i, int j) const {
        if (cnt[i] == cnt[j]) return i < j;  // 一定要加！！！
        return cnt[i] < cnt[j];
    }
};
set<int, Cmp> s;
```

这里 `if (cnt[i] == cnt[j]) return i < j;` 非常关键，如果不加的话，那么 `cnt[i] == cnt[j]` 将会被判定为重复元素，导致 `i,j` 只能加入一个。

## swap函数的时间复杂度

注意如果 $f,g$ 是两个数组，那么 `swap(f,g)` 的时间复杂度是 $O(n)$ 级别的！


## 通用模版

### Z自动取模整数

{{% fold "Z自动取模整数" %}}

```cpp
const int mod = 998244353;
 
template<class T>
T qpow(T a, int b) {
    T res = 1;
    while (b) {
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}
int norm(int x) {
    if (x < 0) {
        x += mod;
    }
    if (x >= mod) {
        x -= mod;
    }
    return x;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    Z(ll x) : x(norm(x % mod)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(mod - x));
    }
    Z inv() const {
        assert(x != 0);
        return qpow(*this, mod - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = (ll)(x) * rhs.x % mod;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        ll v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
```

{{% /fold %}}

### 树状数组

{{% fold "树状数组" %}}

```cpp
struct BIT {
    int n, tr[maxn];  // 记得初始化 tr.n
    inline int lowbit(int x) { return x & -x; }
    void update(int p, int val) {
        while (p <= n) {
            tr[p] += val;
            p += lowbit(p);
        }
    }
    // return sum[1...p]
    int query(int p) {
        int ans = 0;
        while (p > 0) {
            ans += tr[p];
            p -= lowbit(p);
        }
        return ans;
    }
};
```

{{% /fold %}}

