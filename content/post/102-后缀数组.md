+++
title = '后缀数组'
date = 2023-03-22T11:30:39-05:00
draft = false
categories = ['算法']
tags = ['', '']
+++

## 模版


{{% fold "代码" %}}

```cpp
// sa[i]：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 sa[i] 这个后缀）。
// rk[i]：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 rk[i]）。
// height[i]: LCP(sa[i-1], sa[i])，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度
struct SA {
    int n, sa[maxn], rk[maxn<<1], oldrk[maxn<<1], cnt[maxn], id[maxn], key1[maxn], height[maxn];  // 注意 rk[maxn<<1] oldrk[maxn<<1]
    char s[maxn];
    int m = 127;
    bool cmp(int i, int j, int w) {
        return oldrk[i] == oldrk[j] && oldrk[i+w] == oldrk[j+w];
    }
    void init(string& ss) {
        n = ss.size();
        // LOG(n);
        for (int i = 1; i <= n; i++) s[i] = ss[i-1];

        for (int i = 1; i <= n; i++) rk[i] = s[i], cnt[rk[i]]++;
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;

        int p = 0;  // 当前值域
        for (int w = 1; w <= n; w <<= 1) {  // 注意中间没有break的条件
            p = 0;
            for (int i = n; i > n-w; i--) id[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) id[++p] = sa[i] - w;
            }
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++;
            for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
            for (int i = n; i >= 1; i--) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk+1, rk+1, n*sizeof(int));
            p = 0;
            for (int i = 1; i <= n; i++) {
                rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p);
            }
            if (p == n) {
                for (int i = 1; i <= n; i++) sa[rk[i]] = i;
                break;
            }
            m = p;
        }

        // 求 height
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 0) continue;
            if (k > 0) k--;
            while (s[i+k] == s[sa[rk[i]-1]+k]) k++;
            height[rk[i]] = k;
        }
    }
} sa;

int n;
int main() {
    cin >> n;
    string s; cin >> s;
    sa.init(s);

    ll ans = (ll)(n) * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= sa.height[i];
    cout << ans << "\n";

}
```

{{% /fold %}}


## 介绍

后缀数组可以对一个字符串的所有后缀进行排序，然后得到一些有用的信息。

在处理出后缀数组后，我们会得到以下数组：

1. `sa[i]`：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 `sa[i]` 这个后缀）。
2. `rk[i]`：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 `rk[i]`）。
3. `height[i]`: `LCP(sa[i-1], sa[i])`，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度。

## 算法

暴力的思路是求出所有后缀，然后排序，复杂度是 $O(n^2 \log n)$。

利用倍增可以在 $O(n \log n)$ 求出后缀数组。

![img](/images/103/1.png)

如上图，我们先比较每个后缀的第一个字符。

![img](/images/103/2.png)

这样我们可以得到第一个字符的排序（注意这个例子和上面那个不同了）。

接下来比较第二个字符，这样和第一个字符的排序结合起来，可以得到一个双关键字的排序。

![img](/images/103/4.png)

双关键字排序后，又可以得到一个排名，然后注意到此时每个排名都代表 $2$ 个字符长度的排名。

所以两个排名结合起来就对应了 $4$ 个字符长度的排名，于是就可以利用倍增继续双关键字排序，如下：

![img](/images/103/3.png)



## 例题


### 例1 洛谷P2408 [不同子串个数](https://www.luogu.com.cn/problem/P2408)

{{% question 题意 %}}

给定一个长度为 $n$ 的字符串 $s$，求 $s$ 内不同的子串个数。

其中，$n \leq 10^5$。

{{% /question %}}


{{% fold "题解" %}}

答案就是 全部子串数量 $- \sum\limits_{i=2}^n height[i]$。

考虑排序后排名第 $i$ 的后缀（长度为 $m$）贡献了哪些新的子串，有且仅有 $m - height[i]$。

因为跟排名 $i-1$ 的后缀比较，新贡献的肯定是这么多。

如果贡献的数量 $< m - height[i]$，说明这个后缀的前缀在之前的某一个位置出现过了，这说明 $LCP(j, i) > height[i]$，其中 $j < i-1$，这与 $LCP(j,i) = \min\limits_{k=j+1}^i height[k]$ 冲突了。 



{{% /fold %}}


{{% fold "代码" %}}

同模版。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main() {
    cin >> n;
    string s; cin >> s;
    sa.init(s);

    ll ans = (ll)(n) * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= sa.height[i];
    cout << ans << "\n";
}
```

{{% /fold %}}



### 例2 洛谷P2870 [[USACO07DEC]Best Cow Line G](https://www.luogu.com.cn/problem/P2870)

{{% question 题意 %}}

给定一个长度为 $n$ 的字符串 $s$，每次可以从 $s$ 的首部和尾部字符中选一个出来，直到 $s$ 为空，求能够获得的字典序最小的字符串。

其中，$n \leq 5 \times 10^5$。

{{% /question %}}


{{% fold "题解" %}}

当首尾字符不一样时，肯定选较小的那个。

当首尾字符一样时，我们就继续看第 $2$ 个和第 $n-1$ 个字符，如果还是一样就继续对比，直到第一个不一样的为止。

但这样是 $O(n^2)$ 的。

我们观察一下可以发现，首尾字符一样时，本质是比较 $s$ 的一个后缀，和 $s'$ (反过来的 $s$) 的一个后缀的大小。

那么比较两个字符串的后缀的大小，我们在后缀数组里可以 $O(1)$ 做到。

将两个字符串拼在一起的方法是 `s + '@' + s'`，其中 `@` 是一个比所有字符都小的字符，这样保证它在后缀数组中不会影响到 $s,s'$ 后缀的计算。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s, ans;
int main() {
    fastio;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        char c; cin >> c; s += c;
    }
    string t = s;
    s += (char)('A' - 1);
    reverse(t.begin(), t.end());
    s += t;
    sa.init(s);

    int i = 1, j = n;
    while (i <= j) {
        if (s[i-1] < s[j-1]) ans += s[i-1], i++;
        else if (s[i-1] > s[j-1]) ans += s[j-1], j--;
        else {
            // 比较 s[i] 开始的后缀和 t[2n+2-j] 开始的后缀的大小
            if (sa.rk[i] < sa.rk[2*n+2-j]) ans += s[i-1], i++;
            else ans += s[j-1], j--;
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        cout << ans[i];
        if (++cnt == 80) cnt = 0, cout << "\n";
    }
}
```

{{% /fold %}}



