+++
title = '后缀数组'
date = 2023-03-22T11:30:39-05:00
draft = false
categories = ['算法']
tags = ['', '']
+++

## 模版


{{% fold "代码" %}}

```cpp
struct SA {
    int n, sa[maxn], rk[maxn<<1], oldrk[maxn<<1], cnt[maxn], id[maxn], key1[maxn], height[maxn];  // 注意 rk[maxn<<1] oldrk[maxn<<1]
    char s[maxn];
    int m = 127;
    bool cmp(int i, int j, int w) {
        return oldrk[i] == oldrk[j] && oldrk[i+w] == oldrk[j+w];
    }
    void init(string& ss) {
        n = ss.size();
        // LOG(n);
        for (int i = 1; i <= n; i++) s[i] = ss[i-1];

        for (int i = 1; i <= n; i++) rk[i] = s[i], cnt[rk[i]]++;
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;

        int p = 0;  // 当前值域
        for (int w = 1; w <= n; w <<= 1) {  // 注意中间没有break的条件
            p = 0;
            for (int i = n; i > n-w; i--) id[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) id[++p] = sa[i] - w;
            }
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++;
            for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
            for (int i = n; i >= 1; i--) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk+1, rk+1, n*sizeof(int));
            p = 0;
            for (int i = 1; i <= n; i++) {
                rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p);
            }
            if (p == n) {
                for (int i = 1; i <= n; i++) sa[rk[i]] = i;
                break;
            }
            m = p;
        }

        // 求 height
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 0) continue;
            if (k > 0) k--;
            while (s[i+k] == s[sa[rk[i]-1]+k]) k++;
            height[rk[i]] = k;
        }
    }
} sa;

int n;
int main() {
    cin >> n;
    string s; cin >> s;
    sa.init(s);

    ll ans = (ll)(n) * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= sa.height[i];
    cout << ans << "\n";

}
```

{{% /fold %}}


## 介绍

后缀数组可以对一个字符串的所有后缀进行排序，然后得到一些有用的信息。

在处理出后缀数组后，我们会得到以下数组：

1. `sa[i]`：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 `sa[i]` 这个后缀）。
2. `rk[i]`：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 `rk[i]`）。
3. 

## 算法


