+++
title = '后缀数组'
date = 2023-03-22T11:30:39-05:00
draft = false
categories = ['算法']
tags = ['', '']
+++

## 模版


{{% fold "代码" %}}

```cpp
// sa[i]：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 sa[i] 这个后缀）。
// rk[i]：后缀 $i$（指 s[i...n]) 的排名。（第 $i$ 个后缀的排名是 rk[i]）。
// height[i]: LCP(sa[i-1], sa[i])，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度
struct SA {
    int n, sa[maxn], rk[maxn<<1], oldrk[maxn<<1], cnt[maxn], id[maxn], key1[maxn], height[maxn];  // 注意 rk[maxn<<1] oldrk[maxn<<1]
    char s[maxn];
    int m = 127;
    bool cmp(int i, int j, int w) {
        return oldrk[i] == oldrk[j] && oldrk[i+w] == oldrk[j+w];
    }
    void init(string& ss) {
        n = ss.size();
        for (int i = 1; i <= n; i++) s[i] = ss[i-1];

        for (int i = 1; i <= n; i++) rk[i] = s[i], cnt[rk[i]]++;
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;

        int p = 0;  // 当前值域
        for (int w = 1; w <= n; w <<= 1) {  // 注意中间没有break的条件
            p = 0;
            for (int i = n; i > n-w; i--) id[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) id[++p] = sa[i] - w;
            }
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++;
            for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
            for (int i = n; i >= 1; i--) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk+1, rk+1, n*sizeof(int));
            p = 0;
            for (int i = 1; i <= n; i++) {
                rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p);
            }
            if (p == n) {
                for (int i = 1; i <= n; i++) sa[rk[i]] = i;
                break;
            }
            m = p;
        }

        // 求 height
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 0) continue;
            if (k > 0) k--;
            while (s[i+k] == s[sa[rk[i]-1]+k]) k++;
            height[rk[i]] = k;
        }
    }
    void clear() {
        memset(sa, 0, sizeof(sa));
        memset(rk, 0, sizeof(rk));
        memset(oldrk, 0, sizeof(oldrk));
        memset(cnt, 0, sizeof(cnt));
        memset(id, 0, sizeof(id));
        memset(key1, 0, sizeof(key1));
        memset(height, 0, sizeof(height));
        memset(s, 0, sizeof(s));
        m = 127;  // 这个必须有！
    }
} sa;

int n;
int main() {
    cin >> n;
    string s; cin >> s;
    sa.init(s);

    ll ans = (ll)(n) * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= sa.height[i];
    cout << ans << "\n";

}
```

{{% /fold %}}


## 介绍

后缀数组可以对一个字符串的所有后缀进行排序，然后得到一些有用的信息。

在处理出后缀数组后，我们会得到以下数组：

1. `sa[i]`：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 `sa[i]` 这个后缀）。
2. `rk[i]`：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 `rk[i]`）。第 $i$ 个后缀指的是 $s[i...n]$。
3. `height[i]`: `LCP(sa[i-1], sa[i])`，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度。

• 对于第 $i$ 名的后缀和第 $j$ 名的后缀的 LCP 长度（$i<j$），可以直接用 $\min\limits_{k=i+1}^j height[k]$ 求出。

## 算法

暴力的思路是求出所有后缀，然后排序，复杂度是 $O(n^2 \log n)$。

利用倍增可以在 $O(n \log n)$ 求出后缀数组。

![img](/images/102/1.png)

如上图，我们先比较每个后缀的第一个字符。

![img](/images/102/2.png)

这样我们可以得到第一个字符的排序（注意这个例子和上面那个不同了）。

接下来比较第二个字符，这样和第一个字符的排序结合起来，可以得到一个双关键字的排序。

![img](/images/102/4.png)

双关键字排序后，又可以得到一个排名，然后注意到此时每个排名都代表 $2$ 个字符长度的排名。

所以两个排名结合起来就对应了 $4$ 个字符长度的排名，于是就可以利用倍增继续双关键字排序，如下：

![img](/images/102/3.png)


## 应用

### 比较字符串中，两个子串的大小关系

如果需要比较 $A = S[a...b]$ 和 $B = S[c...d]$ 的大小关系，那么：

求出后缀 $S[a...]$ 与 $S[c...]$ 的 LCP长度，设其为 $L$。

若 $L \geq \min(|A|,|B|)$，那么 $A < B \iff |A| < |B|$。

若 $L < \min(|A|,|B|)$，那么 $A < B \iff rk[a] < rk[c]$。


### 查询一个/多个模式串 $T$ 在文本串 $S$ 中出现的所有位置

处理出 $S$ 的后缀数组，由于后缀是 sorted 的，所以可以在后缀数组上二分 $T$ 的 `lower_bound` 和 `upper_bound` 位置。

设 $L$ 为 `lower_bound`, $R$ 为 `upper_bound`，则后缀数组上 $[L,R]$ 内对应的所有位置就是 $T$ 出现的所有位置。

二分时，直接用 $|T|$ 的时间暴力比较即可。

• 如果 $S$ 的某个后缀长度不够 $|T|$，则仍然按正常的字符串比较方式判断大小。

复杂度：$O(|T|\log |S|)$。

也可以用于多模式串匹配，复杂度比哈希和 `bitset` 更加优秀，而且还支持在线。

{{% fold "代码" %}}

```cpp
string s, t;
int main() {
    cin >> s >> t;
    int n = s.size(), m = t.size();
    sa.init(s);
    int low = 1, high = n, L = n+1, R = 0;

    while (low <= high) {
        int mid = (low + high) >> 1;
        int st = sa.sa[mid];
        int cp = 0;
        for (int j = st; j <= min(n, st + m - 1); j++) {
            if (s[j-1] < t[j-st]) {
                cp = -1;
                break;
            }
            if (s[j-1] > t[j-st]) {
                cp = 1;
                break;
            }
        }

        if (st + m - 1 > n && !cp) {  // 长度不够了，但仍然相等，说明 t 更大
            cp = -1;
        }

        if (!cp) {
            L = mid;   // 区别
        }

        if (cp >= 0) {   // 区别
            high = mid - 1;
        } else low = mid + 1;
    }

    low = 1, high = n;
    while (low <= high) {
        int mid = (low + high) >> 1;
        int st = sa.sa[mid];
        int cp = 0;
        for (int j = st; j <= min(n, st + m - 1); j++) {
            if (s[j-1] < t[j-st]) {
                cp = -1;
                break;
            }
            if (s[j-1] > t[j-st]) {
                cp = 1;
                break;
            }
        }

        if (st + m - 1 > n && !cp) {
            cp = -1;
        }

        if (!cp) {
            R = mid;  // 区别
        }

        if (cp > 0) {   // 区别
            high = mid - 1;
        } else low = mid + 1;
    }

    vector<int> res;
    for (int i = L; i <= R; i++) {
        res.push_back(sa.sa[i]);
    }
    sort(res.begin(), res.end());  // 从小到大排序
    for (int x : res) cout << x << "\n";
}
```

{{% /fold %}}



## 例题


### 例1 洛谷P2408 [不同子串个数](https://www.luogu.com.cn/problem/P2408)

{{% question 题意 %}}

给定一个长度为 $n$ 的字符串 $s$，求 $s$ 内不同的子串个数。

其中，$n \leq 10^5$。

{{% /question %}}


{{% fold "题解" %}}

答案就是 全部子串数量 $- \sum\limits_{i=2}^n height[i]$。

考虑排序后排名第 $i$ 的后缀（长度为 $m$）贡献了哪些新的子串，有且仅有 $m - height[i]$。

因为跟排名 $i-1$ 的后缀比较，新贡献的肯定是这么多。

如果贡献的数量 $< m - height[i]$，说明这个后缀的前缀在之前的某一个位置出现过了，这说明 $LCP(j, i) > height[i]$，其中 $j < i-1$，这与 $LCP(j,i) = \min\limits_{k=j+1}^i height[k]$ 冲突了。 



{{% /fold %}}


{{% fold "代码" %}}

同模版。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main() {
    cin >> n;
    string s; cin >> s;
    sa.init(s);

    ll ans = (ll)(n) * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= sa.height[i];
    cout << ans << "\n";
}
```

{{% /fold %}}



### 例2 洛谷P2870 [[USACO07DEC]Best Cow Line G](https://www.luogu.com.cn/problem/P2870)

{{% question 题意 %}}

给定一个长度为 $n$ 的字符串 $s$，每次可以从 $s$ 的首部和尾部字符中选一个出来，直到 $s$ 为空，求能够获得的字典序最小的字符串。

其中，$n \leq 5 \times 10^5$。

{{% /question %}}


{{% fold "题解" %}}

当首尾字符不一样时，肯定选较小的那个。

当首尾字符一样时，我们就继续看第 $2$ 个和第 $n-1$ 个字符，如果还是一样就继续对比，直到第一个不一样的为止。

但这样是 $O(n^2)$ 的。

我们观察一下可以发现，首尾字符一样时，本质是比较 $s$ 的一个后缀，和 $s'$ (反过来的 $s$) 的一个后缀的大小。

那么比较两个字符串的后缀的大小，我们在后缀数组里可以 $O(1)$ 做到。

将两个字符串拼在一起的方法是 `s + '@' + s'`，其中 `@` 是一个比所有字符都小的字符，这样保证它在后缀数组中不会影响到 $s,s'$ 后缀的计算。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s, ans;
int main() {
    fastio;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        char c; cin >> c; s += c;
    }
    string t = s;
    s += (char)('A' - 1);
    reverse(t.begin(), t.end());
    s += t;
    sa.init(s);

    int i = 1, j = n;
    while (i <= j) {
        if (s[i-1] < s[j-1]) ans += s[i-1], i++;
        else if (s[i-1] > s[j-1]) ans += s[j-1], j--;
        else {
            // 比较 s[i] 开始的后缀和 t[2n+2-j] 开始的后缀的大小
            if (sa.rk[i] < sa.rk[2*n+2-j]) ans += s[i-1], i++;
            else ans += s[j-1], j--;
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        cout << ans[i];
        if (++cnt == 80) cnt = 0, cout << "\n";
    }
}
```

{{% /fold %}}

### 例3 [最长公共子串 LCS](https://www.luogu.com.cn/problem/SP1811)

{{% question 题意 %}}

给定两个字符串 $s,t$，长度分别为 $n,m$。求最长公共子串的长度。

其中，$n,m \leq 2.5 * 10^5$。

• 子串指的是 Substring，是连续的。

{{% /question %}}


{{% fold "题解" %}}

首先利用经典套路，将 $s,t$ 中间用一个极小的字符连在一起。

然后要求最长公共子串，可以发现必然来自于两个后缀的 LCP，而这两个后缀是来自于不同字符串的。

而我们知道任意两个后缀的 LCP 可以用height数组计算出来，并且是取一个范围 min 的，很显然每个后缀只用考虑左边和右边第一个和它来源于不同字符串的后缀，求LCP即可。

然而可以更简单：因为是取范围min，所以直接考虑排名 $i-1$ 和 $i$ 的后缀，来源的字符串是否不同，如果不同的话就 `ans = max(ans, height[i])` 即可。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
int from[maxn];  // from[i] = 1: s, from[i] = 2: t
int main() {
    int n, m;
    string s, t; cin >> s >> t;
    n = s.size(), m = t.size();
    string S = s + (char)('a' - 1) + t;
    sa.init(S);

    for (int i = 1; i <= n; i++) {
        from[sa.rk[i]] = 0;
    }
    for (int i = n+2; i <= n+m+1; i++) {
        from[sa.rk[i]] = 1;
    }
    from[sa.rk[n+1]] = 2;

    int ans = 0;
    for (int i = 2; i <= n+m+1; i++) {
        if ((from[i] ^ 1) == from[i-1]) ans = max(ans, sa.height[i]);
    }
    cout << ans << endl;
}

```

{{% /fold %}}

### 例4 NOI2015 [品酒大会](https://www.luogu.com.cn/problem/P2178)

{{% question 题意 %}}

给定一个长度为 $n$ 的字符串 $S$，并且位置 $i$ 有权值 $a_i$。

现在定义位置 $p,q$ 是 "$r$ 相似的" 当且仅当：

$$S[p...p+r-1] = S[q...q+r-1]$$

现在对于每一个 $r=0,1,2,...,n-1$，都回答以下两个问题：

1. 有多少个pair $(p,q)$，使得 $p,q$ 是 "$r$ 相似的"？其中 $p<q$。
   
2. 输出所有 "$r$ 相似的" 的 pair $(p,q)$ 中，$a_p * a_q$ 的最大值。

其中，$n \leq 3 \times 10^5, |a_i| \leq 10^9$。

{{% /question %}}


{{% fold "题解" %}}

如果 $(p,q)$ 是 "$r$ 相似的"，意味着 $p,q$ 位置的 LCP 长度 $\geq r$。

先考虑第一个问题，有多少个pair是 "$r$ 相似的"？

本质上是在问，在height数组上，有多少个 pair $(p,q)$ 的区间最小值是 $\geq r$ 的？

我们不妨将整个数组视为一个拥有 $n$ 个空格子的数组，询问 $r$ 时，我们将所有 $<r$ 的位置加上一个障碍物，那么剩下来的就是若干个空格子组成的一些联通块。

如果一个联通块大小为 $x$，那么它就贡献了 $1+2+...+x = \frac{x(x+1)}{2}$ 的数量。

然而，如果我们从小往上加障碍物，将一个大的联通块分成若干个小联通块，很明显不好计算，所以我们反过来做。

从 $r=n-1$ 开始到 $0$，逐渐消掉障碍物，相当于将一些小联通块合并在一起，可以用并查集实现。

<hr>

接下来解决第二个问题，$a_p * a_q$ 的最大值。

在我们得到联通块之后，答案就是每一个联通块 $[L,R]$ 内，求 $p,q \in [L,R]$，$a_p * a_q$ 的最大值。

由于 $a_i$ 有正有负有 $0$，所以我们用线段树解决这个问题：

每个节点里记录这个区间内，正数的最大值和最小值，负数的最大值和最小值，再记录是否存在 $0$。

然后 $a_p * a_q$ 的最大值就来自于 left child 和 right child 的最大值，以及正数/负数的最大/小值的两两组合，如果有 $0$ 的话再与 $0$ 取个最大值即可。

所以在并查集合并过程中，每次合并两个区间，就更新 count 和 最大值即可。

{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
ll cal(ll x) {
    return x*(x+1)/2;
}
ll val[maxn];
struct Node {
    ll ans;  // -1e18
    ll neg[2], pos[2];  // neg[0] < neg[1], pos[0] < pos[1], neg = {1e9, 1e9}, pos = {-1e9, -1e9}
    bool haszero;  // 0
};
struct SegmentTree {
    Node tr[maxn<<2];
    Node init() {
        Node res;
        res.ans = -1e18;
        res.neg[0] = res.neg[1] = 1e9;  // neg[0] > 0, 代表这个区间不存在负数
        res.pos[0] = res.pos[1] = -1e9;  // pos[0] < 0, 代表这个区间不存在正数
        res.haszero = 0;
        return res;
    }
    void init(int cur, int p) {
        tr[cur] = init();
        tr[cur].haszero = (!val[p]);
        if (val[p] > 0) tr[cur].pos[0] = tr[cur].pos[1] = val[p];
        if (val[p] < 0) tr[cur].neg[0] = tr[cur].neg[1] = val[p];
    }
    void push_up(int cur) {
        int lc = cur<<1, rc = lc + 1;
        tr[cur] = merge(tr[lc], tr[rc]);
    }
    Node merge(Node lc, Node rc) {
        Node cur = init();
        cur.ans = max(lc.ans, rc.ans);
        if (lc.haszero || rc.haszero) cur.ans = max(cur.ans, 0LL), cur.haszero = 1;
        for (int o1 = 0; o1 < 2; o1++) {
            for (int o2 = 0; o2 < 2; o2++) {
                if (lc.neg[o1] < 0 && rc.neg[o2] < 0) cur.ans = max(cur.ans, lc.neg[o1] * rc.neg[o2]);
                if (lc.neg[o1] < 0 && rc.pos[o2] > 0) cur.ans = max(cur.ans, lc.neg[o1] * rc.pos[o2]);
                if (lc.pos[o1] > 0 && rc.neg[o2] < 0) cur.ans = max(cur.ans, lc.pos[o1] * rc.neg[o2]);
                if (lc.pos[o1] > 0 && rc.pos[o2] > 0) cur.ans = max(cur.ans, lc.pos[o1] * rc.pos[o2]);
            }
        }
        if (lc.neg[0] < 0) cur.neg[0] = cur.neg[1] = lc.neg[0];
        if (rc.neg[0] < 0) cur.neg[0] = cur.neg[1] = rc.neg[0];
        if (lc.pos[0] > 0) cur.pos[0] = cur.pos[1] = lc.pos[0];
        if (rc.pos[0] > 0) cur.pos[0] = cur.pos[1] = rc.pos[0];

        if (lc.neg[0] < 0) cur.neg[0] = min(cur.neg[0], lc.neg[0]), cur.neg[1] = max(cur.neg[1], lc.neg[1]);
        if (rc.neg[0] < 0) cur.neg[0] = min(cur.neg[0], rc.neg[0]), cur.neg[1] = max(cur.neg[1], rc.neg[1]);
        if (lc.pos[0] > 0) cur.pos[0] = min(cur.pos[0], lc.pos[0]), cur.pos[1] = max(cur.pos[1], lc.pos[1]);
        if (rc.pos[0] > 0) cur.pos[0] = min(cur.pos[0], rc.pos[0]), cur.pos[1] = max(cur.pos[1], rc.pos[1]);
        return cur;
    }
    Node query(int cur, int l, int r, int L, int R) {
        if (l >= L && r <= R) return tr[cur];
        int mid = (l+r) >> 1;
        Node res = init();
        Node lres = init(), rres = init();
        if (L <= mid) lres = query(cur<<1, l, mid, L, R);
        if (R > mid) rres = query(cur<<1|1, mid+1, r, L, R);

        if (L <= mid && R <= mid) return lres;
        if (L > mid && R > mid) return rres;
        assert(L <= mid && R > mid);
        return merge(lres, rres);
    }

    void build(int cur, int l, int r) {
        if (l == r) {
            init(cur, l);
            return;
        }
        int mid = (l+r) >> 1;
        build(cur<<1, l, mid);
        build(cur<<1|1, mid+1, r);
        push_up(cur);
    }
} tr;


int n;
ll cnt = 0, ans = -1e18;
struct UnionFind {
    int par[maxn], sz[maxn], L[maxn], R[maxn];
    int finds(int u) {
        if (!par[u]) return 0;
        if (par[u] == u) return u;
        return par[u] = finds(par[u]);
    }
    bool unions(int u, int v) {
        u = finds(u), v = finds(v);
        if (u == v || !u || !v) return 0;
        if (sz[u] < sz[v]) swap(u, v);
        cnt -= (cal(sz[u]) + cal(sz[v]));
        sz[u] += sz[v];
        cnt += cal(sz[u]);
        par[v] = u;
        L[u] = min(L[u], L[v]);
        R[u] = max(R[u], R[v]);
        ans = max(ans, tr.query(1, 1, n, L[u]-1, R[u]).ans);
        return 1;
    }
    void init(int u) {
        par[u] = u;
        sz[u] = 1;
        L[u] = R[u] = u;
        cnt++;
        ans = max(ans, tr.query(1, 1, n, L[u]-1, R[u]).ans);
    }
} uf;


ll a[maxn];
string s;

vector<int> pos[maxn];
int main() {
    cin >> n >> s;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sa.init(s);
    for (int i = 2; i <= n; i++) {
        pos[sa.height[i]].push_back(i);
    }
    for (int i = 1; i <= n; i++) {
        int r = sa.sa[i];
        val[i] = a[r];
    }
    tr.build(1, 1, n);

    vector<pll> vec;
    for (int i = n-1; i >= 0; i--) {
        for (int p : pos[i]) {
            uf.init(p);
        }
        for (int p : pos[i]) {
            uf.unions(p, p-1);
            uf.unions(p, p+1);
        }
        if (cnt > 0)
            vec.push_back({cnt, ans});
        else
            vec.push_back({cnt, 0});
    }
    reverse(vec.begin(), vec.end());
    for (auto [x, y] : vec) cout << x << " " << y << "\n";
}
```

{{% /fold %}}

### 例5 HAOI2016 [找相同字符](https://loj.ac/p/2064)

{{% question 题意 %}}

给定两个字符串 $s,t$，求出：在两个字符串中各取出一个子串，使得这两个子串相同的方案数。

其中，$|s|,|t| \leq 2 \times 10^5$。

{{% /question %}}


{{% fold "题解" %}}

先将两个字符串粘在一起，然后对于每个pair $(p,q)$，求出 LCP 以后，可以知道这个 pair 对答案的贡献就是对应的 LCP 的长度。

所以问题转化为，求

$$\sum\limits_{i<j} LCP(i,j)$$

不过，我们还要保证 $p,q$ 分别来自于 $s$ 和 $t$ 才行。

于是我们可以先在 $s,t$ 上分别求出 $\sum\limits_{i<j} LCP(i,j)$，然后在 $S = s+t$ 上再求一次，减掉即可。

<hr>

现在问题是怎么求 

$$\sum\limits_{i<j} LCP(i,j)$$

不难发现上一题已经有答案了：

只要求出有多少个pair是 "$r$ 相似的" 即可，所以套用上题代码。


{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
// sa[i]：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 sa[i] 这个后缀）。
// rk[i]：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 rk[i]）。
// height[i]: LCP(sa[i-1], sa[i])，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度
struct SA {
    int n, sa[maxn], rk[maxn<<1], oldrk[maxn<<1], cnt[maxn], id[maxn], key1[maxn], height[maxn];  // 注意 rk[maxn<<1] oldrk[maxn<<1]
    char s[maxn];
    int m = 127;
    bool cmp(int i, int j, int w) {
        return oldrk[i] == oldrk[j] && oldrk[i+w] == oldrk[j+w];
    }
    void clear() {
        memset(sa, 0, sizeof(sa));
        memset(rk, 0, sizeof(rk));
        memset(oldrk, 0, sizeof(oldrk));
        memset(cnt, 0, sizeof(cnt));
        memset(id, 0, sizeof(id));
        memset(key1, 0, sizeof(key1));
        memset(height, 0, sizeof(height));
        memset(s, 0, sizeof(s));
        m = 127;
    }
    void init(string& ss) {
        clear();
        n = ss.size();
        for (int i = 1; i <= n; i++) s[i] = ss[i-1];

        for (int i = 1; i <= n; i++) rk[i] = s[i], cnt[rk[i]]++;
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;

        int p = 0;  // 当前值域
        for (int w = 1; w <= n; w <<= 1) {  // 注意中间没有break的条件
            p = 0;
            for (int i = n; i > n-w; i--) id[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) id[++p] = sa[i] - w;
            }
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++;
            for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
            for (int i = n; i >= 1; i--) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk+1, rk+1, n*sizeof(int));
            p = 0;
            for (int i = 1; i <= n; i++) {
                rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p);
            }
            if (p == n) {
                for (int i = 1; i <= n; i++) sa[rk[i]] = i;
                break;
            }
            m = p;
        }

        // 求 height
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 0) continue;
            if (k > 0) k--;
            while (s[i+k] == s[sa[rk[i]-1]+k]) k++;
            height[rk[i]] = k;
        }
    }
};

ll cal(ll x) {
    return x*(x+1) / 2;
}

int n;
ll cnt = 0;
struct UnionFind {
    int par[maxn], sz[maxn];
    int finds(int u) {
        if (!par[u]) return 0;
        if (par[u] == u) return u;
        return par[u] = finds(par[u]);
    }
    bool unions(int u, int v) {
        u = finds(u), v = finds(v);
        if (u == v || !u || !v) return 0;
        if (sz[u] < sz[v]) swap(u, v);
        cnt -= (cal(sz[u]) + cal(sz[v]));
        sz[u] += sz[v];
        cnt += cal(sz[u]);
        par[v] = u;
        return 1;
    }
    void init(int u) {
        par[u] = u;
        sz[u] = 1;
        cnt++;
    }
    void clear() {
        memset(par, 0, sizeof(par));
        memset(sz, 0, sizeof(sz));
    }
};


UnionFind uf;
SA sa;
vector<int> pos[maxn];
ll solve(string s) {
    sa.init(s);
    cnt = 0;
    uf.clear();

    int n = s.size();
    for (int i = 0; i <= n; i++) pos[i].clear();
    for (int i = 2; i <= n; i++) {
        pos[sa.height[i]].push_back(i);
    }
    ll res = 0;
    for (int i = n-1; i >= 1; i--) {
        for (int p : pos[i]) {
            uf.init(p);
        }
        for (int p : pos[i]) {
            uf.unions(p, p-1);
            uf.unions(p, p+1);
        }
        res += cnt;
    }
    return res;
}

int main() {
    string s, t; cin >> s >> t;
    ll ans = -solve(s) - solve(t);
    s = s + (char)('a' - 1) + t;
    ans += solve(s);
    cout << ans << endl;
}
```

{{% /fold %}}

### 例5 NOI2016 [优秀的拆分](https://loj.ac/p/2083)

{{% question 题意 %}}

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是**非空**字符串，则我们称该字符串的这种拆分是优秀的。

一个字符串可能存在多种优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，求出它所有子串中，优秀拆分的方案数的和。

其中，$n \leq 30000$。

{{% /question %}}


{{% fold "题解" %}}

对于每一个位置 $i$，如果求出两个数组 `pre[i], suf[i]`。

`pre[i]` 表示以 $i$ 作为结尾，`AA` 类型字符串的数量。

`suf[i]` 代表以 $i$ 作为开头，`AA` 类型字符串的数量。

那么答案就等于 

$$\sum\limits_{i=1}^n \text{pre}_{i-1}*\text{suf}_i$$

例如 `"aabaab"` 这个字符串，对于位置 $1$ 来说，`suf[1] = 2`，因为位置 $1$ 作为开头，有 `"aa"` 和 `"aabaab"` 两个 "AA" 类型的字符串。

现在问题是怎么求出 `pre[], suf[]`？

我们枚举 "AA" 类型字符串中，"A" 的长度，设为 $k$。

然后我们在 $1, k+1, 2k+1, 3k+1, ...$ 位置设立一个特殊点。

对于第 $j$ 个特殊点和第 $j-1$ 个特殊点（假设坐标分别为 $i, i-k$），让我们来看一下它们观测到了哪些 "AA" 类型字符串？

![img](/images/102/5.jpg)

对于这两个特殊点，我们计算它们的后缀的 LCP 和前缀的 LCS（最长公共后缀）。

假设 $|LCP| + |LCS| - 1 \geq k$（-1是因为观测点本身只被考虑一次）（图上画的是刚好等于的情况），就说明它观测到了至少一个 "AA" 类型字符串。

例如图上，"AA" 类型字符串的 "A" 就是从第一个蓝色的 `[` 开始，到第一个红色的 `]` 结束。

如果 $|LCP| + |LCS| - 1 > k$ 的话，观测到的则是多个 "AA" 类型字符串，不难发现将是一整个区间都是 "A" 的开始点。

所以利用差分数组来记录 "A" 的开始位置。

不过也要注意，如果字符串 $S$ 是 `aaaaa....` 这种类型的，那么 LCP 和 LCS 的长度可能会非常长，长到覆盖了其他特殊点。

所以我们规定，第 $i$ 个特殊点只考虑到 第 $i-1$ 个特殊点的这段区间，只考虑这段区间内计算出来的 "A" 的开始点。

`suf[]` 同理。

一顿暴力手搓式子以后就可以了，代码很简洁。

• 求 LCS 和 LCP 就用 ST表。
 
{{% /fold %}}


{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;

struct SparseTable {
    int n;
    vector<int> a;
    int st[maxn][18], bin[maxn];
    int ask_st(int l, int r) {
        int len = r-l+1;
        int k = bin[len];
        return min(st[l][k], st[r-(1<<k)+1][k]);
    }
 
    void build_st() {
        bin[1] = 0; bin[2] = 1;
        for (int i = 3; i < maxn; i++) bin[i] = bin[i>>1] + 1;
        for (int i = 1; i <= n; i++) st[i][0] = a[i];
        for (int k = 1; k < 18; k++) {
            for (int i = 1; i + (1<<k) - 1 <= n; i++)
                st[i][k] = min(st[i][k-1], st[i+(1<<(k-1))][k-1]);
        }
    }
};

struct SA {
    SparseTable st;
    int n, sa[maxn], rk[maxn<<1], oldrk[maxn<<1], cnt[maxn], id[maxn], key1[maxn], height[maxn];  // 注意 rk[maxn<<1] oldrk[maxn<<1]
    char s[maxn];
    int m = 127;
    bool cmp(int i, int j, int w) {
        return oldrk[i] == oldrk[j] && oldrk[i+w] == oldrk[j+w];
    }
    void init(string& ss) {
        n = ss.size();
        for (int i = 1; i <= n; i++) s[i] = ss[i-1];

        for (int i = 1; i <= n; i++) rk[i] = s[i], cnt[rk[i]]++;
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;

        int p = 0;  // 当前值域
        for (int w = 1; w <= n; w <<= 1) {  // 注意中间没有break的条件
            p = 0;
            for (int i = n; i > n-w; i--) id[++p] = i;
            for (int i = 1; i <= n; i++) {
                if (sa[i] > w) id[++p] = sa[i] - w;
            }
            memset(cnt, 0, sizeof(cnt));
            for (int i = 1; i <= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++;
            for (int i = 1; i <= m; i++) cnt[i] += cnt[i-1];
            for (int i = n; i >= 1; i--) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk+1, rk+1, n*sizeof(int));
            p = 0;
            for (int i = 1; i <= n; i++) {
                rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p);
            }
            if (p == n) {
                for (int i = 1; i <= n; i++) sa[rk[i]] = i;
                break;
            }
            m = p;
        }

        // 求 height
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 0) continue;
            if (k > 0) k--;
            while (s[i+k] == s[sa[rk[i]-1]+k]) k++;
            height[rk[i]] = k;
        }

        st.n = n;
        st.a.resize(n+5);
        for (int i = 1; i <= n; i++) {
            st.a[i] = height[i];
        }
        st.build_st();
    }
    void clear() {
        memset(sa, 0, sizeof(sa));
        memset(rk, 0, sizeof(rk));
        memset(oldrk, 0, sizeof(oldrk));
        memset(cnt, 0, sizeof(cnt));
        memset(id, 0, sizeof(id));
        memset(key1, 0, sizeof(key1));
        memset(height, 0, sizeof(height));
        memset(s, 0, sizeof(s));
        m = 127;
    }
};

int n, pre[maxn], suf[maxn];
void solve() {
    memset(pre, 0, sizeof(pre));
    memset(suf, 0, sizeof(suf));
    SA sa, sa2; sa.clear(); sa2.clear();
    string s; cin >> s;
    n = s.size();
    string t = s; reverse(t.begin(), t.end());
    sa.init(s), sa2.init(t);
    
    for (int k = 1; k < n; k++) {
        for (int i = k+1; i <= n; i += k) {
            int j = i-k;
            int ri = sa.rk[i], rj = sa.rk[j];
            if (ri > rj) swap(ri, rj);
            int R = sa.st.ask_st(ri+1, rj);

            ri = sa2.rk[n-i+1], rj = sa2.rk[n-j+1];
            if (ri > rj) swap(ri, rj);
            int L = sa2.st.ask_st(ri+1, rj);
            if (L + R - 1 < k) continue;

            suf[max({j-L+1, 1, j-k+1})]++, suf[min(j,j+R-k)+1]--;   // [j-L+1, j+R-k]
            pre[max(i,i-L+k)]++, pre[min({i+k-1, n, i+R-1})+1]--;  // [i-L+k, i+R-1]
        }
    }
    for (int i = 1; i <= n; i++) pre[i] += pre[i-1], suf[i] += suf[i-1];
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += (ll)pre[i-1] * suf[i];
    }
    cout << ans << endl;
}

int main() {
    int T; cin >> T;
    while (T--) {
        solve();
    }
}
```

{{% /fold %}}

