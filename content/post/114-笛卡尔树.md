+++
title = '笛卡尔树'
date = 2023-09-01T11:14:35-05:00
draft = false
categories = ['算法']
tags = ['', '']
+++

## 定义

笛卡尔树是一种二叉树，每一个结点由一个键值二元组 $(k,v)$ 构成。

## 性质

1. $k$ 满足 BST 的性质
2. $v$ 满足 min-heap 的性质。
3. 如果笛卡尔树的 $k,v$ 值确定，且 $k$ 互不相同，$v$ 互不相同，那么这个笛卡尔树的结构是唯一的。


![img](/images/114/1.png)

## $O(n) 建树$

给定一个数组，可以建出对应的笛卡尔树，将数组的值作为 $v$，数组的index作为 $k$，建树的思想是：

每次取当前数组中最小的那个元素，将它左边作为左子树，右边作为右子树，然后递归建树。

通过单调栈维护从根出发的向右的链（递增栈），在加入一个新元素 $x$ 前（弹出过程已经完成）：

1. 如果之前有弹出元素，那么最后一个弹出的元素作为 $x$ 的左child。
2. 如果此时栈上有元素，那么栈顶的元素的右 $child$ 是 $x$。


### 例1 洛谷P5854[【模板】笛卡尔树](https://www.luogu.com.cn/problem/P5854)

{{% question 题意 %}}

给定一个 $1$ 到 $n$ 的permutation，构建出笛卡尔树。

{{% /question %}}

{{% fold "代码" %}}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e7+5;

struct Node {
    int lc, rc, p, idx;
} a[maxn];
int n;
int main() {
    fastio;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].p;
        a[i].idx = i;
    }
    stack<pii> st;
    for (int i = 1; i <= n; i++) {
        int last = 0;
        while (st.size() && st.top().first > a[i].p) last = st.top().second, st.pop();
        if (last) a[i].lc = last;
        if (st.size()) a[st.top().second].rc = a[i].idx;
        st.push({a[i].p, i});
    }

    ll ans1 = 0, ans2 = 0;
    for (int i = 1; i <= n; i++) {
        ans1 ^= ((ll)i * (a[i].lc + 1));
        ans2 ^= ((ll)i * (a[i].rc + 1));
    }
    cout << ans1 << " " << ans2 << "\n";
}
```

{{% /fold %}}


