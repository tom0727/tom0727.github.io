[{"categories":["算法"],"contents":"介绍 单调队列可以用于解决滑动窗口最值问题。\n简单来说，单调队列内维护的是 index，单调队列要满足两个特性：\n q[tail] - q[head] \u0026lt; m，其中 $m$ 是窗口的大小。 队列中的元素，对应的值单调递减/递增。  要维护第二条的话，就需要在插入一个新的元素时，从队列的尾部不断 pop 掉元素，保证单调性（本质上和单调栈一样）。\n例1 洛谷P2627 [USACO11OPEN]Mowing the Lawn G 题意\n给定一个包含 $n$ 个正整数的数组，从中选取一些数，使得不存在连续的 $\u0026gt;k$ 个数。\n输出选取方案中，可能的最大和。\n其中，$n \\leq 10^5$\n 题解 DP。设 $dp[i]$ 为前 $i$ 个数字所能得到的最大答案。\n所以我们枚举一下上一个不选的位置 $j$，则有\n$$dp[i] = \\max_{j=i-k}^i\\{dp[j-1]+sum(j+1,i)\\}$$\n$$=\\max_{j=i-k}^i\\{dp[j-1]+sum[i] - sum[j]\\}$$\n由于 $i$ 固定，所以可以把 $sum[i]$ 拿出来，我们只要求\n$$\\max_{j=i-k}^i\\{dp[j-1] - sum[j]\\}$$\n这个东西只与 $j$ 有关，所以就是一个滑动窗口最小值问题了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll q[maxn\u0026lt;\u0026lt;1], a[maxn], sum[maxn], dp[maxn]; int head = 1, tail = 0, n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], sum[i] = sum[i-1] + a[i]; for (int i = 1; i \u0026lt;= k; i++) { dp[i] = sum[i]; while (head \u0026lt;= tail \u0026amp;\u0026amp; dp[q[tail]] - sum[q[tail]+1] \u0026lt;= dp[i-1] - sum[i]) tail--; q[++tail] = i-1; } for (int i = k+1; i \u0026lt;= n; i++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; dp[q[tail]] - sum[q[tail]+1] \u0026lt;= dp[i-1] - sum[i]) tail--; q[++tail] = i-1; while (q[tail] - q[head] \u0026gt;= k+1) head++; int j = q[head]; dp[i] = sum[i] + dp[j] - sum[j+1]; } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; }   ","date":"2021-11-17T17:24:34+08:00","permalink":"https://tom0727.github.io/post/058-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","tags":["",""],"title":"单调队列"},{"categories":["算法"],"contents":"定义 基环树指的是一个 $n$ 个节点，$n$ 条边的联通图。\n叫基环树的原因是：给定一棵树，在这棵树上加上 任意一条边，就可以形成一个基环树了。\n基环树的性质很优秀，因为去掉环上的任意一条边，就可以转化为一棵树。\n所以基环树的常用套路有：\n 找环，然后删掉环上的任意一条边 $(u,v)$，对 $u$ 为根的树进行一次树形DP（并强制不选 $u$），再对 $v$ 为根的树进行一次树形DP（并强制不选 $v$）。 将环缩成一个点，然后分类讨论答案是否经过环两种情况。  例1 洛谷P2607 [ZJOI2008]骑士 题意\n给定 $n$ 个骑士，每个骑士有一个能力值 $a_i$，和他的一个痛恨的人 $b_i$（痛恨的人不能是自己）。\n从这些骑士中选出若干个，使得两两之间没有痛恨的人，求出最大的能力值总和。\n其中，$n \\leq 10^6$。\n 题解 按照每个人 $i$ 与他痛恨的人 $b_i$ 连边，这就可以形成一个基环森林了（由多个基环树组成的森林）。\n现在，只考虑一个基环树的话怎么办？\n首先发现，如果断开一条边，在树上考虑这个问题的话，就是一个非常简单的树形DP了。\n所以我们不妨断开环上的任意一条边 $(u,v)$。\n然后以 $u$ 为根，在这个新的树上进行一次树形DP，并强制不选 $u$。\n同理，以 $v$ 为根，在这个新的树上进行一次树形DP，并强制不选 $v$。\n求两次树形DP得出的最大值即可。\n最终答案就是每个基环树求出的最大值之和。\n 找环的话，只要发现一个 backward edge，记录一下这个 edge 的编号 E，标记一下 E 和 E^1，在树形DP中避开这两条边，就可以达到断开边的效果了。这要求我们建图时，使用 ecnt = 2。\n• 需要格外注意一下，在断边的时候，必须判断当前枚举的边 e 是否等于 E 或者 E^1，而不能判断边的两端端点，这是防止出现 $(1,2), (2,1)$ 这种情况，可以参考这里。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, head[maxn], ecnt = 2; ll a[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int ed, dep[maxn], par[maxn], E; void dfs1(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u]) continue; if (dep[to]) { E = e; } else { dep[to] = dep[u] + 1; par[to] = u; dfs1(to); } } } ll ans = 0, tot = 0; ll dp[maxn][2]; void dfs2(int u, int p) { dp[u][0] = 0; dp[u][1] = a[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || e == E || e == (E^1)) continue; dfs2(to, u); dp[u][0] += max(dp[to][0], dp[to][1]); dp[u][1] += dp[to][0]; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; v; addEdge(i,v); addEdge(v,i); } for (int u = 1; u \u0026lt;= n; u++) { if (!dep[u]) { ans = 0; E = 0; dep[u] = 1; dfs1(u); int c1 = edges[E].to, c2 = edges[E^1].to; dfs2(c1, 0); ans = max(ans, dp[c1][0]); dfs2(c2, 0); ans = max(ans, dp[c2][0]); tot += ans; } } cout \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; }   例2 洛谷P4381 [IOI2008] Island 题意\n给定一个基环树组成的森林，每条边上有边权，求出每个基环树的最长链的长度之和。\n最长链的定义为：一条路径，不经过重复的节点。\n其中，$n \\leq 10^6$。\n 题解 既然是基环森林，那就只考虑每个基环树怎么求最长链。\n注意到一个基环树由一个环，以及每个环的子树组成，长这样：\n所以我们可以讨论这个最长链的位置：\n第一种情况：最长链不经过环\n这说明最长链完全在一个子树内，那么这就是一个树的直径问题。\n第二种情况：最长链经过环\n如果经过了环，我们设它从环上的某个点 $u$ 的子树开始，到环上另外一个点 $v$ 的子树结束。\n并且设 $dis(u,v)$ 为 $u,v$ 在环上的最长距离，设 $d(u)$ 为 $u$ 的子树最大深度。\n所以答案就是\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n但找这样的 $(u,v)$ 是 $O(n^2)$ 的，考虑一下如何优化？\n如果我们将一个环 $1,2,3,\u0026hellip;,n$ 断开，并复制一份，得到 $1,2,3,\u0026hellip;,n,1\u0026rsquo;,2\u0026rsquo;,3\u0026rsquo;,\u0026hellip;,n'$，则我们可以快速的算出 $dis(u,v)$。\n不妨设 $u\u0026lt;v$，并且求一个距离的前缀和 $a[]$，其中 $a[i]=a[i-1]+w(i-1,i)$。\n那么\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n就可以写成\n$$\\max_{(u,v)}\\{d(u)+d(v)+a[v]-a[u]\\}, u,v\\in[1,n] \\cup [1\u0026rsquo;,n\u0026rsquo;], (v-u) \\in [1, n-1]$$\n当 $v$ 确定时，我们要求的实际上就是\n$$\\max_u \\{d(u) - a[u]\\}, u \\in [v-n+1,v-1]$$\n这就是个单调队列优化dp。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, in[maxn]; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } bool vis[maxn], ring[maxn]; ll ans = 0; // solve the component containing u vector\u0026lt;int\u0026gt; ver; // vertex in current component void bfs(int u) { vis[u] = 1; ver.push_back(u); int p = 0; while (p \u0026lt; ver.size()) { int v = ver[p]; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to]) continue; vis[to] = 1; ver.push_back(to); } p++; } } ll dep[maxn], maxdep[maxn]; vector\u0026lt;int\u0026gt; tmp; // used for storing leaf int maxi = 0, n; int q[maxn\u0026lt;\u0026lt;1], hd, tail, par[maxn]; void bfs2(int u) { int o = u; hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; if (dep[u] \u0026gt; dep[maxi]) maxi = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || ring[to]) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } maxdep[o] = dep[maxi]; } ll md = 0; void bfs3(int u, int v) { hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; md = max(md, dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || (ring[to] \u0026amp;\u0026amp; to != v)) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } } vector\u0026lt;int\u0026gt; rings; bool tag[maxn\u0026lt;\u0026lt;1]; struct Node { ll a, d; } nd[maxn\u0026lt;\u0026lt;1]; bool del[maxn]; void solve(int u) { ver.clear(); tmp.clear(); bfs(u); ll res = 0; for (int v : ver) { if (in[v] == 1) tmp.push_back(v); } while (!tmp.empty()) { int v = tmp.back(); tmp.pop_back(); del[v] = 1; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!del[to]) { in[v]--; in[to]--; if (in[to] == 1) tmp.push_back(to); } } } for (int v : ver) { if (in[v] \u0026gt;= 2) ring[v] = 1; // v is on the ring } rings.clear(); int cnt = 0; for (int v : ver) { if (ring[v]) { cnt++; if (!rings.size()) rings.push_back(v); maxi = 0; md = 0; bfs2(v); dep[maxi] = 0; bfs3(maxi, v); res = max(res, md); hd = 1, tail = 0; } } // get the ring if (rings.size()) { while (rings.size() \u0026lt; cnt) { int v = rings.back(); for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!ring[to] || (rings.size() \u0026gt; 1 \u0026amp;\u0026amp; to == rings[rings.size()-2])) continue; if (to == rings[0]) { goto done; } rings.push_back(to); break; } } } done:; int ptr = 0; if (rings.size()) { rings.push_back(rings.front()); nd[++ptr] = {0, maxdep[rings[0]]}; } int m = rings.size(); for (int i = 0; i \u0026lt; m-1; i++) { int v = rings[i]; int v2 = rings[i+1]; for (int e = head[v]; e; e = edges[e].nxt) { if (edges[e].to == v2 \u0026amp;\u0026amp; !tag[e]) { ll w = edges[e].w; nd[ptr+1].a = nd[ptr].a + w; nd[ptr+1].d = maxdep[v2]; ptr++; tag[e] = tag[e^1] = 1; // 标记边，防止有大小为2的环！ break; } } } for (int i = 0; i \u0026lt; m-2; i++) { nd[ptr+1].a = nd[ptr].a + (nd[i+2].a - nd[i+1].a); nd[ptr+1].d = maxdep[rings[i+1]]; ptr++; } hd = 1, tail = 0; q[++tail] = 1; m--; // now: m is the size of the ring for (int i = 2; i \u0026lt;= ptr; i++) { while (hd \u0026lt;= tail \u0026amp;\u0026amp; i - q[hd] \u0026gt;= m) hd++; if (hd \u0026lt;= tail) { res = max(res, nd[i].a + nd[i].d + nd[q[hd]].d - nd[q[hd]].a); } while (hd \u0026lt;= tail \u0026amp;\u0026amp; nd[i].d - nd[i].a \u0026gt;= nd[q[tail]].d - nd[q[tail]].a) tail--; q[++tail] = i; } ans += res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int v; ll w; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(i,v,w); addEdge(v,i,w); in[i]++; in[v]++; } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { solve(i); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   注意点\n 所有的树上/图上操作（包括找树的直径）都必须用 bfs 进行，因为 $n \\leq 10^6$，dfs 会爆栈。 找环的时候用拓扑排序，不过注意这个是无向图，所以写法略有不同。 找出环以后，要按照环的顺序把环断开，不能只考虑哪些节点在环上而不考虑顺序。 一定要注意 大小为 $2$ 的环，我们在断环为链的时候不能考虑节点之间的关系，而是要标记 edge，因为双向图的缘故，大小为 $2$ 的环之间会有重边，一定要注意！   例3 洛谷P1399 [NOI2013] 快餐店 题意\n给定一个 $n$ 个节点，$n$ 条边的无向图（基环树），边上有权值。\n现在要在树上找一个位置 $x$，这个位置 $x$ 可以位于边上的任意一处，也可以位于节点上。\n如何选择 $x$ 的位置，使得它到 所有节点的最短距离的最大值 最小？输出这个最小值。\n形式化的，求：\n$$\\min_x \\{\\max_u\\{dis(x,u)\\}\\}$$\n其中，$n \\leq 10^5$。\n 题解 先考虑，如果这是一棵树的话怎么办？\n那我们只要求出这棵树的直径，然后答案就是 直径/2 了。\n对于基环树，我们一般都是断环，得到一棵树，那么对于这个题我们有类似的想法：\n猜想：环上必然存在一条边，使得这条边断开以后对整个答案没有任何影响。\n证明：我们考虑 $x$ 的位置\n $x$ 在环上 $x$ 在一棵子树中  对于第一种情况，我们注意到 $x$ 到所有节点的最短路径中，由环上路径和树内路径组成。\n我们只考虑环上的路径（因为我们要证明的是环上的所有边不可能都被用到，至少有一个是用不上的）。\n那么问题就相当于，$x$ 到环上所有节点的最短路径，是否存在一条边用不上？\n确实如此，因为无论我们怎么画，都会有一条边被断开以后没有任何影响，如图：\n 所以问题就转化成了：\n给定一棵基环树，我们现在要断开环上的一条边，求所有断开的方案中，树的直径最小的一个方案，求出最小值？\n然后这题就和上一个例子差不多了，一样分类讨论直径在哪：\n 断开后，树的直径在子树内 断开后，树的直径在原先的环上  对于第一种情况，无论断开哪个都不影响答案，所以对于每个子树统计一下直径即可。\n对于第二种情况，上一题的单调队列套路不好使了，我们形式化的描述一下这个问题：\n给定一个环 $1,2,\u0026hellip;,n$，对于每一种断环方案，都求出：\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n然后取所有断环方案对应的最小值。\n这里有了个断环方案要讨论，就变得非常不友好，就算断环成链也没什么思路，我们考虑另外一种方法：\n假设我们要断开 $(i,i+1)$，那么此时，这个所求的最大值对应的 $(u,v)$ 有几种情况呢？\n $(u,v)$ 都在 $[1,i]$ 内。 $(u,v)$ 都在 $[i+1,n]$ 内。 $u$ 在 $[1,i]$，$v$ 在 $[i+1,n]$。  对于第一种，我们同样用前缀和的方式来看，因为 $dis(u,v) = sum(v) - sum(u)$，所以和上一题一样处理一个前缀和即可，本题甚至都不需要单调队列，维护一下前缀的 -sum[u] + d[u] 的最大值即可。\n然后我们就可以处理出一个 pre[] 数组，pre[i] 的意思就是如果 $(u,v)$ 都在 $[1,i]$ 内，可以得到的最大值。\n同理对于第二种我们用后缀处理一下即可，可以得到 suf[]。\n对于第三种，我们可以发现我们所求的 $dis(u,v)$，等于\n$u$ 的 前缀链 + $v$ 的 后缀链 + $w(n,1)$\n 所以我们只要把这个前缀链的最大值 maxl[i] 求出即可（同理后缀链最大值也求出 maxr[]）。\n那么，当我们断开 $(i,i+1)$ 时，就有\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\} = \\max\\{pre(i), suf(i+1), maxl(i) + maxr(i+1) + w(n,1)\\}$$\n然后将 $i$ 从 $1$ 枚举到 $n$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, in[maxn]; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } bool ring[maxn]; ll ans = 0; ll dep[maxn], maxdep[maxn]; vector\u0026lt;int\u0026gt; tmp; // used for storing leaf int maxi = 0, n; int q[maxn\u0026lt;\u0026lt;1], hd, tail, par[maxn]; void bfs2(int u) { int o = u; hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; if (dep[u] \u0026gt; dep[maxi]) maxi = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || ring[to]) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } maxdep[o] = dep[maxi]; } ll md = 0; void bfs3(int u, int v) { hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; md = max(md, dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || (ring[to] \u0026amp;\u0026amp; to != v)) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } } vector\u0026lt;int\u0026gt; rings; bool tag[maxn\u0026lt;\u0026lt;1]; struct Node { ll a, d; } nd[maxn\u0026lt;\u0026lt;1]; bool del[maxn]; ll maxl[maxn], maxr[maxn], pre[maxn], suf[maxn]; void solve() { ll res = 0; for (int v = 1; v \u0026lt;= n; v++) { if (in[v] == 1) tmp.push_back(v); } while (!tmp.empty()) { int v = tmp.back(); tmp.pop_back(); del[v] = 1; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!del[to]) { in[v]--; in[to]--; if (in[to] == 1) tmp.push_back(to); } } } for (int v = 1; v \u0026lt;= n; v++) { if (in[v] \u0026gt;= 2) ring[v] = 1; // v is on the ring } int cnt = 0; for (int v = 1; v \u0026lt;= n; v++) { if (ring[v]) { cnt++; if (!rings.size()) rings.push_back(v); maxi = 0; md = 0; bfs2(v); dep[maxi] = 0; bfs3(maxi, v); res = max(res, md); hd = 1, tail = 0; } } // get the ring if (rings.size()) { while (rings.size() \u0026lt; cnt) { int v = rings.back(); for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!ring[to] || (rings.size() \u0026gt; 1 \u0026amp;\u0026amp; to == rings[rings.size()-2])) continue; if (to == rings[0]) { goto done; } rings.push_back(to); break; } } } done:; int ptr = 0; if (rings.size()) { rings.push_back(rings.front()); nd[++ptr] = {0, maxdep[rings[0]]}; } int m = rings.size(); for (int i = 0; i \u0026lt; m-1; i++) { int v = rings[i]; int v2 = rings[i+1]; for (int e = head[v]; e; e = edges[e].nxt) { if (edges[e].to == v2 \u0026amp;\u0026amp; !tag[e]) { ll w = edges[e].w; nd[ptr+1].a = nd[ptr].a + w; nd[ptr+1].d = maxdep[v2]; ptr++; tag[e] = tag[e^1] = 1; // 标记边，防止有大小为2的环！ break; } } } for (int i = 0; i \u0026lt; m-2; i++) { nd[ptr+1].a = nd[ptr].a + (nd[i+2].a - nd[i+1].a); nd[ptr+1].d = maxdep[rings[i+1]]; ptr++; } hd = 1, tail = 0; ll R = res; res = 1e18; m--; // now: m is the size of the ring // maxl: record a+d for (int i = 1; i \u0026lt;= m; i++) maxl[i] = max(maxl[i-1], nd[i].a + nd[i].d); for (int i = m; i \u0026gt;= 1; i--) maxr[i] = max(maxr[i+1], nd[m+1].a - nd[i].a + nd[i].d); // pre: record the maximum of two i,j \u0026lt;= pre, which dis(i,j) + d[i] + d[j] is maximum (just record minimum of -a + d) ll mn = 0; for (int i = 1; i \u0026lt;= m; i++) { pre[i] = max(pre[i-1], mn + nd[i].a + nd[i].d); mn = max(mn, -nd[i].a + nd[i].d); } mn = 0; for (int i = m; i \u0026gt;= 1; i--) { suf[i] = max(suf[i+1], mn + nd[m+1].a - nd[i].a + nd[i].d); mn = max(mn, -(nd[m+1].a - nd[i].a) + nd[i].d); } for (int i = 1; i \u0026lt;= m; i++) { // break (i,i+1) ll r1 = 0, r2 = 0; r1 = max(pre[i], suf[i+1]); r2 = maxl[i] + maxr[i+1]; res = min(res, max(r1,r2)); } ans += max(R, res); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); in[u]++; in[v]++; } solve(); printf(\u0026quot;%.1f\\n\u0026quot;,(double)(ans)*0.5); }   ","date":"2021-11-16T15:38:25+08:00","permalink":"https://tom0727.github.io/post/057-%E5%9F%BA%E7%8E%AF%E6%A0%91/","tags":["",""],"title":"基环树"},{"categories":["解题报告"],"contents":"排名 Solve: 5 (ADEFJ)\nPenalty: 767\nRank: 122/343 (35%)\n题解 D - Exam Results 题意\n给定 $n$ 个学生，第 $i$ 个学生的分数要么为 $a_i$，要么为 $b_i$。\n给定整数 $P \\in [1,100]$，如果最高分为 $x$，则分数 $\\geq x * \\frac{P}{100}$ 的学生可以及格。\n求所有可能的情况中，及格学生的最大数量？\n其中，$1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i \\leq b_i \\leq 10^9$。\n 题解 直接枚举可能出现的最高分，我们知道要保证 $x$ 为最高分，必须有 $x \\geq \\max \\{a_i\\}$。\n如果我们从小到大枚举 $x$，会发现 $[x * \\frac{P}{100}, x]$ 是一个滑动的窗口。\n所以本题只要先把所有的 $a_i, b_i$ 放在一起，然后 sort 一下，从 $\\max \\{a_i\\}$ 开始枚举 $x$，在窗口滑动的过程中，利用类似于莫队的思想维护及格人数即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+7; ll n,p,ans = 0; struct Point { ll x, id; } arr[maxn*2]; int cnt[maxn]; ll cur = 0; void add(int x) { cnt[x]++; if (cnt[x] == 1) cur++; } void minu(int x) { cnt[x]--; if (!cnt[x]) cur--; } int main() { int T; read(T); for (int t = 1; t \u0026lt;= T; t++) { ans = 0; read(n), read(p); cur = 0; ll lmax = 0; for (int i = 1; i \u0026lt;= n; i++) { ll a,b; read(b); read(a); a *= 100LL, b *= 100LL; lmax = max(lmax, a); arr[i*2 - 1] = {a, i}, arr[i*2] = {b, i}; } sort(arr+1, arr+2*n+1, [](auto a, auto b) { return a.x \u0026lt; b.x; }); int st = 0; for (int i = 1; i \u0026lt;= 2*n; i++) { if (arr[i].x \u0026gt;= lmax) { st = i; break; } } int lptr = 0, rptr = 0; for (int i = st; i \u0026lt;= 2*n; i++) { ll L = arr[i].x / 100 * p, R = arr[i].x; while (rptr + 1 \u0026lt;= 2*n \u0026amp;\u0026amp; arr[rptr+1].x \u0026lt;= R) { rptr++; add(arr[rptr].id); } while (lptr + 1 \u0026lt;= rptr \u0026amp;\u0026amp; arr[lptr+1].x \u0026lt; L) { lptr++; minu(arr[lptr].id); } ans = max(ans, cur); } printf(\u0026quot;Case #%d: %lld\\n\u0026quot;, t, ans); fill(cnt, cnt+n+5, 0); } }   J - Kingdom\u0026rsquo;s Power 题意\n给定一棵 $n$ 个节点的有根树，根为 $1$。$1$ 的位置有无限个飞船。\n每一步操作中，可以选定任意一个飞船，让它走向它的一个邻居。\n求最少操作数使得所有节点被访问至少一次？\n其中，$n \\leq 10^6$\n 题解 猜想 $1$：\n任意时刻，只有一个飞船是 有用的。\n要么我们动这个飞船，要么我们动 $1$ 里面的无限个飞船。如果我们在访问某个子树时没有使用这个飞船，那么这个飞船就再也不会被用到了。\n这个猜想是正确的（然而我也不确定怎么严格证明）。\n猜想 $2$：\n我们可以利用贪心，从 $1$ 开始 dfs，根据 最大深度 的顺序，从小到大 dfs 它的 child。\n这个贪心也是正确的，感性理解的话可以考虑最简单的情况：\n这里从 $2$ 出发的话应该是先访问 $3,4$ ，最后访问 $5$。\n 利用以上贪心就可以写出一个 $O(n\\log n)$ 的解法：\n直接维护当前 有用 飞船的位置 $x$，然后每次要移动到下一个点 $y$ 的时候，比较一下 $d(x,y)$ 和 $d(1,y)$ 的距离即可，然后更新 $x=y$。\n比赛的时候就是这样写的，然后愉快的T了。\n $O(n)$ 正解：\n我们发现，对于一个节点 $u$，我们定义 $dp[u]$ 为：访问完 $u$ 的整个子树，并且飞船不回来（即停留在访问时的哪个节点）所需要的步数。\n$dp[u]$ 怎么转移？\n对于 $u$ 的每个child $v$，除了最后一个访问的 $v$ 以外，其他的 child 都需要访问结束以后，再回到 $u$。\n回到 $u$ 的飞船，要么是访问完 $v$ 的那个飞船再走回来，要么我们直接从 $1$ 派一个飞船到 $u$，看哪个距离更近就好了。\n所以有：\n$$dp[u] = \\sum\\limits_v \\{1 + dp[v] + \\min \\{maxdep[v] - dep[u], dep[u]\\} \\}$$\n注意到这个转移把 最后一个child $v$ 需要回到 $u$ 的贡献也算上了，且我们知道最后一个child $v$ 访问完毕时，停留的节点深度为 $maxdep[u]$，所以我们需要减掉这个贡献：\n$$dp[u] = dp[u] - \\min \\{maxdep[u] - dep[u], dep[u]\\}$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+3; int T, n; int dep[maxn], maxdep[maxn], head[maxn], ecnt = 1; ll dp[maxn]; struct Edge { int to, nxt; } edges[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u) { maxdep[u] = dep[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dep[to] = dep[u] + 1; dfs1(to); maxdep[u] = max(maxdep[u], maxdep[to]); } } void dfs2(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs2(to); dp[u] += (dp[to] + min(maxdep[to] - dep[u], dep[u]) + 1); } dp[u] -= (min(maxdep[u] - dep[u], dep[u])); } int main() { read(T); for (int t = 1; t \u0026lt;= T; t++) { read(n); for (int u = 2; u \u0026lt;= n; u++) { int v; read(v); addEdge(v, u); } dep[1] = 0; dfs1(1); dfs2(1); printf(\u0026quot;Case #%d: %lld\\n\u0026quot;,t, dp[1]); fill(maxdep, maxdep+n+2, 0); fill(dp, dp+n+2, 0); ecnt = 1; fill(head, head+n+2, 0); } }   H - Interstellar Hunter 题意\n在一个无限大的二维平面中，我们的初始位置为 $(0,0)$，现在给定 $Q$ 个询问，每次询问为两种格式：\n$1 ~ x ~ y$：获得 $(x,y)$ 的跳跃能力。\n$2 ~ x ~ y ~ w$：在 $(x,y)$ 的位置出现一个价值为 $w$ 的宝藏，可以选择走到这里拿宝藏。\n当我们拥有 $(a,b)$ 的跳跃能力时，可以将我们的坐标 $(x,y)$ 变为 $(x+a,y+b)$ 或者 $(x-a,y-b)$。\n求最大的宝藏价值总和？\n其中，$Q \\leq 10^6$。\n 题解 获得一个跳跃能力以后，我们每次移动就多了一种移动方式。\n注意到我们当前坐标为多少不会影响答案，因为这个获得的跳跃能力，相当于在一个 整数域 中维护一些向量组成的 $span$。每次都看作是从 $(0,0)$ 出发就好了。\n现在问题就在于如何维护向量集合了。\n有一个结论：\n如果集合中有 $\\geq 2$ 个不共线向量，则可以用 $(d,0), (x_2,y_2)$ 来表示这个向量集合的 $span$，其中 $d \\leq x_2$。\n证明？我也不会。\n现在考虑一下如果我们加入了一个新的向量 $(x,y)$，怎么更新这些向量？\n在整数域下，就需要保证 $d$ 尽量小，而 $y_2$ 也尽量小。\n所以我们可以先用 $(x_2,y_2)$ 与 $(x,y)$ 构造出一个 $(x\u0026rsquo;,0)$ 的向量，然后更新 $d = \\gcd(d,x\u0026rsquo;)$。\n要令 $y_2$ 尽量小，则我们用 $(x_2,y_2)$ 与 $(x,y)$ 构造出 $(x\u0026rsquo;', \\gcd(y_2,y))$。\n这个构造的过程，就是一个 linear combination 的过程。\n那么怎么构造呢？注意到是在整数域下，所以用 $exgcd$！\n所以设：\n$$ay_2 + by = 0$$\n令 $g = \\gcd(y_2,y)$，就有：\n$$a\\frac{y_2}{g} + b\\frac{y}{g} = 0$$\n所以 $a = -\\frac{y}{g}, b = \\frac{y_2}{g}$，就有：\n$$a(x_2,y_2) + b(x,y) = (x\u0026rsquo;, 0)$$\n然后同理，解出\n$$a(x_2,y_2) + b(x,y) = (x\u0026rsquo;', \\gcd(y_2,y))$$\n解出来以后，令 $x_2 = x\u0026rsquo;', y_2 = \\gcd(y_2,y)$ 即可。\n• 注意需要单独处理 $d,x,y=0$ 的情况。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+3; int T, Q; ll curx, cury; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int cnt = 0; ll d = 0, x2, y2; int main() { read(T); for (int tt = 1; tt \u0026lt;= T; tt++) { read(Q); d = x2 = y2 = 0; ll ans = 0; while (Q--) { int t; ll x,y,w; read(t); read(x); read(y); if (t == 1) { if (y == 0) { d = gcd(d, x); continue; } ll a,b; ll g = exgcd(y, y2, a, b); // 因为 y2 = 0 无所谓，所以 g != 0 ll xx = abs(-y2 * x + y * x2) / g; d = gcd(d, xx); y2 = g; x2 = a * x + b * x2; if (d) x2 = (x2 % d + d) % d; } else { read(w); if (y == 0) { if (!d \u0026amp;\u0026amp; !x) ans += w; if (d \u0026gt; 0 \u0026amp;\u0026amp; x % d == 0) ans += w; } else { if (y2 \u0026amp;\u0026amp; y % y2 == 0) { ll c = y / y2; x -= c * x2; if (d \u0026amp;\u0026amp; x % d == 0) ans += w; if (!d \u0026amp;\u0026amp; !x) ans += w; } } } } printf(\u0026quot;Case #%d: %lld\\n\u0026quot;, tt, ans); } }   参考链接\nhttps://www.silllage.com/2020-ccpc-qhd-i-interstellar-hunter/ https://blog.csdn.net/nagisa2019/article/details/115414362 https://blog.csdn.net/wanherun/article/details/114477252 https://www.cnblogs.com/st1vdy/p/13870452.html\n ","date":"2021-10-31T11:32:46+08:00","permalink":"https://tom0727.github.io/post/056-ccpc2020%E7%A7%A6%E7%9A%87%E5%B2%9B/","tags":["",""],"title":"CCPC2020秦皇岛"},{"categories":["算法"],"contents":"二次剩余用于解决在 模意义下开根 的问题：\n题意\n给定一个质数 $P$ 和一个非负整数 $N$，求 $x$ 使得\n$$x^2 \\equiv N (\\text{mod } P)$$\n本问题等价于求 $$\\sqrt N ~(\\text{mod } P)$$\n 性质  这个问题可能无解，如果有解，则有两个解，它们互为相反数。   模版 // 求 sqrt(a) 在 mod P 下的值 // 调用 solve(a, P, r1, r2) // 若有解，r1, r2 分别为两个解，其中 r1 小，r2 大 // 若无解，r1 == -1 namespace Quadratic_residue { ll qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } bool check_if_residue(ll x, ll P) { return qpow(x, (P - 1) \u0026gt;\u0026gt; 1, P) == 1; } void solve(ll a, ll P, ll\u0026amp; r1, ll\u0026amp; r2) { if (a \u0026lt;= 1) { r1 = a, r2 = P - a; return; } if (!check_if_residue(a, P)) { r1 = -1; return; } ll x; while (1) { x=1ll*rand()*rand()%P; if (qpow((x*x-a+P)%P,(P-1)/2, P)!=1) break; } ll w=(x*x-a+P)%P; pll res = {1,0}, t = {x,1}; auto Mul=[\u0026amp;](pll a,pll b){ // 复数乘法 ll x=(1ll*a.first*b.first+1ll*a.second*b.second%P*w)%P; ll y=(1ll*a.first*b.second+1ll*a.second*b.first)%P; return make_pair(x,y); }; ll d=(P+1)/2; while (d) { if(d\u0026amp;1) res=Mul(res,t); t=Mul(t,t); d\u0026gt;\u0026gt;=1; } ll r = (res.first % P + P) % P; r1 = min(r, (P - r) % P); r2 = max(r, (P - r) % P); } };  参考链接  https://chasingdeath.github.io/articles/2020/08/15/2244ecc3.html （模版来源） https://www.luogu.com.cn/problem/P5491  ","date":"2021-10-30T11:19:19+08:00","permalink":"https://tom0727.github.io/post/055-%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/","tags":["二次剩余"],"title":"二次剩余"},{"categories":["算法"],"contents":"介绍 生成函数可以解决形如 满足XX条件的方案数共有多少种 的问题，它也能够解决 推导通项公式 等问题，生成函数常常与多项式运算结合在一起。\n定义 对于一个无限数列\n$$a = \\{a_0, a_1, a_2, \u0026hellip;\\}$$\n它的生成函数为\n$$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; = \\sum\\limits_{i=0}^{\\infty}a_ix^i$$\n其中 $x$ 的值并没有意义。\n• 有限数列 $\\{a_0, a_1, a_2, \u0026hellip;, a_n\\}$ 的生成函数就是 $f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n = \\sum\\limits_{i=0}^{n}a_ix^i$\n• 我们定义 $[x^{k}]f(x)$ 为 $f(x)$ 表达式中，$x^k$ 的系数。（为了方便表达，有的时候也会使用 $a_k, b_k$）\n封闭形式与展开形式 生成函数有 封闭形式 和 展开形式 两种形态。\n封闭形式适合进行生成函数之间的运算，展开形式则可以得到生成函数各项的系数（通项公式），从而获得最终的答案（方案数的统计）。\n例如，对于无限数列\n$$\\{1,1,1,1,\u0026hellip;\\}$$\n它的生成函数展开形式为：\n$$f(x) = 1+x+x^2+x^3+\u0026hellip;$$\n很明显这是一个等比数列，公比为 $x$，进行求和可以得到封闭形式：\n$$f(x) = 1+x+x^2+x^3+\u0026hellip; = \\frac{1}{1-x}$$\n一些常见的封闭式与展开式的对应    封闭形式 展开形式 数列 通项公式     $\\frac{1}{1-x}$ $\\sum\\limits_{i=0}^{\\infty}x^i = 1+x+x^2+x^3+\u0026hellip;$ $\\{1,1,1,1,\u0026hellip;\\}$ $b_k = 1$   $\\frac{1}{(1-x)^2}$ $\\sum\\limits_{i=0}^{\\infty}(i+1)x^i = 1+2x+3x^2+4x^3+\u0026hellip;$ $\\{1,2,3,4,\u0026hellip;\\}$ $b_k = k+1$   $\\frac{1}{1-ax}$ $\\sum\\limits_{i=0}^{\\infty}a^ix^i = 1+ax+a^2x^2+a^3x^3+\u0026hellip;$ $\\{1,a,a^2,a^3,\u0026hellip;\\}$ $b_k = a^{k}$   $\\frac{1}{(1-ax)^n}$ $\\sum\\limits_{i=0}^{\\infty}C_{(n-1)+i}^{(n-1)}a^ix^i$ $\\{1, C_{n}^{1}a^1, C_{n+1}^{2}a^2,C_{n+2}^{3}a^3,\u0026hellip;\\}$ $b_k = C_{n+k-1}^{k}a^k$   $\\frac{1}{1+x}$ $\\sum\\limits_{i=0}^{\\infty}(-1)^ix^i = 1-x+x^2-x^3+\u0026hellip;$ $\\{1,-1,1,-1,\u0026hellip;\\}$ $b_k = -1^k$     证明 证明1 $$\\frac{1}{1-x} = 1+x+x^2+x^3+\u0026hellip;$$\n证：等比数列，公比为 $x$。\n 证明2 $$\\frac{1}{(1-x)^2} = 1+2x+3x^2+4x^3+\u0026hellip;$$\n证：因为\n$$\\frac{1}{(1-x)^2} = (\\frac{1}{1-x})^2 = (1+x+x^2+x^3+\u0026hellip;)^2$$\n根据组合意义，对于 $x^k$，有 $(0,k),(1,k-1),\u0026hellip;,(k,0)$ 共 $(k+1)$ 种组合方式，并且每一种的系数为 $1$，所以 $x^k$ 的系数为 $(k+1)$。\n 证明3 $$\\frac{1}{1-ax} = 1+ax+a^2x^2+a^3x^3+\u0026hellip;$$\n证：等比数列，公比为 $ax$。\n 证明4 $$\\frac{1}{(1-ax)^n} = \\sum\\limits_{i=0}^{\\infty}C_{(n-1)+i}^{(n-1)}a^ix^i$$\n证：因为\n$$\\frac{1}{(1-ax)^n} = (1+ax+a^2x^2+a^3x^3+\u0026hellip;)^n$$\n根据组合意义，对于 $x^k$ 而言，每个 $(1+ax+a^2x^2+a^3x^3+\u0026hellip;)$ 都可以贡献给 $k$，而这样的式子有 $n$ 个。\n所以相当于：\n求 $a_1+a_2+\u0026hellip;+a_n = k$ 的非负整数解的个数。\n 这是 小球放盒子 模型，$k$ 个球放入 $n$ 个盒子并且允许空盒，用隔板法即可，方案数为 $C_{(n-1)+k}^{(n-1)}$，这就是 $a^kx^k$ 的系数。\n 证明5 $$\\frac{1}{1+x} = 1-x+x^2-x^3+\u0026hellip;$$\n等比数列，公比为 $-x$。\n 计算例子 例1 题意\n求无限数列 $a_i = i^2$ 的生成函数。\n分别求出展开式和封闭式。\n 展开式 $\\Rightarrow$ 封闭式 数列 $a$ 为：\n$$a = \\{0,1,4,9,16,\u0026hellip;\\}$$\n那么生成函数的展开式为：\n$$f(x) = x + 4x^2 + 9x^3 + 16x^4 + \u0026hellip; = \\sum\\limits_{i=1}^{\\infty}i^2x^i$$\n 在推导生成函数的封闭式时，一个非常重要的 trick 是给展开式 乘上一个 $x$。\n 那么乘上 $x$ 以后，相当于整个展开式向右移动了一位，对应的生成函数就是\n$$xf(x) = 0 + x^2 + 4x^3 + 9x^4 + \u0026hellip; = \\sum\\limits_{i=1}^{\\infty}(i-1)^2x^i$$\n所以两者相减，可得：\n$$(1-x)f(x) = \\sum\\limits_{i=1}^{\\infty}(i^2 - (i-1)^2)x^i = \\sum\\limits_{i=1}^{\\infty}(2i-1)x^i$$\n$$=2\\sum\\limits_{i=1}^{\\infty}ix^i - \\sum\\limits_{i=1}^{\\infty}x^i$$\n$$=\\frac{2x}{(1-x)^2} - \\frac{x}{1-x}$$\n• 注意到因为求和是从 $i=1$ 开始的，相当于 $i=0$ 的情况整体右移了一位，所以要乘上 $x$ 得到 $\\frac{2x}{(1-x)^2}$\n所以生成函数 $f(x)$ 的封闭式为：\n$$f(x) = \\frac{2x}{(1-x)^3} - \\frac{x}{(1-x)^2} = \\frac{x(x+1)}{(1-x)^3}$$\n 封闭式 $\\Rightarrow$ 展开式 已知 $f(x)$ 的封闭式为\n$$f(x) = \\frac{x(x+1)}{(1-x)^3}$$\n我们将其化简为上面 常用表 里面的组合，也就是 裂项：\n$$f(x) = \\frac{x(x+1)}{(1-x)^3} = \\frac{2x}{(1-x)^3} - \\frac{x}{(1-x)^2}$$\n考虑第 $k$ 项的系数，注意到我们可以将分子中的 $x$ 提出来，所以 $f(x)$ 的第 $k$ 项系数 $a_k$ 就等于 $g(x) = (\\frac{2}{(1-x)^3} - \\frac{1}{(1-x)^2})$ 的第 $(k-1)$ 项系数 $b_{k-1}$。\n$$\\frac{2}{(1-x)^3} = 2\\sum\\limits_{i=0}^{\\infty}C_{2+i}^{2}x^i, ~ \\frac{x}{(1-x)^2} = \\sum\\limits_{i=0}^{\\infty}(i+1)x^i$$\n所以 $g(x)$ 的第 $(k-1)$ 项系数为：\n$$b_{k-1} = [x^{k-1}]2(\\sum\\limits_{i=0}^{\\infty}C_{2+i}^{2}x^i) - \\sum\\limits_{i=0}^{\\infty}(i+1)x^i = 2C_{k+1}^2 - k = k^2$$\n所以 $f(x)$ 的第 $k$ 项系数为 $a_k = b_{k-1} = k^2$。\n于是生成函数的展开式为：\n$$f(x) = \\sum\\limits_{i=0}^{\\infty}i^2x^i = x + 4x^2 + 9x^3 + 16x^4 + \u0026hellip;$$\n 例2 题意\n求斐波那契数列 $$f_0 = 0, f_1 = 1, f_i = f_{i-1} + f_{i-2}$$\n的生成函数，分别求出展开式（通项公式）和封闭式。\n 封闭式 注意到\n$$f(x) = f_0 + f_1x^1 + f_2x^2 + f_3x^3 + \u0026hellip;$$\n$$xf(x) = 0 + f_0x^1 + f_1x^2 + f_2x^3 + \u0026hellip;$$\n$$x^2f(x) = 0 + 0+ f_0x^2 + f_1x^3 + \u0026hellip;$$\n由于 $f_i = f_{i-1} + f_{i-2}$，所以：\n$$f(x)(1-x-x^2) = f_0 + (f_1-f_0)x^1 = x$$\n所以 $$f(x) = \\frac{x}{1-x-x^2}$$\n 封闭式$\\Rightarrow$展开式 $$f(x) = \\frac{x}{1-x-x^2}$$\n我们希望将它转为表格中存在的形式，所以我们设：\n$$(1-ax)(1-bx) = 1-x-x^2$$\n可得 $a = \\frac{1 + \\sqrt 5}{2}, b = \\frac{1 - \\sqrt 5}{2}$\n设\n$$g(x) = \\frac{f(x)}{x} = \\frac{1}{(1-ax)(1-bx)}$$\n那么要求 $f(x)$ 的第 $n$ 项系数，只要求 $g(x)$ 的第 $(n-1)$ 项系数即可。\n因为\n$$g(x) = \\frac{1}{(1-ax)(1-bx)}$$ $$= \\sum\\limits_{i=0}^{\\infty}a^ix^i * \\sum\\limits_{j=0}^{\\infty}b^jx^j$$ $$= (1+ax+a^2x^2+a^3x^3+\u0026hellip;) * (1+bx+b^2x^2+b^3x^3+\u0026hellip;)$$\n这是个卷积，那么 $g(x)$ 的第 $(n-1)$ 项系数为：\n$$[x^{n-1}]g(x) = \\sum\\limits_{k=0}^{n-1}a^{k}b^{n-1-k}$$\n$$=b^{n-1}\\sum\\limits_{k=0}^{n-1}a^{k}b^{-k}$$\n$$=b^{n-1}\\sum\\limits_{k=0}^{n-1}(\\frac{a}{b})^k$$\n右边就是个等比数列求和了，公比为 $\\frac{a}{b}$，最后可得\n$$[x^n]f(x) = [x^{n-1}]g(x) = \\frac{1}{\\sqrt 5}((\\frac{1+\\sqrt 5}{2})^n - (\\frac{1-\\sqrt 5}{2})^n)$$\n那么求出了 $f(x)$ 的通项公式，展开式也就可以写出来了。\n 例题 例1 洛谷P4721【模板】分治 FFT 题意\n给定 $n-1$ 个非负整数 $g_1, g_2, \u0026hellip; g_{n-1}$。\n定义 $$f_0 = 1, f_i = \\sum\\limits_{j=1}^if_{i-j}g_j$$\n求出 $f_1, f_2, \u0026hellip;, f_{n-1}$，答案对 $998244353$ 取模。\n其中，$2 \\leq n \\leq 10^5$\n 题解  看到 $\\sum\\limits_{j=1}^if_{i-j}g_j$ 就想到卷积，也就是多项式乘法。\n 那么令\n$$f(x) = f_0 + f_1x^1 + f_x2x^2 + \u0026hellip; + f_{n-1}x^{n-1}$$\n$$g(x) = g_0 + g_1x^1 + g_x2x^2 + \u0026hellip; + g_{n-1}x^{n-1}$$\n$$h(x) = f(x)g(x)$$\n则有：\n$$[x^n]h(x) = \\sum\\limits_{i=0}^nf_ig_{n-i}$$\n发现和 $f_n = \\sum\\limits_{j=1}^nf_{n-j}g_j$ 就差一个 $j=0$ 的情况（多了一个 $g_0f_n$），那么我们直接令 $g_0 = 0$ 就没问题了。\n这样的话，当 $n=0$ 时，$h_0 = 0$，其他时候 $h_n = f_n$。\n所以：\n$$f(x)g(x) = h(x) = 0 + f_1x^1 + f_x2x^2 + \u0026hellip; + f_{n-1}x^{n-1} = f(x) - f_0 = f(x) - 1$$\n得到\n$$f(x)(1-g(x)) = 1$$\n$$f(x) = \\frac{1}{1-g(x)}$$\n多项式求逆即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 板子省略 ll f[maxn], g[maxn], invG[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) cin \u0026gt;\u0026gt; g[i]; for (int i = 1; i \u0026lt;= n-1; i++) g[i] = (-g[i] + mod) % mod; g[0] = 1; poly_inverse(g, invG, n); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; (invG[i]) % mod \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   注意点\n多项式的题目中，要注意几个点：\n 看到 $\\sum_{i=0}^n f_ig_{n-i}$ 这种形式，即系数之和无论 $i$ 为多少，均为定值的，就想到 卷积，从而想到 多项式乘法。 转化出来的新多项式要注意 常数项。也就是代入 $n=0$ 判断一下左右两边是否相等。   例2 洛谷P4841 集训队作业2013 城市规划 题意\n求 $n$ 个节点的 简单（无重边无自环）有标号无向 连通 图数目。答案对 $1004535809$ 取模。\n其中，$n \\leq 130000$\n 题解  小tips：计数问题可以想想 dp 怎么做。\n 设 $f_n$ 为 $n$ 个节点的 简单（无重边无自环）有标号无向 连通 图数目。\n设 $g_n$ 为 $n$ 个节点的 简单（无重边无自环）有标号无向图数目。（区别在于不需要连通）\n发现在一个完全图中有 $C_n^2$ 条边，每条边可以选或者不选，那么\n$$g_n = 2^{C_n^2}$$\n我们想要用另外一种方式表示 $g_n$，可以枚举 节点 $1$ 所在的联通块的大小：\n 节点 $1$ 所在联通块大小为 $1$ 时，方案数为：$f_1g_{n-1}$ 节点 $1$ 所在联通块大小为 $2$ 时，方案数为：$C_{n-1}^{1}f_2g_{n-2}$ 节点 $1$ 所在联通块大小为 $k$ 时，方案数为：$C_{n-1}^{k-1}f_kg_{n-k}$  所以联通块大小 $1$ 枚举到 $n$，有：\n$$g_n = \\sum\\limits_{i=1}^n C_{n-1}^{i-1}f_ig_{n-i}$$\n 看到 $f_ig_{n-i}$ 的形式马上想到 卷积，也就是 多项式乘法。\n 但是有一个 $C_{n-1}^{i-1}$，我们把它拆开即可：\n$$g_n = \\sum\\limits_{i=1}^n C_{n-1}^{i-1}f_ig_{n-i}$$\n$$g_n = (n-1)!\\sum\\limits_{i=1}^n\\frac{f_i}{(i-1)!}\\frac{g_{n-i}}{(n-i)!}$$\n令\n$$F_i = \\frac{f_i}{(i-1)!}, G_i = \\frac{g_i}{i!}$$\n则有：\n$$\\frac{g_n}{(n-1)!} = \\sum\\limits_{i=1}^nF_iG_{n-i}$$\n令\n$$F(x) = 0 + F_1x + F_2x^2 + \u0026hellip; + F_{n}x^n$$\n$$G(x) = G_0 + G_1x + G_2x^2 + \u0026hellip; + G_{n}x^n$$\n则可以发现，（注意 $F(x)$ 的常数项为 $0$）：\n$$[x^n]\\frac{g(x)}{(n-1)!} = [x^n]F(x)G(x)$$\n注意到 $\\frac{1}{(n-1)!}$ 是不可以提到外面去的，因为它与 $n$ 有关。\n定义\n$$H_n = \\frac{g_n}{(n-1)!}, H_0 = 0$$\n• $H_0 = 0$ 是因为：如果我们代入 $n=0$ 进 $[x^n]\\frac{g(x)}{(n-1)!} = [x^n]F(x)G(x)$，会发现右边为 $0$，所以 $H_0 = 0$。\n则有：\n$$[x^n]H(x) = [x^n]F(x)G(x)$$\n注意到左右两个多项式的 $n$ 次项系数对于任何 $n$ 都相等，所以有\n$$H(x) = F(x)G(x)$$\n$$F(x) = \\frac{H(x)}{G(x)}$$\n由于 $H(x), G(x)$ 均已知，多项式求逆即可求出 $F(x)$，在每一项系数上乘以 $(n-1)!$ 即可得到 $f(x)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1004535809; const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 多项式板子部分省略 ll f[maxn], g[maxn], G[maxn], invG[maxn], fac[maxn], invfac[maxn], h[maxn]; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; g[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) { g[i] = qpow(2, i * (i-1) / 2); } fac[0] = 1; for (int i = 1; i \u0026lt;= n; i++) fac[i] = fac[i-1] * (ll)i % mod; invfac[n] = qpow(fac[n], mod-2); for (int i = n-1; i \u0026gt;= 0; i--) invfac[i] = invfac[i+1] * (ll)(i+1) % mod; h[0] = 0; for (int i = 0; i \u0026lt;= n; i++) G[i] = g[i] * invfac[i] % mod; for (int i = 1; i \u0026lt;= n; i++) h[i] = g[i] * invfac[i-1] % mod; poly_inverse(G, invG, n+1); poly_multiply(h, n+1, invG, n+1, f); f[n] = f[n] * fac[n-1] % mod; cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; }   注意点\n 计数问题，想想 dp 思路？ 项数不能随便提出去，尤其是与 $n$ 有关的。遇到项数就转化成一个新的多项式来处理。 如果对于任何 $n$，左右两边的多项式第 $n$ 项系数相同，则这两个多项式相等。   例3 CF438E The Child and Binary Tree 题意\n给定一个包含 distinct 正整数的集合 $\\{c_1, c_2, \u0026hellip;, c_n\\}$。\n给定整数 $m$，对于所有的 $s \\in [1,m]$，求出满足以下条件的本质不同的 带点权二叉树个数：\n 每个顶点的权值必须在 $\\{c_1, c_2, \u0026hellip;, c_n\\}$ 中。 所有顶点的权值之和为 $s$。  答案对 $998244353$ 取模。\n其中，$1 \\leq n,m,c_i \\leq 10^5$。\n 题解 首先用 dp 的思路：\n设 $f_n$ 为权值和为 $n$ 的二叉树个数（根的值 尚未确定），设 $g_n$ 为权值和为 $n$ 的二叉树个数（根的值 已经确定）。\n则我们可以得出：\n$$f_n = \\sum\\limits_{i=1}^n g_{n-c_i}$$\n$$g_n = \\sum\\limits_{i=0}^n f_if_{n-i}$$\n解释：\n对于第一个式子，我们枚举根的值即可。\n对于第二个式子，由于根的值已经确定，所以只需要枚举左右子树的权值和即可。\n我们看到 $g_n = \\sum\\limits_{i=0}^n f_if_{n-i}$，发现这就是个卷积，所以有\n$$g(x) = f(x)^2$$\n但第一个式子怎么办呢？这是个加法，无法表示为卷积？\n注意到本题中所有的权值 $\\leq 10^5$，我们不如定义 $h_i$ 为：\n$$h_i = \\begin{cases} 1 ~~~~ \\text{if } i \\in \\{c_1, c_2, \u0026hellip;, c_n\\} \\\\\n0 ~~~~ \\text{if } i \\notin \\{c_1, c_2, \u0026hellip;, c_n\\} \\end{cases}$$\n则我们可以将 $f_n = \\sum\\limits_{i=1}^n g_{n-c_i}$ 转化为：\n$$f_n = \\sum\\limits_{i=1}^nh_ig_{n-i}$$\n这就又是个卷积了，代入 $n=0$ 可以发现：因为 $f_0 = g_0 = 1, h_0 = 0$，所以\n$$f(x) = h(x)g(x) + 1 = h(x)f(x)^2 + 1$$\n所以：\n$$h(x)f(x)^2 - f(x) + 1 = 0$$\n利用公式 $x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 有：\n$$f(x) = \\frac{1 \\pm \\sqrt{1-4h(x)}}{2h(x)}$$\n有个问题，$h(x)$ 的常数项 $h(0) = 0$ 没法求逆？（注意到求逆的本质是 $h(x) * h^{-1}(x) = 1$）\n没关系，没法求逆就乘到左边去，得到：\n$$2f(x)h(x) = 1 \\pm \\sqrt{1-4h(x)}$$\n代入 $x = 0$，由 $h(0) = 0$ 可以得到右边只能取 负号。\n所以再把 $h(x)$ 除回去，得到：\n$$f(x) = \\frac{1 - \\sqrt{1-4h(x)}}{2h(x)}$$\n上下同乘 $(1 + \\sqrt{1-4h(x)})$ 得到：\n$$f(x) = \\frac{2}{1 + \\sqrt{1-4h(x)}}$$\n多项式求逆求出 $f(x)$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;21) + 5; int n,m; ll h[maxn], H[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int c; cin \u0026gt;\u0026gt; c; h[c] = 1; } for (int i = 1; i \u0026lt;= 1e5; i++) { h[i] = 4LL * h[i] % mod; h[i] = (-h[i] + mod) % mod; } h[0] = (h[0] + 1) % mod; poly_sqrt(h, H, 1e5+1); H[0] = (H[0] + 1) % mod; memset(h, 0, sizeof(h)); poly_inverse(H, h, 1e5+1); for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; h[i] * 2LL % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P4451 [国家集训队]整数的lqp拆分 题意\n给定正整数 $N$，对于所有可能的 $m \u0026gt; 0$，一个整数拆分是一个有序数组 $(a_1,a_2,\u0026hellip;,a_m)$ 满足：\n $a_i \u0026gt; 0$ $a_1 + a_2 + \u0026hellip; + a_m = N$  我们定义斐波那契数列为：\n$$F_0 = 0, F_1 = 1, F_2 = 1, F_n = F_{n-1} + F_{n-2}$$\n对于 $N$ 而言，它的一个整数拆分 $(a_1,a_2,\u0026hellip;,a_m)$ 的权值为：\n$$F_{a_1} * F_{a_2} * \u0026hellip; * F_{a_m}$$\n求所有可能的整数拆分的权值之和？形式化的，求：\n$$\\sum\\limits_{(a_1,a_2,\u0026hellip;,a_m)}\\prod_{i=1}^mF_{a_i}$$\n答案对 $10^9 + 7$ 取模。\n其中，$1 \\leq N \\leq 10^{10000}$\n 题解 我们发现这个 $\\sum$ 和 $\\prod$ 的顺序其实可以调换的。\n所以我们枚举一下第一个元素 $a_1$，设 $f_n$ 为我们所求的值，问题就转化为：\n$$f_n = \\sum\\limits_{j=1}^nF_j*f_{n-j}$$\n其中，$f_0 = 1$。\n所以设\n$$G(x) = F(x)f(x)$$\n$$G(0) = F(0)f(0) = 0$$\n所以有\n$$f(x) = G(x) + 1 = F(x)f(x) + 1$$\n得出\n$$f(x) = \\frac{1}{1-F(x)}$$\n斐波那契数列的生成函数为（不记得了就手推一下）：$$F(x) = \\frac{x}{1-x-x^2}$$\n所以得到：\n$$f(x) = \\frac{1-x-x^2}{1-2x-x^2} = 1-\\frac{x}{x^2+2x-1}$$\n我们发现这个常数项 $1$ 对我们的 $n$ 次项系数 $f_n$ 并没有任何影响，所以可以直接忽略。\n现在我们需要裂项了，转化为表里面的形式：\n$$f(x) = \\frac{-x}{x^2+2x-1} = \\frac{c}{1-ax} + \\frac{d}{1-bx}$$\n解方程就可以得到\n$$b = -1\\pm \\sqrt 2, a = -1 \\mp \\sqrt 2$$\n发现随便取哪个符号都一样（毕竟 $a,b$ 本就是对称的），所以有：\n$$b = 1 + \\sqrt 2, a = 1 - \\sqrt 2, c = -\\frac{1}{2\\sqrt 2}, d = \\frac{1}{2\\sqrt 2}$$\n所以\n$$f(x) = \\frac{c}{1-ax} + \\frac{d}{1-bx}$$\n$f(x)$ 的第 $n$ 次项系数为：\n$$[x^n]f(x) = -\\frac{1}{2 \\sqrt 2}(a^n - b^n) = \\frac{1}{2\\sqrt 2}[(1+\\sqrt 2)^n - (1-\\sqrt 2)^n]$$\n最后的问题就是如何求 $(1+\\sqrt 2)^n - (1-\\sqrt 2)^n$ ？\n我们需要先知道 $\\sqrt 2$ 在 $\\text{mod }10^9 + 7$ 意义下的值，可以利用二次剩余解决。\n然后对于 $n$，我们发现它出现在指数位置，而我们由费马小定理知道 $\\forall a, a^{P-1} \\equiv 1 (\\text{mod } P)$\n所以，我们只要将 $n$ 取一个 $n = n(\\text{mod } (P-1))$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const ll mod = 1e9+7; const int maxn = 1e5+7; // 求 sqrt(a) 在 mod P 下的值 // 调用 solve(a, P, r1, r2) // 若有解，r1, r2 分别为两个解，其中 r1 小，r2 大 // 若无解，r1 == -1 namespace Quadratic_residue { ll qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } bool check_if_residue(ll x, ll P) { return qpow(x, (P - 1) \u0026gt;\u0026gt; 1, P) == 1; } void solve(ll a, ll P, ll\u0026amp; r1, ll\u0026amp; r2) { if (a \u0026lt;= 1) { r1 = a, r2 = P - a; return; } if (!check_if_residue(a, P)) { r1 = -1; return; } ll x; while (1) { x=1ll*rand()*rand()%P; if (qpow((x*x-a+P)%P,(P-1)/2, P)!=1) break; } ll w=(x*x-a+P)%P; pll res = {1,0}, t = {x,1}; auto Mul=[\u0026amp;](pll a,pll b){ // 复数乘法 ll x=(1ll*a.first*b.first+1ll*a.second*b.second%P*w)%P; ll y=(1ll*a.first*b.second+1ll*a.second*b.first)%P; return make_pair(x,y); }; ll d=(P+1)/2; while (d) { if(d\u0026amp;1) res=Mul(res,t); t=Mul(t,t); d\u0026gt;\u0026gt;=1; } ll r = (res.first % P + P) % P; r1 = min(r, (P - r) % P); r2 = max(r, (P - r) % P); } }; ll s2, _; //sqrt(2) ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll readBigint() { string s; cin \u0026gt;\u0026gt; s; ll res = 0; for (int i = 0; i \u0026lt; s.size(); i++) { res = res * 10 % (mod - 1); res = (res + (s[i] - '0')) % (mod - 1); } return res; } int main() { ll n = readBigint(); Quadratic_residue::solve(2, mod, s2, _); ll ans = qpow((1LL + s2) % mod, n) - qpow((1LL - s2 + mod) % mod, n); ans = (ans + mod) % mod; ans = ans * inv(2LL * s2 % mod) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   注意事项\n$$a^b \\equiv a^{b \\text{ mod } (P-1)} (\\text{mod } P)$$\n 参考链接  https://blog.csdn.net/a_forever_dream/article/details/102594411  ","date":"2021-09-23T15:42:20+08:00","permalink":"https://tom0727.github.io/post/054-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","tags":["OGF",""],"title":"普通生成函数（OGF）"},{"categories":["算法"],"contents":"模版 多项式全家桶 const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { static ll F[maxn], G[maxn]; int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 for (int i = 0; i \u0026lt;= n1; i++) F[i] = f[i]; for (int i = 0; i \u0026lt;= n2; i++) G[i] = g[i]; for (int i = n1+1; i \u0026lt; n; i++) F[i] = 0; for (int i = n2+1; i \u0026lt; n; i++) G[i] = 0; memset(h, 0, sizeof(ll) * n); ntt.ntt(F, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(G, n, 1); for (int i = 0; i \u0026lt; n; i++) h[i] = F[i] * G[i] % mod; ntt.ntt(h, n, -1); } // calculate f^{-1}, store it into g[] // m = deg(f) + 1 void poly_inverse(ll f[], ll g[], const int m) { if (m == 1) { g[0] = ntt.inv(f[0]); // 应该改为二次剩余 return; } static ll F[maxn]; poly_inverse(f, g, (m+1)\u0026gt;\u0026gt;1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; // 因为 deg(h) = (m-1) * 2 for (int i = 0; i \u0026lt; m; i++) F[i] = f[i]; for (int i = m; i \u0026lt; n; i++) F[i] = 0; ntt.ntt(F, n, 1); ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt; n; i++) { g[i] = g[i] * ((2LL - g[i] * F[i] % mod + mod) % mod) % mod; } ntt.ntt(g, n, -1); for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // get f'(x), store it into g[] // n = deg(f) + 1 inline void poly_derivatives(ll f[], ll g[], const int n) { for (ll i = 1; i \u0026lt; n; i++) { g[i-1] = f[i] * i % mod; } g[n-1] = 0; } // get integral f(x)dx, store it into g[] // n = deg(f) + 1 inline void poly_integral(ll f[], ll g[], const int n) { for (ll i = n-1; i \u0026gt;= 1; i--) { g[i] = f[i-1] * ntt.inv(i) % mod; } g[0] = 0; } // get ln(f(x)), store it into g[] // n = deg(f) + 1 void poly_ln(ll f[], ll g[], const int n) { static ll invf[maxn], deriv_f[maxn]; memset(invf, 0, sizeof(invf)); memset(deriv_f, 0, sizeof(deriv_f)); poly_inverse(f, invf, n); poly_derivatives(f, deriv_f, n); poly_multiply(deriv_f, n, invf, n, g); poly_integral(g, g, n); } // get e^f(x), store it into g[] // m = deg(f) + 1 void poly_exp(ll f[], ll g[], const int m) { static ll F[maxn], G[maxn], lng[maxn]; if (m == 1) { g[0] = 1; return; } poly_exp(f, g, (m+1) \u0026gt;\u0026gt; 1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; for (int i = 0; i \u0026lt; m; i++) F[i] = f[i], G[i] = g[i]; for (int i = m; i \u0026lt; n; i++) F[i] = 0, G[i] = 0, lng[i] = 0; poly_ln(g, lng, m); ntt.ntt(F, n, 1); ntt.ntt(G, n, 1); ntt.ntt(lng, n, 1); for (int i = 0; i \u0026lt; n; i++) { g[i] = G[i] * ((1LL - lng[i] + F[i] + mod) % mod) % mod; } ntt.ntt(g, n, -1); for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // given f(x), calculate g(x), such that g(x)^2 = f(x) // m = deg(f) + 1 void poly_sqrt(ll f[], ll g[], const int m) { static ll F[maxn], G[maxn], invG[maxn]; if (m == 1) { g[0] = 1; return; } poly_sqrt(f, g, (m+1) \u0026gt;\u0026gt; 1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; for (int i = 0; i \u0026lt; m; i++) F[i] = f[i], G[i] = g[i], invG[i] = 0; for (int i = m; i \u0026lt; n; i++) F[i] = 0, G[i] = 0, invG[i] = 0; poly_inverse(G, invG, m); poly_multiply(f, m, invG, m, g); for (int i = 0; i \u0026lt; m; i++) g[i] = (g[i] + G[i]) % mod * ntt.inv(2) % mod; for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // given f(x) and g(x), calculate q(x), r(x) such that f(x) = q(x) * g(x) + r(x) // n = deg(f) + 1, m = deg(g) + 1, deg(q) = n-m, deg(r) \u0026lt; deg(g) - 1 = m void poly_division(ll f[], ll g[], ll q[], ll r[], const int n, const int m) { static ll F[maxn], G[maxn], invG[maxn]; for (int i = 0; i \u0026lt;= n-1; i++) F[i] = f[n-1-i]; for (int i = 0; i \u0026lt;= m-1; i++) G[i] = g[m-1-i]; poly_inverse(G, invG, n-m+1); poly_multiply(F, n-m+1, invG, n-m+1, q); for (int i = n-m+1; i \u0026lt;= 2LL * (n-m+1); i++) q[i] = 0; reverse(q, q+n-m+1); poly_multiply(q, n-m+1, g, m, G); for (int i = 0; i \u0026lt; m; i++) r[i] = (f[i] - G[i] + mod) % mod; } ll f[maxn], g[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; f[i]; poly_sqrt(f, g, n); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   多项式求逆 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$f(x) * g(x) \\equiv 1 ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证有解。\n 定义 $x^n$：指舍弃含有 $x^n$ 及更高次数的项。\n我们设 $g(x)$ 为 $f(x)$ 在 $\\text{ mod } x^n$ 意义下的逆元，设 $G(x)$ 为 $f(x)$ 在 $\\text{ mod } x^{\\lceil{\\frac{n}{2}}\\rceil}$ 意义下的逆元，则有：\n$$f(x)g(x) \\equiv 1 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil}), ~~ f(x)G(x) \\equiv 1 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n所以\n$$f(x)(g(x) - G(x)) \\equiv 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n由于 $deg(f) = n-1$，所以 $f \\neq 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$，所以\n$$g(x) - G(x) \\equiv 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n两边同时平方，可得\n$$g(x)^2 + G(x)^2 - 2g(x)G(x) \\equiv 0 (\\text{mod } x^n)$$\n由于 $f(x)g(x) \\equiv 1 (\\text{mod } x^n)$，两边同乘以 $f(x)$ 可得：\n$$g(x) + f(x)G(x)^2 - 2G(x) \\equiv 0 (\\text{mod } x^n)$$\n所以\n$$g(x) \\equiv 2G(x) - f(x)G(x)^2 (\\text{mod } x^n)$$\n注意点\n  $G(x)$ 是 $(\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$ 意义下的逆元，刚好是一个递归的问题，只要求出来 $G(x)$ 即可求出 $g(x)$，而这个式子用 NTT 解决即可。\n  只需要用 DFT 求出 $f(x), G(x)$ 在特殊点的值 $f(x_i), G(x_i)$，然后直接进行上述计算 $2G(x_i) - f(x_i)G(x_i)^2$，然后再 IDFT 回来即可。\n  板子里面使用的 $m$ 代表 $m = deg(f) + 1$，这样是为了递归 base case 的正确处理。\n  如果 $f(x)$ 的常数项 $f(0) = 0$ 则无法求逆。\n    多项式求 $\\ln$ 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv \\ln f(x) ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证有解。\n 两边同时求导，可以得到 $$g\u0026rsquo;(x) \\equiv \\frac{f\u0026rsquo;(x)}{f(x)} ~ (\\text{mod } x^n)$$\n多项式求导和积分都很简单，所以右边可以很容易的计算出来。\n计算出来右边以后，两边同时积分即可得到 $g(x)$。\n 多项式求 $exp$ 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv e^{f(x)} ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证 $f_0 = 0$。\n 前置知识：牛顿迭代法求零点 牛顿迭代法可以快速求出一个函数 $f(x)$ 的零点。\n思想：随便找一个 $x_1$ 作为起点，求出 $(x_1, f(x_1))$ 处的切线方程，设 $x_2$ 为这个切线与 $x$ 轴的交点，继续此过程。\n推导：\n$f(x)$ 在 $x_1$ 处的切线为\n$$y = f\u0026rsquo;(x_1)(x-x_1) + f(x_1)$$\n令 $y = 0$，得到\n$$x = x_1 - \\frac{f(x_1)}{f\u0026rsquo;(x_1)}$$\n 上述的过程对于多项式也适用！\n假设我们给定一个多项式 $F(x)$，要求一个多项式 $G(x)$ 使得 $$F(G(x)) \\equiv 0 ~ (\\text{mod } x^n)$$\n则我们可以先求出 $G_1(x)$，满足\n$$F(G_1(x)) \\equiv 0 ~ (\\text{mod } x^{\\lceil \\frac{n}{2} \\rceil})$$\n然后根据牛顿迭代的式子，求出\n$$G(x) = G_1(x) - \\frac{F(G_1(x))}{F\u0026rsquo;(G_1(x))}$$\n令 $G_2(x) = G(x)$，然后递归此过程直到 $n=1$ 即可。\n• base case 为 $n = 1$，所以总复杂度为 $O(n \\log n)$\n证明？需要用到泰勒展开（数学浓度有一点点高所以我先鸽了）\n 用牛顿迭代求多项式的exp 回顾一下问题：\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv e^{f(x)} ~ (\\text{mod } x^n)$$\n两边同时求 $\\ln$，可得：\n$$\\ln (g(x)) - f(x) \\equiv 0 ~ (\\text{mod } x^n)$$\n设\n$$F(g(x)) = \\ln (g(x)) - f(x)$$\n则我们要求的是 $F(x)$ 在 $(\\text{mod } x^n)$ 意义下的零点（注意这个零点本身是个多项式）。\n所以根据牛顿迭代的式子，可以写出：\n$$g_2(x) = g_1(x) - \\frac{F(g_1(x))}{F\u0026rsquo;(g_1(x))}$$\n注意到 $F\u0026rsquo;(g(x)) = \\frac{1}{g(x)}$，所以有：\n$$g_2(x) = g_1(x)(1-\\ln (g_1(x)) - f(x))$$\n• 其中 base case 是 $n=1$ 时，由于 $f_0 = 0$，所以\n$$g_0(x) = e^{f_0(x)} = e^0 = 1$$\n 时间复杂度：$T(n) = T(\\frac{n}{2}) + O(n \\log n)$，所以 $T(n) = O(n \\log n)$\n  多项式除法 题意\n给定一个多项式 $f(x)$ 和一个多项式 $g(x)$，$deg(f) = n, deg(g) = m, n \u0026gt; m$，求 $q(x), r(x)$ 使得：\n$$deg(q) = n-m, deg(r) \u0026lt; m$$\n$$f(x) = q(x) * g(x) + r(x)$$\n系数对 998244353 取模。所有的系数均为非负整数。\n 设\n$$F(x) = x^nf(\\frac{1}{x})$$\n可以发现 $F(x)$ 就是 $f(x)$ 所有系数翻转过来 得到的多项式。\n然后有：\n$$f(x) = q(x) * g(x) + r(x)$$\n$$f(\\frac{1}{x}) = q(\\frac{1}{x}) * g(\\frac{1}{x}) + r(\\frac{1}{x})$$\n两边同乘 $x^n$ 可得：\n$$x^nf(\\frac{1}{x}) = x^{n-m}q(\\frac{1}{x}) * x^mg(\\frac{1}{x}) + x^{n-m+1} * x^{m-1}r(\\frac{1}{x})$$\n$$F(x) = Q(x) * G(x) + x^{n-m+1}R(x)$$\n两边同时 $\\text{mod } x^{n-m+1}$ 可得：\n$$F(x) \\equiv Q(x) * G(x) ~ (\\text{mod } x^{n-m+1})$$\n所以\n$$Q(x) \\equiv \\frac{F(x)}{G(x)} ~ (\\text{mod } x^{n-m+1})$$\n发现 $deg(q) = n-m$，所以刚好求出来的 $Q(x)$ 在 $\\text{mod } x^{n-m+1}$ 意义下，就是正确的结果。\n所以可以直接计算出 $Q(x)$，翻转系数得到 $q(x)$。\n至于 $r(x)$，直接由 $$r(x) = f(x) - q(x) * g(x)$$ 即可得到。\n 多项式开根 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求 $g(x)$ 使得：\n$$g^2(x) \\equiv f(x) ~ (\\text{mod } x^{n})$$\n系数对 998244353 取模。保证 $f_0 = 1$，所有的系数均为非负整数。\n 设\n$$F(g(x)) = g^2(x) - f(x)$$\n要求的就是 $F(x)$ 的零点。\n假设我们已经求出了在 $(\\text{mod } x^{\\lceil \\frac{n}{2}} \\rceil)$ 意义下的 $g_1(x)$ 使得 $g_1^2(x) \\equiv f(x) (\\text{mod } x^{\\lceil \\frac{n}{2}} \\rceil)$\n则根据牛顿迭代，有：\n$$g_2(x) = g_1(x) - \\frac{F(g_1(x))}{F\u0026rsquo;(g_1(x))}$$\n$$= g_1(x) - \\frac{g_1^2(x) - f(x)}{2g_1(x)}$$\n• base case 为 $n=1$ 时，由于 $f_0 = 1$，直接开根得到 $g_0 = \\sqrt 1 = 1$\n• 如果 $f_0 \\neq 1$，需要 二次剩余 来求出 $g_0$\n注：有另外一种不用牛顿迭代的推导方法，可以看 这里\n注意事项  在代码中，使用 ntt.ntt() 时注意指定的长度是 $n$，而 不是 $deg(f) = m$ TODO: 所有需要递归的非递归写法？ TODO: 二次剩余  参考链接  https://blog.csdn.net/a_forever_dream/article/details/102483602 https://gauss0320.blog.luogu.org/ti-xie-p4726-mu-ban-duo-xiang-shi-zhi-shuo-han-shuo-duo-xiang-shi-e https://blog.csdn.net/a_forever_dream/article/details/106281196 https://www.luogu.com.cn/blog/user7035/solution-p4512  ","date":"2021-09-21T20:09:39+08:00","permalink":"https://tom0727.github.io/post/053-polynomial/","tags":["多项式",""],"title":"多项式全家桶"},{"categories":["算法"],"contents":"模版 NTT const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 memset(h, 0, sizeof(ll) * n); ntt.ntt(f, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt; n; i++) h[i] = f[i] * g[i] % mod; ntt.ntt(h, n, -1); } int n1, n2; ll f[maxn/2], g[maxn/2], h[maxn]; int main() { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; // deg(f) = n1 - 1, deg(g) = n2 - 1 for (int i = 0; i \u0026lt; n1; i++) cin \u0026gt;\u0026gt; f[i]; for (int i = 0; i \u0026lt; n2; i++) cin \u0026gt;\u0026gt; g[i]; poly_multiply(f, n1, g, n2, h); for (int i = 0; i \u0026lt;= n1+n2-2; i++) cout \u0026lt;\u0026lt; h[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; }   介绍 NTT（快速数论变换）和 FFT 一样，都是用来解决多项式乘法问题。\nNTT可以处理在 $mod ~ p$ 意义下的多项式乘法，并且不需要处理复数和小数。\n在开始介绍 NTT 之前，我们需要一些基本的前置知识。\n原根 对于一个质数 $p$，在 $mod ~ p$ 意义下，原根 $g$ 满足：\n$$ord(g) = |Z_p^{\\times}| = \\phi(p)$$\n• 注意 $\\phi(p)$ 是 $p$ 的欧拉函数，代表 $[1,p]$ 中与 $p$ 互质的数的数量。\n• $ord(g)$ 代表一个最小的数字 $r = ord(g)$ 使得 $g^r \\equiv 1(mod ~ p)$，且 $\\forall k \\in [1,r-1], g^k \\neq 1(mod ~ p)$\nNTT原理 使用 NTT 的限制条件：\n 模数 $p$ 需要满足 $p = k \\times 2^m + 1$，其中 $k, m \\geq 1$，$p$ 为质数。 若 $p = k \\times 2^m + 1$，则只能处理 $deg(h) \\leq 2^m$ 的情况。   在发现了原根 $g$ 以后，我们会发现令 $g_n = g^{\\frac{p-1}{n}}$，则 $g_n$ 拥有着 FFT 中，$\\omega$ 的优秀性质：\n $g_n^n = 1$，且 $\\forall k \\in [1, n-1], g_n ^ k \\neq 1$ $g_n^{k+\\frac{n}{2}} = -g_n^{k}$  证明：\n 根据原根的定义即可。 只要证 $g_n^{\\frac{n}{2}} = -1$ 即可。因为 $g_n^n = 1$，所以 $g_n^{\\frac{n}{2}} = \\pm 1$，而因为 $\\forall k \\in [1, n-1], g_n ^ k \\neq 1$，所以 $g_n^{\\frac{n}{2}} = -1$   剩下的就和 FFT 一样了，只不过把 $\\omega$ 换成 $g_n = g^{\\frac{p-1}{n}}$ 而已。\n当然注意到，由于 $n$ 需要是 $2^k$，所以 $p-1$ 需要是 $2^k$ 的倍数，故我们需要满足 $p = k \\times 2^m + 1$。\n常用的组合：\n$$p = 998244353, ~~g = 3$$\n参考链接  https://blog.csdn.net/a_forever_dream/article/details/102469390 https://oi-wiki.org/math/poly/ntt/  ","date":"2021-09-18T19:51:17+08:00","permalink":"https://tom0727.github.io/post/052-ntt/","tags":["NTT"],"title":"NTT"},{"categories":["算法"],"contents":"  .center { margin-left: auto; margin-right: auto; display: table; width: auto; }   模版 FFT const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 注意这里需要是 \u0026gt; 2^k struct Complex { double x,y; Complex(double _x = 0.0, double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(const double f[], int n1, const double g[], int n2, double h[]) { int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = a[i].x; } int n1, n2; double f[maxn/2], g[maxn/2], h[maxn]; int main() { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; // deg(f) = n1 - 1, deg(g) = n2 - 1 for (int i = 0; i \u0026lt; n1; i++) cin \u0026gt;\u0026gt; f[i]; for (int i = 0; i \u0026lt; n2; i++) cin \u0026gt;\u0026gt; g[i]; poly_multiply(f, n1, g, n2, h); for (int i = 0; i \u0026lt;= n1+n2-2; i++) cout \u0026lt;\u0026lt; h[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; }   使用板子的注意事项：\n maxn 的值必须大于一个 $2^k$，且 $2^k \u0026gt; n_1+n_2$  介绍 FFT (Fast Fourier Transform, 快速傅立叶变换) 可以在 $O(n \\log n)$ 的时间内计算两个多项式的乘法，也可以用来计算卷积。\n• 一般卷积的形式为 $$C_k = \\sum\\limits_{i=0}^kA_iB_{k-i} = A_0B_k + A_1B_{k-1} + \u0026hellip; + A_kB_0$$\n在开始介绍 FFT 之前，我们需要一些基本的前置知识。\n多项式 一个多项式有两种表示方法：系数表示法 和 点值表示法。\n系数表示法 $$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n$$\n则 $\\{a_0,a_1,\u0026hellip;,a_n\\}$ 即可表示这个多项式 $f(x)$。\n点值表示法 选取多项式函数上的 $(n+1)$ 个点 $(x_0,y_0), (x_1,y_1), \u0026hellip;, (x_n,y_n)$ 也可以唯一的表示这个多项式 $f(x)$。\n证明：使用高斯消元即可，$(n+1)$ 个未知量，对应 $(n+1)$ 个方程。\n复数 $n$ 次单位根 若 $\\omega$ 满足 $\\omega^n = 1$，那么 $\\omega$ 就是 $n$ 次单位根 (n-th root of unity)。\n若 $\\omega$ 满足 $\\omega^n = 1$，且满足 $\\omega ^ k \\neq 1, \\forall k \\in [1, n-1]$，则 $\\omega$ 就是 $n$ 次本原单位根 (primitive n-th root of unity)\n$\\omega$ 的取值 定理\n$$\\omega_n^k = e^{i\\frac{2k\\pi}{n}} = \\cos(\\frac{2k\\pi}{n}) + i \\sin(\\frac{2k\\pi}{n})$$\n$$\\omega = e^{i \\frac{2\\pi}{n}} = \\cos(\\frac{2\\pi}{n}) + i \\sin(\\frac{2\\pi}{n})$$\n 为了方便，下文我们就写 $\\omega = e^{i \\frac{2\\pi}{n}}$\n$\\omega$ 有几个优秀的性质：\n $\\omega$ 为 $n$ 次本原单位根，这说明 $\\forall k \\in [1, n-1], \\omega^n = 1$，且 $\\omega ^ k \\neq 1$ $\\omega^{k+\\frac{n}{2}} = -\\omega^{k}$  FFT原理 问题\n给定两个已知多项式 $f(x)$ 和 $g(x)$，$deg(f) = n_1, deg(g) = n_2$，求 $h(x) = f(x) * g(x)$？\n FFT 分为三步：\n  DFT：令 $n = n_1 + n_2$，在 $x$ 轴上选择 $(n + 1)$ 个特殊点 $x_0,x_1,\u0026hellip;,x_{n}$，求出 $f(x_0), f(x_1), \u0026hellip;, f(x_n)$ 与 $g(x_0), g(x_1), \u0026hellip;, g(x_n)$ 的值。\n复杂度：$O(n\\log n)$\n  点值乘法：求出 $(n+1)$ 个点上，点值的乘积，即 $h(x_i) = f(x_i) * g(x_i), i \\in [0, n]$\n复杂度：$O(n)$\n  IDFT：给定一个未知 $h(x)$ 上的 $(n+1)$ 个特殊点 $\\{(x_0,y_0), (x_1,y_1), \u0026hellip;, (x_n,y_n)\\}$，求出 $h(x)$ 的系数表达式。\n复杂度：$O(n\\log n)$\n  第一步 DFT 问题\n假设现在有一个 $deg(f) = n$ 的多项式，且 $n$ 为偶数。我们想要求 $f(x)$ 在 $n$ 个不同的特殊点 $x_0,x_1,\u0026hellip;,x_{n-1}$ 上的值。\n  注意到这个问题也等价于一个矩阵乘法，即给定 一个矩阵 $X$ 和一个向量 $\\vec a$，在我们可以自由选择 $x_0,x_1,\u0026hellip;,x_{n-1}$ 的情况下，用 $O(n \\log n)$ 的时间求出 $\\vec y = X \\vec a$ 的值？\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\\n\\end{bmatrix} \\begin{bmatrix} a_0 \\\\\na_1 \\\\\n\u0026hellip;\\\\\na_{n-1} \\\\\n\\end{bmatrix} = \\begin{bmatrix} y_0 \\\\\ny_1 \\\\\n\u0026hellip;\\\\\ny_{n-1} \\\\\n\\end{bmatrix} $$\n 那么，如何快速求出 $f(x_0), f(x_1), \u0026hellip;, f(x_{n-1})$呢？我们只要选一些特殊的 $x_0, x_1, \u0026hellip;, x_{n-1}$ 即可。\n结论：$x_i = \\omega^i$\n 证明：\n因为\n$$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n$$\n$$=(a_0 + a_2x^2 + a_4x^4 + \u0026hellip; + a_{n-2}x^{n-2}) + (a_1x + a_3x^3 + a_5x^5 + \u0026hellip; + a_{n-1}x^{n-1})$$\n令\n$$f_{even}(x) = a_0 + a_2x + a_4x^2 + \u0026hellip; + a_{n-2}x^{\\frac{n}{2} - 1}$$ $$f_{odd}(x) = a_1 + a_3x + a_5x^2 + \u0026hellip; + a_{n-1}x^{\\frac{n}{2} - 1}$$\n则有\n$$f(x) = f_{even}(x^2) + xf_{odd}(x^2)$$\n现在，我们选择 $x_i = \\omega^i$，则我们求 $f(x_i)$ 和 $f(x_{i+\\frac{n}{2}})$，可以发现\n$$x_{\\frac{n}{2}} = \\omega^{\\frac{n}{2}} = -1, ~~x_{i+\\frac{n}{2}} = \\omega^{i+\\frac{n}{2}} = -\\omega^i = -x_i$$\n所以\n$$\\forall i \\in [0,\\frac{n}{2}-1], ~~f(x_i) = f_{even}(x_i^2) + x_if_{odd}(x_i^2), ~~f(x_{i+\\frac{n}{2}}) = f_{even}(x_i^2) - x_if_{odd}(x_i^2)$$\n又因为，求 $\\forall i \\in [0,n], f(x_i)$ 的值，等价于求 $\\forall i \\in [0,\\frac{n}{2}-1], f(x_i) 和 f(x_{i+\\frac{n}{2}})$ 的值，\n所以这个问题就可以等价转化为求 $f_{even}(x_i^2) + x_if_{odd}(x_i^2)$ 的值。而这就是一个规模减半了的子问题。\n所以设 $T(n)$ 为：求出 $\\forall i \\in [0,n], f(x_i)$ 的值所需的时间，则可以列出方程：\n$$T(n) = 2T(\\frac{n}{2}) + O(n)$$\n所以 $T(n) = O(n\\log n)$\n第二步 点值乘法 第一步DFT以后，我们有了 $f(x_0), f(x_1), \u0026hellip;, f(x_{n-1})$ 与 $g(x_0), g(x_1), \u0026hellip;, g(x_{n-1})$ 的值，我们就可以直接将这些值乘起来，得到\n$$h(x_0), h(x_1), \u0026hellip;, h(x_{n-1})$$\n的值。\n第三步 IDFT 问题\n现在给定一个未知的多项式 $h(x)$，且 $deg(h) = n-1$，已知 $h(x)$ 上的 $n$ 个点 $(x_0,h(x_0)), (x_1,h(x_1)), \u0026hellip;, (x_{n-1},h(x_{n-1}))$，求 $h(x)$ 的表达式？\n  注意到这个问题也等价于一个矩阵乘法，即给定 一个矩阵 $X$ 和一个向量 $\\vec y$，已知 $X\\vec a = \\vec y$，如何用 $O(n \\log n)$ 的时间求出 $\\vec a$ 的值？\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\\n\\end{bmatrix} \\begin{bmatrix} a_0 \\\\\na_1 \\\\\n\u0026hellip;\\\\\na_{n-1} \\\\\n\\end{bmatrix} = \\begin{bmatrix} y_0 \\\\\ny_1 \\\\\n\u0026hellip;\\\\\ny_{n-1} \\\\\n\\end{bmatrix} $$\n 发现了什么？这实际上和第一步 DFT 的过程是一样的，如果我们把 $X^{-1}$ 给两边乘上 ，就变成了\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\\n\\end{bmatrix}^{-1} \\begin{bmatrix} y_0 \\\\\ny_1 \\\\\n\u0026hellip;\\\\\ny_{n-1} \\\\\n\\end{bmatrix} = \\begin{bmatrix} a_0 \\\\\na_1 \\\\\n\u0026hellip;\\\\\na_{n-1} \\\\\n\\end{bmatrix}$$\n那么，令\n$$X=\\begin{bmatrix}1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\\n1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\\n\\end{bmatrix}$$\n把 $x_i = \\omega^i$ 代进去，就可以得到：\n$$X = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\\n1 \u0026amp; \\omega^1 \u0026amp; \\omega^{1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{1\\cdot (n-1)} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; \\omega^{1} \u0026amp; \\omega^{(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{(n-1)\\cdot (n-1)} \\\\\n\\end{bmatrix}$$\n令\n$$V(\\omega) = X = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\\n1 \u0026amp; \\omega^1 \u0026amp; \\omega^{1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{1\\cdot (n-1)} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; \\omega^{1} \u0026amp; \\omega^{(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{(n-1)\\cdot (n-1)} \\\\\n\\end{bmatrix}, ~~~V(\\omega^{-1}) = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\\n1 \u0026amp; \\omega^{-1} \u0026amp; \\omega^{-1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{-1\\cdot (n-1)} \\\\\n\u0026hellip;\\\\\n1 \u0026amp; \\omega^{-1} \u0026amp; \\omega^{-(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{-(n-1)\\cdot (n-1)} \\\\\n\\end{bmatrix}$$\n则有：\n$$V(\\omega) \\cdot V(\\omega^{-1}) = nI$$\n证明：直接进行矩阵运算即可，注意要用到 $\\omega^n = 1$ 的特性。\n这说明\n$$X^{-1} = V(w)^{-1} = \\frac{1}{n} V(\\omega^{-1})$$\n所以上面的 $X^{-1}\\vec y = \\vec a$ 就可以表示为：\n$$V(\\omega)^{-1} \\begin{bmatrix} y_0 \\\\\ny_1 \\\\\n\u0026hellip;\\\\\ny_{n-1} \\\\\n\\end{bmatrix} = \\begin{bmatrix} a_0 \\\\\na_1 \\\\\n\u0026hellip;\\\\\na_{n-1} \\\\\n\\end{bmatrix} ~~\\Rightarrow~~ \\frac{1}{n}V(\\omega^{-1})\\begin{bmatrix} y_0 \\\\\ny_1 \\\\\n\u0026hellip;\\\\\ny_{n-1} \\\\\n\\end{bmatrix} = \\begin{bmatrix} a_0 \\\\\na_1 \\\\\n\u0026hellip;\\\\\na_{n-1} \\\\\n\\end{bmatrix}$$\n这就等价于我们有一个系数为 $y_0, y_1, \u0026hellip; y_{n}$ 的多项式，然后要在 $x_0^{-1}, x_1^{-1}, \u0026hellip;, x_n^{-1}$ 这些特殊点上进行求值。\n我们发现 $x_0^{-1} = \\omega^{-1}$ 仍然是一个 $n$ 次本原单位根 (primitive n-th root of unity)（证明略），所以它仍然有上述优秀的性质。\n所以这个问题可以用 DFT 解决，求出来的值，就是我们想要的 $h(x)$ 的多项式系数。\n 注意一下，上述所有过程都是完美的分治过程，所以我们需要把 $deg(h)$ 补成一个 $2^k$ 形式，其中 $deg(h) = 2^k \\geq 2(n_1+n_2)$\n 非递归 FFT 递归 FFT 常数过大，不好用，所以我们可以写一个非递归版本的。\n我们手推一下 FFT 的分治过程，每一次分治都是拆分奇数项和偶数项，模拟拆分过程有：\n初始序列：$\\{a_0,a_1,a_2,a_3,a_4,a_5,a_6,a_7\\}$\n第一次拆分：$\\{a_0,a_2,a_4,a_6\\},\\{a_1,a_3,a_5,a_7\\}$\n第二次拆分：$\\{a_0,a_4\\},\\{a_2,a_6\\},\\{a_1,a_5\\},\\{a_3,a_7\\}$\n第三次拆分：$\\{a_0\\},\\{a_4\\},\\{a_2\\},\\{a_6\\},\\{a_1\\},\\{a_5\\},\\{a_3\\},\\{a_7\\}$\n发现了什么？\n 拆分前：0, 1, 2, 3, 4, 5, 6, 7\n拆分后：0, 4, 2, 6, 1, 5, 3, 7\n 化成二进制：\n 拆分前：000, 001, 010, 011, 100, 101, 110, 111\n拆分后：000, 100, 010, 110, 001, 101, 011, 111\n 机智的你或许发现了，拆分前后，每个数字对应的二进制刚好就是翻转了一下，最左边的bit跑到最右边去了，反之亦然。\n那么这个二进制翻转就可以直接 $O(n \\log n)$ 实现了，但是这样不够高效，有一个 $O(n)$ 的基于 DP 的方法：\n设 $R(x)$ 为 $x$ 翻转后的结果，可知 $R(0) = 0$。\n我们从小到大求 $R(x)$，在求 $R(x)$ 时，我们已知了 $R(\\frac{x}{2})$ 的值，相当于：\n$$x = abc[0/1], ~ \\frac{x}{2} = abc, ~ R(\\frac{x}{2}) = cba, ~ R(x) = [0/1]cba$$\n则我们只要判断一下 $x$ 的最低位为 $0$ 还是 $1$，然后给 $R(\\frac{x}{2})$ 的最高位补上一个 $0$ 或者 $1$ 就可以得到 $R(x)$ 了。\nvoid rearrange(Complex a[], const int n) { static int rev[maxn]; for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } }  至于非递归写法的原理，我懒得写了先鸽着吧（\n优化（三步变两步） 暂时没遇到需要优化的情况，先鸽着。\n例题 例1 洛谷P1919 【模板】A*B Problem升级版（FFT快速傅里叶） 题意\n给定正整数 $a,b$，求 $a*b$？\n其中，$1\\leq a,b \\leq 10^{10^6}$\n 题解 把大整数看成多项式，例如 $356$ 就看作 $f(x) = 3x^2 + 5x + 6$\n两个大整数相乘就看作多项式相乘，最后代入 $x = 10$，处理一下进位和前缀零即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = (1\u0026lt;\u0026lt;21) + 5; struct Complex { long double x,y; Complex(long double _x = 0.0, long double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(int f[], int n1, int g[], int n2, int h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn], c[maxn]; for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = (int)(a[i].x + 0.5); } int n1, n2; int f[maxn/2], g[maxn/2], h[maxn]; int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; int n1 = s1.size() - 1, n2 = s2.size() - 1; for (int i = 0; i \u0026lt;= n1; i++) f[i] = s1[n1-i] - '0'; for (int i = 0; i \u0026lt;= n2; i++) g[i] = s2[n2-i] - '0'; poly_multiply(f, n1, g, n2, h); int i = 0; for (i = 0; i \u0026lt; maxn-2; i++) { h[i+1] += h[i] / 10; h[i] %= 10; } string ans = \u0026quot;\u0026quot;; for (int i = 0; i \u0026lt; maxn-2; i++) ans += (char)(h[i] + '0'); for (int j = ans.size()-1; j \u0026gt;= 0; j--) { if (ans[j] == '0') { ans.erase(ans.begin() + j); } else break; } reverse(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P3338 [ZJOI2014]力 题意\n给定 $n$ 个实数 $q_1,q_2,\u0026hellip;,q_n$，定义：\n$$F_j = \\sum\\limits_{i=1}^{j-1}\\frac{q_i \\times q_j}{(i-j)^2} - \\sum\\limits_{i=j+1}^{n}\\frac{q_i \\times q_j}{(i-j)^2}$$\n$$E_j = \\frac{F_j}{q_j}$$\n求 $E_1, E_2, \u0026hellip;, E_n$ 的值？\n其中，$n \\leq 10^5$\n 题解 FFT 可以用于处理卷积问题，我们先化简一下式子：\n$$E_j = \\frac{F_j}{q_j} = \\sum\\limits_{i=1}^{j-1}\\frac{q_i}{(i-j)^2} - \\sum\\limits_{i=j+1}^{n}\\frac{q_i}{(i-j)^2}$$\n令\n$$f_i = q_i, ~~g_i = \\frac{1}{i^2}$$\n则\n$$E_j = \\sum\\limits_{i=1}^{j-1}f_ig_{j-i} - \\sum\\limits_{i=j+1}^{n}f_ig_{i-j}$$\n注意到第一项 $\\sum\\limits_{i=1}^{j-1}f_ig_{j-i}$ 可以写成 $i=0$ 开始，到 $j$ 结束（令 $f_0 = g_0 = 0$ 即可），所以第一项等于 $\\sum\\limits_{i=0}^{j}f_ig_{j-i}$，也就是一个卷积形式，可以利用 FFT 计算。\n 第二项 $\\sum\\limits_{i=j+1}^{n}f_ig_{i-j}$ 怎么写成卷积呢？\n注意到，如果我们令 $f_j\u0026rsquo; = f_{n-j}$，则有\n$$\\sum\\limits_{i=j+1}^{n}f_ig_{i-j} = \\sum\\limits_{i=j}^{n}f\u0026rsquo;_{n-i}g_{i-j} = g_0f\u0026rsquo;_{n-j} + g_1f\u0026rsquo;_{n-j-1} + \u0026hellip; + g_{n-j}f\u0026rsquo;_0$$\n那么，这就又是一个卷积了，所以最后我们的结果可以表示为：\n$$E_j = \\sum\\limits_{i=0}^{j}f_ig_{j-i} - \\sum\\limits_{i=j}^{n}f\u0026rsquo;_{n-i}g_{i-j}$$\n 第一项 $\\sum\\limits_{i=0}^{j}f_ig_{j-i}$：计算多项式 $f(x) * g(x)$，取第 $j$ 项的系数即可。\n第二项 $\\sum\\limits_{i=j}^{n}f\u0026rsquo;_{n-i}g_{i-j}$：计算多项式 $f\u0026rsquo;(x) * g(x)$，取第 $n-j$ 项的系数即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = (1\u0026lt;\u0026lt;21) + 5; struct Complex { double x,y; Complex(double _x = 0.0, double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(const double f[], int n1, const double g[], int n2, double h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = a[i].x; } double f[maxn/2], g[maxn/2], h[maxn]; double f2[maxn], h2[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; f[i]; g[i] = (1.0/i/i); } poly_multiply(f, n, g, n, h); for (int i = 0; i \u0026lt;= n; i++) f2[i] = f[n-i]; // f'[i] = f[n-i] poly_multiply(f2, n, g, n, h2); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026quot;%.3f\\n\u0026quot;, h[i] - h2[n-i]); } }   例3 洛谷P3723 [AH2017/HNOI2017]礼物 题意\n给定两个长度为 $n$ 的正整数序列 $x,y$，我们进行一次以下操作：\n第一步：给其中一个序列的所有数加上一个非负整数 $c$。\n第二步：旋转一个序列，可以旋转任意长度。\n 序列的旋转意思是全部元素左移，或者右移，超出界限的部分从另外一边补齐。\n例如： $[1,2,3,4,5]$ 向右旋转 $2$ 个长度，得到 $[4,5,1,2,3]$。\n 现在我们想知道，如何选择 $c$ 和旋转序列的方式，使得\n$$\\sum\\limits_{i=1}^n(x_i-y_i)^2$$\n最小？\n其中，$1\\leq n \\leq 50000, 1\\leq x_i, y_i \\leq 100$\n 题解 首先由于第一步中，我们可以选择任意一个序列来加上 $c$，所以可以看作选择一个序列，然后加上一个 任意整数 $c$。\n最后我们设旋转后，对齐的两个序列为 $a,b$。\n则\n$$\\sum\\limits_{i=1}^n(x_i-y_i)^2$$\n可以表示为：\n$$\\sum\\limits_{i=1}^n(a_i+c-b_i)^2$$\n$$=\\sum\\limits_{i=1}^n ((a_i^2+b_i^2+c^2)+2c(a_i-b_i) - 2a_ib_i)$$\n$$=nc^2 + \\sum\\limits_{i=1}^n (a_i^2+b_i^2)+2c\\sum\\limits_{i=1}^n(a_i-b_i) - \\sum\\limits_{i=1}^n 2a_ib_i$$\n如果我们暂时不考虑 $c$，则会发现，无论最终旋转的 $a,b$ 是什么样的，前三项均为定值，只有 $\\sum\\limits_{i=1}^n 2a_ib_i$ 的值是个变量。\n所以我们只需要 最大化 $\\sum\\limits_{i=1}^n a_ib_i$ 的值即可。\n 现在问题转化为，如何求一种旋转方式，使得 $\\sum\\limits_{i=1}^n a_ib_i$ 的值最大？\n我们不妨直接把每一种旋转方式的值都求出来，然后取最大即可。\n怎么全部一次性求出呢？卷积！\n令\n$$E_j = \\sum\\limits_{i=j}^na_ib_{i-j+1} + \\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j}$$\n则 $E_j$ 所代表的就是，如果我们如此排列：\n   $a_j$ $a_{j+1}$ \u0026hellip; $a_n$ $a_1$ $a_2$ \u0026hellip; $a_{j-1}$     $b_1$ $b_2$ \u0026hellip; $b_{n+1-j}$ $b_{n+2-j}$ $b_{n+3-j}$ \u0026hellip; $b_{n}$     最后得出来对应位置的乘积的和，就是 $E_j$。\n所以我们只要求出 $E_1, E_2, \u0026hellip;, E_n$，然后取最小值即可。\n如何求呢？\n 先考虑第一项 $\\sum\\limits_{i=j}^na_ib_{i-j+1}$\n把它转成卷积的形式，令 $c_i = a_{n-i}$，则有：\n$$\\sum\\limits_{i=j}^na_ib_{i-j+1} = \\sum\\limits_{i=j}^nc_{n-i}b_{i-j+1} = b_1c_{n-j} + b_2c_{n-j-1} + \u0026hellip; + b_{n-j+1}c_{0}$$\n令 $a_0 = b_0 = 0$，就可以再给上式加一个 $b_0c_{n-j+1}$，得到：\n$$b_0c_{n-j+1} + b_1c_{n-j} + b_2c_{n-j-1} + \u0026hellip; + b_{n-j+1}c_{0}$$\n那么这就是一个卷积了，相当于 $b(x) * c(x)$ 的第 $(n-j+1)$ 项。\n 再考虑第二项 $\\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j}$\n仍然转成卷积形式，令 $d_i = b_{n-i}$，则有：\n$$\\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j} = \\sum\\limits_{i=1}^{j-1}a_id_{j-i-1} = a_1d_{j-2} + a_2d_{j-3} + \u0026hellip; + a_{j-1}d_{0}$$\n由于 $a_0 = 0$，给上式加上 $a_0d_{j-1}$，得到：\n$$a_0d_{j-1} + a_1d_{j-2} + a_2d_{j-3} + \u0026hellip; + a_{j-1}d_{0}$$\n这又是一个卷积，相当于 $a(x) * d(x)$ 的第 $(j-1)$ 项。\n 所以 $\\sum\\limits_{i=1}^n a_ib_i$ 的最大值求出来了，剩下的变量只有 $c$ 了。\n注意到 $1 \\leq x_i,y_i \\leq 100$，所以 $c$ 只要取遍所有的可能值，然后判断最小值即可。\n在代码中，$c \\in [-200, 200]$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;20) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 memset(h, 0, sizeof(ll) * n); ntt.ntt(f, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt;= n; i++) h[i] = f[i] * g[i] % mod; ntt.ntt(h, n, -1); } int n1, n2; ll a[maxn/2], b[maxn/2], c[maxn/2], d[maxn/2], r1[maxn], r2[maxn]; int n,m; ll ans = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], c[n-i] = a[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i], d[n-i] = b[i]; ll absum = 0; // a_i - b_i for (int i = 1; i \u0026lt;= n; i++) absum += a[i] - b[i]; ll res = 1e18; for (ll c = -200; c \u0026lt;= 200; c++) { res = min(res, n * c * c + 2LL * c * absum); } ans += res; for (int i = 1; i \u0026lt;= n; i++) { ans += (a[i] * a[i]) + (b[i] * b[i]); } poly_multiply(a, n, d, n, r1); // r1 = a*d poly_multiply(b, n, c, n, r2); // r2 = b*c ll ab = 0; for (int i = 1; i \u0026lt;= n; i++) { ab = max(ab, (r1[i-1] + r2[n-i+1])); } ans -= 2LL * ab; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   参考资料  HKU COMP3250 FFT课件 https://oi-wiki.org/math/poly/fft/ https://oi.men.ci/fft-notes/ https://zhuanlan.zhihu.com/p/128661674  ","date":"2021-09-17T13:52:57+08:00","permalink":"https://tom0727.github.io/post/051-fft/","tags":["FFT"],"title":"FFT"},{"categories":["算法"],"contents":"介绍 线性基是一般用于解决 子集XOR，XOR最值 一类问题的算法。\n定义 线性基是一个 linear space，在这个space中，所有的向量为 非负整数，而 scalar 则为 $\\{0,1\\}$，元素之间的运算为 XOR。\n可以直接与 linear algebra 中，由矩阵组成的 linear space 直接关联起来，并且专属名词的定义与矩阵 linear space 中的基本相同。\n性质   线性基 $S = \\{x_1,x_2,\u0026hellip;,x_n\\}$ 中，所有元素 $\\{x_1,x_2,\u0026hellip;,x_n\\}$ 之间是 linearly independent 的。\n  线性基 $S = \\{x_1,x_2,\u0026hellip;,x_n\\}$ 中的所有元素组成了一个 basis，意味着 $$\\forall x \\in span(S), x = a_1x_1 + a_2x_2 + \u0026hellip; a_nx_n$$ 且 $(a_1,a_2,\u0026hellip;,a_n)$ 是 unique 的。（$a_i \\in \\{0,1\\}$）\n  在线性基中，每个元素的二进制最高位均不同。\n  对于线性基第 $i$ 位上的元素 a[i]，保证 a[i] 二进制第 $i$ 位为 $1$，并且：\n$\\forall j \u0026gt; i$，a[i] 的二进制第 $j$ 位为 $0$。\n对于 $j \u0026lt; i$，a[i] 的二进制第 $j$ 位可以为 $1$ 或者 $0$。\n  推论 根据线性基的性质，有以下推论：\n  从 $S$ 中取任意个（至少 $1$ 个）元素，它们的 XOR 均不为 $0$。\n  $S$ 中任意元素 $x_i$ 均 无法 由其他元素 XOR 得到。\n  对于一个非负整数 $x$，如果在 $S$ 中，取一些元素 $x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}$ 使得 $x = XOR(\\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\})$，则：\n使用 $x$ 替换掉 $x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}$ 中的任意一个，线性基均不变。\n 如何找到这样的 $x_1, x_2, \u0026hellip;, x_k$ 使得 $x = XOR(\\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\})$？\n 答：在正常的 insert() 过程中，如果执行了 x ^= a[j]，就说明 $x_j \\in \\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\}$。\n 注：为了维持线性基的特性，不能直接进行替换。\n 正确方式是在正常的 insert() 过程中，在遇到想要替换的 j 时，进行 swap(x, a[j])，然后再 x ^= a[j]。\n  构造方法 构造线性基是一个 动态过程，意味着我们逐一往线性基中 插入元素 来构造。\n我们利用一个数组 ll a[63] 来维护线性基。\n其中 a[i] 代表线性基中的一个元素，它的二进制最高位为第 $i$ 位（从右往左数）。如果 a[i] = 0，说明这个元素不存在。\ninsert 操作 当我们向线性基中插入一个元素 $x$ 时，遵循以下步骤：\n  从高位往低位，遍历 $x$ 的二进制bit。\n  遍历到第 $i$ 位时，如果 $x$ 的第 $i$ 位为 $0$，直接跳到下一位。\n如果 $x$ 的第 $i$ 位为 $1$，则：\n2.1. 如果 a[i] = 0（说明这一位不存在元素），则令 a[i] = x，然后 break。（说明插入元素成功）。\n2.2. 如果 a[i] \u0026gt; 0（说明这一位存在元素），则令 x = x ^ a[i]，然后继续遍历下一位bit。\n  ll a[63]; bool insert(ll x) { for (int j = 62; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; // 插入元素 x return 1; // 插入元素成功 } } } return 0; // 插入元素失败 }  由以上的过程，可以看出：\n插入元素 $x$ 成功 $\\iff x \\notin span(S)$，插入后 $span(S)$ 的大小翻倍。\n插入元素 $x$ 失败 $\\iff x \\in span(S)$。\nquery 操作 查询一个元素 $x$ 是否满足 $x \\in span(S)$，只要遵循上面的 insert 操作，然后不进行真正的插入即可。\n应用 最大子集 XOR 和 Q: 给定一个数组 $S$，求它的子集 $S\u0026rsquo; \\subseteq S$，使得 $S'$ 中所有元素的 XOR值 最大。\nA: 构造 $S$ 的线性基，然后从高到低位遍历线性基，如果 ans ^ a[i] 更大，则 ans = ans ^ a[i]。\n例 洛谷P3812 【模板】线性基 题意\n给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; ll a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; break; } } } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { ll x; cin \u0026gt;\u0026gt; x; insert(x); } ll ans = 0; for (int j = 60; j \u0026gt;= 0; j--) { ans = max(ans, (ans ^ a[j])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 洛谷P3857 [TJOI2008]彩灯 题意\n有 $n$ 个彩灯，$m$ 个开关，每个开关会控制一些彩灯的状态。每个彩灯只有开和关两种状态。初始状态下所有彩灯为关。\n求所有可能的彩灯样式数量。\n其中，$n,m \\leq 50$\n 题解 每个开关看成一个数字，然后构建原集合的线性基。\n最终答案为 $2^{|S|}$，其中 $|S|$ 为线性基的大小。\n证明：因为线性基中，对于每个二进制位，如果有，则仅有一个元素 $x$ 使得 $x$ 的最高位为 $1$。\n先令集合 $X = \\{0\\}$，代表 $span(S)$。\n我们从低位开始往高位考虑，对于第 $i$ 位而言，如果 a[i] 存在，则将 $X$ 内所有的元素与 a[i] 进行 XOR，会得到最高位 $i$ 为 $1$ 的元素，而原来 $X$ 中并不存在这样的元素，所以 $X$ 的大小翻倍了。\n 注意，在使用 bit shifting 的时候，要注意用 1LL \u0026lt;\u0026lt; j，而不是 1 \u0026lt;\u0026lt; j，后者会爆 int。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; break; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (!m) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } for (int i = 1; i \u0026lt;= m; i++) { string s; cin \u0026gt;\u0026gt; s; ll x = 0; for (int j = 0; j \u0026lt; n; j++) { if (s[n-j-1] == 'O') { x |= (1LL\u0026lt;\u0026lt;j); } } insert(x); } ll ans = 1, cnt = 0; for (int j = 60; j \u0026gt;= 0; j--) { if (a[j]) cnt++; } ans = (1LL\u0026lt;\u0026lt;cnt) % 2008LL; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P4570 [BJWC2011]元素 题意\n有 $n$ 个矿石，每个矿石 $i$ 拥有一个元素序号 $a_i$，还有一个魔力值 $b_i$。\n请选出一些矿石，使得这些矿石的元素序号的 XOR 不为 $0$，并且使得魔力值之和最大。\n 题解 先根据魔力值从大到小 sort 一下所有矿石，然后根据这个顺序，加入矿石的元素序号到线性基中。\n最终把线性基中，所有矿石对应的魔力值加起来即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[63]; bool insert(ll x) { for (int j = 62; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return 1; } } } return 0; } struct node { ll x, val; } arr[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].x \u0026gt;\u0026gt; arr[i].val; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026gt; b.val; }); ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { if (insert(arr[i].x)) { ans += arr[i].val; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P3292 [SCOI2016]幸运数字 题意\n给定一个 $n$ 个节点的树，每个节点 $i$ 都有一个权值 $a_i$。\n现在给定 $q$ 个询问，每次询问 $x ~ y$，回答：\n对于从 $x$ 到 $y$ 的最短路径上的所有节点，选出一个子集使得权值的 XOR 最大，回答这个最大值。\n其中，$n \\leq 2 \\times 10^4, q \\leq 10^5$，所有权值为非负整数。\n 题解 首先暴力做法很好想，直接找 $x \\rightarrow y$ 路径上的所有权值，构建一个线性基即可。\n然后考虑优化：\n看到 树 就立刻想到 树形DP，看到 树形DP 就立刻想到了 树上差分。\n虽然这题不能直接用树上差分，但是差分中常用的 倍增LCA 倒是可以用。\n所以做法就是对于每个节点 $u$，令 $j = 0,1,2,\u0026hellip;$，代表从 $u$ 出发，往上跳 $2^j$ 个节点，从起点到终点之间所有节点的权值构建的线性基。\n所以构建出的数组就是个 ll a[maxn][16][61]; // a[u][k] 代表从 u 开始往上从 2^k 格，形成的线性基。\n构建这个线性基的过程和倍增同理，只不过需要 两个线性基合并为一个。\n这个过程也不难，直接把两个线性基中的所有元素拿出来，然后都 insert 进一个空的线性基即可。\n最后，询问 $x ~ y$ 的话就先找到 $l = lca(x,y)$，然后通过倍增，合并出 $(x,l)$ 和 $(y,l)$ 对应的线性基，然后再将两者合并即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e4+5; const int maxm = 1e5+5; int n,q; ll arr[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][16], dep[maxn]; ll a[maxn][16][61]; // a[u][k] 代表从 u 开始往上从 2^k 格，形成的线性基 // insert 一个元素 x 进入 b[] 中 void insert(ll x, ll b[]) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (b[j]) x ^= b[j]; else { b[j] = x; return; } } } } // 将 a1, a2 两个线性基合并为 b void merge(ll a1[], ll a2[], ll b[]) { for (int j = 60; j \u0026gt;= 0; j--) { if (a1[j]) insert(a1[j], b); if (a2[j]) insert(a2[j], b); } } void dfs(int u, int p) { par[u][0] = p; insert(arr[u], a[u][0]); dep[u] = dep[p] + 1; for (int j = 1; j \u0026lt;= 15; j++) { par[u][j] = par[par[u][j-1]][j-1]; merge(a[u][j-1], a[par[u][j-1]][j-1], a[u][j]); } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int jump(int u, ll d, ll b[]) { int j = 0; while (d) { if (d \u0026amp; 1) { for (int k = 60; k \u0026gt;= 0; k--) { if (a[u][j][k]) insert(a[u][j][k], b); } u = par[u][j]; } j++; d \u0026gt;\u0026gt;= 1; } return u; } ll query(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); static ll tmp[61]; memset(tmp, 0, sizeof(tmp)); u = jump(u, dep[u] - dep[v], tmp); if (u == v) { insert(arr[u], tmp); } else { for (int j = 15; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { u = jump(u, (1LL\u0026lt;\u0026lt;j), tmp); v = jump(v, (1LL\u0026lt;\u0026lt;j), tmp); } } u = jump(u, 1, tmp); v = jump(v, 1, tmp); insert(arr[u], tmp); insert(arr[v], tmp); } ll ans = 0; for (int j = 60; j \u0026gt;= 0; j--) { if (tmp[j]) ans = max(ans, (ans ^ tmp[j])); } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); while (q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; query(u,v) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P4151 [WC2011]最大XOR和路径 题意\n给定 $n$ 个节点，$m$ 条边的无向连通图。每条边上有权值。\n考虑从 $1$ 到 $n$ 的所有可能路径中，路径上所有边权值的XOR，求这些路径对应的XOR最大值。\n路径可以包含环，一条边可以被经过多次（经过多次的话，权值也要XOR多次）。\n图中可能包含重边和自环。\n其中，$n \\leq 5 \\times 10^4, m \\leq 10^5$\n 题解 首先考虑一下 无环 的情况，那它就是个树了，那路径只有一种可能。就是从 $1 \\rightarrow n$。\n然后考虑一下 有环 的情况，\n可以发现，最终的答案可以是 $1 \\rightarrow n$ 的路径（我们称之为 主路径），XOR上这些环（也可以不 XOR），而链接环与主路径之间的边，可以忽略不计（因为被经过两次了）。\n所以一个大胆（且正确）的猜想是：\n求出所有的环，随便找一条 $1 \\rightarrow n$ 的简单路径（无环），用所有环的XOR值构造一个线性基，最后和主路径XOR起来，得到最大值。\n然后就有几个问题了：\n Q1. 求出所有的环？复杂度会爆炸的吧？\nA1. 我们可以发现，所有环的 XOR 均由它的 简单环 组成。所以我们只需要考虑简单环即可。\nQ2. 如何求出所有的简单环？\nA2. 用一次DFS，DFS的过程中找到所有的 back-edge 即可，由于 $m$ 最多为 $10^5$，所以 back-edge 也不会超过 $10^5$ 个，所以最多只有 $10^5$ 个简单环。\nQ3. 主路径如果有多条怎么办？\nA3. 注意到，尽管只往线性基里加入了简单环，但是由于线性基的特性，所以任意简单环的组合都可以被线性基所表示。所以这就相当于线性基包含了所有可能的环。\n那么，如果从 $1 \\rightarrow n$ 有多条简单路径，则两条不同的简单路径会形成一个环。\n假如最优的主路径为 $B$，而我们考虑了 $A$ 为主路径，但是 $A ~xor~ B$ 实际上是一个环。所以最后我们在考虑最终答案时，有 $A \\text{ xor } (A \\text{ xor } B) = B$，所以 $B$ 就变成最优解中的主路径了。\nQ4. 如何求出一个环的 XOR？\nA4. 直接从 $1$ 开始DFS，记录一个 d[]，其中 d[u] 代表这个 DFS 过程中，找到的一条 $1 \\rightarrow u$ 的简单路径的 XOR。\n则对于 $u$ 的任意一个neighbor $v$，如果 $(u,v,w)$ 是 back-edge，那么 $(d[u] \\text{ xor } d[v] \\text{ xor } w)$ 就是这个环的 XOR。\n 最后的答案就是 d[n] 作为初始值，所有简单环构建出线性基，然后求最大值。\n• 注意到 d[n] 并不在线性基中，因为 d[n] 是 必须要取 的，所以作为 ans 的初始值。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 1e5+5; int n,m; struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll d[maxn], a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return; } } } } bool vis[maxn]; void dfs(int u) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (vis[to]) { // 发现 back-edge，对应一个简单环 insert(d[u] ^ d[to] ^ w); // 加入一个简单环 } else { d[to] = d[u] ^ w; dfs(to); } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1); ll ans = d[n]; // 注意 d[n] 作为初始值，因为它必须要存在于最终答案中 for (int j = 60; j \u0026gt;= 0; j--) { ans = max(ans, (ans ^ a[j])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 LOJ 114 k小异或和 题意\n给定 $n$ 个非负整数，$m$ 次询问。\n每次询问一个数字 $k$，输出 $S$ 所有非空子集的不同的XOR中，第 $k$ 小的XOR值。\n如果 $S$ 的所有非空子集中，不同的XOR数量 $\u0026lt; k$，则输出 $-1$。\n其中，$n,m \\leq 10^5$。\n 题解 本题主要考察 线性基的化简。\n首先可以构建线性基，如果在构建中出现了 插入失败 的情况，则说明 $\\exists T \\subseteq S$，使得 $XOR(T) = 0$，这说明最小值为 $0$，否则最小值不为 $0$。\n构建完毕后，我们知道，$span(S)$ 的大小为 $2^{|S|}$。\n我们设 $span(S_i)$ 为：只考虑（从小到大）前 $i$ 位的线性基的 $span$，则有：\n$span(S_i) = span(S_{i-1}) \\sqcup span(S_{i-1}) \\text{ xor } x_i$ （注意 $\\sqcup$ 是 disjoint union）\n由此，我们可以联想到，把 $k$ 写成二进制，然后根据 $k$ 的二进制，来构造这个数字。\n比如，$k = 1101$，那么我们就把线性基的第 $0,2,3$ 位 XOR 起来，得到答案。\n 但是这样有一个问题，这样得到的答案不一定正确。比如说：\n线性基 $\\{1,2\\}$ 和 $\\{1,3\\}$ 实际上是等价的，但是对于同样的 $k$，答案却不相同，只有 $\\{1,2\\}$ 构造出来的答案才是正确的。\n 所以我们有了一个想法：把线性基上 每一位的数字转化为它可能的最小值，也就是 化简线性基。\n这个化简的过程，很像高斯消元，但又不完全一样。\n 怎么化简呢？\n想到我们求一个线性基所能表示的最大值时，使用的 ans = max(ans, (ans ^ a[i]))。\n那么化简也是同理，只不过把它改成 min 而已，然后把 ans 替换为线性基上的某一位即可。\n// 将线性基所有元素变成最小 for (int k = 50; k \u0026gt;= 0; k--) { for (int j = k-1; j \u0026gt;= 0; j--) { a[k] = min(a[k], (a[k] ^ a[j])); } }  这样就化简完毕了，举几个例子：\n $\\{70,32,28,8,4,3,1\\}$ 化简后，得到 $\\{64,32,16,8,4,2,1\\}$ $\\{14, 7\\}$ 化简后，得到 $\\{9,7\\}$  化简后就可以用上面的方法来构造了，注意构造答案的时候，只需要考虑线性基上非空的位。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[51]; bool insert(ll x) { for (int j = 50; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return 1; } } } return 0; } int main() { cin \u0026gt;\u0026gt; n; bool zero = 0; for (int i = 1; i \u0026lt;= n; i++) { ll x; cin \u0026gt;\u0026gt; x; if (!insert(x)) zero = 1; } int sz = 0; for (int k = 50; k \u0026gt;= 0; k--) { if (a[k]) sz++; } // 将线性基所有元素变成最小 for (int k = 50; k \u0026gt;= 0; k--) { for (int j = k-1; j \u0026gt;= 0; j--) { a[k] = min(a[k], (a[k] ^ a[j])); } } // 只考虑线性基的非空位 vector\u0026lt;int\u0026gt; vec; for (int k = 0; k \u0026lt;= 50; k++) { if (a[k]) vec.push_back(k); } cin \u0026gt;\u0026gt; m; while (m--) { ll k; cin \u0026gt;\u0026gt; k; if (zero) k--; // 最小值为 0 if (k \u0026gt;= (1LL \u0026lt;\u0026lt; sz)) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } ll ans = 0; for (int j = 0; j \u0026lt;= 50; j++) { if (k \u0026amp; (1LL \u0026lt;\u0026lt; j)) { ans ^= (a[vec[j]]); // 只考虑非空位 } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例6 HDU6579 Operation 题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$ 和 $m$ 个询问。\n每次询问为两种：\n$0 ~ l ~ r$：从 $\\{a_l,\u0026hellip;,a_r\\}$ 中选取任意个数字，输出 XOR 的最大值。\n$1 ~ x$：给序列 append 一个数字 $x$，使得 $n = n+1$。\n所有询问强制在线。\n其中，$n,m \\leq 5 \\times 10^5$。\n 题解 前缀线性基。\n对于每个 $i$，我们都根据 $\\{a_1,a_2,\u0026hellip;,a_i\\}$ 来构建一个线性基，所以总共有 $n$ 个线性基。\n构建以后，每次询问 $[L,R]$，我们都可以先找到 $[1,R]$ 对应的线性基。\n 找到 $[1,R]$ 的线性基以后，问题转化成，如何去掉 $[1,L-1]$ 的影响？\n我们维护一个数组 pos[]，其中 pos[j] 代表 最大 的index i，使得 $a_i$ 影响到了 线性基的第 $j$ 位 $x_j$。\n所以，在询问 $[L,R]$ 时，我们遍历 $[1,R]$ 对应的线性基中，每一位 $j \\in [0,50]$，如果 $pos[j] \\geq L$，则说明线性基的第 $j$ 位可以被使用。\n 如何维护 pos[] 数组，并且保证 pos[] 数组内的值尽可能大？\n在线性基的推论第 $3$ 条中，我们提到了如果要使用一个新的元素来替换掉线性基中的旧元素，可以使用 swap() 的方式实现。\n这里也是同理，我们在 insert $a_i$ 时，如果当前考虑到了线性基的第 $j$ 位，那么我们检查 $pos[j] \u0026lt; i$ 是否成立，如果是，就进行替换操作（swap()）。\n • 如果这个题可以离线，就可以预处理一下所有的询问，按照 右端点排序，在从左往右扫的时候维护一个 pos[31] 数组即可。\n离线版本可以见：ABC223H\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; // 注意因为 n 最高可被增加到 1e6，所以这里使用的是 1e6 const int maxm = 1e5+5; int n,m; int a[maxn][31], pos[maxn][31]; void insert(int i, int x) { memcpy(a[i], a[i-1], 31 * sizeof(int)); // 注意这里有 sizeof(int) memcpy(pos[i], pos[i-1], 31 * sizeof(int)); int p = i; for (int j = 30; j \u0026gt;= 0; j--) { if (x \u0026amp; (1\u0026lt;\u0026lt;j)) { if (a[p][j]) { if (pos[p][j] \u0026lt; i) { // 进行替换 swap(a[p][j], x); swap(pos[p][j], i); } x ^= a[p][j]; } else { a[p][j] = x; pos[p][j] = i; return; } } } } int query(int l, int r) { int ans = 0; for (int j = 30; j \u0026gt;= 0; j--) { if (pos[r][j] \u0026gt;= l) ans = max(ans, (ans ^ a[r][j])); } return ans; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int lastans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; insert(i, x); } while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 0) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l = (l ^ lastans) % n + 1; r = (r ^ lastans) % n + 1; if (l \u0026gt; r) swap(l,r); lastans = query(l,r); cout \u0026lt;\u0026lt; lastans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { int x; cin \u0026gt;\u0026gt; x; x = x ^ lastans; insert(n+1, x); n++; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 30; j++) { a[i][j] = pos[i][j] = 0; } } } }   例7 ABC141F Xor Sum 3 题意\n给定 $n$ 个非负整数，将它们分为两个非空集合 $A,B$，求 $XOR(A) + XOR(B)$ 的最大值？\n其中，$2 \\leq n \\leq 10^5$\n 题解 分为两个集合的话，就可以考虑二进制每一位的count的奇偶性。\n对于第 $i$ 位bit而言：\n 如果 count 是奇数：那么无论怎么分，最后分出来的两个集合一定是 奇 + 偶 的形式，所以最后一定会贡献 $2^i$ 给答案。 如果 count 是偶数：最后分出来，要么为 奇 + 奇，要么为 偶 + 偶，所以对于这些位置，分出来的两个数 $a,b$ 一定是相同的。  所以我们先把 奇数count 的位置贡献算出来，然后把它们全部置为 $0$，接下来所有的位就只有偶数 count 了，此时无论怎么分，最后得到的两个数字都是相同的，也就是答案等于 $2x$。\n所以我们只要让 $x$ 最大就好了，用线性基解决即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll a[61], arr[maxn], ans = 0; int n; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return; } } } } int cnt[61]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; for (int j = 60; j \u0026gt;= 0; j--) { if (arr[i] \u0026amp; (1LL \u0026lt;\u0026lt; j)) cnt[j] ^= 1; } } for (int j = 60; j \u0026gt;= 0; j--) { if (cnt[j]) { ans += (1LL \u0026lt;\u0026lt; j); for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026amp; (1LL \u0026lt;\u0026lt; j)) arr[i] -= (1LL \u0026lt;\u0026lt; j); } } } for (int i = 1; i \u0026lt;= n; i++) insert(arr[i]); ll x = 0; for (int j = 60; j \u0026gt;= 0; j--) { x = max(x, (x^a[j])); } cout \u0026lt;\u0026lt; 2LL*x + ans \u0026lt;\u0026lt; endl; }   参考链接  https://oi.men.ci/linear-basis-notes/ https://ouuan.github.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://zhuanlan.zhihu.com/p/68575986  ","date":"2021-09-14T13:44:57+08:00","permalink":"https://tom0727.github.io/post/050-%E7%BA%BF%E6%80%A7%E5%9F%BA/","tags":["线性基"],"title":"线性基"},{"categories":["算法"],"contents":"介绍 高斯消元是矩阵操作里最基础的一个，主要用于解形如 $a_1x_1 + a_2x_2 + a_3x_3 = b_1$ 之类的线性方程组。\n步骤  按 column 进行遍历 遍历到第 $k$ 个 column 时，在这个column中，寻找一个 $maxrow$ 使得 $A[maxrow][k]$ 最大。 将第 $k$ 行 与 第 $maxrow$ 行进行交换。 交换后，以第 $k$ 行作为pivot，减掉其他所有行，消去第 $k$ 列其他行上的数字。 最后会得到一个 diagonal matrix，除以对应系数即可得到 $\\vec{b}$  复杂度：$O(n^3)$\n先上板子：\n模版 P3389 【模板】高斯消元法 题意\n给定一个线性方程组，进行求解。\n输入一个 $n \\times (n+1)$ 的矩阵，每一行为 $a_1, a_2, \u0026hellip;, a_n, b_k$，代表一组方程。\n #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; double A[maxn][maxn]; int n; void solve() { for (int k = 1; k \u0026lt;= n; k++) { int maxrow = k; // 当前行初始情况下为：当前列对应的行数 for (int i = k+1; i \u0026lt;= n; i++) { // 从当前行往下找 if (abs(A[i][k]) \u0026gt; abs(A[maxrow][k])) maxrow = i; } for (int i = 1; i \u0026lt;= n+1; i++) swap(A[k][i], A[maxrow][i]); //交换两行, 保证A[k][k]最大 if (abs(A[k][k]) \u0026lt; eps) { cout \u0026lt;\u0026lt; \u0026quot;Infinite solutions.\u0026quot; \u0026lt;\u0026lt; endl; // 出现一行全是 0 的情况，一般说明有无数个解 return; } for (int i = 1; i \u0026lt;= n; i++) { if (i == k) continue; double m = A[i][k] / A[k][k]; for (int j = 1; j \u0026lt;= n+1; j++) { //更新上下的行 A[i][j] -= (m * A[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { A[i][n+1] /= A[i][i]; // 最后除以斜线上的系数 A[i][i] = 1.0; printf(\u0026quot;%.2f\\n\u0026quot;, A[i][n+1]); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n+1; j++) { cin \u0026gt;\u0026gt; A[i][j]; // 输入矩阵，j=n+1 代表 b } } solve(); }  例题 例1 洛谷P2447 [SDOI2010]外星千足虫 题意\n有 $n$ 个虫子，每只虫子来自地球或者火星。来自地球的虫子有偶数个脚，火星的虫子有奇数个脚。\n现在给定 $m$ 个方程，代表已知哪些虫子的脚数量之和为奇数或者偶数。\n求每个虫子的归属地（地球或者火星）。\n如果有解，输出最小的 $k \\leq n$ 使得仅用前 $k$ 个方程即可得到结果。\n如果无解，则输出 Cannot Determine。\n其中，$1 \\leq n \\leq 10^3, 1 \\leq m \\leq 2 \\times 10^3$。\n 题解 高斯消元即可。现在有几个问题：\nQ1. 如果有解，如何求出 $k$？\nA1. 注意到高斯消元的第二步是寻找一个 $maxrow$。然而这个题中，矩阵中的数要么为 $0$，要么为 $1$。所以只要找到 $1$，就不需要再往下找了。\n所以在寻找 $1$ 的过程中记录一下用到的 row number 的最大值即可，一旦找到就立刻break。\n Q2. 高斯消元是 $O(n^3)$ 的，复杂度不对？\nA2. 再次注意到这个矩阵仅由 $0,1$ 组成，可以用 bitset 进行优化。优化幅度为 $\\frac{1}{w}$，其中 $w=32$。\n所以复杂度为 $O(\\frac{n^2m}{w})$，足以通过本题。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e3+2; const int maxm = 7e5+5; bitset\u0026lt;maxn\u0026gt; A[maxn+maxn]; int ans; int n,m; void solve() { for (int k = n; k \u0026gt;= 1; k--) { int maxrow = n-k+1; for (int i = n-k+1; i \u0026lt;= m; i++) { ans = max(ans, i); if (A[i].test(k)) { maxrow = i; break; } } swap(A[n-k+1], A[maxrow]); if (!A[n-k+1].test(k)) { cout \u0026lt;\u0026lt; \u0026quot;Cannot Determine\\n\u0026quot;; return; } for (int i = 1; i \u0026lt;= m; i++) { if (i == n-k+1) continue; if (A[i].test(k)) A[i] ^= A[n-k+1]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) { if (A[i].test(0)) cout \u0026lt;\u0026lt; \u0026quot;?y7M#\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;Earth\\n\u0026quot;; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (m \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;Cannot Determine\\n\u0026quot;; return 0; } ans = 1; for (int i = 1; i \u0026lt;= m; i++) { string s1,s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; A[i] = bitset\u0026lt;maxn\u0026gt;(s1 + s2); } solve(); }   例2 洛谷P4035 [JSOI2008]球形空间产生器 题意\n在 $n$ 维空间中，有一个球体。现在已知该球面上 $(n+1)$ 个点的坐标，求出球心坐标？\n其中，$1 \\leq n \\leq 10$，数据保证有唯一解。\n 题解 设球心坐标为 $(b_1,b_2,\u0026hellip;,b_n)$，那么就可以列出 $(n+1)$ 个方程：\n$(b_1 - a_{11})^2 + (b_2 - a_{12})^2 + \u0026hellip; + (b_n - a_{1n})^2 = R^2$ \u0026hellip;\n但是这并不是线性方程组。\n为了使其成为线性方程组，将 $(n+1)$ 个方程进行相减，得到\n 方程 $2$ 减去方程 $1$ 方程 $3$ 减去方程 $1$ \u0026hellip;  即可得到 $n$ 个线性方程。\n然后用高斯消元即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 12; double A[maxn][maxn], arr[maxn][maxn]; int n; void solve() { for (int k = 1; k \u0026lt;= n; k++) { int maxrow = k; for (int i = k+1; i \u0026lt;= n; i++) { if (abs(A[i][k]) \u0026gt; abs(A[maxrow][k])) maxrow = i; } for (int i = 1; i \u0026lt;= n+1; i++) swap(A[k][i], A[maxrow][i]); //交换两行, 保证A[k][k]最大 if (abs(A[k][k]) \u0026lt; eps) { cout \u0026lt;\u0026lt; \u0026quot;No Solution\u0026quot; \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= n; i++) { if (i == k) continue; double m = A[i][k] / A[k][k]; for (int j = 1; j \u0026lt;= n+1; j++) { //更新上下的行 A[i][j] -= (m * A[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { A[i][n+1] /= A[i][i]; // 最后除以斜线上的系数 A[i][i] = 1.0; printf(\u0026quot;%.3f \u0026quot;, A[i][n+1]); } } double sq(double a) { return a*a; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n+1; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { A[i][j] = arr[i+1][j] - arr[i][j]; } for (int k = 1; k \u0026lt;= n; k++) { A[i][n+1] += sq(arr[i+1][k]) - sq(arr[i][k]); } A[i][n+1] /= 2; } solve(); }   ","date":"2021-09-10T22:00:43+08:00","permalink":"https://tom0727.github.io/post/049-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","tags":[""],"title":"高斯消元"},{"categories":["算法"],"contents":"例1 洛谷P1850 [NOIP2016 提高组] 换教室 题意\n有 $n$ 个时间段，每个时间段有 $2$ 节课程。其中在时间段 $i$ 的两节课，分别在教室 $c_i, d_i$ 上。\n对于所有的时间段 $i$，牛牛预先被安排在 $c_i$ 上课。\n对于一个时间段 $i$，牛牛可以申请转到教室 $d_i$ 上课。但这个申请只有 $k_i$ 的概率被批准。\n牛牛最多可以申请 $m$ 个时间段，但是所有申请必须一次性提交。\n同时，校园可以看作是一个图，教室为节点（共 $v$ 个教室），教室之间有双向边（共 $e$ 个边），边有长度。\n每当一节课结束后，牛牛会沿着最短路径走到下一节课所在的教室。\n现在牛牛想知道，怎么申请时间段，使得他在教室间移动的路程长度期望值最小，求出这个最小期望。\n其中，$1 \\leq n \\leq 2000, 0 \\leq m \\leq 2000, 1 \\leq v \\leq 300, 0 \\leq e \\leq 90000$。\n 题解 首先用 floyd $O(n^3)$ 求出每两个节点之间的最短路长度。\n然后一个很明显的 DP 思路：\n设 $dp[i][j][k]$ 为：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前在哪个教室。\n这个思路看起来很有道理，但是不正确。因为题目提到 所有申请必须一次性提交。\n而 $k=0/1$ 如果代表当前在哪个教室，就说明我们已经知道了当前的申请结果，来考虑后面的时间段是否申请。这会导致我们的决策更加的精明，从而使得答案小于正确答案。\n 正确的状态为：$dp[i][j][k]$：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前 是否申请过，$dp$ 数组的值代表路径长度期望值。\n然后转移的时候，就要分类讨论 是否申请下一个时间段，得到两个结果，取 $\\min$ 就得到了当前状态的答案。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2002; int n,m,v,e, c[maxn], d[maxn]; double k[maxn]; int adj[302][302], dis[302][302]; double dp[maxn][maxn][2]; // K = 1: 已申请， K = 0: 未申请 double dfs(int i, int j, int K) { if (i \u0026gt;= n) return 0.0; if (dp[i][j][K] \u0026gt;= 0.0) return dp[i][j][K]; double r1 = 1e18, r2 = 1e18; // next: 申请/不申请 if (K) { r1 = k[i] * (dfs(i+1, j, 0) + dis[d[i]][c[i+1]]) + (1.0 - k[i]) * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]); if (j \u0026gt; 0) r2 = k[i] * (k[i+1] * (dfs(i+1, j-1, 1) + dis[d[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[d[i]][c[i+1]])) + (1.0 - k[i]) * (k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]])); } else { r1 = 1.0 * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]); if (j \u0026gt; 0) r2 = k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]]); } return dp[i][j][K] = min(r1, r2); } int main() { scanf(\u0026quot;%d%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;v,\u0026amp;e); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;c[i]); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;d[i]); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%lf\u0026quot;, \u0026amp;k[i]); for (int i = 1; i \u0026lt;= e; i++) { int u,v,w; scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;u,\u0026amp;v,\u0026amp;w); if (adj[u][v]) { if (adj[u][v] \u0026gt; w) adj[u][v] = adj[v][u] = w; } else adj[u][v] = adj[v][u] = w; } memset(dis, 0x3f3f3f3f, sizeof(dis)); for (int i = 1; i \u0026lt;= v; i++) { for (int j = 1; j \u0026lt;= v; j++) { if (adj[i][j]) dis[i][j] = dis[j][i] = adj[i][j]; } } for (int i = 1; i \u0026lt;= v; i++) dis[i][i] = 0; for (int k = 1; k \u0026lt;= v; k++) { for (int i = 1; i \u0026lt;= v; i++) { for (int j = 1; j \u0026lt;= v; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[i][j][0] = dp[i][j][1] = -1; } } double ans1 = 1.0 * dfs(1, m, 0), ans2 = 1e18; if (m \u0026gt; 0) { ans2 = 1.0 * dfs(1, m-1, 1); } double ans = min(ans1, ans2); printf(\u0026quot;%.2lf\\n\u0026quot;, ans); }   例2 洛谷P3830 [SHOI2012]随机树 题意\n给定一棵二叉树，初始状态下只有根节点。每次操作会在所有叶子节点中，等概率选择一个，给它添加左右两个child。\n给定正整数 $n$，求：对于由此生成的含有 $n$ 个叶子节点的二叉树，输出 叶子结点深度 的期望值，和 树深度 的期望值。\n其中，$n \\leq 100$，根节点的深度为 $0$。\n 题解 先考虑一下 叶子结点深度 的期望值。\n每次扩展一个叶子，设其原深度为 $x$，相当于总深度增加了 $2(x+1) - x = x+2$。\n所以设，对于 $n$ 个叶子的树，平均叶子深度若为 $f_n$，则总深度为 $f_n * n$。\n所以在这个树中选择一个叶子展开，平均叶子增加深度为 $f_n + 2$。\n所以 $f_{n+1} = \\frac{(f_n * n + f_n + 2)}{n+1} = f_n + \\frac{2}{n+1}$。\n 然后看第二问，树深度 的期望值。\n在做到这里的时候我的想法出现了一些偏差：我一直在考虑如何将 叶子数为 $(n-1)$ 的状态转移到 叶子数为 $n$ 的状态。\n但是实际做法是一个很神奇的想法：\n 使用 左，右子树 进行转移。\n 设 $dp[i][j]$ 为：有 $i$ 个叶子节点，深度 $\\geq j$ 的概率，枚举 左子树 叶子节点数量 $k$，有以下转移：\n$$dp[i][j] = \\frac{\\sum\\limits_{k=1}^{i-1}dp[k][j-1] + dp[i-k][j-1] - dp[k][j-1] * dp[i-k][j-1]}{i-1}$$\n什么意思呢？我们先看分子：\n显然对于根节点来说，它左右子树必然不为空，所以转移的时候 $k=1$ 开始，到 $(i-1)$，能转移的状态是深度为 $j-1$ 的，所以都加上。\n但是因为两边深度均为 $j-1$ 算重了，所以用容斥减去重复的部分 $dp[k][j-1] * dp[i-k][j-1]$。\n分子 $(i-1)$ 是哪里来的呢？因为考虑到期望的定义是 值 乘上 概率 之和。对于 $k$ 不同的情况，有不同的概率。\n但是我们可以得出结论，每一种概率都是相同的。\n意思就是：对于一棵 $n$ 个叶子节点的树，左子树拥有的叶子节点数量为 $1,2,\u0026hellip;,n-1$，发生的概率均相同。\n 证明：用数学归纳法即可。\n首先可以得到对于 $n=2$ 是相同的。\n我们设 $p[i][j]$ 为：叶子节点数为 $i$ 的树中，左子树有 $j$ 个叶子节点的概率。\n则 $p[i][j] = p[i-1][j-1] * \\frac{j-1}{i-1} + p[i-1][j] * \\frac{(i-1)-j}{i-1}$\n由数学归纳法，设对于 $(i-1)$ 而言，$\\forall j \\in [1,i-2], p[i-1][j] = \\frac{1}{i-2}$。\n则 $p[i][j] = \\frac{1}{i-2} * \\frac{j-1}{i-1} + \\frac{1}{i-2} * \\frac{(i-1)-j}{i-1} = \\frac{1}{i-1}$，与 $j$ 无关。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int q,n; double dp[102][102]; // dp[i][j]: 对于第i步，深度为j的期望叶子节点期望个数 int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;q,\u0026amp;n); double ans = 0.0; if (q == 1) { dp[1][0] = 1.0; // 第 i 步有 2i-1 个节点, 有 i 个叶子节点 for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 0; j \u0026lt;= i-1; j++) { double p = dp[i][j] / (i); dp[i+1][j+1] += p * 2.0; dp[i+1][j] -= p * 1.0; } for (int j = 0; j \u0026lt;= i-1; j++) dp[i+1][j] += dp[i][j]; } for (int j = 0; j \u0026lt;= n; j++) ans += dp[n][j] * j; printf(\u0026quot;%.6f\\n\u0026quot;, ans/(n)); } else { for (int i = 0; i \u0026lt;= n; i++) dp[i][0] = 1.0; dp[0][0] = 1.0; dp[1][0] = 1.0; dp[2][0] = dp[2][1] = 1.0; for (int i = 3; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt; i; j++) { for (int k = 1; k \u0026lt;= i-1; k++) { dp[i][j] += dp[k][j-1] + dp[i-k][j-1] - dp[k][j-1] * dp[i-k][j-1]; } dp[i][j] /= (i-1); } } for (int j = n-1; j \u0026gt;= 0; j--) { double p = - dp[n][j+1] + dp[n][j]; ans += (p * j); } printf(\u0026quot;%.6f\\n\u0026quot;, ans); } }   例3 洛谷 P2221 [HAOI2012]高速公路 题意\n一条线上有 $n$ 个收费站，从第 $i$ 个到第 $(i+1)$ 个收费站之间有一条路，通过一条路需要交费。初始状态下，每条路的费用为 $0$。\n给定 $m$ 个询问，每个询问为两种之一：\n$C ~ l ~ r ~ v$：将第 $l$ 到第 $r$ 个收费站之间的所有道路费用增加 $v$。\n$Q ~ l ~ r$：回答在第 $l$ 到第 $r$ 个收费站之间，等概率选择两个不同的收费站 $a,b$，从 $a$ 行驶到 $b$ 的期望费用？\n其中，$1 \\leq n,m \\leq 10^5, -10^4 \\leq v \\leq 10^4$，在任何时间段，任何一条道路的费用绝对值不超过 $10^4$。\n 题解 线段树。首先把收费站转成道路，就对于所有的 $l,r$，都改成 $l,r-1$。对于线段树，从 $1$ 和 $n-1$ 之间build。\n计算期望的时候，可以知道分母是 $C_{r-l}^2$。分子是从 $l,r$ 之间所有的选择之和。\n现在问题是：如何求出一个区间内，所有可能的 $l,r$ 组合的区间和的和？\n数学表达：对于区间 $[L,R]$，求\n$$\\sum\\limits_{i=L}^R\\sum\\limits_{j=i}^R sum(arr[i\u0026hellip;j])$$\n 直接从线段树的角度来考虑：一个区间的 $\\sum\\limits_{i=l}^r\\sum\\limits_{j=i}^r sum(arr[i\u0026hellip;j])$，能否用左右区间的这个信息来维护？\n可以的，注意到：对于一个区间 $[L,R]$ 来说，所有 $l,r$ 的组合可以分为三种：\n $l,r \\in [L, mid]$ $l,r \\in [mid+1, R]$ $l \\in [L, mid], r \\in [mid+1, R]$  前两种已经被子区间用到了，只要考虑第三种情况即可。\n所以问题就转化成：\n对于一个区间 $[L,R]$，求\n$$\\sum\\limits_{i=L}^{mid}\\sum\\limits_{j=mid+1}^R sum(arr[i\u0026hellip;j])$$\n 对于这个问题，我们可以固定 $l,r$ 其中之一。\n比如我们固定 $l=mid$，那么 $r$ 会从 $mid+1$ 一直iterate到 $R$，得到的 sum 就是：\n$$sum(arr[mid\u0026hellip;mid+1]) + sum(arr[mid\u0026hellip;mid+2]) + \u0026hellip; + sum(arr[mid\u0026hellip;R])$$\n把它从 $mid$ 的位置拆开来，就等于：\n$$(R-mid) * arr[mid] + sum(arr[mid+1\u0026hellip;mid+1]) + sum(arr[mid+1\u0026hellip;mid+2]) + sum(arr[mid+1\u0026hellip;R])$$\n$$=(R-mid) * arr[mid] + \\sum\\limits_{l=mid+1}^R sum(arr[l\u0026hellip;R])$$\n发现：$\\sum\\limits_{l=mid+1}^R sum(arr[l\u0026hellip;R])$ 是可以用线段树来维护的。\n 所以最后，我们维护几个值：\n 一个区间的 $sum$ 一个区间的 $lsum$：指 $\\sum\\limits_{r=L}^R sum(arr[L\u0026hellip;r])$ 一个区间的 $rsum$：指 $\\sum\\limits_{l=R}^L sum(arr[l\u0026hellip;R])$ 一个区间的 $allsum$：指所求，即 $\\sum\\limits_{i=L}^{mid}\\sum\\limits_{j=mid+1}^R sum(arr[i\u0026hellip;j])$  转移方程见代码。\n • 注意到在线段树 $query$ 的过程中，合并的时候仍然要用转移方程，而不能直接用左右的 $allsum$ 的和。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } ll cnt[maxn]; ll n,m; char op; struct node { ll lsum, rsum, sum, allsum; ll lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; ll C(ll a) { return a * (a+1) / 2LL; } void push_down(ll cur, ll L, ll R) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; tr[cur].lazy = 0; ll mid = (L+R) \u0026gt;\u0026gt; 1; ll l = cur\u0026lt;\u0026lt;1, r = l+1; tr[l].lazy += lazy, tr[r].lazy += lazy; ll llen = (mid - L + 1), rlen = (R - mid); tr[l].sum += llen * lazy; tr[r].sum += rlen * lazy; tr[l].lsum += C(llen) * lazy; tr[r].lsum += C(rlen) * lazy; tr[l].rsum += C(llen) * lazy; tr[r].rsum += C(rlen) * lazy; tr[l].allsum += cnt[llen] * lazy; tr[r].allsum += cnt[rlen] * lazy; } void push_up(ll cur, ll L, ll R) { ll l = cur\u0026lt;\u0026lt;1, r = l+1; ll mid = (L+R) \u0026gt;\u0026gt; 1; ll llen = (mid - L + 1), rlen = (R - mid); tr[cur].sum = tr[l].sum + tr[r].sum; tr[cur].lsum = tr[l].lsum + tr[r].lsum + rlen * tr[l].sum; tr[cur].rsum = tr[l].rsum + tr[r].rsum + llen * tr[r].sum; tr[cur].allsum = tr[l].rsum * rlen + tr[r].lsum * llen + tr[l].allsum + tr[r].allsum; } void update(ll cur, ll l, ll r, ll L, ll R, ll val) { ll len = (r-l+1); if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].lazy += val; tr[cur].sum += len * val; tr[cur].lsum += C(len) * val; tr[cur].rsum += C(len) * val; tr[cur].allsum += cnt[len] * val; return; } ll mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur, l, r); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, val); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val); push_up(cur, l, r); } node query(ll cur, ll l, ll r, ll L, ll R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur]; } push_down(cur, l, r); ll mid = (l+r) \u0026gt;\u0026gt; 1; node lnode {}, rnode {}, curnode {}; ll llen = max(mid - max(L, l) + 1, 0), rlen = max(min(R, r) - mid, 0); if (L \u0026lt;= mid) lnode = query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) rnode = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); curnode.sum = lnode.sum + rnode.sum; curnode.lsum = lnode.lsum + rnode.lsum + rlen * lnode.sum; curnode.rsum = lnode.rsum + rnode.rsum + llen * rnode.sum; curnode.allsum = lnode.allsum + rnode.allsum + lnode.rsum * rlen + rnode.lsum * llen; push_up(cur, l, r); return curnode; } void init() { cnt[1] = 1; cnt[2] = 4; for (ll i = 3; i \u0026lt;= maxn-5; i++) { ll mid = (1+i) \u0026gt;\u0026gt; 1; ll j = mid, k = i-mid; cnt[i] = cnt[j] + cnt[k] + C(j) * k + C(k) * j; } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; init(); n--; while (m--) { cin \u0026gt;\u0026gt; op; if (op == 'C') { ll l,r,v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; r--; update(1, 1, n, l, r, v); } else { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; r--; ll res = query(1, 1, n, l, r).allsum; int flag = 1; if (res \u0026lt; 0) flag = -1; res = abs(res); ll d = C(r-l+1); ll g = gcd(res,d); res /= g; d /= g; if (flag \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026quot;-\u0026quot;; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;/\u0026quot; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例4 CF850F Rainbow Balls 题意\n有一个袋子，袋子中有 $n$ 种颜色的球，第 $i$ 种颜色的球有 $a_i$ 个。\n现在持续进行以下操作：\n有顺序地随机取出两个球，把第二个球涂成第一个球的颜色，然后把两个球都放回袋子。\n求操作次数的期望，使得所有球的颜色相同？\n• 可以证明最终答案为 $\\frac{P}{Q}$ 的形式，输出 $P \\times Q^{-1}$ 在 $\\mod (10^9+7)$ 下的值。\n其中，$n \\leq 2500, 1 \\leq a_i \\leq 10^5$。\n 题解 一个比较明显的想法是：先决定最终的颜色。\n在决定好最终颜色（比如红色）后，其他颜色都可以看作同一种颜色（非红色）。\n在问题变成 红色/非红色 之后，可以发现使用 DP 可以表示递推状态。\n并且 DP 的状态仅与 红色球 的数量有关。\n 令 $s = \\sum\\limits_{i=1}^na_i$ （表示总球数）。\n令 $f_i$ 为：现在有 $i$ 个红色球，把所有球都变成 红色 的期望操作次数。\n首先可以知道，$f_s = 0$，且 $f_0$ 不存在。\n 然后考虑转移方程：\n对于 $f_i$ 来说，有 $i$ 个红色球，$(s-i)$ 个非红色球。\n那么随机取两个球，能对状态产生影响的就两种情况：\n 红 + 非红 -\u0026gt; 红色球数 加 $1$ 非红 + 红 -\u0026gt; 红色球数 减 $1$  这两种情况的样本大小均为 $i(s-i)$，而总样本空间的大小为 $s(s-1)$。\n所以，令 $$p_i = \\frac{i(s-i)}{s(s-1)}$$\n则从 $f_i$ 转移到 $f_{i-1}, f_{i+1}$ 的概率均为 $p_i$，而什么都没发生（转移回 $f_i$）的概率为 $(1-2p_i)$。\n 如此，我们可以列出方程：\n$$f_i = p_if_{i-1} + p_if_{i+1} + (1-2p_i)f_i + v$$\n$v$ 是什么？\n注意到转移时，也是会消耗 $1$ 次操作的。\n• 但是注意，$v$ 不等于 $1$！\n这是因为 $f_i$ 的意义是：最终颜色为红色 的情况下的操作期望值。\n所以 $v$ 应该等于 这一次操作 被分到 最终颜色为红色 情况下的 贡献（对于期望值的贡献）。\n相当于把 $1$ 次操作拆成很多份，每一份分别贡献给了每一种最终颜色对应的期望。\n 结论：$v = \\frac{i}{s}$\n证明：从字面上理解来看，$v$ 的值代表了在有 $i$ 个红色球的情况下，最终颜色为红色的概率。\n所以我们求出这个概率即可。\n设 $g_i$ 为：有 $i$ 个红色球的情况下，最终颜色为红色的概率。\n易知 $g_0 = 0, g_s = 1$。\n并且同上转移方程，可得方程：\n$$g_i = p_ig_{i-1} + p_ig_{i+1} + (1-2p_i)g_i$$\n即 $2g_i = g_{i-1} + g_{i+1}$，也就是 $g_{i+1} - g_i = g_i - g_{i-1}$，等差数列。\n所以 $g_i = \\frac{i}{s}$，证毕。\n 所以我们最终的方程就有了：\n$$f_i = p_if_{i-1} + p_if_{i+1} + (1-2p_i)f_i + \\frac{i}{s}$$\n化简一下可得：\n$$2f_i = f_{i-1} + f_{i+1} + \\frac{s-1}{s-i}$$\n其中，$f_s = 0, f_0$ 不存在。\n处理不存在的值 $f_0$，我们不能把它当成 $\\inf$，只能把其当成 $0$。\n所以代入 $i=1$，有 $f_2 = 2f_1 - 1$。\n$i$ 的有效值为 $i \\in [1,s-1]$，未知量为 $f_1, f_2, \u0026hellip;, f_{s-1}$，总共有 $(s-1)$ 个方程 和 $(s-1)$ 个未知量，发现是可以解出来的。\n但是问题在于 $s$ 的范围高达 $2500 * 10^5$，不能直接用高斯消元来解。\n所以只能手推式子了，联立 $(s-1)$ 个方程后，可以手推得出\n$$f_1 = \\frac{(s-1)^2}{s}$$\n剩下的 $f_2, \u0026hellip;, f_{s-1}$ 也可以得出了。\n枚举所有最终颜色的情况，最终的答案就为 $ans = \\sum\\limits_i{f_{a_i}}$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 2505; const int maxm = 1e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = (res * a) % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } int n; ll arr[maxn], s = 0; ll f[maxm]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], s += arr[i]; f[1] = (s-1) * (s-1) % mod * inv(s) % mod; // f1 = (s-1)^2 / s f[2] = (2 * f[1] % mod - 1 + mod) % mod; // f2 = 2f1 - 1 for (int i = 3; i \u0026lt;= maxm-5; i++) { f[i] = (2 * f[i-1] % mod - f[i-2] - (s-1) * inv(s-(i-1)) % mod + 2LL * mod) % mod; // f_k = 2f_{k-1} - f_{k-2} - (s-1)/(s-k+1) } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += f[arr[i]], ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-07-27T17:57:28+08:00","permalink":"https://tom0727.github.io/post/048-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/","tags":["概率","期望","数学"],"title":"概率期望"},{"categories":null,"contents":"","date":"2021-06-09T12:19:07+08:00","permalink":"https://tom0727.github.io/cf-problems/","tags":null,"title":"CF Problems"},{"categories":["算法"],"contents":"介绍 网络 是一个有向图 $G = (V,E)$，每条边 $(u,v) \\in E$ 都拥有一个容量 $c(u,v)$。\n在一个网络中，拥有两个特殊的节点 $s, t$ （源点，汇点）。\n定义 流 为一个函数 $f(u,v)$，其中 $u,v \\in V$，满足：\n 容量限制：每条边的流不能超过这条边的容量，即 $f(u,v) \\leq c(u,v)$。 斜对称性：每条边的流量，与其相反边的流量，互为相反数，即 $f(u,v) = -f(v,u)$。 流守恒性：从源点 $s$ 流出的流量，等于汇点 $v$ 流入的流量。同时对于每个点 $u$（除了 $s,t$），流入 $u$ 的流量需要等于 流出 $u$ 的流量。  定义 残量网络 为：对于一个流函数 $f$，残量网络 $G_f$ 是网络 $G$ 中 所有的节点 和 剩余容量 $\u0026gt; 0$ 的边 组成的子图。\n残量网络中，可能存在 原图中不存在的边（一条边剩余流量，产生的反向边，也能算入残量网络）。\n 网络流的三种问题类型：最大流，最小割，费用流。\n最大流 定义一个网络的流量为：汇入 $t$ 的流量之和。\n最大流就是求：从 $s$ 流到 $t$ 的最大流量。\n最小割 如果我们要从原图中，切掉一个 边集 $E\u0026rsquo; \\subseteq E$，使得 $s,t$ 无法联通。\n让这个边集的容量和 最小，就是最小割。\n• 在数值上，最小割 等于 最大流，如果要求出具体是哪些边，可以看残量网络。\n费用流 每一条边 $(u,v)$ 都有一个费用 $w(u,v)$，每当有 $1$ 个单位的流量流过这条边，就要付出 $w(u,v)$ 的代价。\n在 保证最大流 的基础上，求出 最小/最大费用，就是 费用流。\n 算法 定义 增广路 为：残量网络中，一条从 $s$ 到 $t$ 的路径。\n如果我们要求最大流，那么 当前的流是最大流 $\\iff$ 残量网络 $G_f$ 中不存在增广路（即，残量网络中 $s,t$ 不相连）。\nEK算法 $EK$ 算法的思想就是：每一轮增广，都用 BFS 在 残量网络 上找到一个增广路，然后根据这个路径上，最小 的剩余流量，来流过这条路径。然后更新残量网络，直到残量网络中不存在增广路。\n由于实践中一般不用，所以就不多赘述。\nDinic算法 思想与 EK 算法相同，在每一轮增广时，按照以下顺序进行操作：\n 从源点 $s$ 开始进行 BFS，获得一张分层图。 利用 DFS 进行增广，增广过程中保证一定是从 第 $x$ 层增广到 第 $(x+1)$ 层。利用 DFS 增广的好处是可以多路增广，在一条路径增广完毕，回溯的时候可以寻找下一条。  Dinic 算法有几个重要的优化：\n 删点：在一个点 $u$ 尝试向外流的时候，如果成功流出的流量为 $0$，说明这个点 $u$ 已经无法向 $t$ 推送流量了，我们将这个点的 dis[u] = -1。意思为删除这个点。 当前弧优化：在 DFS 过程中，如果我们推完了一条边，然后回溯了，这说明，要么 走这条边已经无法连通到 $t$了，要么 入流量用完了。无论是哪一种，都说明我们无法再使用这条边了。所以就在本轮增广中，删去这条边。在代码中，使用 cur[] 数组来实现。  复杂度：$O(n^2m)$，在实际使用中，一般跑的比这个快（所以不用太担心复杂度问题）。\n费用流 在 Dinic 的基础上，把 BFS求分层图 的过程，改成 SPFA求最短路 即可。然后在增广的过程中，只走最短路径。\n同时，如果有费用为 $0$ 的边，使得这条边，及其反向边的费用均为 $0$，这可能会导致算法的最短路一直在这两个节点之间走。为了防止这个问题导致死循环，我们需要一个 vis[] 数组保证在 DFS 过程中每个点只被访问一次。\n复杂度：$O(n^2m^2)$，在实际使用中，一般跑的比这个快（所以不用太担心复杂度问题）。\n 模版 最大流模版 int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add(u, v, w); } cout \u0026lt;\u0026lt; maxflow() \u0026lt;\u0026lt; endl; }   费用流模版 int n,m,s,t; struct Edge { int to, nxt; ll w, c; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost = true) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll cost = 0; ll mcmf() { ll maxflow = 0; while (spfa()) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w,c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; c; add(u,v,w,c); } ll maxflow = mcmf(); cout \u0026lt;\u0026lt; maxflow \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; endl; }   套路 二元决策（最小割模型） 有一类问题：有 $n$ 个元素，每个元素要么放入集合 $A$，要么放入集合 $B$，放入集合 $A,B$ 会产生不同的收益，同时可能还会有 相邻 的元素 / 特定的一些元素组合 在同一个集合/不同集合中，就产生额外的收益。求最大/最小的收益。\n一般套路为：对于每个元素 $u$，连 $(s,u), (u,t)$ 的边。\n例如我们用 $s$ 表示集合 $A$，用 $t$ 表示 $B$。哪条边 被保留下来了，就代表选择了这个元素 $u$ 被放入了哪个集合。\n在最小割中，要么 $(s,u)$ 被割掉，要么 $(u,t)$ 被割掉，这说明每个元素最终只会被放入其中的一个集合。\n 对于 特定元素组合 产生的额外收益，举个例子：\n比如 $u,v$ 都放入集合 $A$ (与 $s$ 相连) 就会产生额外收益 $k$ 的话。就创造一个额外的节点 $x$，连接有向边 $(x,u), (x,v), (s,x)$，其中令 $(x,u), (x,v)$ 的流量为 $inf$，而令 $(s,x)$ 的流量为 $k$。\n解释：流量为 $inf$ 的边代表在最小割中一定不会被割去，而如果 $u,v$ 之间，有任何一个元素 没有被放入集合 $A$，那么它就一定会与 $t$ 相连，此时，为了保证图不联通，在最小割中，就一定会割掉 $(s,x)$ 这条边，所以就损失了 $k$ 的收益。\n区间覆盖模型（不等式模型） 给定多种区间，每种区间可以使用一定次数，每次使用有一个代价 cost，在一条直线上，有一些点我们需要覆盖多次。求最小的 cost 使得这些覆盖条件被满足？\n我们以直线上，每个点作为一个节点。\n对于一个区间 $[a,b]$，使用次数限制为 $w$，代价为 $c$。\n则：由 $a$ 对应的节点 $u$，连一条边到 $b$ 对应的节点 $v$，容量为 $w$（代表这个区间可以被选择 $w$ 次），代价为 $c$。\n 怎么满足/限制 直线上每个点，被覆盖的次数呢？\n直觉上说，由每个节点连边到 $t$。但是这样不对，因为这里的区间是 强制覆盖 $[a,b]$，并不能覆盖一半的。\n 正确的方法是：将所有的点，连边连成一条直线。相当于，原本直线上每个点对应一个节点，现在我们把这些节点按照它们原来的方式连边。\n如果第 $i$ 个点，需要被覆盖 $a_i$ 次，那么就连一条边 $(i,i+1,-a_i,0)$（流量为负数，实现中，可以使用 $inf - a_i$ 来代替），代表这里少了 $a_i$ 个点。\n如何保证这些点一定被覆盖了呢？用最大流来限制即可。\n由 $s$ 向 $1$ 连接容量为 $inf$ 的边，cost 为 0；由 $n$ 向 $t$ 连接容量为 $inf$ 的边，cost 为 0。\n费用流保证最大流的过程中，就会保证每个点被覆盖了相应的次数。\n 网络流例题 例1 洛谷P4016 负载平衡问题 题意\n有 $n$ 个环形排列的仓库，给定每个仓库初始的储存量 $a_i$。\n我们只能在相邻的仓库之间搬运。\n求最少的搬运量，使得 $n$ 个仓库的库存数量相同。（保证储存量的平均数是一个整数）。\n其中，$1 \\leq n \\leq 100$。\n 题解（贪心） 正解实际上是 $O(n\\log n)$ 的贪心，一个标准的均分纸牌问题。（加强版的在这：洛谷P2512 HAOI2008 糖果传递）。\n设第 $i$ 个人 向右传递 了 $x_i$。注意到这里 $x_i$ 可正可负可零。\n则目标是求 $\\min \\{ |x_1| + |x_2| + \u0026hellip; + |x_n|\\}$。\n因为最后每个人都获得了 $a$（$a$ 就是平均数）。\n则有：$a_1 + x_1 - x_2 = a, a_2 + x_2 - x_3 = a$，以此类推。\n进行代换，可得：\n$$x_2 = x_1 - (a-a_1)$$ $$x_3 = x_1 - (2a-a_1-a_2)$$ $$x_4 = x_1 - (3a-a_1-a_2-a_3)$$ $$\u0026hellip;$$ $$x_n = x_1 - ((n-1)a - a_1 - a_2 - \u0026hellip; - a_{n-1})$$\n所以就只剩下一个变量 $x_1$ 了。\n因为 $x_1$ 的值可以随便选，由上面的表达式可以看出，这相当于在一个直线上，有 $n$ 个点，坐标为：\n$$0,(a-a_1 ),(2a-a_1-a_2 ),(3a-a_1-a_2-a_3 ),…,((n-1)a-a_1-a_2-…-a_{n-1} )$$\n选择直线上一个点，使得它到这 $n$ 个点距离之和最短？很明显，选这些点的中位数即可。\n 题解（网络流） 需要最小化搬运数量。很明显是一个费用流。\n 网络流的常见套路 $1$：创建超级源点 $s$ 和 超级汇点 $t$。\n 对于相邻的节点，我们链接一个双向的边，费用为 $1$，容量无限。\n同时创建超级源点 $s$，超级汇点 $t$，使得：\n$s$ 向每个节点 $i$ 连接一个 费用为 $0$，容量等于 $a_i$ 的边。\n每个节点 $i$ 向汇点 $t$ 连接一个 费用为 $0$，容量等于 $avg$（储存量的平均数）的边。\n答案就是最小费用。\n 网络流代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 105; const int maxm = 5e4+5; int n, s, t, mincost = 0; int arr[maxn]; struct Edge { int to, nxt, w, c; } edges[maxn\u0026lt;\u0026lt;4]; int head[maxn], ecnt = 2, cur[maxn]; void addEdge(int u, int v, int w, int c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } bool inq[maxn]; int dis[maxn]; bool spfa() { fill(dis, dis+maxn, 1e9); memset(inq, 0, sizeof(inq)); memcpy(cur, head, sizeof(head)); queue\u0026lt;int\u0026gt; q; q.push(s); dis[s] = 0; inq[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w, c = edges[e].c; if (w == 0) continue; if (dis[u] + c \u0026lt; dis[to]) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != 1e9; } bool vis[maxn]; int dfs(int u, int in) { if (u == t) return in; vis[u] = 1; int out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to, w = edges[e].w, c = edges[e].c; if (w == 0 || vis[to] || dis[u] + c != dis[to]) continue; int res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e9; return out; } int mcmf() { int maxflow = 0; while (spfa()) { memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis int res = dfs(s, 1e9); maxflow += res; mincost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } int main() { fastio; cin \u0026gt;\u0026gt; n; int sum = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; sum /= n; s = n+1, t = n+2; for (int i = 1; i \u0026lt;= n; i++) { addEdge(s, i, arr[i], 0); addEdge(i, s, 0, 0); addEdge(i, t, sum, 0); addEdge(t, i, 0, 0); if (i != n) { addEdge(i, i+1, 1e9, 1); addEdge(i+1, i, 0, -1); addEdge(i+1, i, 1e9, 1); addEdge(i, i+1, 0, -1); } } addEdge(n, 1, 1e9, 1); addEdge(1, n, 0, -1); addEdge(1, n, 1e9, 1); addEdge(n, 1, 0, -1); mcmf(); cout \u0026lt;\u0026lt; mincost \u0026lt;\u0026lt; endl; }   例2 洛谷P2774 方格取数问题 题意\n给定一个 $n \\times m$ 的方格图，每个方格中有一个正整数。\n要从方格中取数，使任意两个数所在方格没有公共边，求取出的数的最大和。\n其中，$n,m \\leq 100$。\n 题解 首先这题的限制条件是 不能相邻。对于一个方格来说，只有相邻的（最多4个）方格不能被选。\n所以我们应该从 禁止选择 的角度考虑这个问题，也就是说，应该先选择所有的方格，然后删掉那些互斥的部分。\n如果进行建图：每个方格都是一个 点，然后按照互斥条件进行 连边。\n可以发现，如果我们把这个方格图进行 二分图染色，一定有一个合理的方案。保证相邻的方格颜色不同即可。\n如果对方格图进行染色，建图后，就可以得到一张 二分图。\n 二分图有什么用呢？\n我们最终的目标是使得 整张图中不存在互斥情况，并且 使得删掉的那些方格权值和最小。\n那么我们建立超级源点 $s$，汇点 $t$，然后将 $s$ 连向所有的左侧点（容量为对应点的权值），所有的右侧点连向 $t$（容量为对应点的权值），我们可以发现：\n $s \\rightarrow u$ 代表节点 $u$ 被选择了。 $v \\rightarrow t$ 代表节点 $v$ 被选择了。 如果整张图是 连通的，说明仍然存在互斥情况。  所以我们要 使得删掉的那些方格权值和最小，只要保证删掉的边的权值和最小，使得整张图不连通即可。\n求这张图的 最小割 即可。答案就是 所有权值的和 减去 最小割。\n 总结一下这题：\n 互斥的点 的颜色一定不同，使得我们可以转化为 二分图模型。 互斥的点之间连边，代表了互斥关系。 图的连通性代表了是否消除了所有的互斥条件。   参考链接：https://www.luogu.com.cn/problem/solution/P2774\n另外一道几乎一样的例题是 骑士共存问题。\n题意大概是在一个 $n \\times n$ 的棋盘上，有些格子不能放，问最多能放几个马，使得它们互相不会攻击。\n我们会发现按照 横坐标 $x$ 和 纵坐标 $y$ 之和 $(x+y)$ 的奇偶性进行染色分类，仍然是个二分图，剩下的就和本题一样了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 4e4+5; int vid[102][102], color[maxn]; ll val[102][102]; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } int delta[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int id = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; val[i][j]; vid[i][j] = ++id; if ((i+j) \u0026amp; 1) color[id] = 1; else color[id] = 0; } } s = n*m+1, t = n*m+2; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { int ID = vid[i][j]; ans += val[i][j]; if (color[ID] == 1) { add(s, ID, val[i][j]); for (int d = 0; d \u0026lt; 4; d++) { int di = delta[d][0] + i, dj = delta[d][1] + j; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= m) { add(ID, vid[di][dj], 1e18); } } } else { add(ID, t, val[i][j]); } } } while (bfs()) { ans -= dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P1251 餐巾计划问题 题意\n总共有 $N$ 天，第 $i$ 天需要 $r_i$ 个干净的餐巾。每天结束时，餐厅需要决定如何处理脏餐巾，有以下几个选项：\n 不处理，留到之后再洗。 送去快洗部，洗一块需要 $m$ 天，费用为 $f$ 元。 送去慢洗部，洗一块需要 $n$ 天，费用为 $s$ 元。  同样，餐厅在每天开始/结束时，可以选择购买新的餐巾，每块新餐巾的费用为 $p$ 元。\n求出最少花费，使得每天需要的餐巾数满足要求，初始情况下，餐巾数为 $0$。\n其中，$N \\leq 2000$。\n 题解  网络流的常见套路 $2$：拆点\n 一个比较明显的费用流思路：\n将每一天看作一个节点，然后每个节点拆成 $2$ 个，分别表示 干净餐巾 和 脏餐巾。\n换个角度来看，就是将每个节点拆成了 每天的开始（需要提供干净餐巾） 和 每天的结束（产出了一些脏餐巾）。\n我们设：第 $i$ 天的节点分别为 $s_i, e_i$ （对应干净，脏）。\n那么对于脏餐巾的处理，我们可以这样连边：\n 不处理，留到之后再洗：从 $t_i$ 连边到 $t_{i+1}$，费用为 $0$，容量为 $\\inf$。 送到快洗部（洗一块需要 $m$ 天，费用为 $f$ 元）：从 $t_i$ 连边到 $s_{i+m}$，费用为 $f$，容量为 $\\inf$。 送去慢洗部（洗一块需要 $n$ 天，费用为 $s$ 元）：从 $t_i$ 连边到 $s_{i+n}$，费用为 $s$，容量为 $\\inf$。  剩下的问题是：购买新餐巾，每天需要提供 $r_i$ 个干净餐巾，每天需要让 $r_i$ 个干净餐巾变成脏的。\n购买新餐巾（一条 $P$ 元）：源点 $s$ 向每个 $i$ 对应的 $s_i$ 连一条边，费用为 $P$，容量为 $\\inf$。 每天需要提供 $r_i$ 个干净餐巾：从每个 $i$ 对应的 $s_i$ 向汇点 $t$ 连一条边，费用为 $0$，容量为 $r_i$。 每天需要让 $r_i$ 个干净餐巾变成脏的：源点 $s$ 向每个 $i$ 对应的 $t_i$ 连一条边，费用为 $0$，容量为 $r_i$。  • 这里重点讲一下 $5,6$：我们如何强制保证干净餐巾够用呢？\n注意到我们求的是最小费用 最大流。所以通过 限制流量 来保证干净餐巾的数量，也就是让每天的干净节点 $s_i$ 都流向汇点 $t$。\n但是如果干净餐巾流向了 $t$，就必须保证从 $s$ 开始有脏餐巾流向 $t_i$，才能保证流量守恒（不买餐巾的情况下，餐巾的总数守恒）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4005; const int maxm = 5e4+5; int n,s,t,arr[maxn]; struct Edge { int to, nxt; ll w, c; } edges[maxn\u0026lt;\u0026lt;4]; int head[maxn], ecnt = 2, cur[maxn]; void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } queue\u0026lt;int\u0026gt; q; ll dis[maxn]; bool inq[maxn]; bool spfa() { memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, 1e18); memcpy(cur, head, sizeof(head)); dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if (dis[u] + c \u0026lt; dis[to]) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != 1e18; } bool vis[maxn]; ll dfs(int u, ll in) { if (u == t) return in; vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0 || vis[to] || dis[to] != dis[u] + c) continue; ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll mincost = 0; ll mcmf() { ll maxflow = 0; while (spfa()) { memset(vis, 0, sizeof(vis)); ll res = dfs(s, 1e18); maxflow += res; mincost += res * dis[t]; } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } int main() { fastio; cin \u0026gt;\u0026gt; n; ll sum = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; ll P,M,F,N,S; cin \u0026gt;\u0026gt; P \u0026gt;\u0026gt; M \u0026gt;\u0026gt; F \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; s = 2*n + 1, t = 2*n+2; for (int i = 1; i \u0026lt;= n; i++) { add(s, i, 1e18, P); add(i, t, arr[i], 0); add(s, i+n, arr[i], 0); if (i != n) { add(i+n, i+n+1, 1e18, 0); } if (i + M \u0026lt;= n) { add(i+n, i+M, 1e18, F); } if (i + N \u0026lt;= n) { add(i+n, i+N, 1e18, S); } } ll ans = mcmf(); assert(ans == sum); cout \u0026lt;\u0026lt; mincost \u0026lt;\u0026lt; endl; }   例4 洛谷P2764 最小路径覆盖问题 题意\n给定一个 DAG（有向无环图），$n$ 个节点，$m$ 条边。\n定义一个路径覆盖为：由多个简单路径组成，覆盖了所有节点，并且每个节点被覆盖了仅一次，一条路径最短可以仅为一个节点。\n求这个 DAG 的最小路径覆盖（路径数量最小）。\n其中，$1 \\leq n \\leq 150, 1 \\leq m \\leq 6000$。\n 题解 我们考虑一下怎么让 路径数量 最小？\n初始状态下，令每一个节点本身都是一条路径，那么我们可以让路径合并，合并的方式就是 一个路径的尾部 和 另外一个路径的头部 连在一起。最后的总路径条数就等于 $n$ 减去合并的次数。\n而每个节点可以作为一个路径的头部，也可以作为一个路径的尾部，且每个节点在路径合并的过程中，最多只能成为一次头部/尾部。\n那我们就进行 拆点。\n将每个节点 $u$ 拆成 $2$ 种，一种是 尾部 $u_1$，一种是 头部 $u_2$。如果 $u \\rightarrow v$ 在 DAG 中是一条边，那么就在新图中，连一条 $u_1 \\rightarrow v_2$ 的边。\n可以发现，这个新图是一个二分图，其最大匹配就是合并路径的次数。\n所以答案就是 $n$ 减去最大匹配。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 155; const int maxm = 6e4+5; int n,m,head[maxn\u0026lt;\u0026lt;1], ecnt = 1, match[maxn\u0026lt;\u0026lt;1], vis[maxn\u0026lt;\u0026lt;1], visid = 0; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } bool dfs(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to] == visid) continue; vis[to] = visid; if (!match[to] || dfs(match[to])) { match[to] = u; return 1; } } return 0; } int from[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v+n); } int ans = n; for (int i = 1; i \u0026lt;= n; i++) { visid++; ans -= dfs(i); } // 处理答案 for (int i = n+1; i \u0026lt;= 2*n; i++) { if (match[i]) from[match[i]] = i-n; } for (int i = n+1; i \u0026lt;= 2*n; i++) { if (!match[i]) { int j = i-n; while (j) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot; \u0026quot;; j = from[j]; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 洛谷P2766 最长不下降子序列问题 题意\n给定一个正整数序列 $x_1, x_2, \u0026hellip;, x_n$。\n 计算最长不下降子序列（不需要连续）的长度 $len$。 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。 如果允许在取出的序列中多次使用 $x_1, x_n$，（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个 不同的 长度为 $s$ 的不下降子序列。  其中，$1 \\leq n \\leq 500$。\n 题解 第一个问题是标准的 $O(n^2)$ DP。\n第二问和第三问要用到网络流。\n我们如何得到一个合法的子序列？这里利用到了 分层图 思想。\n我们先求出，对于每一个 index $i$，以index $i$ 结尾的最长不下降子序列的长度，设其为 $f_i$。\n那么如果一个子序列合法，子序列中的每个元素 $f_{i_1}$，和它下一个元素 $f_{i_2}$ 的关系一定是 $f_{i_1} + 1 = f_{i_2}$。\n所以我们按照 $f_i$ 的值进行分层，只有 $f_i = x$ 的节点可以连向 $f_j = x+1$ 的节点。\n我们要求最长的子序列，那么就让源点 $s$ 连边到 $u$（$f_u = 1$）。让 $v$ 连边到 $t$（$f_v = len$）。求一个最大流就是答案了。\n 现在考虑第二问：每个元素只允许使用一次。我们发现之前的建图就已经足够了，跑最大流即可。\n第三问：$x_1, x_n$ 允许使用多次。我们可以通过控制 流量 来控制这个变量。\n 如何控制一个节点的入流量和出流量？拆点！\n 将每个节点 $u$ 拆成两个节点，分别代表入点 $u_{in}$ 和 出点 $u_{out}$。\n所有原先 进入 $u$ 的边，现在都改为 进入 $u_{in}$，所有原先 **离开** $u$ 的边，现在都改为 **离开** $u_{out}$。\n连一条边 $u_{in} \\rightarrow u_{out}$。这一条边的流量，就代表了这个节点 $u$ 被限制的入流量和出流量。\n 综上，第二问和第三问的模型都可以拆点，只不过第二问对于每一个节点 $u$，限制的流量均为 $1$。\n而第三问中，对于节点 $1,n$，不限制流量（即 $in, out$ 中间这条边的流量为 $\\inf$）。\n参考链接：https://oi-wiki.org/graph/node/\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; const int maxm = 2e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } int arr[maxn], dp[maxn], len = 0; void solve1() { if (len == 1) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return; } // subtask 1 for (int i = 1; i \u0026lt;= n; i++) { if (dp[i] == 1) add(s, i, 1e18); add(i, i+n, 1); if (dp[i] == len) add(i+n, t, 1e18); for (int j = i+1; j \u0026lt;= n; j++) { if (dp[j] == dp[i] + 1) add(i+n, j, 1); } } ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void solve2() { // subtask 2 if (len == 1) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return; } ecnt = 2; memset(head, 0, sizeof(head)); for (int i = 1; i \u0026lt;= n; i++) { if (dp[i] == 1) add(s, i, 1e18); if (i == 1 || i == n) add(i, i+n, 1e18); else add(i, i+n, 1); if (dp[i] == len) add(i+n, t, 1e18); for (int j = i+1; j \u0026lt;= n; j++) { if (arr[j] \u0026gt;= arr[i] \u0026amp;\u0026amp; dp[j] == dp[i] + 1) add(i+n, j, 1); } } ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void build() { for (int i = 1; i \u0026lt;= n; i++) { dp[i] = 1; for (int j = i-1; j \u0026gt;= 1; j--) { if (arr[j] \u0026lt;= arr[i]) { dp[i] = max(dp[i], dp[j] + 1); } } len = max(len, dp[i]); } cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; s = 2*n+1, t = 2*n+2; solve1(); solve2(); } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; build(); }   例6 洛谷P1646 Happiness 题意\n给定一个 $n \\times m$ 的座位表，每个同学要选择理科或者文科，每个人选择理科时，会获得喜悦值 $a_{ij}$，选择文科时会获得喜悦值 $b_{ij}$。\n位于 $(i,j)$ 的同学，如果和 $(i+1, j)$ 的同学同时选择了理科，会获得额外 $c_{ij}$ 的喜悦值，如果同时选择文科，会获得 $d_{ij}$ 的喜悦值。\n位于 $(i,j)$ 的同学，如果和 $(i, j+1)$ 的同学同时选择了理科，会获得额外 $e_{ij}$ 的喜悦值，如果同时选择文科，会获得 $f_{ij}$ 的喜悦值。\n求喜悦值的最大和。\n其中，$n,m \\leq 100$。\n 题解 最小割的二元选择模型。\n首先每个同学是一个节点 $u$，然后连接 $(s,u,a), (u,t,b)$。\n然后对于两个相邻的同学，创造一个新的节点 $x$，连接 $(s,x,c), (x,u,inf), (x,v,inf)$。（其中 $c$ 代表同时选择文科的额外喜悦值），再创造一个节点 $y$，连接 $(y,t,d), (u,y,inf), (v,y,inf)$\n上面已经解释过了，意思就是只要两个人中，任何一个人选了文，则 理理 的额外收益就没了（被割掉）。任何一个人选了理，则 文文 的额外收益就没了（被割掉）。由此建图即可。\n注意，我们计算的是 最小割，意思是 损失的最小收益，所以最终的答案（最大收益）应该是由 所有可能获得的收益 减去 最小割。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 7e4+5; const int maxm = 5e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int a[103][103], b[103][103]; int N = 0, id[103][103]; ll sum = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = 5*n*m+1, t = s+1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j], id[i][j] = ++N; add(s, N, a[i][j]); sum += a[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; b[i][j]; add(id[i][j], t, b[i][j]); sum += b[i][j]; } } for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 1; j \u0026lt;= m; j++) { int aa; cin \u0026gt;\u0026gt; aa; // 文文 add(s, ++N, aa); add(N, id[i][j], 1e9); add(N, id[i+1][j], 1e9); sum += aa; } } for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 1; j \u0026lt;= m; j++) { int bb; cin \u0026gt;\u0026gt; bb; // 理理 add(++N, t, bb); add(id[i][j], N, 1e9); add(id[i+1][j], N, 1e9); sum += bb; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m-1; j++) { int aa; cin \u0026gt;\u0026gt; aa; add(s, ++N, aa); add(N, id[i][j], 1e9); add(N, id[i][j+1], 1e9); sum += aa; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m-1; j++) { int bb; cin \u0026gt;\u0026gt; bb; // 理理 add(++N, t, bb); add(id[i][j], N, 1e9); add(id[i][j+1], N, 1e9); sum += bb; } } cout \u0026lt;\u0026lt; sum - maxflow() \u0026lt;\u0026lt; endl; }   例7 CF1404E Bricks 题意\n给定一个 $n \\times m$ 的网格，每个格子要么为黑，要么为白。\n定义一个 brick 为：一个长方形，要么长度为 $1$，宽度任意；要么宽度为 $1$，长度任意。\n我们需要用 brick 来覆盖所有的黑色格子，要求不能覆盖到白色格子上，并且一个黑格子只能被覆盖一次。\n求最少的 brick 数量？\n其中，$1 \\leq n,m \\leq 200$，保证至少有一个黑格子。\n 题解 一个 brick 可以横着摆，也可以纵着摆。\n所以，每个黑格子要么被一个 横brick 覆盖，要么被一个 纵brick 覆盖。\n如果被 横brick 覆盖，就相当于给这个格子填上 $1$。被 纵brick 覆盖就相当于给这个格子填上 $0$。\n我们会发现，如果在横方向上，有两个连续的 $1$，那么这两个格子就可以合并为一个（相当于只用了一个横brick就覆盖了它们两个），纵向同理。\n问题就转化为，怎么给每个格子填上 $0/1$，使得这种合并的发生次数最多。\n让合并的发生次数最多，实际上就和上一题一样了。就是定义两个相邻的格子，同时选0/1时，可以获得一些额外收益，这个收益就是合并次数。\n最终的答案就是 黑格子数量 减去 合并发生次数。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 7e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int grid[205][205], id[205][205], N = 0; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int sum = 0; for (int i = 1; i \u0026lt;= n; i++) { string ss; cin \u0026gt;\u0026gt; ss; for (int j = 1; j \u0026lt;= m; j++) { if (ss[j-1] == '#') grid[i][j] = 1, id[i][j] = ++N, sum++; } } int tmp = sum; s = N+1, t = s+1; for (int i = 1; i \u0026lt;= N; i++) { add(s, i, 1); add(i, t, 1); } N += 3; int delta[2][2] = {{1, 0}, {0, 1}}; int inf = 1e9; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (!id[i][j]) continue; for (int o = 0; o \u0026lt; 2; o++) { int di = delta[o][0] + i, dj = delta[o][1] + j; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= m \u0026amp;\u0026amp; id[di][dj]) { if (o == 0) { // 纵向 add(s, ++N, 1); add(N, id[i][j], inf); add(N, id[di][dj], inf); sum++; } else { // 横向 add(++N, t, 1); add(id[i][j], N, inf); add(id[di][dj], N, inf); sum++; } } } } } cout \u0026lt;\u0026lt; tmp - sum + maxflow() \u0026lt;\u0026lt; endl; }   例8 ABC193F Zebraness 题意\n给定 $n \\times n$ 的网格，每个格子要么为黑色，要么为白色，要么没有颜色。\n现在要将所有没有颜色的格子，涂上黑色或者白色。\n求最终情况下，相邻的不同色格子的最大数量。\n其中，$1 \\leq N \\leq 100$。\n 题解 看起来非常像最小割的二元模型，但是有一点不太一样的在于，这里是两个相邻的，不同颜色 的格子才能产生收益。而上面两道例题，都是 相同颜色 的格子才能产生收益。\n这样的话就没法建图了。\n但是我们可以把问题转化一下，成为 相同颜色 的格子才能产生收益。\n怎么做呢？\n把这些格子分为两类，一类是 $x,y$ 坐标加起来为奇数的，另外一类是 $x,y$ 坐标加起来为偶数的。我们把其中一类格子的颜色全部反过来（如果没有颜色就不用动它）。问题就转化成 相同颜色 的格子产生收益了。\n 但是，这题有一些格子是已经固定好颜色了的。假如一个格子已知为白色，那么就不连 $(u,t)$ 这条边即可。并且为了保证这个格子一定选择了白色，我们连 $(s,u,inf)$。\n对于黑色，就连 $(u,t,inf)$。\n对于没有颜色，就连 $(s,u,1), (u,t,1)$。\n然后相邻的格子仍然按照同色的套路来创建新点，连接容量为 $1$ 的边即可。\n 注意到本题，因为一个格子本身选择什么颜色并不提供价值。所以我们要把 总价值 中，通过选择单个格子获得的价值减掉。\n所以原本 一个黑/白 格子提供的价值为 $1$，现在则为 $0$。原本一个 无色 格子提供的价值为 $2$，现在则为 $1$。相邻格子同色带来的价值不变。\n最后用 总价值 减去 最小割 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 7e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int arr[102][102]; int vid[102][102], vidcnt = 0; int main() { fastio; cin \u0026gt;\u0026gt; n; int N = n*n; s = 5*N+1, t = 5*N+2; for (int i = 1; i \u0026lt;= n; i++) { string SS; cin \u0026gt;\u0026gt; SS; for (int j = 1; j \u0026lt;= n; j++) { if (SS[j-1] == 'W') arr[i][j] = 0; if (SS[j-1] == 'B') arr[i][j] = 1; if (SS[j-1] == '?') arr[i][j] = -1; if (((i+j)\u0026amp;1) \u0026amp;\u0026amp; arr[i][j] \u0026gt;= 0) arr[i][j] ^= 1; vid[i][j] = ++vidcnt; } } int delta[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; ll ans = 0; int inf = 1e9; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int id = vid[i][j]; if (arr[i][j] == 0) { add(s, id, inf); } if (arr[i][j] == 1) { add(id, t, inf); } if (arr[i][j] == -1) { add(s, id, 1), add(id, t, 1); ans++; } for (int o = 0; o \u0026lt; 2; o++) { int di = i + delta[o][0], dj = j + delta[o][1]; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= n) { int did = vid[di][dj]; add(s, ++vidcnt, 1); add(vidcnt, id, inf); add(vidcnt, did, inf); ans++; add(++vidcnt, t, 1); add(id, vidcnt, inf); add(did, vidcnt, inf); ans++; } } } } ans -= maxflow(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例9 [NOI2008] 志愿者招募 题意\n有 $n$ 天，每天需要 $a_i$ 个人。我们有 $m$ 种人可以招募，第 $i$ 种人会从 第 $s_i$ 天 工作到 第 $t_i$ 天，并且花费 $c_i$ 元。\n求最少费用的方案，满足每天工作的人数？\n其中 $1 \\leq n \\leq 1000, 1 \\leq m \\leq 10000$。\n 题解 区间覆盖模型，上面讲过了。\n连 $(s,1,inf,0), (n+1,t,inf,0)$，同时对于每一个 $i$，连 $(i,i+1,inf-a_i,0)$。\n对于每种工人，连 $(s_i, t_i + 1, inf, c_i)$。\n跑最小费用最大流即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 5e4+5; int n,m,s,t; struct Edge { int to, nxt; ll w, c; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost = true) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll cost = 0; ll mcmf() { ll maxflow = 0; while (spfa()) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = n+2, t = n+3; ll inf = 4e9; add(s, 1, inf, 0); for (int i = 1; i \u0026lt;= n; i++) { ll a; cin \u0026gt;\u0026gt; a; add(i, i+1, inf-a, 0); } add(n+1, t, inf, 0); while (m--) { int l,r,c; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; add(l, r+1, inf, c); } ll maxflow = mcmf(); cout \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; endl; }   例10 洛谷P3358 最长k可重区间集问题 题意\n给定 $n$ 个左闭右开的区间，请选出一些区间，使得直线上任意一点，被覆盖的次数不超过 $k$ 次。\n求这些区间的长度之和的最大值。\n其中，$1 \\leq n \\leq 500, 1\\leq k \\leq 3$，保证每个区间的左右端点为整数，且长度大于等于 $1$。\n 题解 由于区间左右端点可能会有很大的值，甚至负数，所以第一步肯定是离散化。\n如何限定被覆盖的次数不超过 $k$ 次？\n我们只要限制 流量 最多为 $k$ 即可。\n对于区间，仍然是和上面一样的套路。\n 所以建图：\n离散化出直线上的关键点，将它们作为节点，编号为 $1, 2, \u0026hellip;, N$。\n对于 $\\forall i \\in [1,N-1]$，连 $(i,i+1,inf,0)$。\n同时连 $(s,1,k,0), (N,t,k,0)$。\n对于每个区间 $[l,r]$，连接 $(a_l, a_r, 1, r-l)$，其中 $a_l$ 就是 $l$ 在离散化之后对应的节点。\n跑一个最大费用最大流即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 5e5+5; int n,m,s,t,k; struct Edge { int to, nxt; ll w, c; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost = true) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (ll)(mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll cost = 0; ll mcmf() { ll maxflow = 0; while (spfa(false)) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } struct Segment { int l,r; } seg[505]; set\u0026lt;int\u0026gt; bound; map\u0026lt;int, int\u0026gt; mp; // map boundary to index int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; seg[i].l \u0026gt;\u0026gt; seg[i].r; bound.insert(seg[i].l); bound.insert(seg[i].r); } int N = 0; // 线段的数量 for (int a : bound) { mp[a] = ++N; } for (int i = 1; i \u0026lt;= n; i++) { int l = mp[seg[i].l], r = mp[seg[i].r]; add(l, r, 1, seg[i].r - seg[i].l); } s = N+1, t = s+1; for (int i = 1; i \u0026lt;= N; i++) { if (i \u0026lt; N) add(i, i+1, 2e9, 0); } add(s, 1, k, 0); add(N, t, k, 0); ll maxflow = mcmf(); cout \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; endl; }   参考链接  https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic https://www.cnblogs.com/birchtree/p/12912607.html#%E4%B8%80%E4%BA%9B%E8%BF%9E%E8%BE%B9%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93  ","date":"2021-06-04T12:03:44+08:00","permalink":"https://tom0727.github.io/post/047-%E7%BD%91%E7%BB%9C%E6%B5%81/","tags":["网络流","最大流"],"title":"网络流"},{"categories":["算法"],"contents":"二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。\n二分图 - 性质  二分图 $\\iff$ 图中没有奇环（指节点个数为奇数的环） $\\iff$ 可以进行二分图染色  二分图染色 给定一个二分图，我们可以仅用两种颜色将每个节点染上色，并且保证每个 edge 的两端颜色一定不同。\n同理，如果一个图可以进行二分图染色，那么它就是一个二分图（这用于 判断一个图是否为二分图）\n染色的方法：用 DFS 即可。（记得要从每个节点都开始 DFS 一次）\n 随机选择一个点 $u$ 作为出发点，它的颜色为 $c_u = 0$。 看它的 neighbor $v$ 的颜色，如果等于 $c_u$ ^ $1$，或者没染色，就染成 $c_u$ ^ $1$。否则的话产生冲突，说明这不是二分图。  例题 例1 CF741C Arpa’s overnight party and Mehrdad’s silent entering 题意\n给定 $n$ 对情侣 $(a_i, b_i)$（$a_i, b_i \\in [1,2n]$），总共有 $2n$ 个人，每个人的编号是从 $1$ 到 $2n$。现在有 $2$ 种食物（$1$ 或者 $2$），求一种分配方式使得：\n 每对情侣 $(a_i, b_i)$ 不能吃同一种食物。 相邻的 $3$ 个编号，食物不能完全相同。（编号是环形的，这意味着 $2n, 1, 2$ 也算是相邻的 $3$ 个人）。  如果无解，输出 $-1$。\n其中，$1 \\leq n \\leq 10^5$。\n 题解 每对情侣 $(a_i, b_i)$ 的食物不同，让我们想到二分图。但是第二个条件怎么办？\n直觉上来说，这个题一定是有解的。\n所以，我们可以做一个特殊的限制，直接强制 $2i-1, 2i$ 的食物不同，这个条件就满足了。\n接下来我们要证明，将第二个限制条件转化以后，仍然有解。\n 对于这个模型建图，将每个人作为一个节点，每对情侣 $(a_i, b_i)$ 作为一条边连起来。然后再将 $(2i-1, 2i)$ 作为一条边连起来。\n那么只要这个图是二分图，就有解。（因为二分图保证了每条边两端的颜色不同）\n如果图中有环，那么必然是由 $x$ 对情侣组成的一个环。所以环的节点数量为 $2x$。所以不可能有奇环。所以这个图是二分图。\n所以建完图以后，跑一个二分图染色即可。\n• 注意，二分图染色的 DFS 要从每一个节点都开始一次。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 1e6; int n; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; int color[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int a[maxn], b[maxn]; bool vis[maxn]; void dfs(int u) { if (vis[u]) return; vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; color[to] = color[u] ^ 1; dfs(to); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i]; addEdge(a[i], b[i]); addEdge(b[i], a[i]); } for (int i = 1; i \u0026lt;= 2*n; i+=2) { addEdge(i, i+1); addEdge(i+1, i); } vis[1] = 1; for (int i = 1; i \u0026lt;= 2*n; i++) dfs(i); for (int i = 1; i \u0026lt;= n; i++) { if (!color[a[i]]) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; if (!color[b[i]]) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 CF553C Love Triangles 题意\n给定 $n$ 个人，每两个人之间，要么互相love，要么互相hate。\n现在已知 $m$ 个关系，每个关系的格式为 $a ~ b ~ c$，代表 $a$ 和 $b$ 互相 love（$c = 1$），或者互相 hate（$c = 0$）。\n请求出，有多少个方案使得整个关系网满足以下条件（答案对 $10^9+7$ 取模）\n 对于任意三个人 $a,b,c$，要么这三个人互相 love，要么 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。\n 其中，$3 \\leq n \\leq 10^5, 0 \\leq m \\leq 10^5$\n 题解 首先我们会发现，love是有传递性的：如果 $a,b$ 互相love，$b,c$ 互相love，那么根据定义，一定有 $a,c$ 互相love。\n所以对于love的关系，我们可以求出一个连通块，使得这个块内每个人互相love，那就可以缩点了。（当然需要注意的是 hate 不具有传递性）。\n于是，我们只需要考虑一下 hate 怎么处理。\n 先放一个结论：\n 如果我们把这个问题考虑为图染色问题，那么两个互相hate，说明颜色不同。而互相love，说明颜色相同。\n如果存在一个合法的染色方式，则说明有解。（本质上是二分图染色，互相love的在同一侧，互相hate的在两侧）\n 证明：存在染色方式 $\\rightarrow$ 有解：\n任取三个节点 $a,b,c$，有两种情况：\n $a,b,c$ 在同一侧，所以满足 $a,b,c$ 互相love。 $a,b$ 在同一侧，$c$ 在另外一侧。这也刚好满足了 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。  证明：有解 $\\rightarrow$ 存在染色方式：\n根据定义染色即可，我们会发现没有冲突情况。\n 方案数怎么计算？\n我们先进行 DFS，求出图中的连通块。\n如果每个连通块内，都没有冲突情况（也就是说，每个连通块都可以做二分图染色）的话，说明有解，否则无解（$ans = 0$）。\n同时我们发现，对于任何一个连通块，我们只要给其中一个节点染上色，这个连通块内的其他所有节点的颜色也都确定了。\n所以我们只需要给每个连通块染色即可。\n设连通块的数量为 $c$，那么答案就是 $2^{c-1}$。\n• 为什么不是 $2^c$？我们只要确定了第一个块的颜色，剩下的 $(c-1)$ 个块随便选颜色。我们答案是否合法，实际上与第一个块的颜色无关。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,m; int head[maxn], ecnt = 1, color[maxn]; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll ans = 1; void dfs(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (color[to] \u0026gt;= 0) { if (color[to] != (color[u] ^ w ^ 1)) ans = 0; } else { color[to] = (color[u] ^ w ^ 1); dfs(to); } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } fill(color, color+maxn, -1); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (color[i] == -1) { cnt++; color[i] = 0; dfs(i); } } cnt--; for (int i = 1; i \u0026lt;= cnt; i++) { ans = ans * 2LL % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }    二分图匹配 - 定义 一个 匹配 的定义是一个 边集，并且这个边集中，每两个边之间没有共同的顶点。二分图的最大匹配是指 边的数量 最多的一个匹配。\n二分图匹配常用的算法是 匈牙利算法 $O(nm)$，或者 最大流（dinic的复杂度为 $O(\\sqrt n m)$。\n匈牙利算法求最大匹配 匈牙利算法本质上是一个个求增广路（增广路指的是 从左开始，到右结束的路径，其中 左 $\\rightarrow$ 右都是未匹配边，右 $\\rightarrow$ 左都是匹配边）的过程。\n如果我们以男女配对为例子：\n对于每一个男生 $i$（$i$ 在二分图的 左侧点集 中），遍历他每一个心仪的女生 $j$ （$j$ 在二分图的 右侧点集 中）（这说明 $(i,j)$ 是一条边）。那么有两种情况：\n 女生 $j$ 未配对，那么他们两个就配对在一起，match[j] = i。 女生 $j$ 已配对，那么就让女生 $j$ 去问一下她当前的男朋友 match[j]，让她男朋友尝试再换一个新的女朋友（所以就变成一个新的男生尝试配对，那么这就是一个递归的过程）。如果她男朋友成功换掉了女朋友，那么这个男生 $i$ 就可以和 女生 $j$ 配对了。否则 $i$ 就只能单着。  代码片段如下：\nint n, m, adj[maxn][maxn]; int match[maxn], vis[maxn], id = 0; // match[j] 代表女生j 当前的男朋友 i, vis[j] 代表这个女生在当前男生 i 的配对过程中，是否访问过了 bool dfs(int i) { for (int j = 1; j \u0026lt;= m; j++) { if (!adj[i][j] || vis[j] == id) continue; vis[j] = id; if (!match[j] || dfs(match[j])) { match[j] = i; return 1; } } return 0; } int main() { int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { id++; ans += dfs(i); } }  有几个需要注意的点：\n 利用 int vis[] 来代表这个女生 $j$ 在当前男生 $i$ 的配对过程中，是否访问过了。（因为对于每个男生 $i$ 而言，对于每个女生 $j$ 只需要问一次即可）。 利用 id 来记录这是第几次 $dfs(i)$，然后只要判断 $vis[j]$ 是否等于 $id$ 就可以判断，本次 DFS 中是否询问过女生 $j$ 了。（这样就不用每次 DFS 结束都 memset() 一次）。  时间复杂度：每个男生都要询问所有女生，所以是 $O(nm)$（这里 $n$ 代表左边点集的数量，$m$ 代表右边点集）。\n最大匹配，最小点覆盖，最大独立集，最小边覆盖 TODO\n例题 例1 洛谷P1963 NOI2009 变换序列 题意\n给定一个序列 $0,1,\u0026hellip;,N-1$，我们需要求出一个变换序列 $T$，其中 $T$ 是 $0$ 到 $N-1$ 的一个 permutation。\n同时，我们定义任意两个数字 $i,j$ 之间的距离 $D(i,j) = \\min \\{ |i-j|, N-|i-j|\\}$。\n现在给定原序列 和 变换序列 $T$ 之间，每个元素的距离 $D_i$，求出一个字典序最小的变换序列 $T$，如果无解，则输出 \u0026ldquo;No Answer\u0026rdquo;。\n其中，$N \\leq 10^4$。\n 样例：\nInput:\n5 1 1 2 2 1  Output:\n1 2 4 0 3  解释：原序列是 [0,1,2,3,4]，距离序列是 [1,1,2,2,1]，所以最终的变换序列可能是 [0+1, 1+1, 2+2, 3-|5-2|, 4-1] = [1,2,4,0,3]。\n 题解 将 原序列 作为二分图的左部分，变换序列作为二分图右部分。连边的方式就根据 距离序列 来。\n例如原序列的第一个位置是 $0$，对应的距离序列第一个位置是 $1$，所以变换序列对应的值可能是 $1$ 或者 $4$。所以 $0 \\rightarrow 1, 0 \\rightarrow 4$ 连边即可。\n连完边，跑一个最大匹配即可，如果最大匹配的数量等于 $N$ 说明有解，否则无解。\n 最后考虑一下 字典序最小 怎么解决？\n一般来说，看到 字典序最小 就想到 贪心。所以第一个贪心思路是每次匹配的时候都 从小到大 找配对点。\n然而这样有一个问题，比如 $0 \\rightarrow 1$ 以后，有可能因为后续的匹配导致 $0 \\rightarrow 4$。\n所以我们按照编号大小，从后往前进行 DFS 即可。\nfor (int i = n; i \u0026gt;= 1; i--) { // 注意这里是从 n 到 1 id++; dfs(i); }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; int match[maxn], vis[maxn], id = 0, d[maxn], n; set\u0026lt;int\u0026gt; adj[maxn]; bool dfs(int i) { for (int j : adj[i]) { if (vis[j] == id) continue; vis[j] = id; if (!match[j]) { match[j] = i; return 1; } if (dfs(match[j])) { match[j] = i; return 1; } } return 0; } bool ok(int i) { return i \u0026gt;= 1 \u0026amp;\u0026amp; i \u0026lt;= n; } int ans[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; d[i]; for (int i = 1; i \u0026lt;= n; i++) { int j = (i - d[i]); if (ok(j)) adj[i].insert(j); j = (i + d[i]); if (ok(j)) adj[i].insert(j); j = (i + (n - d[i])); if (ok(j)) adj[i].insert(j); j = (i - (n - d[i])); if (ok(j)) adj[i].insert(j); } for (int i = n; i \u0026gt;= 1; i--) { id++; dfs(i); } int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (match[i]) cnt++; } if (cnt \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;No Answer\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { for (int i = 1; i \u0026lt;= n; i++) ans[match[i]] = i; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i]-1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } }   例2 洛谷 P2825 [HEOI2016/TJOI2016]游戏 题意\n在游戏 \u0026ldquo;泡泡堂\u0026rdquo; 中，给定一个 $n \\times m$ 的网格，其中 * 代表空地，x 代表软石头，# 代表硬石头。\n每个炸弹会影响它所在的行与列。炸弹可以穿透软石头，但是无法穿透硬石头。\n给定一个地图，求最多放置多少个炸弹，使得每两个炸弹之间的影响范围不相交？\n 题解 二分图匹配的一个常见套路就是应用在 网格地图 中。\n我们把 每一行 看作一个节点，每一列 也看作一个节点，而每个网格就看作一条边。\n如果我们不考虑硬石头的情况，那么这个题非常简单。把每个空地看作一条边，连起来以后跑一个最大匹配即可。\n但是现在有硬石头。我们会发现一个硬石头可以 隔断纵向的和横向的 炸弹威力。那么，我们把硬石头隔断的部分，也看作是一个节点即可。\n也就是说，现在不再是每一行/每一列作为节点，而是以 横向/纵向 线段 作为单位，每个线段是一个节点。\n现在，每个网格里有 $3$ 种情况：\n 空地：看作一个正常的边 软石头：忽略不计 硬石头：作为分界点，上下是两个不同的线段，左右是两个不同的线段。  图建好了，再跑一个最大匹配即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 55; const int maxm = 2505; int n,m; char arr[maxn][maxn]; vector\u0026lt;int\u0026gt; adj[maxm]; int id, lcnt, rcnt; int l[maxn][maxn], r[maxn][maxn]; int match[maxm], vis[maxm], vis_id; bool dfs(int i) { for (int j : adj[i]) { if (vis[j] == vis_id) continue; vis[j] = vis_id; if (!match[j] || dfs(match[j])) { match[j] = i; return 1; } } return 0; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } id = 0; for (int i = 1; i \u0026lt;= n; i++) { id++; for (int j = 1; j \u0026lt;= m; j++) { if (arr[i][j] == '#') { id++; continue; } l[i][j] = id; } } lcnt = id; id = 0; for (int j = 1; j \u0026lt;= m; j++) { id++; for (int i = 1; i \u0026lt;= n; i++) { if (arr[i][j] == '#') { id++; continue; } r[i][j] = id; } } rcnt = id; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (arr[i][j] == '*') { adj[l[i][j]].push_back(r[i][j]); } } } int ans = 0; for (int i = 1; i \u0026lt;= lcnt; i++) { vis_id++; ans += dfs(i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-05-30T22:31:30+08:00","permalink":"https://tom0727.github.io/post/046-%E4%BA%8C%E5%88%86%E5%9B%BE/","tags":["二分图","二分图匹配"],"title":"二分图 \u0026 二分图匹配"},{"categories":["算法"],"contents":"介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。\n第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考虑 $u$ 的subtree，求出这样的答案 $dp[u]$。\n第二次DFS：令最终答案为 $ans[u]$，则可知 $ans[1] = dp[1]$。然后我们需要通过已知的 $ans[u]$，来推出它的child $ans[to]$ 的值。一般我们由 $ans[u]$ 来推导 $ans[to]$ 时，需要考虑到换根时 $to$ 子树内的贡献，和子树外的贡献 变化。\n套路 我们考虑一下一种general的情况：从 $u$ 换根到 $v$。\n此时我们一定位于 dfs(u) 中，并且已经求出了 $ans[u]$。现在要求 $ans[v]$。（注：这里的 $ans[u]$ 是广义的，代表 $u$ 相关的信息。不一定真的是最终的 $ans$，比如例4）\n那么换根前是这样：\n换根后，是这样：\n步骤如下：\n 基于 $ans[u]$，将 $u$ 的child $v$ 所带来的贡献删掉，得到 $dp2[u]$。 基于 $dp[v]$，将 $u$ 作为一个新的child 加给 $v$（实际上，就是将 $dp2[u]$ 的贡献加给 $dp[v]$），得到 $ans[v]$。  • 注意，这里的 $dp2[u]$ 实际上是一个临时的变量。对于每一个 $v$ 而言，$dp2[u]$ 互不相同。\n例题 例1 洛谷P3478 [POI2008]STA-Station 题意\n给定 $n$ 个节点的树，求一个节点 $u$ 使得 $u$ 到其他节点的距离和最大。\n即，求出 $u$，使得 $\\sum\\limits_v d(u,v)$ 最大。\n 题解 首先固定 $1$ 为根，进行一次DFS。\n令 dp[u] 为第一次DFS，只考虑 $u$ 的子树内的答案。（考虑深度和即可）\n令 ans[u] 为最终答案，那么有 ans[1] = dp[1]。\n 现在我们要从 $1$ 开始换根。\n比如说，我们已知了 $u$ 的答案 $ans[u]$，我们就可以理解成：整棵树，以 $u$ 作为root的答案已经求出来了，怎么求出 $to$ 的答案？\n换根的过程是一个旋转的过程。我们把 $to$ 的子树向上旋转，将 $to$ 外面的部分（$u$ 和其他的子树）向下旋转。\n则，向上旋转的部分，对于答案贡献了 -sz[to]（因为深度减少了），而向下旋转的部分，对于答案贡献了 (n-sz[to])。\n所以，$ans[to] = ans[u] - sz[to] + (n - sz[to]);$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int n, head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } ll sz[maxn], dp[maxn]; void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; dp[u] += dp[to] + sz[to]; } } ll ans[maxn]; void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ans[to] = ans[u] - sz[to] + ((ll)n - sz[to]); dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(1, 0); ans[1] = dp[1]; dfs2(1, 0); ll maxans = 0, idx = 0; for (int i = 1; i \u0026lt;= n; i++) { if (ans[i] \u0026gt; maxans) { maxans = ans[i]; idx = i; } } cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; }   例2 CF1324F Maximum White Subtree 题意\n给定 $n$ 个节点的树，每个节点有一个值 $1$ 或者 $-1$。\n对于每一个节点 $i$，求 $i$ 所在的连通块中，最大的节点权值和？\n其中，$2 \\leq n \\leq 2 \\times 10^5$\n 题解 首先固定 $1$ 为 root，进行一次DFS。\n这样可以求出一个 dp[u]：代表以 $1$ 为root时，每个节点仅考虑其subtree，得到的最大值。\n在第一次DFS的过程中，再维护一个数组 bool used[]，其中 used[u] = 1 代表 $u$ 的parent $p$ 的答案用到了 $u$ 的这个subtree。\n 然后进行第二次DFS，计算出最终答案 ans[]。\n首先有，ans[1] = dp[1]。\n当我们在 dfs2(u) 时，在求一个child to 的答案 ans[to] 时，我们有两种选择：\n  to 不使用外面的节点：$ans[to] = \\max(ans[to], dp[to])$\n  to 使用外面的节点：分两种情况讨论\n 如果 to 已经被包含在 $u$ 的答案中了（used[to] = 1），则 $ans[to] = \\max(ans[to], ans[u])$ 如果 to 并没有被包含在 $u$ 的答案中，（used[to] = 0），那么 to 的最终答案，就是由 $to$ 的subtree 和 外面节点的合并而来。即 $ans[to] = \\max(ans[to], ans[u] + dp[to])$     代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int n, head[maxn], ecnt = 1, val[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int dp[maxn]; bool used[maxn]; // when calculating answer, whether used[u] is taken into consideration void dfs1(int u, int p) { dp[u] = val[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); if (dp[to] \u0026gt; 0) dp[u] += dp[to], used[to] = 1; } } int ans[maxn]; void dfs2(int u, int p) { ans[u] = max(ans[u], dp[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (used[to]) ans[to] = max(ans[to], ans[u]); else ans[to] = max(ans[to], ans[u] + dp[to]); dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; val[i]; if (val[i] == 0) val[i] = -1; } for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } fill(ans, ans+maxn, -1e9); dfs1(1,0); dfs2(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 洛谷P6419 [COCI2014-2015#1] Kamp 题意\n给定 $n$ 个节点的树。经过每条边都需要时间 $w_i$。\n有 $K$ 个人，初始在 $K$ 个不同的点，他们要集中在一个点聚会。\n聚会结束后，一辆车从聚会点出发（装上所有人），把这 $K$ 个人分别送回去。\n求：如果聚会点在 $i$，则将这些人都送回去，所需最少的时间？\n输出对于所有 $i = 1$ ~ $n$ 的结果。\n其中，$1 \\leq K \\leq n \\leq 5 \\times 10^5, 1 \\leq w \\leq 10^8$。\n 题解 换根DP首先考虑：如果以 $1$ 作为根，怎么求出 $1$ 的答案？\n• 以下，所有初始点我们都打上标记。\n令 $sz[u]$ 为：$u$ 的 subtree（以 $1$ 为根的版本）中，标记点的数量。\n令 $dp[u]$ 为：从 $u$ 出发，经过 $u$ 的 subtree（以 $1$ 为根的版本） 所有标记点，再回到 $u$，所需的最少时间（如果子树内无标记，则为0）。\n那么通过第一次DFS，我们可以求出整个dp数组。\nif (sz[to]) dp[u] += dp[to] + 2*w;   有了 $dp[1]$，我们还需要一个 $d[u]$，代表以 $u$ 为根的子树（以 $1$ 为根的版本）最长的链的长度。\n同时我们再记录 $f[u]$：代表以u为根，包含了最长链的直接child $to$ 的编号。\n最后 $1$ 对应的答案是：$dp[1] - d[1]$。（因为送到最长链，就不用再回到 $1$ 了）。\n 现在问题是，已知 $1$ 的答案，我们需要求出其他点的答案。\n令 $ans[u]$ 为：从 $u$ 出发，经过整棵树的所有标记点，再回到 $u$，所需的最少时间。\n易证 $ans[1] = dp[1]$。\n然后进行第二次DFS，我们需要改变 $d[u]$ 的意义：此时 $d[u]$ 代表从 $u$ 出发的最长链的长度（以整棵树而言）。\n同时，我们再维护一个数组 $s[u]$，代表从 $u$ 出发的第二长链的长度（以整棵树而言），并且第二长链必须和最长链 不在同一个子树内（这里的子树指，以 $u$ 为根的判断标准）。\n我们在从 $u$ 转移到 $to$ 的时候，就有以下的几种情况：\n  $to$ 内无标记：\n先从 $to$ 走到 $u$，访问所有的点，再从 $u$ 回到 $to$。\nans[to] = ans[u] + 2LL * w; d[to] = d[u] + w; // 现在，d[] 表示全局的链    $to$ 里面包含了整棵树的所有标记点：\n最终答案就 等于 以 $to$ 为根，subtree的答案。\nans[to] = dp[to];    $to$ 里面包含了标记，外面也包含了标记：\n那么对于整棵树而言，从 $to$ 出发，还是从 $u$ 出发都一样。所以 ans[to] = ans[u]。\n但是我们需要更新最长链和次长链。这个时候，我们就要分类讨论 f[u] = to 与否。\n如果 $u$ 原本的最长链就不在 $to$ 的子树内，那么换根以后（旋转），$to$ 的最长链必然是 $to \\rightarrow u \\rightarrow f[u]$。\n如果 $u$ 原本用到的最长链是 $to$，而旋转后，$to$ 的最长链就有可能用到 $u$ 的其他子树（除了 $to$ 以外的子树），所以我们需要维护次长链 $s[u]$，并且进行比较。\n相应的，换根过程中，我们也要更新次长链 $s[to]$。\nans[to] = ans[u]; if (f[u] != to) { // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然继承 u 原来的最长链 s[to] = d[to]; d[to] = w + d[u]; f[to] = u; } else { if (s[u] + w \u0026gt;= d[to]) { s[to] = d[to]; d[to] = s[u] + w; f[to] = u; } else if (s[u] + w \u0026gt; s[to]) { s[to] = s[u] + w; } }     代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; int n, K, head[maxn], ecnt = 1; bool tag[maxn]; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } ll dp[maxn]; // dp[u]: 从u出发，只考虑其subtree中有标记的点，再回到u，得到的答案（如果子树内无标记，则为0） ll ans[maxn]; // 从u出发，送完所有人，再回到u得到的答案 ll d[maxn]; // d[u]: 以u为根的子树内，最长的链的长度 ll s[maxn]; // s[u]: 以u为根的子树内，次长的链的长度 (不能和d所在的子树相同) ll f[maxn]; // f[u]: 以u为根，包含了最深的有标记节点的to编号 int sz[maxn]; // sz[u]: 以u为根的subtree里的标记点数量 void chmax(int u, ll val) { if (val \u0026gt; d[u]) { s[u] = d[u]; d[u] = val; } else { if (val \u0026gt; s[u]) s[u] = val; } } void dfs1(int u, int p) { if (tag[u]) { sz[u] = 1; d[u] = 0; s[u] = -1e15; } else { d[u] = s[u] = -1e15; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; dfs1(to, u); if (!sz[to]) continue; // 子树内无标记 dp[u] += dp[to] + 2LL*w; sz[u] += sz[to]; if (d[to] + w \u0026gt;= d[u]) { s[u] = d[u]; d[u] = d[to] + w; f[u] = to; } else if (d[to] + w \u0026gt; s[u]) { s[u] = d[to] + w; } } } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (to == p) continue; if (!sz[to]) { // to 里面没有标记点 ans[to] = ans[u] + 2LL * w; d[to] = d[u] + w; // 现在，d[] 表示全局的链 } else if (K - sz[to] == 0) { // to 里面全是标记点 ans[to] = dp[to]; // 无需更新最长/次长链 } else { // 里外都有标记 ans[to] = ans[u]; if (f[u] != to) { // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然出现在 u 所在的子树里 s[to] = d[to]; d[to] = w + d[u]; f[to] = u; } else { if (s[u] + w \u0026gt;= d[to]) { s[to] = d[to]; d[to] = s[u] + w; f[to] = u; } else if (s[u] + w \u0026gt; s[to]) { s[to] = s[u] + w; } } } dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= K; i++) { int a; cin \u0026gt;\u0026gt; a; tag[a] = 1; } dfs1(1,0); ans[1] = dp[1]; dfs2(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] - d[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF708C Centroids 题意\n给定一个 $n$ 个节点的树，定义树的重心 $u$ 为：如果以 $u$ 为根，每个子树的大小都 $\\leq \\frac{n}{2}$。\n现在，对于每个点 $u$，我们需要判断：\n以 $u$ 为根时，能否在这棵树内，删去一条边，再添加一条边（不能加入已有的边），使得 $u$ 是重心？\n其中，$2 \\leq n \\leq 4 \\times 10^5$\n 题解 首先，如果一个节点本来就是重心，那么它的答案就是 $1$。\n现在考虑，如果一个节点 $u$ 现在不是重心，怎么删边和加边，使得它成为重心？\n我们会发现，如果以 $u$ 为根，对于 $u$ 的所有 neighbor $v$，有且仅有一个 $v$，使得 $v$ 所在的 subtree 的大小 $\u0026gt; \\frac{n}{2}$， 那么我们就从这个 subtree $S_v$ 中，找到一个更小的subtree $S$，满足：\n $S$ 的大小 $\\leq \\frac{n}{2}$。 $S$ 是 $S_v$ 内，所有满足条件中，最大的subtree。  然后我们把这个 subtree $S$ 断开，然后接到 $u$ 上，然后再判断一下 $u$ 此时是否为重心即可。\n 我们会发现，如果以 $u$ 为根，这样的 $S$ 其实很容易找到。现在要考虑换根的问题。\n 对于这道题而言，如果我们仅仅维护一个节点 $u$ 作为根时，subtree的信息，那么换根时会很麻烦。\n我们需要额外维护一个信息 out[u]，其中 $out[u]$ 就代表：以 $1$ 为根时，$u$ 所在子树 $S_u$ 外面的信息。\n具体定义：$out[u]$ 代表：以 $1$ 为根时，设 $u$ 的parent为 $p$。然后令 $p$ 为根，除了 $S_u$ 以外的部分，满足大小 $\\leq \\frac{n}{2}$ 的最大子树。\n然后就是 套路 里所说的：\n先删去 $to$ 对于 $u$ 的贡献，再将 $u$ 加到 $to$ 上。\nvoid dfs2(int u, int p) { if (n - sz[u] \u0026gt; n/2) { if (n - sz[u] - out[u] \u0026gt; n/2) ok[u] = 0; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (n - sz[to] \u0026lt;= n/2) { out[to] = n - sz[to]; } else { // 删去 to 对于 u 的贡献（维护最大值，次大值 是常见套路了） // 再把 u 加到 to 上去（更新 out[to]） if (use[u][0] == to) { out[to] = max(out[u], dp[u][1]); } else { out[to] = max(out[u], dp[u][0]); } } if (sz[to] \u0026gt; n/2) { if (sz[to] - dp[to][0] \u0026gt; n/2) ok[u] = 0; } dfs2(to, u); } }  • 当然注意到上述代码，我们不一定要定义一个 $dp2[]$ 数组。这题的状态转移相对简单，所以直接将两步合成一步就可以了。下一题会用到较复杂的状态转移，此时就需要定义 $dp2[]$ 数组了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4e5+5; int sz[maxn], head[maxn], ecnt = 1, dp[maxn][2], out[maxn], use[maxn][2], n; bool ok[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026lt;= n/2) { if (sz[to] \u0026gt; dp[u][0]) { dp[u][1] = dp[u][0]; dp[u][0] = sz[to]; use[u][0] = to; } else if (sz[to] \u0026gt; dp[u][1]) { dp[u][1] = sz[to]; use[u][1] = to; } } else if (dp[to][0] \u0026gt; dp[u][0]) { dp[u][1] = dp[u][0]; dp[u][0] = dp[to][0]; use[u][0] = to; } else if (dp[to][0] \u0026gt; dp[u][1]) { dp[u][1] = dp[to][0]; use[u][1] = to; } } } void dfs2(int u, int p) { if (n - sz[u] \u0026gt; n/2) { if (n - sz[u] - out[u] \u0026gt; n/2) ok[u] = 0; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (n - sz[to] \u0026lt;= n/2) { out[to] = n - sz[to]; } else { if (use[u][0] == to) { out[to] = max(out[u], dp[u][1]); } else { out[to] = max(out[u], dp[u][0]); } } if (sz[to] \u0026gt; n/2) { if (sz[to] - dp[to][0] \u0026gt; n/2) ok[u] = 0; } dfs2(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } fill(ok, ok+maxn, 1); dfs1(1, 0); dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; ok[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例5 洛谷P3647 [APIO2014]连珠线 题意\n现在有 $n$ 个珠子。珠子之间用线链接，每个线要么是红色，要么是蓝色。\n我们将会从其中一个珠子开始（我们不知道这个珠子是哪个），每次用如下两种方式之一，添加珠子：\n 将一个 新的珠子 $w$ 和已经添加的珠子 $v$，用红线连起来。 将两个已经存在的珠子 $u,v$ 之间相连的红线删掉，然后添加一个 新的珠子 $w$ 使得 $(u,w)$，$(w,v)$ 用蓝线链接。  每条线都具有一个长度，游戏结束后，最终得分为蓝线长度之和。\n给定游戏结束的局面（是一棵树），我们已知 珠子和线的连接方式，以及每条线的长度。但是我们不知道线的颜色。\n求最大可能的得分？\n其中，$1 \\leq n \\leq 2 \\times 10^5$\n 题解 观察一下会发现，如果 $a,b$ 之间有蓝线，$b,c$ 之间也有蓝线。那么 $b$ 就是一个中间节点。这样的节点满足两个条件：\n $b$ 与 $a,c$ 一定是直接的neighbor。 $b$ 只能作为一次中间节点（因为 $b$ 是通过第二种操作添加的新节点） $a,c$ 不能均为中间节点（因为 $a,c$ 之间，必须以红线相连，然后断开才行。这说明 $a,c$ 其中一个必须是通过第一种操作，得到的新珠子）  那么，在最终形成的树中，对于蓝线，有以下两种可能：\n第一种情况：grandparent, parent, child\n第二种情况：parent, child1, child2\n我们发现第二种情况很复杂，因为我们需要分类讨论 $a,c$ 是否本身为中间节点。\n但是第一种情况，就比较好处理。我们只要加一个限定条件：\n如果 $b$ 是中间节点（用 $1$ 来标记），那么它用蓝线相连的child $c$，就不能是中间节点（用 $0$ 来标记）。\n 等等，有两个疑问：\n 为什么我们限定的是蓝线相连的 child $c$？为什么不是parent $a$ ？ 那如果第二种情况的那种出现了，怎么办？  这些问题都可以通过 固定 树的根来解决。\n我们可以发现，如果我们设定树的根为： 最优解 中，最开始的那个珠子（虽然我们不知道它是哪一个），这些问题就都解决了。（比如第二个问题，我们可以保证这种情况不会出现）。\n 如上，我们只需要考虑第一种情况。那么，固定 $1$ 为根时，第一次 DFS 中，我们有：\n设 $dp[u][0]$ 为：如果 $u$ 不是一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。\n设 $dp[u][1]$ 为：如果 $u$ 是一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。\n状态转移方程：\n$$dp[u][0] = \\sum\\limits_{to} \\max(w + dp[to][1], dp[to][0])$$\n对于 $dp[u][1]$，因为它只能选择一个 child。它选择的那个child $v$，对它的贡献是 $w_{u,v} + dp[v][0]$，其他的child $to$ 的贡献都是 $\\max(w + dp[to][1], dp[to][0])$。\n所以只要把这个 $v$ 的贡献减去，再加上新贡献就可以了。\n$$dp[u][1] = dp[u][0] + \\max\\limits_v \\{ w+dp[v][0] - \\max(w+dp[v][1], dp[v][0])\\}$$\n 以 $1$ 为根的情况有了，现在考虑一下换根？\n由换根套路，首先将 $to$ 对于 $u$ 的影响删去（基于 $ans[u]$），有：\n$$dp2[u][0] = ans[u][0] - \\max(w + dp[to][1], dp[to][0])$$\n然后，对于 $dp2[u][1]$，我们分类讨论一下 $to$ 是否为 $u$ 的最佳转移点（也就是说，$ans[u][1]$ 是否用到了 $to$，作为最大值）。\n$$dp2[u][1] = \\begin{cases} ans[u][1] - maxval[u][0] + maxval[u][1] \u0026amp; \\text{If to 是 u 的最佳转移点} \\\\\nans[u][1] \u0026amp; \\text{Otherwise} \\end{cases}$$\n然后，再基于 $dp[to]$ 的基础上，将 $dp2[u]$ 作为 child 给 $to$ 的影响加到 $to$ 上即可。\n最后，答案就是 $\\max\\limits_u \\{ans[u][0]\\}$。（因为 $ans[u][1]$ 并没有意义，$u$ 作为根的时候是没有parent的）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, w, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, dp[maxn][2], dp2[maxn][2], ans[maxn][2]; // dp: 以 1 为根, dp2: 换根后, ans: 最终答案 int use[maxn][2], maxval[maxn][2]; // use[u]: 转移时，所用的前两大的值，对应的两个vertex； maxval[u] : 转移时所用的前两大的值 void addEdge(int u, int v, int w) { Edge e = {v, w, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (to == p) continue; dfs1(to, u); dp[u][0] += max(w + dp[to][1], dp[to][0]); // 转移 dp[u][0] // 转移 dp[u][1] int val = w + dp[to][0] - max(w + dp[to][1], dp[to][0]); if (val \u0026gt; maxval[u][0]) { maxval[u][1] = maxval[u][0]; use[u][1] = use[u][0]; maxval[u][0] = val; use[u][0] = to; } else if (val \u0026gt; maxval[u][1]) { maxval[u][1] = val; use[u][1] = to; } } dp[u][1] = dp[u][0] + maxval[u][0]; } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (to == p) continue; // 删去 to 对于 u 的影响，基于 ans[u]，得到 dp2[u] dp2[u][0] = ans[u][0] - max(w + dp[to][1], dp[to][0]); if (to == use[u][0]) { dp2[u][1] = ans[u][1] - maxval[u][0] + maxval[u][1]; } else { dp2[u][1] = ans[u][1]; } dp2[u][1] -= max(w + dp[to][1], dp[to][0]); // 将 dp2[u] 作为 child，重新加给 to(在 dp[to] 的基础上)，作为新的 child ans[to][0] = dp[to][0] + max(w + dp2[u][1], dp2[u][0]); int val = w + dp2[u][0] - max(w + dp2[u][1], dp2[u][0]); if (val \u0026gt; maxval[to][0]) { maxval[to][1] = maxval[to][0]; use[to][1] = use[to][0]; maxval[to][0] = val; use[to][0] = u; } else if (val \u0026gt; maxval[to][1]) { maxval[to][1] = val; use[to][1] = u; } ans[to][1] = ans[to][0] + maxval[to][0]; dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= n; i++) maxval[i][0] = maxval[i][1] = -1e9; // 注意初始化，否则会有问题 dfs1(1, 0); ans[1][0] = dp[1][0], ans[1][1] = dp[1][1]; dfs2(1, 0); int maxans = 0; for (int i = 1; i \u0026lt;= n; i++) maxans = max(maxans, ans[i][0]); // 注意这里是 ans[i][0] cout \u0026lt;\u0026lt; maxans \u0026lt;\u0026lt; endl; }   ","date":"2021-04-22T21:49:20+08:00","permalink":"https://tom0727.github.io/post/045-%E6%8D%A2%E6%A0%B9dp/","tags":["树形DP","换根DP"],"title":"换根DP"},{"categories":["解题报告"],"contents":"全是数学的一场Div2，$D$ 题是常规操作了，但是考场上没想起来，这里记录一下。\n结尾也记录了 CF1514D，一道使用随机算法的神奇题目。\nCF1516B AGAGA XOOORRR 题意\n给定 $n$ 个元素 $a_1,a_2,\u0026hellip;,a_n$，每次操作可以任选 $2$ 个相邻元素 $a_i, a_{i+1}$，将它们删去，并且用 $a_i \\text{ xor } a_{i+1}$ 来替换（位置不变）。\n问：是否存在一序列操作，使得数组最后只有相同的元素，并且长度 $\\geq 2$？\n其中，$2 \\leq n \\leq 2000$\n 题解 可以发现最后数组长度要么为 $2$，要么为 $3$。\n如果最后长度为 $2$，说明 $a_1 \\text{ xor }a_2 \\text{ xor }\u0026hellip; \\text{ xor }a_n = 0$，特判一下即可。\n如果长度为 $3$，则令 $k = a_1 \\text{ xor }a_2 \\text{ xor }\u0026hellip; \\text{ xor }a_n$，则最后数组一定是 $[k,k,k]$。只要判断是否存在连续的 $3$ 段使得它们的$\\text{ xor }$为 $k$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2000+5; int arr[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; int x = arr[1]; for (int i = 2; i \u0026lt;= n; i++) x ^= arr[i]; if (x == 0) { cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } int cur = 0, cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { cur ^= arr[i]; if (cur == x) cnt++, cur = 0; if (cnt \u0026gt;= 2) break; } if (cnt \u0026gt;= 2) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   CF1516C Baby Ehab Partitions Again 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n问：我们最少要从数组中删去几个元素，使得：不存在任何一种方案，将数组分为 sum 相同的两半？\n输出这个最少删除数量，并且输出删除的index。\n其中，$2 \\leq n \\leq 100, 1 \\leq a_i \\leq 2000$\n 题解 我们按照以下步骤进行check：\n  如果 $sum$ 是奇数，答案为 $0$。\n  如果这个数组本身就无法分为两半（直接用 bitset 模拟），答案为 $0$。\n  如果这个数组内，存在一个奇数，答案为 $1$，把这个奇数删掉即可。\n  如果数组内，不存在奇数。则我们会发现，把整个数组的所有数除以 $2$，答案不变（因为原先的分配方案不会改变）。所以我们就一直除，直到出现一个奇数。答案也为 $1$。\n  如上，答案要么为 $0$，要么为 $1$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 105; const int maxm = 2e5+5; int n, arr[maxn], sum = 0, idx = -1; bitset\u0026lt;maxm\u0026gt; dp; bool check() { dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { dp |= (dp \u0026lt;\u0026lt; (arr[i])); } if (dp[sum/2]) return 0; // can partition into equal parts return 1; // cannot partition into equal parts } void done() { if (idx == -1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; } exit(0); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; if (sum \u0026amp; 1) done(); if (check()) done(); bool ok = 0; while (!ok) { for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026amp; 1) ok = 1, idx = i; } for (int i = 1; i \u0026lt;= n; i++) arr[i] /= 2; } done(); }   CF1516D Cut 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n给定 $q$ 个询问，每次询问 $l,r$，回答：\n对于 $[a_l, \u0026hellip;, a_r]$，最少需要将它分为几个连续的subarray，使得每一个subarray内，所有元素的 $LCM$ 等于它们的乘积？\n其中，$1 \\leq n,q,a_i \\leq 10^5, 1 \\leq l \\leq r \\leq n$。\n 题解 如果一个subarray内，所有元素的 $LCM$ 等于它们的乘积，说明 任选两个元素，$gcd = 1$，也就是说不存在两个元素使得它们共享一个质因子。\n所以一个 trivial 的算法如下：\n每次询问 $L,R$，就从 $L$ 开始出发，一直向右走，直到遇到一个 $x \\in [L+1,R]$ 使得 $[a_L,\u0026hellip;,a_x]$ 不满足上述条件。然后将 $ans+1$，令 $L = x$，然后重复此过程。\n 现在问题在于，对于每一个 $L$，如何快速得到这样的 $x$？\n 法一：（很麻烦）\n根号分治 + 质因数分解，类似于 CF1422F Boring Queries。\n我们先对每个数进行质因子分解，如果一个subarray $[L,R]$ 满足条件，那么：\n对于每一个质因子 $p_i$，在 $[L,R]$ 内，它最多只能出现一个位置上。\n我们就可以处理出一个数组 $pre[j][i] = x$，代表对于第 $j$ 个质数 $p_j$，满足：\n $a_i$ 包含 $p_j$ 这个质因子。 $a_x$ 包含 $p_j$ 这个质因子。 $x \u0026lt; i$，且 $x$ 尽可能大。  然后得到一个数组 $pr[i]$，其中 $pr[i] = \\max\\limits_j \\{ pre[j][i]\\}$。\n那么，查询一个区间 $[L,R]$ 是否满足条件，令 $a = \\max\\limits_{i=L}^R \\{pr[i]\\}$，则只要满足 $a \u0026lt; L$，说明这个区间 $[L,R]$ 是合法的。（这个 $a$ 可以用 $ST$ 表维护）\n• 注意到我们需要用根号分治（$ST$ 表只维护 $\\leq \\sqrt {10^5}$ 的部分。\n• 对于大质因子，由于每个位置，出现次数最多只有一次，直接用 map\u0026lt;int,int\u0026gt; 模拟一下前一个和它相等的数的index即可。\n经过上述处理，我们可以在 $O(1)$ 的时间内，查询一个区间 $[L,R]$ 是否合法。\n那么，对于每一个 $L$，二分 右边界 $R$ 就可以得到最大的合法 $R$ 的值为 $R'$，令 $x = R'+1$ 即可。\n 法二：（正解）\nDP + 质因数分解。\n首先求出每一个数的所有质因子。\n然后我们从 $n$ 遍历到 $1$，维护两个数组 int pnxt[], dp[]：\n pnxt[p]：代表当前情况下，对于质因子 $p$，出现最靠前的位置。 dp[i]：对于位置 $i$，最多能往右走到 dp[i] 这个index（不包括）。  首先我们有 dp[i] = min(dp[i], dp[i+1])，然后对于当前index $i$，我们有：\n$$dp[i] = \\min\\limits_p \\{pnxt[p]\\}$$\n其中，$p$ 是 $a_i$ 的所有质因子。\n处理出 dp[] 数组，就是我们所求的了。\n 现在我们已知，对于每一个 $L$，它最远可以走到 $x$（不包括），那么每次询问 $[L,R]$，怎么快速得到答案？\n模拟肯定不行，如果数组是 $2,2,2,2,2\u0026hellip;,2$ 的话，每次询问复杂度为 $O(n)$。\n使用 $LCA$ 中的倍增思想就可以了。\n我们预处理出 $nxt[i][j]$：代表从 $i$ 出发，走 $2^j$ 次，最远能走到哪。（其中，$nxt[i][0]$ 就是上述的 $dp[i]$）。\n 法一代码（根号分治 \u0026#43; 质因数分解 \u0026#43; ST表） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n, q, arr[maxn], small[maxn]; // small[i] 代表 i 的最小质因子 bool isprime[maxn]; vector\u0026lt;int\u0026gt; primes; bool have[70][maxn]; int pre[70][maxn]; int ptr = 0; // 记录小质因子(\u0026lt;=317) 的数量 int mp[70]; // 1 -\u0026gt; 2, 2 -\u0026gt; 3, 3-\u0026gt;5（因为质因数小于70个，节省空间） int rmap[maxn]; // mp 的 reverse map int pr[maxn]; int st[maxn][18]; int bin[maxn]; int dp[maxn]; int ask_st(int l, int r) { int len = r-l+1; int k = bin[len]; return max(st[l][k], st[r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) st[i][0] = pr[i]; for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) st[i][k] = max(st[i][k-1], st[i+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } void init() { fill(isprime, isprime+maxn, 1); isprime[1] = 0; small[1] = 1; for (int i = 2; i \u0026lt;= 1e5; i++) { if (isprime[i]) primes.push_back(i), small[i] = i; for (int j = 0; j \u0026lt; primes.size(); j++) { int p = primes[j]; if (i*p \u0026gt; 1e5) break; isprime[i*p] = 0; small[i*p] = p; // 注意这里，无论是否有 i%p，都要 small[i*p] = p if (i % p == 0) { break; } } } for (int i = 0; i \u0026lt; primes.size(); i++) { mp[++ptr] = primes[i]; rmap[primes[i]] = ptr; if (primes[i] \u0026gt; 317) break; } for (int i = 1; i \u0026lt;= n; i++) { while (arr[i] \u0026gt; 1) { int p = small[arr[i]]; if (p \u0026gt; 317) break; have[rmap[p]][i] = 1; while (arr[i] % p == 0) arr[i] /= p; } } for (int j = 1; j \u0026lt;= ptr; j++) { for (int i = 1; i \u0026lt;= n; i++) { if (have[j][i-1]) pre[j][i] = i-1; pre[j][i] = max(pre[j][i], pre[j][i-1]); if (have[j][i]) { pr[i] = max(pr[i], pre[j][i]); } } } unordered_map\u0026lt;int,int\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026lt;= 317) continue; if (m.count(arr[i])) pr[i] = max(pr[i], m[arr[i]]); m[arr[i]] = i; } build_st(); } // 询问 [L,R] 这个区间是否合法 bool ok(int l, int r) { int a = ask_st(l,r); if (a \u0026lt; l) return 1; return 0; } int nxt[maxn][19]; // nxt[i][j]: 从i开始，跳j步能达到的index int main() { read(n); read(q); for (int i = 1; i \u0026lt;= n; i++) read(arr[i]); init(); for (int L = 1; L \u0026lt;= n; L++) { int l = L, r = n; int res; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (ok(L,mid)) { res = mid; l = mid+1; } else r = mid-1; } nxt[L][0] = res + 1; } fill(nxt[n+1], nxt[n+1] + 19, n+1); for (int k = 1; k \u0026lt;= 18; k++) { for (int i = 1; i \u0026lt;= n; i++) { nxt[i][k] = nxt[nxt[i][k-1]][k-1]; } } while (q--) { int L, R, ans = 0; read(L), read(R); for (int k = 18; k \u0026gt;= 0; k--) { if (nxt[L][k] \u0026lt;= R) L = nxt[L][k], ans += (1\u0026lt;\u0026lt;k); } ans++; write(ans); } }   法二代码（DP \u0026#43; 质因数分解） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n, q, arr[maxn]; vector\u0026lt;int\u0026gt; fac[maxn]; // fac[i]: i的质因子 (不重复) void get_factors() { for (int i = 2; i \u0026lt;= 1e5; i++) { if (fac[i].size() == 0) { // i为质数 fac[i].push_back(i); for (int j = i+i; j \u0026lt;= 1e5; j += i) { fac[j].push_back(i); } } } } int nxt[maxn][18]; // nxt[i][0] = j: 从i开始向右走，最多能走到j（不包括j） int pnxt[maxn]; // pnxt[p] = i: 当前状态下，包含了质因子p的最小index i void init() { get_factors(); fill(pnxt, pnxt+maxn, n+1); fill(nxt[n+1], nxt[n+1] + 18, n+1); for (int i = n; i \u0026gt;= 1; i--) { int cur = arr[i]; nxt[i][0] = nxt[i+1][0]; for (int p : fac[cur]) { nxt[i][0] = min(nxt[i][0], pnxt[p]); pnxt[p] = i; } } for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i \u0026lt;= n; i++) { nxt[i][k] = nxt[nxt[i][k-1]][k-1]; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; init(); while (q--) { int L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int ans = 0; for (int j = 17; j \u0026gt;= 0; j--) { if (nxt[L][j] \u0026lt;= R) { L = nxt[L][j]; ans += (1\u0026lt;\u0026lt;j); } } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   CF1514D Cut and Stick 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n给定 $q$ 个询问，每次询问 $l,r$，回答：\n对于 $[a_l, \u0026hellip;, a_r]$，最少需要将它分为几个subsequence（不用连续），使得每一个subsequence都满足：如果这个subsequence的长度为 $len$，那么众数的出现次数 $\\leq \\lceil \\frac{len}{2} \\rceil$。\n 题解 对于每次询问，求出 $[l,r]$ 中是否存在出现次数大于一半的数字，这样的数如果有，只能有一个。\n假设存在这样的数，那么我们的方案就是将这个众数一个个单独拿出来，每个单独组成一个subsequence，直到剩下的那个大subsequence满足条件为止。\n令 $len = (r-l+1)$，$f$ 为众数出现次数。\n设我们拿走了 $x$ 个众数。那么有：$\\lceil\\frac{len-x}{2}\\rceil = f-x$，注意到 $\\lceil\\frac{len-x}{2}\\rceil = \\frac{len-x+1}{2}$，则有 $\\frac{len-x+1}{2} = f-x$，推出 $x = 2f-len-1$，再加上单独分出来的那个大subsequence，答案就是 $x+1 = 2f-len$。\n• 当然，如果懒得推公式，也可以直接利用倍增思想模拟 $x$ 的值。（见主席树代码中的倍增部分）\n 求一个区间出现次数大于一半的数字，主席树的模版了。具体做法看代码。\n 我们要重点讲一下的是随机化算法。\n首先我们要预处理出 每个数字 出现的位置，用 vector\u0026lt;int\u0026gt; pos[maxn] 来维护。\n这样，每次询问 $[l,r]$，我们对于任何一个数字 $x$ 都可以求出 $x$ 在 $[l,r]$ 内出现的次数！\nauto itr1 = lower_bound(pos[x].begin(), pos[x].end(), l); auto itr2 = upper_bound(pos[x].begin(), pos[x].end(), r); int cnt = itr2 - itr1;  现在，我们需要找到这个区间内，最多的出现次数。\n那么一个随机化的算法就是：\n有放回的，从 $[l,r]$ 中随机选取 $40$ 个元素，将每个元素的出现次数取最大值。\n假设出现次数超过一半的数字存在，那么它在 $40$ 次随机选择中，都没有被选到的概率最多为 $2^{-40}$。\n 主席树代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; const int maxm = 2e7+5; struct node { int lc, rc, cnt; } tr[maxm]; int root[maxn], id = 0; int build(int l, int r) { int cur = ++id; if (l == r) { return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; // 复制一份上个版本 tr[cur].cnt++; // 添加了一个节点 if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) tr[cur].rc = insert(tr[cur].rc, mid+1, r, p); return cur; } // query the most number in this segment [pre,cur] int query(int pre, int cur, int l, int r, int k) { if (l == r) return tr[cur].cnt - tr[pre].cnt; int prelc = tr[pre].lc, lc = tr[cur].lc; int prerc = tr[pre].rc, rc = tr[cur].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc].cnt - tr[prelc].cnt; int rcnt = tr[rc].cnt - tr[prerc].cnt; if (lcnt \u0026gt; k) return query(prelc, lc, l, mid, k); if (rcnt \u0026gt; k) return query(prerc, rc, mid+1, r, k); return -1; } int main() { int n,q; read(n); read(q); root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; i++) { int a; read(a); root[i] = insert(root[i-1], 1, n, a); } while (q--) { int l,r; read(l); read(r); int len = r-l+1; if (len == 1) { write(1); continue; } int k = len / 2 + (len\u0026amp;1); int res = query(root[l-1], root[r], 1, n, k); if (res == -1) { write(1); continue; } int ans = 1; // 懒得推公式，直接用倍增进行模拟 for (int j = 19; j \u0026gt;= 0; j--) { int d1 = (1\u0026lt;\u0026lt;j); int len2 = len - d1; int res2 = res - d1; if (res2 \u0026gt; len2/2 + (len2\u0026amp;1)) { res -= d1; len -= d1; ans += d1; } } while (res \u0026gt; len/2 + (len\u0026amp;1)) { res--; len--; ans++; } write(ans); } }   随机化代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int arr[maxn]; const int T = 40; vector\u0026lt;int\u0026gt; pos[maxn]; void solve(int l, int r) { int cnt = 0; for (int t = 1; t \u0026lt;= T; t++) { int p = randint(l,r); int cur = arr[p]; auto itr1 = lower_bound(pos[cur].begin(), pos[cur].end(), l); auto itr2 = upper_bound(pos[cur].begin(), pos[cur].end(), r); cnt = max(cnt, itr2 - itr1); } int len = r-l+1; if (cnt \u0026lt;= (len+1)/2) { write(1); } else { write(2 * cnt - len); } } int main() { int n,q; read(n); read(q); for (int i = 1; i \u0026lt;= n; i++) { read(arr[i]); pos[arr[i]].push_back(i); } while (q--) { int l,r; read(l); read(r); solve(l,r); } }   ","date":"2021-04-22T12:07:06+08:00","permalink":"https://tom0727.github.io/post/044-cf1516-tutorial/","tags":["",""],"title":"Codeforces Round #717 (Div.2) 解题报告"},{"categories":["算法"],"contents":"定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。\n树的直径有以下性质：（以下，我们假设所有边上的权值均 $\\geq 0$）。\n  直径一定是由两个 leaf 组成\n  对于任意一个节点 $u$，距离它最远的一个节点，必然为直径的其中一端。\n  在一棵树上，任取两个点集 $S_1, S_2$，设 $S_1$ 这个点集的直径是 $(u_1,v_1)$，设 $S_2$ 这个点集的直径是 $(u_2, v_2)$，那么令 $S = S_1 \\cup S_2$。则点集 $S$ 的直径只可能为以下 $6$ 种的之一：\n$$(u_1, v_1), (u_2, v_2), (u_1, u_2), (u_1, v_2), (v_1, u_2), (v_2, u_2)$$\n即，新的直径一定由原先 $4$ 个端点组成。\n  证明：第二个性质 我们设直径是 $(s,t)$，并且设节点 $a$ 距离最远的节点是 $b$，其中 $b \\neq s, b \\neq t$。\nCase1：$a$ 位于直径 $(s,t)$ 上：\n如上，有 $L_1 \u0026gt; L_2$，$L_1 \u0026gt; L_3$。且 $L_2 + L_3$ 为直径。\n那么 $L_1 + L_3 \u0026gt; L_2 + L_3$，$L_1 + L_2 \u0026gt; L_2 + L_3$。\n所以 $L_1 + L_3$ 或者 $L_1 + L_2$ 才是直径。contradiction。\n Case2：$(a,b)$ 之间的路径横穿了 $(s,t)$，交点为 $x$。\n如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 \u0026gt; L_1 + L_3$，$L_1 + L_2 \u0026gt; L_1 + L_3$。\n那么 $L_2 \u0026gt; L_3$，$L_2 \u0026gt; L_4$。\n所以 $L_2 + L_3 \u0026gt; L_3 + L_4$，$L_2 + L_4 \u0026gt; L_3 + L_4$。\n所以 $L_2 + L_3$ 或者 $L_2 + L_4$ 才是直径。contradiction。\n Case3：$(a,b)$ 之间的路径没有穿过 $(s,t)$，但是 $(a,b)$ 路径上，有一个距离 $(s,t)$ 最短的点 $x$，并且这个 $x$ 通过 $y$ 与 $(s,t)$ 相交。\n如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 \u0026gt; L_1 + L_5 + L_4$，$L_1 + L_2 \u0026gt; L_1 + L_5 + L_3$。\n所以有 $L_2 \u0026gt; L_5 + L_4$，$L_2 \u0026gt; L_5 + L_3$。\n所以 $L_3 + L_5 + L_2 \u0026gt; L_3 + L_4$，$L_4 + L_5 + L_2 \u0026gt; L_3 + L_4$。\n所以 $L_3 + L_5 + L_2$ 或者 $L_4 + L_5 + L_2$ 才是直径。contradiction。\n • 第三个性质的证明不会，先咕着\n求树的直径 求树的直径有两种方法：两次DFS 和 DP。\n法一：两次DFS（推荐） 由性质 $2$，我们可以以任意节点为根，进行DFS。得到一个距离最远的点 $u$ （这个节点的深度最深）。\n然后再以 $u$ 为根，进行第二次DFS。得到距离最远的点 $v$。那么 $(u,v)$ 就是直径了。\n两次DFS：代码 int n, dep[maxn], d1, d2; // d1: 直径一端，d2: 直径另外一端 void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dep[to] = dep[u] + 1; dfs1(to, u); } } int main() { dep[1] = 0; dfs1(1, 0); // 第一次 DFS (以 1 为根) d1 = 1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d1]) { d1 = u; } } dep[d1] = 0; dfs1(d1, 0); // 第二次 DFS (以直径端点 d1 为根) d2 = d1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d2]) { d2 = u; } } }   法二：树形DP 固定 $1$ 为根。记录每个节点向下，最远能延伸的两个节点的距离 $d_1,d_2$，那么直径就是所有 $d_1+d_2$ 的最大值。\n树形DP：代码 int d1[maxn], d2[maxn], d; // d 是直径的值 void dfs(int u, int p) { d1[u] = d2[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); int t = d1[v] + 1; if (t \u0026gt; d1[u]) d2[u] = d1[u], d1[u] = t; else if (t \u0026gt; d2[u]) d2[u] = t; } d = max(d, d1[u] + d2[u]); } int main() { dfs(1, 0); }   例题 例1 CF911F Tree Destruction 题意\n给定一棵 $n$ 个节点的无权树，然后进行 $(n-1)$ 次以下操作，每次操作分以下三步：\n 选择两个leaf 将这两个leaf之间的距离，加到 ans 中。 将这两个leaf其中之一，删掉。  初始状态下，ans = 0。求 ans 的最大值，并且输出方案。\n其中，$2 \\leq n \\leq 2 \\times 10^5$\n 题解 利用树的直径的第二个性质：任意一个节点 $u$，距离最远的一定是直径的一端。\n所以我们要最大化最终答案，我们可以最大化每个节点的贡献。所以我们只要保留直径，先将剩下的叶子删掉就行了。\n思路如下：\n 找到直径 $(u,v)$ 使用类似于拓扑排序的方法，维护所有 deg = 1 的节点（除了直径两端的两个节点 $u,v$），将它们删去。这个过程，本质上是将直径看作树干，然后逐一拔掉所有的树枝。 最后只剩下一条直径了，从任意一端开始删除即可。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, dep[maxn], d1, d2; // d1: 直径一端，d2: 直径另外一端 void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dep[to] = dep[u] + 1; dfs1(to, u); } } ll ans = 0; struct node { int u,v,r; } path[maxn]; int tail = 0; int deg[maxn]; vector\u0026lt;int\u0026gt; leaf; int dis1[maxn], dis2[maxn]; // 初始化：找出每个节点到 d1, d2的距离 void init() { dep[d1] = 0; dfs1(d1, 0); memcpy(dis1, dep, sizeof(dep)); dep[d2] = 0; dfs1(d2, 0); memcpy(dis2, dep, sizeof(dep)); } // 第一步：拔掉所有除了 d1, d2 以外的叶子 void solve1() { for (int i = 1; i \u0026lt;= n; i++) { if (deg[i] == 1 \u0026amp;\u0026amp; i != d1 \u0026amp;\u0026amp; i != d2) leaf.push_back(i); } while (leaf.size()) { int u = leaf.back(); leaf.pop_back(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; deg[to]--; if (deg[to] == 1) { leaf.push_back(to); } } int t; if (dis1[u] \u0026gt; dis2[u]) t = d1, ans += (ll)dis1[u]; else t = d2, ans += (ll)dis2[u]; path[++tail] = {u,t,u}; } } // 第二步：拔掉直径 void solve2() { leaf.push_back(d2); while (leaf.size()) { int u = leaf.back(); leaf.pop_back(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; deg[to]--; if (deg[to] == 1) { leaf.push_back(to); } } ans += (ll)(dis1[u]); path[++tail] = {u, d1, u}; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); deg[u]++, deg[v]++; } dep[1] = 0; dfs1(1, 0); d1 = 1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d1]) { d1 = u; } } dep[d1] = 0; dfs1(d1, 0); d2 = d1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d2]) { d2 = u; } } init(); solve1(); solve2(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n-1; i++) { cout \u0026lt;\u0026lt; path[i].u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; path[i].v \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; path[i].r \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 CF1192B Dynamic Diameter 题意\n给定 $n$ 个节点的有权树，和 $q$ 次询问。\n每次询问格式为 $d ~ e$：将第 $d$ 条边的权值改为 $e$。\n在每次询问之后，回答：此时树中直径的长度。\n其中，$2 \\leq n \\leq 10^5, 1 \\leq q \\leq 10^5$。\n 欧拉序介绍 欧拉序和DFS序不同的地方在于：\n在一个节点 $u$ 访问完它的一个child $v$ 之后，回溯到 $u$ 时，也会将 $u$ 记录进序列中。\n如上图，访问的顺序如果是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 3$ 的话，得到的欧拉序就是：\n$[1,2,4,5,4,2,6,2,1,3,1]$。\n欧拉序有以下性质：\n 对于 $n$ 个节点的树，欧拉序的长度一定为 $2n-1$。 在欧拉序中任取两个index $i,j$，它分别对应的节点是 $u,v$ 的话。在 $[i,j]$ 这段欧拉序中，depth 最小的index 所对应的节点 $x$ 就是 $LCA(u,v)$。  • 例如，我们把上述欧拉序按照 depth 重新写一下，就会得到：[0,1,2,3,2,1,2,1,0,1,0]。\n我们任取其中一段，比如：[0,1,2,3,2,1,2,1,0,1,0]，那么对应的就是 $5,4,2,6$ 这几个节点。可以发现这一段中，depth 最小值为 $1$，对应的节点是 $2$。而这一段的两端，对应的就是节点 $5,6$。这说明 节点 $5,6$ 的 LCA 就是 节点 $2$。\n 证明性质 $1$：易知，每条 edge 会在欧拉序中贡献 $2$ 个位置。而根节点 $1$ 又会额外贡献一个。所以总共是 $2 \\times (n-1) + 1 = 2n-1$。\n证明性质 $2$：设一段欧拉序的两端，对应的节点分别为 $u,v$。令 $x = LCA(u,v)$。那么这一段欧拉序，一定会经过 $x$，且一定是完全在 $x$ 所在的子树内的，不可能出现在子树外的节点。所以 $x$ 一定是这一段 depth 最小的那个节点。\n 法一 欧拉序 题解 有两种方法，一种是 欧拉序，复杂度 $O(n\\log n)$。还有一种是 DFS序，时间复杂度 $O(n\\log^2 n)$。\n这里介绍一下 法一欧拉序。\n 我们固定 $1$ 为根。求出每个节点的 depth。然后求出欧拉序。\n有了欧拉序以后，我们可以用线段树维护这个欧拉序序列。我们设这个序列为 $a[]$。\n然后询问两个节点 $u,v$ 之间的距离，就可以先找到 $u$ 对应在欧拉序中的位置 $l$（可能对应多个位置，任选一个即可），$v$ 对应在欧拉序中的位置 $r$。由树上差分，可知 $u,v$ 的距离等于 $d_u + d_v - 2 \\times d_x$，则有：\n$$dist(u,v) = a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$$\n 所以整个问题可以转化为一个序列上的问题：给定一个数组 $a[]$，求：\n$$a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$$\n的最大值？（其中 $l,r$ 任选）\n这个式子有 $2$ 个变量，$l,r$，我们需要用线段树来维护一些额外信息，来将其转化为一个变量的问题。\n设\n$$D[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]\\}$$\n我们考虑固定其中一个变量（比如 $l$），那么剩下的变量就只有 $r$ 了，我们就可以考虑 $a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$。\n设\n$$rmax[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k] \\}$$\n$$lmax[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[l] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k] \\}$$\n则，我们有以下转移方程：\n$$rmax[L,R] = \\max \\begin{cases} rmax[L, mid] \\\\\nrmax[mid+1, R] \\\\\nmax[mid+1,R] - 2\\times min[L, mid] \\end{cases} $$\n$$lmax[L,R] = \\max \\begin{cases} lmax[L, mid] \\\\\nlmax[mid+1, R] \\\\\nmax[L, mid] - 2\\times min[mid+1, R] \\end{cases} $$\n$$D[L,R] = \\max \\begin{cases} D[L, mid] \\\\\nD[mid+1, R] \\\\\nmax[L, mid] + rmax[mid+1, R] \\\\\nlmax[L, mid] + max[mid+1, R] \\end{cases} $$\n最后，答案就是 $D[1,2n-1]$。\n 上述转移方程有几个点需要注意：\nQ1. 为什么 $D[L,R]$ 可以由 $max[L, mid] + rmax[mid+1, R]$ 转移而来？$rmax[mid+1, R]$ 并没有考虑到 $[L,mid]$ 这一段中的最小值啊？\nA1. 如果最终答案需要考虑到 $[L,mid]$ 这一段的最小值，那么说明 $D[L,R]$ 应该由 $lmax[L, mid] + max[mid+1, R]$ 或者 $D[L, mid]$ 转移而来。这也说明了为什么我们需要使用 $lmax, rmax$ 进行两次转移。\n• 另外，$rmax[L,R]$ 和 $lmax[L,R]$ 的转移过程同理。\n 最后一个问题：修改边的权值，怎么处理？\n因为我们所有的距离都是基于 depth 的，所以，把修改边的权值改为修改 depth 即可。\n假设有一个边 $(u,v)$，令 $v$ 为 child。设原来的权值为 $e_1$，现在改为 $e_2$，那么就相当于给 $v$ 的 subtree 中的所有节点的 depth 加上 $(e_2 - e_1)$。\n 法二 DFS序 题解 根据树的直径的性质 $3$，我们可以求出整棵树的欧拉序，然后用线段树维护点集的直径。比如 $[5,8]$ 这个区间，维护的就是欧拉序为 $[5,6,7,8]$ 的点集的直径。\n可得，$[1,n]$ 这个点集的直径就是整棵树的直径。\n然后在合并区间 $[L, mid]$ 和 $[mid+1, R]$ 时，就可以枚举 $6$ 种情况的直径长度，得到 $[L,R]$ 对应点集的直径。\n 有几个问题：\nQ1. 怎么得到每种情况的直径长度？\nA1. 和上一个方法一样，固定 $1$ 为根，然后两个节点 $(u,v)$ 之间的距离就可以利用 $d_u + d_v - 2 \\times d_{LCA(u,v)}$ 来求出。\nQ2. 修改权值时，直径会受到影响吗？\nA2. 会的。但是如果我们修改了权值，影响了一个 subtree（在DFS序上就是一段连续区间），则如果一个点集完全存在于这个 subtree 之内，就不会受到影响。我们只需要考虑 点集 与 subtree 拥有相交区间，且点集没有被完全覆盖的情况。这实际上就是线段树 update 过程中正常的 lazy tag 和 push_up() 操作。所以不需要特殊处理，该怎么写怎么写就行。\n 注：本题没有用法二来写，因为本题不需要求出直径具体的节点，只要长度。下一题会使用到法二，代码可以参见下一个例题。\n 法一 欧拉序 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; ll W; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn\u0026lt;\u0026lt;1]; // 欧拉序的 dep int in[maxn], out[maxn]; // in[u]: 节点 u 在欧拉序中的起点 int ori_dep[maxn]; // 原本在树中的depth(不算weight) int id = 0; void dfs(int u, int p, ll d) { dep[++id] = d; in[u] = out[u] = id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; ori_dep[to] = ori_dep[u] + 1; dfs(to, u, d + w); dep[++id] = d; out[u] = id; } } int m; struct tree_node { ll mini, maxi, lmax, rmax, ans; ll lazy = 0; } tr[maxn\u0026lt;\u0026lt;3]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; tr[cur].mini = min(tr[l].mini, tr[r].mini); tr[cur].maxi = max(tr[l].maxi, tr[r].maxi); tr[cur].lmax = max(max(tr[l].lmax, tr[r].lmax), tr[l].maxi - 2LL * tr[r].mini); tr[cur].rmax = max(max(tr[l].rmax, tr[r].rmax), tr[r].maxi - 2LL * tr[l].mini); tr[cur].ans = max(max(tr[l].ans, tr[r].ans), max(tr[l].maxi + tr[r].rmax, tr[r].maxi + tr[l].lmax)); } void push_down(int cur) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[cur].lazy = 0; tr[l].lazy += lazy; tr[r].lazy += lazy; tr[l].maxi += lazy; tr[r].maxi += lazy; tr[l].mini += lazy; tr[r].mini += lazy; tr[l].lmax -= lazy; tr[r].lmax -= lazy; tr[l].rmax -= lazy; tr[r].rmax -= lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].mini = tr[cur].maxi = dep[l]; tr[cur].lmax = tr[cur].rmax = -dep[l]; tr[cur].ans = 0; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, ll x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].maxi += x; tr[cur].mini += x; tr[cur].lmax -= x; tr[cur].rmax -= x; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].ans; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } ll last = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; W; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0, 0); m = 2*n - 1; build(1, 1, m); while (q--) { ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d = (d + last) % (n-1) + 1; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 e = (e + last) % W; ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); update(1, 1, m, in[v], out[v], x); last = query(1, 1, m, 1, m); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 将第 d 条边的 weight 改为 e } }   例3 Lightning Routing I 题意\n给定 $n$ 个节点的有权树，和 $q$ 次询问。\n每次询问有 $2$ 种：\n$C ~ e_i ~ w_i$：将第 $e_i$ 条边的权值改为 $w_i$\n$Q ~ v_i$：询问距离 $v_i$ 最远的节点的距离。\n其中，$1 \\leq n \\leq 10^5, 1 \\leq q \\leq 10^5$。\n 题解 和上一题完全一样。\n需要注意的是 $Q ~ v_i$ 这个询问。由树直径的基本性质，对于任意一个节点 $v$，距离最远的节点一定是直径的其中一端。那么问题可以转化为：\n先求出直径的两端，然后判断一下哪一端距离 $v$ 最远。\n• 这样的话，法一欧拉序就需要在线段树区间合并的时候，加一些额外的信息来 track 具体是哪些index被用到了转移中。\n 法一（欧拉序）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; ll W; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn\u0026lt;\u0026lt;1]; // 欧拉序的 dep int in[maxn], out[maxn]; // in[u]: 节点 u 在欧拉序中的起点 int ori_dep[maxn]; // 原本在树中的depth(不算weight) int id = 0; void dfs(int u, int p, ll d) { dep[++id] = d; in[u] = out[u] = id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; ori_dep[to] = ori_dep[u] + 1; dfs(to, u, d + w); dep[++id] = d; out[u] = id; } } int m; struct tree_node { ll mini, maxi, lmax, rmax, ans; ll lazy = 0; int mini_idx, maxi_idx, lmax_idx, rmax_idx, L, R; } tr[maxn\u0026lt;\u0026lt;3]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; if (tr[l].mini \u0026lt; tr[r].mini) { tr[cur].mini = tr[l].mini; tr[cur].mini_idx = tr[l].mini_idx; } else { tr[cur].mini = tr[r].mini; tr[cur].mini_idx = tr[r].mini_idx; } if (tr[l].maxi \u0026gt; tr[r].maxi) { tr[cur].maxi = tr[l].maxi; tr[cur].maxi_idx = tr[l].maxi_idx; } else { tr[cur].maxi = tr[r].maxi; tr[cur].maxi_idx = tr[r].maxi_idx; } if (tr[l].lmax \u0026gt; tr[r].lmax) { tr[cur].lmax = tr[l].lmax; tr[cur].lmax_idx = tr[l].lmax_idx; } else { tr[cur].lmax = tr[r].lmax; tr[cur].lmax_idx = tr[r].lmax_idx; } if (tr[l].maxi - 2LL * tr[r].mini \u0026gt; tr[cur].lmax) { tr[cur].lmax = tr[l].maxi - 2LL * tr[r].mini; tr[cur].lmax_idx = tr[l].maxi_idx; } if (tr[l].rmax \u0026gt; tr[r].rmax) { tr[cur].rmax = tr[l].rmax; tr[cur].rmax_idx = tr[l].rmax_idx; } else { tr[cur].rmax = tr[r].rmax; tr[cur].rmax_idx = tr[r].rmax_idx; } if (tr[r].maxi - 2LL * tr[l].mini \u0026gt; tr[cur].rmax) { tr[cur].rmax = tr[r].maxi - 2LL * tr[l].mini; tr[cur].rmax_idx = tr[r].maxi_idx; } if (tr[l].ans \u0026gt; tr[r].ans) { tr[cur].L = tr[l].L; tr[cur].R = tr[l].R; tr[cur].ans = tr[l].ans; } else { tr[cur].L = tr[r].L; tr[cur].R = tr[r].R; tr[cur].ans = tr[r].ans; } if (tr[l].maxi + tr[r].rmax \u0026gt; tr[cur].ans) { tr[cur].ans = tr[l].maxi + tr[r].rmax; tr[cur].L = tr[l].maxi_idx; tr[cur].R = tr[r].rmax_idx; } if (tr[r].maxi + tr[l].lmax \u0026gt; tr[cur].ans) { tr[cur].ans = tr[r].maxi + tr[l].lmax; tr[cur].L = tr[l].lmax_idx; tr[cur].R = tr[r].maxi_idx; } } void push_down(int cur) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[cur].lazy = 0; tr[l].lazy += lazy; tr[r].lazy += lazy; tr[l].maxi += lazy; tr[r].maxi += lazy; tr[l].mini += lazy; tr[r].mini += lazy; tr[l].lmax -= lazy; tr[r].lmax -= lazy; tr[l].rmax -= lazy; tr[r].rmax -= lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].mini = tr[cur].maxi = dep[l]; tr[cur].lmax = tr[cur].rmax = -dep[l]; tr[cur].ans = 0; tr[cur].mini_idx = tr[cur].maxi_idx = tr[cur].lmax_idx = tr[cur].rmax_idx = tr[cur].L = tr[cur].R = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, ll x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].maxi += x; tr[cur].mini += x; tr[cur].lmax -= x; tr[cur].rmax -= x; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].ans; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } ll query_min(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].mini; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll r1 = 1e18, r2 = 1e18; if (L \u0026lt;= mid) r1 = query_min(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) r2 = query_min(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return min(r1, r2); } ll dis(int l, int r) { if (l \u0026gt; r) swap(l,r); ll al = query_min(1, 1, m, l, l), ar = query_min(1, 1, m, r, r); ll mi = query_min(1, 1, m, l, r); return al + ar - 2LL * mi; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0, 0); m = 2*n - 1; assert(id == m); build(1, 1, m); cin \u0026gt;\u0026gt; q; while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == 'C') { // 将第 d 条边的 weight 改为 e ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); update(1, 1, m, in[v], out[v], x); } else { int v; cin \u0026gt;\u0026gt; v; v = in[v]; int L = tr[1].L, R = tr[1].R; ll dis1 = dis(L, v); ll dis2 = dis(v, R); cout \u0026lt;\u0026lt; max(dis1, dis2) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   法二（DFS序）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn]; int par[maxn][19], idcnt = 0, in[maxn], out[maxn], ver[maxn]; // in[u] ..., ver[id]: the id which corresponds to u int ori_dep[maxn]; // 原本在树中的depth(不算weight) void dfs(int u, int p) { in[u] = ++idcnt; ver[idcnt] = u; par[u][0] = p; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (to == p) continue; ori_dep[to] = ori_dep[u] + 1; dep[to] = dep[u] + w; dfs(to, u); } out[u] = idcnt; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 18; j++) { if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } int lca(int u, int v) { if (ori_dep[u] \u0026lt; ori_dep[v]) swap(u,v); u = jump(u, ori_dep[u] - ori_dep[v]); for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } if (u == v) return u; return par[u][0]; } struct tree_1 { struct tree_node_1 { ll d = 0, lazy = 0; }; tree_node_1 tr[maxn\u0026lt;\u0026lt;2]; void build(int cur, int l, int r) { if (l == r) { tr[cur].d = dep[ver[l]]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); } void push_down(int cur) { if (!tr[cur].lazy) return; int l = cur\u0026lt;\u0026lt;1, r = l|1; ll lazy = tr[cur].lazy; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].d += lazy, tr[r].d += lazy; tr[cur].lazy = 0; } void update(int cur, int l, int r, int L, int R, ll delta) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += delta; tr[cur].d += delta; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, delta); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, delta); } ll query(int cur, int l, int r, int p) { if (l == r) return tr[cur].d; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(cur\u0026lt;\u0026lt;1, l, mid, p); return query(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } ll query_dis(int id1, int id2) { ll d1 = query(1, 1, n, id1), d2 = query(1, 1, n, id2); ll u1 = ver[id1], u2 = ver[id2]; ll x = lca(u1, u2); int idx = in[x]; ll dx = query(1, 1, n, idx); return d1 + d2 - 2LL * dx; } } tr1; struct tree_2 { struct tree_node_2 { int id1, id2; // 直径的 id }; tree_node_2 tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; int l_id1 = tr[l].id1, l_id2 = tr[l].id2, r_id1 = tr[r].id1, r_id2 = tr[r].id2; ll len = -1; ll dis1 = tr1.query_dis(l_id1, r_id1); ll dis2 = tr1.query_dis(l_id1, r_id2); ll dis3 = tr1.query_dis(l_id2, r_id1); ll dis4 = tr1.query_dis(l_id2, r_id2); ll dis5 = tr1.query_dis(l_id1, l_id2); ll dis6 = tr1.query_dis(r_id1, r_id2); if (dis1 \u0026gt; len) tr[cur] = {l_id1, r_id1}, len = dis1; if (dis2 \u0026gt; len) tr[cur] = {l_id1, r_id2}, len = dis2; if (dis3 \u0026gt; len) tr[cur] = {l_id2, r_id1}, len = dis3; if (dis4 \u0026gt; len) tr[cur] = {l_id2, r_id2}, len = dis4; if (dis5 \u0026gt; len) tr[cur] = {l_id1, l_id2}, len = dis5; if (dis6 \u0026gt; len) tr[cur] = {r_id1, r_id2}, len = dis6; } void build(int cur, int l, int r) { if (l == r) { tr[cur].id1 = tr[cur].id2 = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return; // 完全覆盖不用更新 int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); } } tr2; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0); tr1.build(1, 1, n); tr2.build(1, 1, n); cin \u0026gt;\u0026gt; q; while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == 'C') { // 将第 d 条边的 weight 改为 e ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); tr1.update(1, 1, n, in[v], out[v], x); tr2.update(1, 1, n, in[v], out[v]); } else { int v; cin \u0026gt;\u0026gt; v; v = in[v]; // v 的 id 编号 int id1 = tr2.tr[1].id1, id2 = tr2.tr[1].id2; ll dis1 = tr1.query_dis(id1, v); ll dis2 = tr1.query_dis(v, id2); cout \u0026lt;\u0026lt; max(dis1, dis2) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   参考链接  https://www.luogu.com.cn/problem/solution/P6845  ","date":"2021-04-18T15:34:17+08:00","permalink":"https://tom0727.github.io/post/043-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","tags":["树论","树的直径"],"title":"树的直径"},{"categories":["算法"],"contents":"定义 分层图最短路一般用于解决一种特殊的最短路问题：\n给定一个图，在图上可以进行 $k$ 次决策（一般 $k \\leq 10$），每次决策并不影响图的结构，只会影响目前的状态/代价。\n一般可以将决策前的状态 和 决策后的状态 连接一条边，权值为决策代价。\n总体来说，套路如下：\n 给定 $k$ 次决策，将图复制成 $k+1$ 份，分别表示在进行了第 $i$ 次决策后的状态，每一份复制是一层图。 从第 $i$ 层，连单向边到第 $i+1$ 层。（有的时候并不需要专门连边，可以在跑最短路的时候顺便转移状态） 跑最短路。  例题 例1 洛谷P4568 [JLOI2011]飞行路线 题意\n给定 $n$ 个节点，$m$ 条边的无向连通图，每个边具有一个权值。\n现给出一个整数 $k$，代表我们可以免费走过最多 $k$ 条边。\n给出起点 $s$ 和终点 $t$，求 $s$ 到 $t$ 的最短路？\n其中，$2 \\leq n \\leq 10^4, 1 \\leq m \\leq 5 \\times 10^4, 0 \\leq k \\leq 10$\n 题解 分层图模版题。\n我们建立 $k+1$ 层图，当我们位于 第 $j$ 层的 $i$ 节点时，代表我们此时走到了节点 $i$，已经用掉了 $j$ 次免费机会。\n建图时：（实际上并不需要建图，跑dijkstra的时候顺便转移即可）\n 同一层的权值就和原图一样。 从 第 $i$ 层，连单向边到第 $i+1$ 层的权值为 $0$。  然后跑一下Dijkstra就可以了。\n Dijkstra 有以下几个注意的点：\n priority_queue\u0026lt;node\u0026gt; pq;，直接定义 node 的 operator\u0026lt; 函数即可，但是要注意一些细节，如下： struct node { int u, k, d; // 1. 注意，两个const都需要 // 2. pq默认是大顶，所以要反过来用 \u0026gt; bool operator\u0026lt;(const node\u0026amp; other) const { return d \u0026gt; other.d; } }; priority_queue\u0026lt;node\u0026gt; pq;   Dijkstra使用了一个 int dis[maxn][11] 数组，这是需要在 push() 时更新的，而不是 pop() 时才更新。在 push() 之前先看一下 dis 是否比当前的小，如果小，才 push()。这大大减少了pq 内的元素数量。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 5e4+5; int dis[maxn][11], head[maxn], ecnt = 1; bool vis[maxn][11]; struct Edge { int to, nxt, w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } struct node { int u, k, d; // 注意，两个const都需要 // pq默认是大顶，所以要反过来用 \u0026gt; bool operator\u0026lt;(const node\u0026amp; other) const { return d \u0026gt; other.d; } }; priority_queue\u0026lt;node\u0026gt; pq; int n,m,K,s,t; void dijkstra() { pq.push({s, 0, 0}); while (!pq.empty()) { node cur = pq.top(); pq.pop(); int u = cur.u, k = cur.k, d = cur.d; if (vis[u][k]) continue; vis[u][k] = 1; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (dis[to][k] \u0026gt; d + w) { // 同一层 dis[to][k] = d + w; pq.push({to, k, d + w}); } if (k+1 \u0026lt;= K \u0026amp;\u0026amp; dis[to][k+1] \u0026gt; d) { // 下一层 dis[to][k+1] = d; pq.push({to, k+1, d}); } } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; fill(head, head+maxn, -1); memset(dis, 63, sizeof(dis)); while (m--) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dijkstra(); int ans = 1e9; for (int k = 0; k \u0026lt;= K; k++) ans = min(ans, dis[t][k]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P3119 [USACO15JAN]Grass Cownoisseur G 见 强连通分量（SCC）的这里\n","date":"2021-04-17T22:38:10+08:00","permalink":"https://tom0727.github.io/post/042-%E5%88%86%E5%B1%82%E5%9B%BE/","tags":["分层图","最短路"],"title":"分层图最短路"},{"categories":["算法"],"contents":"定义 割点 在一个 无向图 中，如果删掉节点 $u$ 使得整个图的连通分量增加，那么 $u$ 是一个割点。\n桥 在一个 无向图 中，如果删掉一条边 $(u,v)$ 使得整个图的连通分量增加，那么 $(u,v)$ 是一个桥。\n 点双连通 一个 无向图 是 点双连通 的，当且仅当（以下表达是 equivalent 的）：\n 如果删去任意一个节点，其他节点仍然互相连通。 不包含割点（注意，这个割点是对于 这个子图 而言）。 任取两个点 $u,v$，$u,v$ 之间都存在两条 点不重复 路径。 任取 $2$ 条边，都存在一个简单环（环内不包含其他环），使得这 $2$ 条边在这个简单环内。  • 注意，如果图内只有 $2$ 个连起来的节点，它们仍然点双连通。\n• 点双连通 不具有传递性：\n如上图，$a,b$ 点双连通，$b,c$ 点双连通，但是 $a,c$ 并不点双连通（$a,c$ 不在同一个点双分量内）。\n 边双连通 一个 无向图 是 边双连通 的，当且仅当（以下表达是 equivalent 的）：\n 一个 无向图 中，如果删去任意一条边，其他节点仍然互相连通。 一个 无向图 中，不包含桥（注意，这个桥是对于 整个图 而言）。 一个 无向图 中，任取两个点 $u,v$，$u,v$ 之间都存在两条 边不重复 路径。 一个 无向图 中，任取 $1$ 条边，都存在一个简单环（环内不包含其他环），使得这条边在这个简单环内。  • 点双连通 具有传递性：\n如果 $a,b$ 边双连通，$b,c$ 边双连通，则 $a,c$ 边双连通。\n证明：$a,b$ 边双连通说明 删去图中任意一条边，$a,b$ 仍连通。同理，删去图中任意一条边，$b,c$ 仍连通。所以删去任意一条边，$a,c$ 仍连通。\n 点双连通分量 点双连通分量：一个极大的点双连通的子图。\n 如果把这个子图 单独拿出来，它不存在割点，但是它在原图中，如果它与其他点双分量相连，那么它一定包含 至少一个原图中的割点。 原图中，每个割点 存在于至少 $2$ 个点双分量中。 任意一个 非割点 只存在于一个点双分量中。  点双缩点 利用点双缩点后，得到的新图有以下性质：\n 新图 是一棵树，每个节点要么是一个点双，要么是一个割点。 所有 割点 单独成为一个节点。 点双之间以 割点 相连，并且所有割点的 degree 至少为 $2$。（任意两个点双之间，有且仅有一个公共点，且这个公共点是 割点）。  例1：\n图中的所有点双分量为：$\\{1,2,3\\}, \\{3,4,5\\}$\n图中所有割点为：$3$\n例2：\n图中的所有点双分量为：$\\{1,2\\}, \\{1,3\\}, \\{2,4\\}, \\{2,5\\}, \\{3,6\\}, \\{3,7\\}$\n图中所有割点为：$1,2,3$\n 边双连通分量 边双连通分量：一个极大的边双连通子图。\n相比点双分量来说，边双分量的定义简单很多，因为它 不需要区分 原图和子图！\n 将原图中的所有桥删掉，剩下的分量就是边双连通分量。 桥不属于任何一个边双分量，边双分量之间以桥连接。  例1：\n图中的所有边双分量为：$\\{1,2,7\\}, \\{4,5,6\\}, \\{3\\}$\n图中所有桥为：$(2,3), (2,4)$\n边双缩点 利用边双缩点后，得到的新图有以下性质：\n 新图是 一棵树，每个节点都是一个边双。 原图中 所有的桥，在新图中仍然是桥。   算法 我们利用 tarjan 算法求 割点，桥，点双，边双。\n这里的 tarjan 和 有向图求SCC 的tarjan略有不同，主要体现在：\n 有向图tarjan求SCC：需要记录当前在 栈内 的有哪些元素，更新 low[] 时，需要 to 在栈内才更新。 无向图求割点/桥/点双/边双：需要检查 to 是不是 u 的直接 parent p。（这里指的是 dfs树 内的parent关系），不需要考虑是否在栈内。  另外，求 割点 和 桥 时，也略有不同，主要体现在：\n 求割点时，需要讨论当前节点是否为DFS树的根。但是求桥时，不需要。 求割点时，条件是 $low[to] \\geq dfn[u]$。求桥时，条件是 $low[to] \u0026gt; dfn[u]$。   以下的算法，都要检查 to 是不是 u 的直接 parent p。\n割点 对于一个节点 $u$，在DFS树中，如果：\n 它是DFS树的 根节点：如果 $u$ 拥有 $\\geq 2$ 个子树，那么 $u$ 就是一个割点。 它不是DFS树的 根节点：如果 $u$ 存在一个 direct child $~to$，使得 $low[to] \\geq dfn[u]$。那么 $u$ 就是一个割点。（因为这说明 $to$ 无法到达 $u$ 的上方）  模版题\n题意\n给定一个无向图，求图的所有割点。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e4+5; const int maxm = 1e5+10; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; int dfn[maxn], low[maxn], head[maxn], ecnt = 1, n, m, id; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } vector\u0026lt;int\u0026gt; ans; void dfs(int u, int p) { dfn[u] = ++id; low[u] = id; int child = 0; // 子树数量 bool cut = 0; // 是否为割点 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // 不能直接用parent if (dfn[to]) { low[u] = min(low[u], dfn[to]); continue; } dfs(to, u); child++; low[u] = min(low[u], low[to]); if (p \u0026amp;\u0026amp; low[to] \u0026gt;= dfn[u]) cut = 1; // 如果u不是根节点，且存在 direct child使得 low[to] \u0026gt;= dfn[u]，则u是割点 } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut = 1; // 如果为根节点，且有 \u0026gt;= 2个子树 if (cut) ans.push_back(u); } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i, 0); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } tarjan(); sort(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int a : ans) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   桥 判断一个边 $(u,to)$ 是不是桥，我们设 $u$ 在DFS树中，是 $to$ 的parent。\n如果 $low[to] \u0026gt; dfn[u]$，则 $(u,to)$ 是一个桥。（因为这说明 $to$ 无法到达 $u$ 和 $u$ 的上方）。\n 实现过程中，需要注意以下几点：\n 边的编号从 $0$ 开始（记得将 head[] 初始化为 -1），这样保证了 e 和 e^1 刚好为 $(u,v)$ 和 $(v,u)$。 标记桥的时候，一次标记两个边 e 和 e^1。  代码 void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // 注意不能用parent if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { // 注意这里的条件 bridge[e] = bridge[e^1] = 1; } } } }   点双连通分量（dcc） 求点双分量，可以在求割点的时候顺便求出来。\n当我们发现 $low[to] \\geq dfn[u]$ 时，就说明 $to$ 及其子树（加上 $u$）一起形成了一个点双。\n此时，我们将 栈内的点一直pop，pop 到 to 为止（包括 to），但是 不包括 u。这是因为 u 作为割点，可能还属于别的点双分量，之后还要用到。\n• 求点双时，我们并不关心 $u$ 本身是否为割点，只要出现了 $low[to] \\geq dfn[u]$，就说明出现了一个新点双。（例如，在只有 $1,2$ 这两个点的情况下，不存在割点，但是 $1,2$ 仍然是一个点双）。\n代码 bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn]; void dfs(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) { low[u] = min(low[u], dfn[to]); } else { child++; dfs(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { // 不关心 u 是否为割点，直接开始pop from[to] = ++dcc; while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to） int cur = st[tail--]; from[cur] = from[to]; dcc_list[dcc].push_back(cur); } tail--; // tail--后，指向的是 u dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量 // from[u] = dcc; // from[u] 实际上没有意义 } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) cut[u] = 1; // 割点（非根节点） } } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut[u] = 1; // 割点（根节点） }   边双连通分量（ecc） 求边双分量，可以根据定义：删去所有的桥，剩下的连通分量，就是边双分量。\n所以求边双分量，分以下两步：\n tarjan 求出所有的桥。 进行一次 dfs()，如果 $(u,to)$ 是桥，则不经过这条边。以此求出所有的连通分量。  代码 int from[maxn]; bool bridge[maxm\u0026lt;\u0026lt;1]; void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { bridge[e] = bridge[e^1] = 1; } } } } // dfs求出所有的边双 // f 代表 from (ecc编号) void dfs(int u, int f) { from[u] = f; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥 dfs(to, f); } } int main() { // ... for (int i = 1; i \u0026lt;= n; i++) if (!from[i]) dfs(i, ++ecc); // ... }   例题 例1 洛谷P3225 [HNOI2012]矿场搭建 题意\n给定 $M$ 条边的无向图。初始状态下，每个节点没有标记。\n我们需要给节点打上标记，使得：\n删去图中的任意一个节点，其他的所有节点均可到达一个有标记的节点。\n求：标记节点的最少数量，最少标记数量的方案总数。\n其中，$M \\leq 500$，数据保证不存在单个独立点。\n 题解 首先根据 点双连通 进行缩点。缩点以后，整个图会变成一个由 割点 和 点双分量 组成的 树。\n由于点双的性质，我们知道，如果删去点双分量中的任意一个点（除割点以外），该分量仍然和其他的分量连通。\n所以我们不需要考虑删去 非割点 的情况，我们只关心如果删去了一个 割点，会不会使得有些节点无法到达有标记的节点。\n由上可知，我们 不需要标记割点（因为我们只考虑删去 割点 的情况，如果要删去割点，那说明标记割点是无意义的）。\n 对于一个点双分量而言，可以分以下情况讨论：\n 点双内含有 $\\geq 2$ 个割点：无论删去哪个割点，该分量仍然和其他分量连通，所以无需在该分量内标记。 点双内含有 $1$ 个割点：如果该割点被删了，那么这个分量就断开了，所以该分量内部需要标记 $1$ 个节点。（不标记割点），方案数为 $(sz-1)$ （因为分量里面有一个割点，要去掉标记它的可能性）。 点双内没有割点：说明这个分量本来就是独立开的（在缩点后，是单个独立节点）。所以该分量内需要标记 $2$ 个节点。方案数为 $C_{sz}^2$。   实现中的一些细节：\n 由于一个割点可能属于多个点双分量，所以我们采用 vector\u0026lt;int\u0026gt; dcc_list[maxn]; 来记录每个点双里面的节点。 对于一个割点 $u$ 来说，它的 from[] 数组没有意义。（如果需要缩点，则后续会让 from[u] = ++dcc，缩点后的 from[u] 就有意义了） 与 tarjan 求 SCC 不同，我们不需要记录节点是否在栈内。 在 pop 栈的时候，注意我们是 pop 到 to 为止（包括 to），但是 不包括 u。这是因为 u 作为割点，可能还属于别的点双分量，之后还要用到。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; int n,m, head[maxn], ecnt = 1; struct Edge { int to, nxt; } edges[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int dfn[maxn], low[maxn], id, st[maxn], tail, from[maxn], dcc; bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn]; void dfs(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) { low[u] = min(low[u], dfn[to]); } else { child++; dfs(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { from[to] = ++dcc; while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to） int cur = st[tail--]; from[cur] = from[to]; dcc_list[dcc].push_back(cur); } tail--; // tail--后，指向的是 u dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量 // from[u] = dcc; // from[u] 实际上没有意义 } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) cut[u] = 1; // 割点（非根节点） } } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut[u] = 1; // 割点（根节点） } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i, 0); } } void init() { for (int i = 1; i \u0026lt;= dcc; i++) dcc_list[i].clear(); id = 0; tail = -1; dcc = 0; n = 0; ecnt = 1; fill(cut, cut+maxn, 0); fill(from, from+maxn, 0); fill(head, head+maxn, 0); fill(dfn, dfn+maxn, 0); fill(low, low+maxn, 0); } void solve(int T) { init(); for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; n = max(n,u); n = max(n,v); addEdge(u,v); addEdge(v,u); } tarjan(); int ans1 = 0; ll ans2 = 1; for (int i = 1; i \u0026lt;= dcc; i++) { int cut_cnt = 0; int sz = dcc_list[i].size(); for (int j = 0; j \u0026lt; dcc_list[i].size(); j++) { int cur = dcc_list[i][j]; if (cut[cur]) cut_cnt++; } if (cut_cnt \u0026gt;= 2) continue; if (cut_cnt == 1) ans1++, ans2 *= (ll)(sz - 1); if (cut_cnt == 0) ans1+=2, ans2 *= (ll)(sz) * (ll)(sz-1LL) / 2LL; } printf(\u0026quot;Case %d: %d %lld\\n\u0026quot;, T, max(ans1, 2), ans2); } int main() { int T = 0; while (cin \u0026gt;\u0026gt; m \u0026amp;\u0026amp; m) { T++; solve(T); } }   例2 洛谷P5058 [ZJOI2004]嗅探器 题意\n现有 $n$ 个节点的无向图。\n给定两个节点 $a,b$，输出 最小编号的 $u$ 使得 $a,b$ 之间所有的路径都需要经过 $u$，且 $u \\neq a, u \\neq b$。\n如果无解，则输出 \u0026ldquo;No solution\u0026rdquo;。\n 题解 先点双缩点，如果 $a,b$ 在同一个点双内必然无解（根据定义，大小等于 $3$ 的点双内，任意两点之间有点不重复的路径）。\n如果 $a,b$ 在不同的点双内则说明有解，缩点后，$a,b$ 就是树上的两个节点，它们之间有唯一路径，取这个路径上编号最小的割点即可。\n 一些注意事项：\n 每个割点单独形成一个点双。 缩点得到的树，所有的边必然和 割点 相连，所以建边的时候只需要考虑割点所在的dcc，还有它旁边有哪些dcc就可以了。本题中在缩点建树的过程中，使用了数组 vector\u0026lt;int\u0026gt; cut_from[maxn];。其中 cut_from[u] 代表以 $u$ 作为割点，它neighbor的dcc编号。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 5e5+5; int n,a,b,head[maxn],ecnt = 0; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int dfn[maxn], low[maxn], dcc = 0, id = 0, st[maxn], from[maxn], tail = -1; bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn\u0026lt;\u0026lt;1]; vector\u0026lt;int\u0026gt; cut_from[maxn]; // cut_from[u] 代表以 u 作为割点，它neighbor的dcc编号 void tarjan(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { child++; tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { from[u] = ++dcc; while (st[tail] != to) { int cur = st[tail--]; from[cur] = from[u]; dcc_list[dcc].push_back(cur); } tail--; from[to] = from[u]; dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) { cut[u] = 1; } } } if (child \u0026gt;= 2 \u0026amp;\u0026amp; !p) cut[u] = 1; } vector\u0026lt;int\u0026gt; adj[maxn\u0026lt;\u0026lt;1]; // 缩点后的图 int par[maxn\u0026lt;\u0026lt;1], dep[maxn\u0026lt;\u0026lt;1]; // 缩点后，dfs树用到的数组 int mp[maxn\u0026lt;\u0026lt;1]; // map: dcc -\u0026gt; cut vertex id (只有该dcc对应的是 单个割点形成的 dcc才有用) void dfs(int u, int p) { par[u] = p; dep[u] = dep[p] + 1; for (int to : adj[u]) { if (to == p) continue; dfs(to, u); } } int ans = 1e9; void LCA(int u, int v) { int f1 = mp[u], f2 = mp[v]; if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; vector\u0026lt;int\u0026gt; path; while (d--) { path.push_back(u); u = par[u]; } path.push_back(u); while (u != v) { path.push_back(u); path.push_back(v); u = par[u], v = par[v]; } path.push_back(u); path.push_back(v); for (int c : path) { if (mp[c] == f1 || mp[c] == f2) continue; if (cut[mp[c]]) ans = min(ans, mp[c]); } } void rebuild() { for (int i = 1; i \u0026lt;= dcc; i++) { for (int j : dcc_list[i]) { if (cut[j]) cut_from[j].push_back(i); } } for (int u = 1; u \u0026lt;= n; u++) { if (cut[u]) { int fu = from[u] = ++dcc; mp[dcc] = u; dcc_list[dcc].push_back(u); for (int fv : cut_from[u]) { adj[fu].push_back(fv); adj[fv].push_back(fu); } } } } int main() { cin \u0026gt;\u0026gt; n; int u,v; fill(head, head+maxn, -1); while (cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026amp;\u0026amp; u \u0026amp;\u0026amp; v) { addEdge(u,v); addEdge(v,u); } cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) tarjan(i,0); } rebuild(); for (int i = 1; i \u0026lt;= dcc; i++) { if (!dep[i]) dfs(i,0); } LCA(from[a], from[b]); if (ans == 0 || ans == 1e9) cout \u0026lt;\u0026lt; \u0026quot;No solution\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 POJ3694 Network 题意\n给定 $N$ 个节点和 $M$ 条边的无向图，初始图是连通的。\n现在要加 $Q$ 条边（可重复），每次加边后，回答图中有多少个桥。\n其中，$1 \\leq N \\leq 10^5, N-1 \\leq M \\leq 2 \\times 10^5, 1\\leq Q \\leq 1000$\n 题解 既然是桥，那么就直接先求一个边双，然后缩点。\n边双缩点后可以得到一棵树，所有加边操作都放到这个树上来考虑。\n首先会发现，加上的新边必不可能是桥（因为图原本是连通的）。\n每次加边 $(u,v)$，如果 $u,v$ 在同一个边双里，那么不会有任何影响。\n如果 $u,v$ 不在同一个边双里，那么加上的这条新边就会在树上形成一个环，使得环内的所有边均 不再是桥。\n 那么，回忆一下 AcWing 352 暗之连锁 中，我们可以将树边看作主要边，新加上的边就转化为主要边。\n比如，我们加上 $(u,v)$，那么就给 $u,v$ 之间路径上所有的边打一个标记。被标记过的就不是桥，没标记的就都是桥。\n然而树上差分的做法只适用于离线，只有所有修改操作结束后询问才有效。\n在线的做法我们可以利用 树链剖分（询问边），每次修改前，先进行一下询问，查询有多少个在修改前是无标记的，将答案减去这个数量即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n,m, head[maxn], ecnt = 0, dfn[maxn], low[maxn], id = 0, from[maxn], ecc = 0; bool bridge[maxm\u0026lt;\u0026lt;1]; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { bridge[e] = bridge[e^1] = 1; } } } } // f 代表 from (ecc编号) void dfs(int u, int f) { from[u] = f; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥 dfs(to, f); } } vector\u0026lt;int\u0026gt; adj[maxn]; void rebuild() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; ~e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; adj[fu].push_back(fv); } } } int sz[maxn], son[maxn], top[maxn], tr_id[maxn]; int par[maxn][20], dep[maxn]; void dfs2(int u, int p) { sz[u] = 1; dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; int maxsz = -1; for (int i = 0; i \u0026lt; adj[u].size(); i++) { int to = adj[u][i]; if (to == p) continue; dfs2(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) maxsz = sz[to], son[u] = to; } } void dfs3(int u, int p, int topf) { top[u] = topf; tr_id[u] = ++id; if (son[u]) dfs3(son[u], u, topf); for (int i = 0; i \u0026lt; adj[u].size(); i++) { int to = adj[u][i]; if (to == p || to == son[u]) continue; dfs3(to, u, to); } } struct tree_node { int sum; bool lazy; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void push_down(int cur) { if (!tr[cur].lazy) return; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy = tr[r].lazy = 1; tr[l].sum = tr[r].sum = 0; } void update(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = 1; tr[cur].sum = 0; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].sum; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } void build_tree(int cur, int l, int r) { if (l == r) { tr[cur].sum = 1; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build_tree(cur\u0026lt;\u0026lt;1, l, mid); build_tree(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } int jump(int u, int d) { int j = 0; while (d) { if (d\u0026amp;1) u = par[u][j]; j++, d \u0026gt;\u0026gt;= 1; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; u = jump(u, d); if (u == v) return u; for (int j = 19; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } int curans; void update_path_helper(int u, int v) { if (v == -1) return; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); curans -= query(1, 2, ecc, tr_id[top[u]], tr_id[u]); update(1, 2, ecc, tr_id[top[u]], tr_id[u]); u = par[top[u]][0]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); curans -= query(1, 2, ecc, tr_id[u], tr_id[v]); update(1, 2, ecc, tr_id[u], tr_id[v]); } void update_path(int u, int v) { int x = LCA(u,v); int d,ux,vx; d = dep[u] - dep[x]; if (!d) ux = -1; else ux = jump(u, d-1); d = dep[v] - dep[x]; if (!d) vx = -1; else vx = jump(v, d-1); update_path_helper(u, ux); update_path_helper(v, vx); } void clearall() { fill(head, head+n+1, -1); fill(dfn, dfn+n+1, 0); fill(low, low+n+1, 0); fill(from, from+n+1, 0); fill(bridge, bridge+(m\u0026lt;\u0026lt;1)+2, 0); fill(sz, sz+ecc+1, 0); fill(son, son+ecc+1, 0); fill(top, top+ecc+1, 0); fill(tr_id, tr_id+ecc+1, 0); for (int i = 1; i \u0026lt;= 4*ecc+5; i++) tr[i].lazy = 0; for (int i = 1; i \u0026lt;= ecc; i++) for (int j = 0; j \u0026lt;= 19; j++) par[i][j] = 0; fill(dep, dep+ecc+1, 0); for (int i = 1; i \u0026lt;= n; i++) adj[i].clear(); ecnt = id = ecc = 0; } int main() { fastio; int T = 0; fill(head, head+maxn, -1); while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { T++; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } tarjan(1, 0); for (int i = 1; i \u0026lt;= n; i++) { if (!from[i]) dfs(i, ++ecc); } rebuild(); id = 0; dfs2(1, 0); dfs3(1, 0, 1); curans = ecc-1; cout \u0026lt;\u0026lt; \u0026quot;Case \u0026quot; \u0026lt;\u0026lt; T \u0026lt;\u0026lt; \u0026quot;:\\n\u0026quot;; int Q; cin \u0026gt;\u0026gt; Q; if (ecc == 1) { while (Q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } else { build_tree(1, 2, ecc); while (Q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; update_path(from[u],from[v]); cout \u0026lt;\u0026lt; curans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } clearall(); } }   参考链接  https://cloud.tencent.com/developer/article/1732615 https://oi-wiki.org/graph/bcc/ https://blog.csdn.net/fuyukai/article/details/51303292 https://blog.csdn.net/a_forever_dream/article/details/103019013 https://www.cnblogs.com/Aswert/p/14273854.html https://blog.csdn.net/qq_45458915/article/details/103672762  ","date":"2021-04-14T11:23:25+08:00","permalink":"https://tom0727.github.io/post/041-%E5%89%B2%E7%82%B9-%E6%A1%A5-bcc/","tags":["割点","桥","双连通分量"],"title":"割点 桥 点/边双连通分量（BCC）"},{"categories":["算法"],"contents":"定义 在一个 有向图 中，任意取两个节点 $(u,v)$，$u \\rightarrow v, v \\rightarrow u$ 均有路径，这样的图叫做强连通。\nSCC（强连通分量）：一个极大的强连通子图。\n缩点：当我们求出一个图中的所有 SCC 后，我们可以将每一个 SCC 缩成一个点。缩点过后，我们可以得到一个新的图，我们遍历所有 原图中的边，将原图中的边加到新图中（注意判断 自环，并且一般会出现重复边）。\n• 缩点后得到的图一定是一个 DAG（有向无环图）。\n• DAG 有着很多优秀的性质，比如可以进行 拓扑排序，可以利用 拓扑排序进行 DP 等。\n求一个有向图中的强连通分量，有两种算法，Tarjan 与 kosaraju 算法（复杂度均为 $O(n+m)$）。\nTarjan 求有向图的 SCC 算法流程 定义 $DFS$ 树为：从任意节点出发，形成的一条从上往下的生成树。\n当我们从 $u$ 访问到 direct neighbor $v$ 时，如果 $v$ 尚未被访问过，那么 $(u,v)$ 是一条 树边。否则 $(u,v)$ 是一条 非树边。\n 我们先维护一个栈 st[]，里面储存的是我们当前正在处理的 SCC。\n定义两个数组 $dfn[u], low[u]$。\n $dfn[u]$ ：DFS过程中，节点 $u$ 的编号（前序编号）。 $low[u]$ ：当前，在栈中的所有节点，以下两者的最小值：  $u$ 的子树中，所有节点 $v$ 的 $low[v]$ 最小值。 从 $u$ 出发，经过一条 非树边 达到节点 $v$ 的 $dfn[v]$ 的最小值。    void dfs(int u) { // .... in[u] = 1; // u 进栈 st[++tail] = u; // 进栈 dfn[u] = low[u] = ++id; // 前序编号 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 需要在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } // ....  经过 DFS 后，我们可以发现，在 栈内，有且仅有一个节点 $u$ 使得 $dfn[u] = low[u]$。这个节点就代表 SCC 在DFS树中的根节点。\n所以，当我们进行DFS回溯的时候，检查一下当前节点 $u$ 是否满足 $dfn[u] = low[u]$。如果满足，将栈中所有的节点（直到 $u$ 为止）全部拿出来，就是一个新的 SCC 了。\n// from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小 int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 要记得在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; // 记得这里，将在栈中的标记去掉 } tail--; in[u] = 0; // 记得这里，将在栈中的标记去掉 } }  例题 洛谷P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G 题意\n给定一个 $N$ 个节点，$M$ 条边的有向图。\n定义一个节点 $u$ 为明星，当且仅当：\n对于 任意节点 $v$ ，均有至少一条到 $u$ 的路径。\n问，图中有多少个节点是明星？\n 题解 对原图跑一次tarjan求SCC，然后缩点。\n缩点后，我们会发现 新图中只有一个明星。\n• 如果新图中有 $2$ 个明星，那么 明星 $1$ 存在到 明星 $2$ 的边，反之亦然。那么明星 $1,2$ 就属于同一个SCC，contradiction。\n并且我们会发现，明星的 out-degree 一定为 $0$，否则，明星指向的节点也是一个明星。\n所以，如果缩点后，新图满足：存在 且 仅存在 $1$ 个节点，使得它的 out-degree 为 $0$，那么有解，输出这个SCC对应的大小即可。\n 代码 const int maxn = 1e4+5; const int maxm = 5e4+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1, n,m; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; } tail--; in[u] = 0; } } int deg[maxn]; void build() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fv == fu) continue; // 记得去掉自环 deg[fu]++; } } } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); int cnt = 0, ans; for (int i = 1; i \u0026lt;= scc; i++) { if (!deg[i]) cnt++, ans = i; } if (cnt \u0026gt; 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; sz[ans] \u0026lt;\u0026lt; endl; }   kosaraju 算法 kosaraju 算法本质上利用了 正反 $2$ 次DFS 求出一个图中的强连通分量。\n算法流程   建立原图 $G$，和一个反图 $G'$（将所有的边反过来）\n  在原图 $G$ 上跑 DFS，回溯 的时候记录 ID。\n  在反图 $G'$ 上跑 DFS，起始节点的顺序是 ID从大到小。每次 DFS 的 起始节点 就代表了一个新的SCC，DFS访问到的所有节点就是这个SCC。\n  感性理解 如果将原图进行一个缩点操作，那么我们可以得到一个DAG：\n如上图，可以看出 节点 $1$ 拥有 支配地位（它能到达别的点，但是别的点无法到达它）。\n也可以说，节点 $1$ 在拓扑序中，位置最靠前。\n由于我们是 回溯 的时候才记录 ID，所以节点 $1$ 的 ID 是最大的。\n 那么，在反图 $G'$ 中，所有节点的地位反转了，节点 $1$ 的地位最低，且它在拓扑序中，位置最靠后。\n为了找到 SCC，我们希望的就是找到一个节点，使得它无法到达任何其他节点。那么节点 $1$ 就是我们想要的。\n这解释了为什么我们要 ID从大到小 进行反图的 DFS。\n 注：原图不一定连通，DFS的时候要注意。\n模版题 洛谷P2863 [USACO06JAN]The Cow Prom S\n题意\n给定 $n$ 个节点，$m$ 条边的有向图。\n求点数大于 $1$ 的SCC个数。\n 代码 const int maxn = 1e4+5; const int maxm = 5e4+5; struct Edge { int to, nxt; } edges[maxm], redges[maxm]; int head[maxn], rhead[maxn], ecnt = 1, recnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void rev_addEdge(int u, int v) { Edge e = {v, rhead[u]}; rhead[u] = recnt; redges[recnt++] = e; } int id[maxn], idcnt = 0; bool vis[maxn]; void dfs(int u) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to]) continue; // 已经访问过了，忽略 dfs(to); } id[++idcnt] = u; // 回溯的时候更新ID } int sz[maxn]; void dfs2(int u) { sz[u] = 1; for (int e = rhead[u]; e; e = redges[e].nxt) { int to = redges[e].to; if (sz[to]) continue; // 已经访问过，忽略 dfs2(to); sz[u] += sz[to]; } } int main() { int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); rev_addEdge(v,u); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) dfs(i); } int ans = 0; for (int i = n; i \u0026gt;= 1; i--) { if (!sz[id[i]]) { // 还没dfs过，说明这是一个新的SCC dfs2(id[i]); if (sz[id[i]] \u0026gt; 1) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 洛谷P3119 [USACO15JAN]Grass Cownoisseur G 题意\n给定一个 $n$ 个节点，$m$ 条边的有向图。\n现在我们需要从 $1$ 号节点出发，走一条路径，再返回到 $1$ 号节点。（每个节点可以被通过多次）。\n我们允许反向穿过一条边，但是只能反向一次。\n输出我们能够访问的 distinct 节点的最大数量。\n其中，$1 \\leq n,m \\leq 10^5$\n 题解 看到 每个节点可以被穿过多次，首先想到缩点。\n缩点后，假设我们去掉 可以反向一次 的这个条件，那么答案就是 $1$ 所属的SCC的大小。\n 因为我们只能反向一次，我们可以想到利用 分层图 的思想。\n我们先缩点，得到一个新图 $G_1$，然后将缩点后的图 复制一份，得到 $G_2$。\n对于 $G_1$ 中的每条边 $(u_1,v_1)$，我们建一条新边 $(v_1, u_2)$，从 $G_1 \\rightarrow G_2$。\n 观察到我们只能由 $G_1 \\rightarrow G_2$，又因为 $G_1 = G_2$ 且 $G_1,G_2$ 均为 DAG，所以整个图中满足以下条件：\n 无环（仍然是一个DAG） $G_1 \\rightarrow G_2$ 只能发生一次。（从 $G_2$ 无法返回 $G_1$）  所以问题就转化为：\n 在这个新图中，从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$，最多能经过多少个节点？\n 将 $G_1,G_2$（包括$G_1 \\rightarrow G_2$）中，所有边 $(u,v)$ 赋上权值 $size[v]$。那么我们只要求\n从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$ 的最长路 即可。\n • 注：最长路不能用 dijkstra，只能用 SPFA。复杂度最坏 $O(nm)$\n• 注2：对于 DAG 而言，求最长路也可以直接用 拓扑排序 + DP。复杂度 $O(n+m)$，在DAG中，可以完美替代 SPFA\n• 注3：需要特判一下原图是不是一个SCC（一般这种题都要特判一下）。如果是，直接输出答案 $n$。\n 正确性证明：我们为什么不需要考虑 重复经过某个节点，然后多算了的情况？\n答：因为我们不可能重复经过某个节点。\n证：如果我们在 $G_1$ 中经过了某个节点 $u$，说明 $1$ 是可以到达 $u$ 的。\n那么，如果在 $G_2$ 中经过了同样的节点 $u$，然后由 $u$ 又返回了 $1$。这说明 $1 \\rightarrow u \\rightarrow 1$ 是一个环。然而缩点后的图不可能有环，contradiction。\n 代码（SPFA） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Edge { int to,nxt; } edges[maxn]; int head[maxn], ecnt = 1, id = 0, scc = 0, from[maxn], sz[maxn], st[maxn], tail = -1, n, m, dfn[maxn], low[maxn]; bool in[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u) { dfn[u] = low[u] = ++id; in[u] = 1; st[++tail] = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) { low[u] = min(low[u], dfn[to]); } if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (st[tail] != u) { int cur = st[tail--]; from[cur] = from[u]; sz[scc]++; in[cur] = 0; } tail--; in[u] = 0; } } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } struct New_Edge { int to, nxt, w; } new_edges[maxn\u0026lt;\u0026lt;2]; int new_head[maxn\u0026lt;\u0026lt;1], new_ecnt = 1; void new_addEdge(int u, int v, int w) { New_Edge e = {v, new_head[u], w}; new_head[u] = new_ecnt; new_edges[new_ecnt++] = e; } void build() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; // 注意判重 new_addEdge(fu, fv, sz[fv]); // 原边 new_addEdge(fu+scc, fv+scc, sz[fv]); // 复制 new_addEdge(fv, fu+scc, sz[fu]); // 反向边 } } } int d[maxn\u0026lt;\u0026lt;1]; // 因为复制了一份，记得开2倍大小 bool inq[maxn\u0026lt;\u0026lt;1]; queue\u0026lt;int\u0026gt; q; void spfa() { q.push(from[1]); inq[from[1]] = 1; // 注意是 from[1] while (!q.empty()) { int cur = q.front(); q.pop(); inq[cur] = 0; for (int e = new_head[cur]; e; e = new_edges[e].nxt) { int to = new_edges[e].to, w = new_edges[e].w; if (d[cur] + w \u0026gt; d[to]) { // 无论是否 inq[] 都要更新 d[to] = d[cur] + w; if (!inq[to]) q.push(to); inq[to] = 1; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); spfa(); int ans = d[from[1] + scc]; // 注意是 from[1] if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   代码（拓扑排序 \u0026#43; DP） 因为其他部分完全一样，这里就省略，只保留 main() 和 DP 部分。\nvoid solve() { tail = -1; fill(dp, dp+2*scc+1, -1e9); // 注意赋值为 -inf，因为我们只关心从 from[1] 出发的部分 dp[from[1]] = 0; for (int u = 1; u \u0026lt;= 2*scc; u++) { if (!ind[u]) st[++tail] = u; } while (tail \u0026gt;= 0) { int cur = st[tail--]; for (int e = new_head[cur]; e; e = new_edges[e].nxt) { int to = new_edges[e].to, w = new_edges[e].w; dp[to] = max(dp[to], dp[cur] + w); ind[to]--; if (!ind[to]) st[++tail] = to; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); solve(); int ans = dp[from[1] + scc]; // 注意是 from[1] if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-04-12T22:02:41+08:00","permalink":"https://tom0727.github.io/post/040-scc/","tags":["tarjan","SCC","kosaraju"],"title":"强连通分量（SCC）"},{"categories":["算法"],"contents":"多重背包二进制 int n, V; int dp[2005]; void pack01(int v, int w) { for (int j = V; j \u0026gt;= v; j--) { dp[j] = max(dp[j], dp[j-v] + w); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; V; while (n--) { int v,w,s; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; int k = 1; while (k \u0026lt;= s) { pack01(v*k, w*k); s -= k; k \u0026lt;\u0026lt;= 1; } pack01(v*s, w*s); } int ans = 0; for (int j = 0; j \u0026lt;= V; j++) ans = max(ans, dp[j]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  多重背包（单调队列优化） struct node { int pos, val; } q[20005]; int head = -1, tail = 0, n, V, dp[20005]; void solve(int v, int w, int s) { for (int j = 0; j \u0026lt; v; j++) { head = 0, tail = -1; q[++tail] = {0,0}; for (int i = 1; i*v + j \u0026lt;= V; i++) { while (i - q[head].pos \u0026gt; s) head++; int cur = i*v + j; int val = dp[cur] - i*w; dp[cur] = max(dp[cur], q[head].val + i*w); while (head \u0026lt;= tail \u0026amp;\u0026amp; val \u0026gt;= q[tail].val) tail--; q[++tail] = {i, val}; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; V; for (int i = 1; i \u0026lt;= n; i++) { int v,w,s; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; solve(v,w,s); } int ans = 0; for (int j = 0; j \u0026lt;= V; j++) ans = max(ans, dp[j]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-04-11T21:42:06+08:00","permalink":"https://tom0727.github.io/post/039-%E8%83%8C%E5%8C%85/","tags":["DP","背包"],"title":"背包问题"},{"categories":["算法"],"contents":"介绍 树上差分就是将数组上的差分思想，转化到树上。\n树上差分是一种思想，很多时候树链剖分可以代替树上差分，如果询问不复杂的时候，就可以用树上差分来减少代码难度。\n经典模型 模型1 边权求和 题意\n给定一个 $N$ 个节点的树，每个边 edge上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u,v$ 之间的路径的 edge权值 加上 $d$。\n所有操作结束后，求所有边上的权值？\n 首先将树变成有根树（设 $root = 1$），我们令 dp[u] 为：从 $root$ 开始，一直到 $u$ 的路径上的所有边权，都被加上了 dp[u]。\n那么每次修改操作 $u,v,d$，令 $x = LCA(u,v)$，则修改操作是：\ndp[u] += d, dp[v] += d, dp[x] -= 2 * d\n所有修改操作结束后，我们将 dp[] 的值 从下往上 进行传递（用 dfs() 实现即可）。就可以得到所有的边权了。\n• 在 dfs(u, p) 的过程中，$(u, to)$ 这个edge的权值就是 dp[to]。\nint dp[maxn]; void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); // 注意是先 dfs, 再 dp[u] += dp[to]（从下到上） dp[u] += dp[to]; // dp[to] 就是 (u,to) 这个边的权值 } }  模型2 点权求和 题意\n给定一个 $N$ 个节点的树，每个点 vertex上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u,v$ 之间的路径的 vertex权值 加上 $d$。\n所有操作结束后，求所有点上的权值？\n 同理，令 dp[u] 为：从 $root$ 开始，一直到 $u$ 的路径上的所有点权（inclusive)，都被加上了 dp[u]。\n那么每次修改操作 $u,v,d$，令 $x = LCA(u,v)$，则修改操作是：\ndp[u] += d, dp[v] += d, dp[x] -= d, dp[par[x]] -= d\n所有修改操作结束后，我们将 dp[] 的值 从下往上 进行传递。\n• 代码同上。\n模型3 子树求和 题意\n给定一个 $N$ 个节点的树，每个点 vertex上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u$ 的子树的 vertex权值 加上 $d$。\n所有操作结束后，求所有点上的权值？\n 令 dp[u] 为：$u$ 的子树中的 vertex 权值都被加上了 dp[u]。\n那么每次修改操作 $u, d$，有：\ndp[u] += d\n所有修改操作结束后，我们将 dp[] 的值 从上往下 进行传递。（注意这里的顺序是从上往下）\nint dp[maxn]; void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; // 注意是先 dp[to] += dp[u] (从上到下)，再 dfs dfs(to, u); } }  例题 例1 AcWing 352 暗之连锁 题意\n给定一棵包含 $N$ 个节点的树，树中原先存在的边叫做主要边。\n现在给定 $M$ 个附加边。\n我们需要采取以下操作（仅能进行一次，并且步骤1，2都必须进行）：\n 选定一个主要边，删掉它。 然后选定一个附加边，删掉它。  求有多少种这样的操作，使得树断开？\n其中，$N \\leq 10^5, M \\leq 2 \\times 10^5$\n 题解 因为我们是先删除主要边，再删除附加边。在删除一个主要边 $(u,v)$ 的时候，我们只要关心删除附加边后，能否让 $(u,v)$ 断开。\n我们可以只考虑 主要边，对于附加边，我们把它们转化为 主要边。\n也就是说，对于每个附加边 $(u,v)$，我们都把 $(u,v)$ 在原来树中的路径上，所有 edge（主要边）的权值都加 $1$。\n所以，在进行删除操作的第一步（删除主要边）时，我们可以看一下这个边 $(u,v)$ 的权值。有以下三种情况：\n 权值等于 $0$：树已经断开了，附加边随便删一条即可，所以 ans += M。 权值等于 $1$：存在，且仅存在一个附加边，使得 $u,v$ 仍然连通，所以 ans++。 权值大于等于 $2$：存在多个附加边使得 $u,v$ 仍然连通，所以不可能使得树断开。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int par[maxn][19], head[maxn], ecnt = 1, n, m, dep[maxn], dp[maxn]; ll ans = 0; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u, int p) { par[u][0] = p; dep[u] = dep[p] + 1; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 18; j++) if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int diff = dep[u] - dep[v]; u = jump(u, diff); if (u == v) return u; for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs2(to, u); dp[u] += dp[to]; if (dp[to] == 0) ans += (ll)(m); if (dp[to] == 1) ans++; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); } dfs(1, 0); for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int p = LCA(u,v); dp[u]++, dp[v]++, dp[p] -= 2; } dfs2(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF1076E Vasya and a Tree 题意\n给定 $n$ 个节点的有根树（$1$ 为根）。每个vertex上都有一个权值，初始为 $0$。\n有 $m$ 个询问，每次询问：\n$u ~ d ~ x$：将 $u$ 的子树中，离 $u$ 的距离 $\\leq d$ 的所有 vertex，权值都加上 $x$。\n求所有询问结束后，每个节点上的权值？\n 法一（树上差分） 首先看一下我们怎么进行差分：\n 将 $u$ 的子树中，离 $u$ 的距离 $\\leq d$ 的所有 vertex，权值都加上 $x$。\n 我们可以将上面转化为：\n 将 $u$ 的子树权值都加上 $x$ 然后将 $u$ 距离 $= (d+1)$ 的所有 $v$ 的子树，权值都减去 $x$。   注意到，每次询问，加的都是 子树。\n那么我们可以利用 dfs() 的特点，不需要考虑每次询问加的是哪个节点，而是将询问根据 每个节点的 dep[] 来进行修改，在递归的时候自然就完成了差分，在 dfs() 回溯的时候，再把修改 revert 掉。\n具体操作如下：\n 离线处理所有的询问，记录每一个节点上，都有哪些询问。 dfs(u) 的时候，将 sum[dep[u]] += x，然后 sum[dep[u]+d+1] -= x 回溯的时候，将修改 revert，即：sum[dep[u]] -= x，然后 sum[dep[u]+d+1] += x  记得下传 dp[] 数组的值。\n 法一 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n, m, head[maxn], ecnt = 1, dep[maxn]; ll sum[maxn], ans[maxn], dp[maxn]; // dp[u] 代表u的subtree加上了多少 vector\u0026lt;pii\u0026gt; q[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u, int p) { dep[u] = dep[p] + 1; for (auto pa : q[u]) { int d = pa.first; ll x = pa.second; sum[dep[u]] += x; d = min(3e5, d + dep[u] + 1); sum[d] -= x; } dp[u] += sum[dep[u]]; ans[u] = dp[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; dfs(to, u); } for (auto pa : q[u]) { int d = pa.first; ll x = pa.second; sum[dep[u]] -= x; d = min(3e5, d + dep[u] + 1); sum[d] += x; } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } cin \u0026gt;\u0026gt; m; while (m--) { int u,d,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x; q[u].push_back({d, x}); } dfs(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   法二（BFS序 \u0026#43; 二分 \u0026#43; 差分数组） BFS序就是从上到下，从左到右，一层层的进行编号。\n求 BFS 序用一个普通的 BFS 就可以解决：\nint q[maxn], hd = -1, tail = 0, idcnt = 0, id[maxn]; void bfs() { q[++tail] = 1; while (hd \u0026lt;= tail) { int cur = q[hd++]; id[cur] = ++idcnt; mp[idcnt] = cur; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur][0]) continue; q[++tail] = to; } } }   有了 BFS 序以后，我们可以发现：\n$u$ 的子树中，离 $u$ 的距离 $= d+1$ 的所有 vertex 实际上就是 BFS 序上，一段连续的编号。\n所以，我们只要找到这一段编号即可。\n我们可以利用 二分搜索 来查找这一段编号的 左端点和右端点。\n查找端点的时候，我们看一下当前端点编号为 $mid$，往上跳 $d+1$ 格的端点编号即可。\n令 $mid$ 往上跳 $d+1$ 格的端点为 $p$：\n $id[p] \u0026lt; id[u]$：说明端点在 $x$ 的右侧，l = mid+1 $id[p] \u0026gt; id[u]$：说明端点在 $x$ 的左侧，r = mid-1 $id[p] = id[u]$：如果是在查找左端点，那么左端点在左侧，则 r = mid-1；否则右端点在右侧，则 l = mid+1。  由此可以找到左右端点，然后维护一个差分数组，进行一下区间修改即可。\n 法二 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; const int maxm = 2e5+2; int n, m, q[maxn], head[maxn], hd = 0, tail = -1, ecnt = 1, id[maxn], mp[maxn], idcnt = 0; // id[u]: vertex u的id, mp[id]: id对应的vertex u int par[maxn][20], dep[maxn]; ll sum[maxn], dp[maxn]; // sum 为差分数组, dp[u] 代表u的subtree加上了多少 struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 19; j++) { if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } void dfs(int u, int p) { dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } void bfs() { q[++tail] = 1; while (hd \u0026lt;= tail) { int cur = q[hd++]; id[cur] = ++idcnt; mp[idcnt] = cur; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur][0]) continue; q[++tail] = to; } } } inline void add(int l, int r, ll val) { if (l == -1) return; // 不存在这样的点 sum[l] += val, sum[r+1] -= val; } void update(int u, int d, ll x) { int L = -1, R = -1; int l = id[u], r = n; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; int p = jump(mp[mid], d+1); if (id[p] \u0026lt; id[u]) l = mid+1; if (id[p] \u0026gt; id[u]) r = mid-1; if (id[p] == id[u]) { L = mid; r = mid-1; } } l = id[u], r = n; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; int p = jump(mp[mid], d+1); if (id[p] \u0026lt; id[u]) l = mid+1; if (id[p] \u0026gt; id[u]) r = mid-1; if (id[p] == id[u]) { R = mid; l = mid+1; } } add(L, R, -x); add(id[u], id[u], x); } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; dfs2(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1,0); bfs(); cin \u0026gt;\u0026gt; m; while (m--) { int u,d,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x; update(u, d, x); } for (int i = 1; i \u0026lt;= n; i++) sum[i] += sum[i-1], dp[mp[i]] = sum[i]; dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 CF1467E Distinctive Roots in a Tree 题意\n给定 $n$ 个节点的树，每个节点 $i$ 上有一个值 $a_i$。\n定义一个节点 $u$ 为 distinctive root，如果：\n从 $u$ 出发，连向任意一个节点 $v$ 的路径上，不存在相同的值。\n输出整个树内，distinctive root 的数量。\n其中，$1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i \\leq 10^9$\n 题解 首先转化成有根树（以 $1$ 为根）。然后我们看，对于任意的两个具有相同权值的节点 $u,v$（$a_u = a_v$），可以分为两种情况：\n令 $x = LCA(u,v)$\n $x \\neq u, x \\neq v$ $x = u$ 或者 $x = v$   以下，用蓝色圈起来的节点，代表权值相同\n Case 1: $x \\neq u, x \\neq v$\n 可以发现，在本图中，所有 不可能为 distinctive root 的节点，为 $4$ 的子树 和 $6$ 的子树。\n  Case 2: $x = u$ 或者 $x = v$\n 在本图中，除了 节点 $6,7,14$ 以外，全都 不可能为 distinctive root。\n 由上，我们可以总结出以下结论：\n**情况1：**$x \\neq u, x \\neq v$，那么\n $u$ 的子树 $R_u$ $v$ 的子树 $R_v$  均不可能为 distinctive root。\n**情况2：**$x = u$ 或者 $x = v$，我们假设 $v$ 包含在 $u$ 的子树内。则\n $v$ 的子树 $R_v$ $u$ 外面的所有节点 $u$ 的所有child的子树（除了 $v$ 所在的那个子树以外）  均不可能为 distinctive root。\n例子：如上图中，$u = 3, v = 8$，那么 $u=3$ 有三个子树 $R_{10}, R_6, R_{16}$，因为 $v=8 \\in R_6$，所以 $R_6$ 不受影响。\n 有了上述结论，我们需要思考如何高效的处理。首先我们不可能直接枚举所有权值相同的点对 $(u,v)$。\n对于这一类问题，一个比较常见的套路是：\n维护一个 cnt[] 的桶，在 dfs() 过程中，对当前节点进行统计。\n将上述情况做一个转化：\n对于情况 $1$，我们可以转化为：当我们 dfs(u) 时，看一下 $u$ 的外面是否存在 $v$ 使得 $a_u = a_v$。如果存在，将 $u$ 的所有子树进行标记。\n对于情况 $2$，我们可以转化为：当我们 dfs(u) 时，看一下 $u$ 的某一个子树 $R_j$ 内，是否存在 $v$ 使得 $a_u = a_v$。如果存在，将 除了该子树 $R_j$ 以外 的所有子树都进行标记，然后将 $v$ 的子树 $R_v$ 也进行标记。\n 现在问题转化为：\n对于每个节点 $u$，如何知道：\n $u$ 的外面是否存在 $v$ 使得 $a_u = a_v$ ？ $u$ 的所有child $j$ 的子树 $R_j$ 内，是否存在 $v$ 使得 $a_u = a_v$ ？  这里，就要用到 桶思想。\n先预处理出整棵树的信息 all[]，其中 all[v] 代表 整棵树内 权值为 $v$ 的节点数量。\n维护一个 cnt[]，其中 cnt[v] 代表 当前遇到的 权值为 $v$ 的节点数量。\n在我们 dfs(u) 前，我们看一下 cnt[a[u]] 的值。\n在我们 dfs(u) 结束后，再看一下 cnt[a[u]] 的值。\n  如果在 dfs(u) 之前，cnt[a[u]] = 0。在 dfs(u) 结束后，cnt[a[u]] = all[a[u]]，说明 $u$ 外面不存在 $v$ 使得 $a_u = a_v$。否则，存在。\n  如果在 dfs(to) 之前（$to$ 为 $u$ 的child）和之后，cnt[a[u]] 增加了，说明 $to$ 这个child的子树内，存存在 $v$ 使得 $a_u = a_v$。\n   标记子树就是套路的树上差分了。不再赘述。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; map\u0026lt;int,int\u0026gt; all, cnt; int dp[maxn], f[maxn]; // dp代表标记，f代表处理完以后的值，大于0就说明不行 int val[maxn], head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { all[val[u]]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); } } void dfs2(int u, int p) { int v = val[u]; int pcnt = cnt[v]; cnt[v]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; int pre = cnt[v]; dfs2(to, u); if (cnt[v] - pre \u0026gt; 0) { // 里面存在 cur dp[to]--; dp[1]++; } } if (cnt[v] - pcnt \u0026lt; all[v]) { // 外面存在 cur dp[u]++; } } int ans = 0; void dfs3(int u, int p) { f[u] += dp[u]; if (f[u] == 0) ans++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; // 标记下传 dfs3(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; val[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v), addEdge(v,u); } dfs1(1, 0); dfs2(1, 0); dfs3(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例4 洛谷P1600 [NOIP2016 提高组] 天天爱跑步 题意\n给定一棵 $n$ 个节点的树。有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。所有玩家从第 $0$ 秒开始，以每秒跑 $1$ 条边的速度，沿着最短路径从 $s_i$ 跑到 $t_i$。\n现在给出 $n$ 个数字 $w_i$，对于每个数字 $i$，我们需要回答在 第 $w_i$ 秒时，有多少个玩家恰好站在节点 $i$ 上。\n• 当玩家 $i$ 跑到终点 $t_i$ 后，他会退出游戏。如果他刚好在第 $w_{t_i}$ 秒跑到了节点 $t_i$，那么他会被算入答案中。否则不会被算入。\n其中，$n,m \\leq 3 \\times 10^5, 1 \\leq s_i,t_i \\leq n, 0 \\leq w_i \\leq n$\n 题解 先考虑一下，我们能否对于每一个玩家，考虑他的贡献？\n似乎不行。因为每个节点的 $w_i$ 各不相同，我们没法将一条路径 $(s_i,t_i)$ 上的贡献直接算出来。\n 既然每个节点的 $w_i$ 不同，不妨考虑对于每个节点 $i$，我们看有多少个玩家满足条件。\n同上题一样，一个常规的套路是\n维护一个 cnt[] 的桶，在 dfs() 过程中，对当前节点进行统计。\n那么，这个桶里面需要维护什么信息？\n 首先将树变成有根树（根节点为 $1$），这样每个节点最多只有一个 parent（如果一个节点 $u$ 具有两个 parent $p_1,p_2$，则 $1,p_1,p_2,u$ 成环）。\n所以我们会发现，如果一个玩家 $(s_i,t_i)$ 可能对 $u$ 产生贡献的话，$s_i, t_i$ 的其中至少有一个在 $u$ 的子树内！\n但是，如果只是用一个 cnt[] 来记录，我们无法区分哪个是 $s_i$，哪个是 $t_i$，我们不如分开讨论。\n令 $x_i = LCA(s_i, t_i)$，则路径可以分成两段：$s_i \\rightarrow x_i$（路径上行） 和 $x_i \\rightarrow t_i$ （路径下行）。由于区分了上下行路线，也可以很方便的用 cnt[] 记录深度信息。\n 对于上行路线，只考虑 $s_i$ 的影响。如果 $u$ 在 $s_i \\rightarrow x_i$ 的上行路径上，就可以考虑 $s_i$ 带给 $u$ 的贡献。\n对于这个 $s$，只要满足 $dep[s] - dep[u] = w_u$，即：\n$$dep[u] + w_u = dep[s]$$\n所以在 dfs(u) 的过程中，第 $1$ 个需要维护的桶 ds[]，可以用来维护 dep[s] 的数量，即：\nds[d] 的值为：在 $u$ 的子树内，有多少个节点的 dep = d。\n 对于下行路线，只考虑 $t_i$ 的影响。如果 $u$ 在 $x_i \\rightarrow t_i$ 的下行路径上，就可以考虑 $t_i$ 带给 $u$ 的贡献。\n但是，我们不能单独考虑 $t_i$，因为是否产生贡献，主要是根据 $s_i$ 决定的。我们在考虑 $t_i$ 的时候无法忽略 $s_i$ 的影响。这时候我们要将 $s_i$ 和 $t_i$ 结合起来，变成一个信息，使得我们可以直接用桶来维护。\n带 $s_i$ 的信息不好维护，我们可以预先处理出 $d$，代表 $s_i,t_i$ 这两个节点之间的距离。然后从 $u \\rightarrow t$ 的距离是 $dep[t] - dep[u]$。所以只要满足 $d - (dep[t] - dep[u]) = w_u$，也就是：\n$$w_u - dep[u] = d - dep[t]$$\n所以在 dfs(u) 的过程中，第 $2$ 个需要维护的桶 dt[]，可以用来维护 d - dep[t] 的数量，即：\ndt[a] 的值为：在 $u$ 的子树内，有多少个玩家 $i$ 满足 d - dep[t] = a。\n 有了以上两个桶，就可以在 dfs() 过程中计算答案了。\n我们怎么得到仅在 $u$ 的子树 $R_u$ 内的桶信息？\n还是和上一题一样，在 dfs(u) 之前，和 dfs(u) 结束后，将桶内的值 做一个减法 就可以了！\n 但是我们还有一个问题没解决：\n我们并没有保证 $u$ 在 $s \\rightarrow x \\rightarrow t$ 的路径上！\n这样我们多算了很多答案。为了解决这个问题，我们会发现，当我们的 dfs(u) 只要离开了 $LCA(s,t) = x$ 的子树，$x$ 节点上的信息都没用了。\n所以，我们提前记录每一个节点 $u$ 作为 $LCA$ 时，$s,t$ 在桶内的信息。\n可以在 dfs(u) 离开 $u$ 的时候，减去所有满足 $LCA(s,t) = u$ 的路径 $(s,t)$ 的信息。对应下面的代码是：\nvoid dfs2(int u, int p) { /// Other logics //// // 从两个桶内减去 以u为LCA，(s,t)的桶信息 for (pii a : con[u]) { ds[a.first]--; dt[a.second]--; } } ... // 其他代码 int main() { for (int i = 1; i \u0026lt;= m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int x = LCA(s,t); //// Other logics // 预处理出 以 x为LCA, s和t的桶信息 con[x].push_back({dep[s], d - dep[t]}); } }   我们还剩最后一个问题。如果 $u$ 刚好等于 $LCA(s,t)$，且 $dep[s] - dep[u] = w_u$。\n那么 $s$ 会对 $u$ 产生一次贡献，$t$ 也会产生一次贡献。多产生了一次贡献。\n所以，我们预先看一下每一个玩家 $(s_i, t_i)$，它们的 $LCA$ 是否满足这个条件，如果满足，就事先将 ans[x]--;\n 总结一下本题：\n 将路径分为上行，下行两种。维护两个桶。 dfs() 时，对于 dfs() 前后的信息，相减来获得子树信息。 预处理 $LCA$ 为 $u$ 的所有贡献，在 dfs() 离开 $u$ 时，从桶中减去这些贡献。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,m,head[maxn],ecnt = 1, w[maxn], dep[maxn], par[maxn][20], ans[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 19; j++) { if (d\u0026amp;(1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); u = jump(u, dep[u]-dep[v]); if (u == v) return u; for (int j = 19; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } void dfs(int u, int p) { par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; dep[u] = dep[p] + 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int ds[maxn]; // 第一个桶 map\u0026lt;int,int\u0026gt; dt; // 第二个桶 int st[maxn]; // 记录 start 的数量（st[u] 代表以u为起点的路径数量） vector\u0026lt;int\u0026gt; ed[maxn]; // ed[t] 代表以 t 为终点的所有路径的 d - dep[t] 信息 vector\u0026lt;pii\u0026gt; con[maxn]; void dfs2(int u, int p) { int pds; if (dep[u] + w[u] \u0026lt; maxn) pds = ds[dep[u] + w[u]]; // dfs前，桶1的值 else pds = 0; int pdt = dt[-dep[u] + w[u]]; // dfs前，桶2的值 ds[dep[u]] += st[u]; for (int a : ed[u]) dt[a]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs2(to, u); } if (dep[u] + w[u] \u0026lt; maxn) { ans[u] += ds[dep[u] + w[u]] - pds; // dfs后，桶1的值 } ans[u] += dt[-dep[u] + w[u]] - pdt; // dfs后，桶2的值 for (pii a : con[u]) { // 从两个桶内减去所有 以u为LCA，(s,t)的桶信息 ds[a.first]--; dt[a.second]--; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; dfs(1, 0); for (int i = 1; i \u0026lt;= m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int x = LCA(s,t); int d = dep[s] + dep[t] - 2 * dep[x]; if (dep[s] - dep[x] == w[x]) ans[x]--; // 去重 st[s]++; ed[t].push_back(d - dep[t]); con[x].push_back({dep[s], d - dep[t]}); // 预处理出 以 x为LCA, s和t的桶信息 } dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例5 LOJ146 DFS序3 树上差分1 题意\n给定有 $N$ 个节点的树，根节点为 $R$。每个节点 $i$ 具有初始权值 $V_i$。\n给定 $M$ 个操作，有三种：\n$1 ~ a ~ b ~ x$：将 $a,b$ 之间的路径上所有节点权值加上 $x$。（链修改）\n$2 ~ a$：求节点 $a$ 的权值。（点查询）\n$3 ~ a$：求节点 $a$ 子树的权值和。（子树查询）\n其中，$1 \\leq N,M \\leq 10^6$。\n 题解 看起来是树链剖分的模版题，但是 $O(n\\log^2n)$ 是过不了的。\n本题可以利用 DFS序 + 树上差分 达到 $O(n\\log n)$ 的复杂度！\n首先，对于一个链 $(u,v)$，常见套路就是树上差分：\n令 $x = LCA(u,v)$。\n令 $f_u$ 为 从 $root$ 到 $u$ 的路径上，被加上了多少。\n令 $val$ 为本次修改的值。\n然后链修改就被转化为 $f_u+val, f_v + val, f_x - val, f_{par(x)} - val$ 了。\n 现在问题是，有了 $f_u$ 的值，怎么查询？\n在树上差分中，一个很常见的套路是 贡献 思想。\n对于每一个修改，我们都考虑，它对哪些节点的查询具有贡献？\n注意到 $f_u$ 是从 $root$ 到 $u$ 的路径上，被修改的值。\n 对于单点查询 $a$，我们可以发现：\n只要 $u$ 在 $a$ 的子树内，那么 $f_u$ 就可以被加到 $a$ 上，作为 $u$ 对 $a$ 的贡献。\n所以，单点查询 $a$ 就变成了：\n求 $a$ 的子树中的所有节点 $u$ 的 $f_u$ 之和。\n$$ans = \\sum\\limits_u f_u$$\n拿线段树维护一下子树中，$f_u$ 的 sum 即可。\n 对于子树查询 $a$，可以发现：\n当我们修改 $f_u$ 的时候，如果 $u$ 在 $a$ 的子树内，那么从 $a$ 到 $u$ 的这一条链上所有的节点，都应该被算入贡献当中。\n而这个贡献，刚好就是 $(d_u - d_a + 1) \\times f_u$。（$d_u$ 为 $u$ 的depth）\n但是，我们不能直接把 $(d_u - d_a + 1) \\times f_u$ 加到 $a$ 上面，因为 $a$ 的子树中，每个节点的depth不相同。\n$$ans = \\sum\\limits_u (d_u - d_a + 1) \\times f_u = \\sum\\limits_u d_uf_u + (1-d_a)\\sum\\limits_u f_u$$\n所以，线段树还需要再维护一下子树中，$d_uf_u$ 的 sum。\n 最后注意一下，每个节点有个初始的权值 $V_i$，这个拿一个 sum[] 数组单独维护一下就行，每次查询的时候记得加上。\n 本题卡常，一些卡常小技巧：\n 使用树链剖分来求 $LCA$，复杂度仍然是 $O(\\log n)$，但是常数小。 线段树query的时候，使用传入sum的reference，来进行查询。这样就不用返回查询值了。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, m, root, in[maxn], out[maxn], par[maxn], idcnt = 0, ecnt = 1, head[maxn], V[maxn]; ll sum[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int top[maxn], son[maxn], dep[maxn]; void dfs(int u, int p) { sum[u] += (ll)(V[u]); in[u] = ++idcnt; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); int sz = out[to] - in[to] + 1; if (sz \u0026gt; maxsz) { maxsz = sz; son[u] = to; } sum[u] += sum[to]; } out[u] = idcnt; } void dfs2(int u, int p, int topf) { top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); u = par[top[u]]; } if (dep[u] \u0026lt; dep[v]) return u; return v; } struct tree_node { ll fsum, dfsum; } tr[maxn\u0026lt;\u0026lt;2]; void update(int cur, int l, int r, int p, int val1, ll val2) { tr[cur].fsum += (ll)val1; tr[cur].dfsum += val2; if (l == r) return; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, val1, val2); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, val1, val2); } void query(int cur, int l, int r, int L, int R, ll\u0026amp; fsum, ll\u0026amp; dfsum) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { fsum += (ll)(tr[cur].fsum); dfsum += (ll)(tr[cur].dfsum); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(cur\u0026lt;\u0026lt;1, l, mid, L, R, fsum, dfsum); if (R \u0026gt; mid) query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, fsum, dfsum); } int main() { read(n); read(m); read(root); for (int i = 1; i \u0026lt;= n; i++) read(V[i]); for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; read(u); read(v); addEdge(u, v); addEdge(v, u); } dfs(root, 0); dfs2(root, 0, root); while (m--) { int op; read(op); if (op == 1) { int a,b,x; read(a); read(b); read(x); int lca = LCA(a,b), p = par[lca]; update(1, 1, n, in[a], x, (ll)(dep[a]) * (ll)(x)); update(1, 1, n, in[b], x, (ll)(dep[b]) * (ll)(x)); update(1, 1, n, in[lca], -x, -(ll)(dep[lca]) * (ll)(x)); update(1, 1, n, in[p], -x, -(ll)(dep[p]) * (ll)(x)); } else if (op == 2) { int a; read(a); int L = in[a], R = out[a]; ll fsum = 0, dfsum = 0; query(1, 1, n, L, R, fsum, dfsum); fsum += (ll)(V[a]); write(fsum); } else { int a; read(a); ll fsum = 0, dfsum = 0; int L = in[a], R = out[a]; query(1, 1, n, L, R, fsum, dfsum); ll res = dfsum; ll d = dep[a]; res += (1LL - d) * fsum; res += sum[a]; write(res); } } }   例6 LOJ147 DFS序4 题意\n给定有 $N$ 个节点的树，根节点为 $R$。每个节点 $i$ 具有初始权值 $V_i$。\n给定 $M$ 个操作，有三种：\n$1 ~ a ~ x$：将节点 $a$ 的权值加上 $x$。（点修改）\n$2 ~ a ~ x$：将节点 $a$ 的子树中，所有节点权值加上 $x$。（子树修改）\n$3 ~ a ~ b$：求 $a,b$ 之间的路径上所有节点权值和。（链查询）\n其中，$1 \\leq N,M \\leq 10^6$。\n 题解 和上一题思路几乎一致，仍然是考虑每个修改，对于查询的贡献。\n主要的原因在于 链 是只能通过 $f_u$ 来维护的。\n 考虑 单点修改 $a$ 对于 $f_u$ 的贡献？\n如果 $u$ 在 $a$ 的子树内，则 单点修改 $a$ 对于 $f_u$ 具有贡献 $val$。\n所以单点修改 $a$，就变成了：\n将 $a$ 的子树内，所有的 $f_u$ 加上 $val$。\n 考虑 修改 $a$ 的子树 对于 $f_u$ 的贡献？\n如果 $u$ 在 $a$ 的子树内，则修改 $a$ 的子树 对于 $f_u$ 具有贡献 $(d_u - d_a + 1) \\times val$\n所以单点修改 $a$，就变成了：\n将 $a$ 的子树内，所有的 $f_u$ 加上 $(d_u - d_a + 1) \\times val$。\n然而由于 $d_u$ 对于每个 $u$ 均不同，拆开的话就是：\n$$d_u \\times val + (1-d_a) \\times val$$\n对于 $d_u \\times val$，我们直接维护 $val$ 的 sum，在询问的时候再把 $d_u$ 乘上去。\n对于 $(1-d_a) \\times val$，我们直接加到 $f_u$ 上即可。\n 所以，在线段树中，我们维护两个值，$f_u$ 和 $g_u$。\n单点修改 $a$ 的时候，将 $a$ 的子树内，所有的 $f_u$ 加上 $val$。\n修改 $a$ 的子树时，将 $a$ 的子树内，所有的 $f_u$ 加上 $(1-d_a) \\times val$，所有的 $g_u$ 加上 $val$。\n查询 $f_u$ 的真正值 $ans$ 时，有：\n$$ans = f_u + d_u g_u$$\n 对于每个节点的初始值 $V_i$，仍然用一个 sum[] 数组单独维护一下，查询的时候记得加上。\n 注：线段树在 push_down() 和 update(L,R) 的时候，记得要考虑到当前节点的区间长度 len = (r-l+1)。\n 总结：\n例5和例6是 DFS序+树上差分+贡献思想 的优秀应用。\n但是这样的做法局限性比较强，仅适用于一些特殊情况。\n 链修改 + 点/子树查询 链查询 + 点/子树修改  上面这两种可以这样做。但是如果有 链修改 + 链查询 就必须用树链剖分来做了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, m, root, in[maxn], out[maxn], par[maxn], idcnt = 0, ecnt = 1, head[maxn], V[maxn]; ll sum[maxn]; // sum[u] 代表 root -\u0026gt; u 的链sum struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int top[maxn], son[maxn], dep[maxn]; void dfs(int u, int p) { sum[u] += (ll)(V[u]); in[u] = ++idcnt; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; sum[to] += sum[u]; dfs(to, u); int sz = out[to] - in[to] + 1; if (sz \u0026gt; maxsz) { maxsz = sz; son[u] = to; } } out[u] = idcnt; } void dfs2(int u, int p, int topf) { top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); u = par[top[u]]; } if (dep[u] \u0026lt; dep[v]) return u; return v; } struct tree_node { ll fsum, dfsum; bool lazy = 0; ll lazy_fsum, lazy_dfsum; } tr[maxn\u0026lt;\u0026lt;2]; void push_down(int cur, int L, int R) { if (!tr[cur].lazy) return; ll lazy_fsum = tr[cur].lazy_fsum, lazy_dfsum = tr[cur].lazy_dfsum; tr[cur].lazy = 0; tr[cur].lazy_fsum = tr[cur].lazy_dfsum = 0; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[l].lazy = 1, tr[r].lazy = 1; tr[l].lazy_fsum += lazy_fsum; tr[r].lazy_fsum += lazy_fsum; tr[l].lazy_dfsum += lazy_dfsum; tr[r].lazy_dfsum += lazy_dfsum; int mid = (L+R) \u0026gt;\u0026gt; 1; ll llen = (mid-L+1), rlen = (R-mid); // 记得这里有 len tr[l].fsum += llen * lazy_fsum, tr[r].fsum += rlen * lazy_fsum; tr[l].dfsum += llen * lazy_dfsum, tr[r].dfsum += rlen * lazy_dfsum; } void push_up(int cur) { tr[cur].fsum = tr[cur\u0026lt;\u0026lt;1].fsum + tr[cur\u0026lt;\u0026lt;1|1].fsum; tr[cur].dfsum = tr[cur\u0026lt;\u0026lt;1].dfsum + tr[cur\u0026lt;\u0026lt;1|1].dfsum; } void update(int cur, int l, int r, int L, int R, ll val1, ll val2) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { ll len = (r-l+1); // 记得这里有 len tr[cur].fsum += len * val1; tr[cur].dfsum += len * val2; tr[cur].lazy_fsum += val1; tr[cur].lazy_dfsum += val2; tr[cur].lazy = 1; return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, val1, val2); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val1, val2); push_up(cur); } void query(int cur, int l, int r, int L, int R, ll\u0026amp; fsum, ll\u0026amp; dfsum) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { fsum += (ll)(tr[cur].fsum); dfsum += (ll)(tr[cur].dfsum); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(cur\u0026lt;\u0026lt;1, l, mid, L, R, fsum, dfsum); if (R \u0026gt; mid) query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, fsum, dfsum); } // get the result of vertex u ll get_res(int u) { if (!u) return 0; ll fsum = 0, dfsum = 0; query(1, 1, n, in[u], in[u], fsum, dfsum); ll res = fsum + (ll)(dep[u]) * dfsum + sum[u]; return res; } int main() { read(n); read(m); read(root); for (int i = 1; i \u0026lt;= n; i++) read(V[i]); for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; read(u); read(v); addEdge(u, v); addEdge(v, u); } dfs(root, 0); dfs2(root, 0, root); while (m--) { int op; read(op); if (op == 1) { int a,x; read(a); read(x); update(1, 1, n, in[a], out[a], x, 0); } else if (op == 2) { int a,x; read(a); read(x); ll fsum = (ll)(1-dep[a]) * (ll)(x); update(1, 1, n, in[a], out[a], fsum, x); } else { int a,b; read(a); read(b); int lca = LCA(a,b), p = par[lca]; ll r1 = get_res(a), r2 = get_res(b), r3 = get_res(lca), r4 = get_res(p); ll res = r1+r2-r3-r4; write(res); } } }   参考链接  https://www.acwing.com/blog/content/324/ https://loj.ac/d/1698  ","date":"2021-04-05T15:02:19+08:00","permalink":"https://tom0727.github.io/post/037-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/","tags":["树上差分","树"],"title":"树上差分"},{"categories":["算法"],"contents":"介绍 主席树全名叫做 可持久化权值线段树，一般用于一个数组上，有以下的功能：\n 对于每一个区间 都能 开一个权值线段树。 能够维护数组的 历史版本。（仅用于单点插入/修改）  思想 节点的复制 主席树的主要思想在于，对于在线段树上的单点修改，如果要维护多个版本（修改前和修改后），我们可以复制出新的节点，来维护新版本的信息。\n由于单点修改仅会影响一条链（从叶子节点，一直到根节点），所以每个版本最多会复制出 $O(\\log n)$ 个新节点。\n如上图，橙色部分就是一个新版本，复制出来了一条链。\n• 因为复制节点，所以也需要 动态开点。\n来一道例题：\n例1 洛谷 P3919 【模板】可持久化线段树 1（可持久化数组）\n题意\n维护一个长度为 $N$ 的数组，共有 $M$ 次询问。询问格式如下：\n$v ~ 1 ~ p ~ x$：在版本 $v$ 的基础上，将 $a_p$ 修改为 $x$\n$v ~ 2 ~ p$：在版本 $v$ 的基础上，询问 $a_p$ 的值\n每次询问后，都生成一个新版本。（所以共有 $M+1$ 个版本）\n 题解 可持久化的操作在上面说过了。对于每一次修改，都 复制一条链。如果是操作 $2$，复制根节点就可以了。\n可持久化的复制节点方式和普通的动态开点略有不同，主要体现在：\n 不需要看 cur == 0 与否，直接复制即可，并且将复制后的编号返回。 需要记录 上一个版本 的 同位置 节点的标号 pre 需要 build 操作 root[0] = build(1,n)，因为初始状态无论是否为空，都需要把线段树开好，否则后面无法复制（也无法进行相减操作）。  访问不同版本的线段树时，就访问它们的 root 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = 3e7; int n,m,root[maxn],id, arr[maxn]; struct node { int lc,rc,val; } tr[maxm]; int build(int l, int r) { // 参数中没有 cur int cur = ++id; // 直接添加 if (l == r) { tr[cur].val = arr[l]; return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } // 将位置p 的值修改为 x // pre 是前一个版本的 同位置节点 int insert(int pre, int l, int r, int p, int x) { int cur = ++id; tr[cur] = tr[pre]; if (l == r) { tr[cur].val = x; return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p, x); if (p \u0026gt; mid) tr[cur].rc = insert(tr[pre].rc, mid+1, r, p, x); return cur; } int query(int cur, int l, int r, int p) { if (l == r) return tr[cur].val; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(tr[cur].lc, l, mid, p); else return query(tr[cur].rc, mid+1, r, p); } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; root[0] = build(1,n); // 注意需要 build(1,n)，这是版本 0 } int main() { init(); for (int i = 1; i \u0026lt;= m; i++) { int v, op, p; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; op \u0026gt;\u0026gt; p; if (op == 1) { int x; cin \u0026gt;\u0026gt; x; root[i] = insert(root[v], 1, n, p, x); } else { int res = query(root[v], 1, n, p); // 版本 v 的根 cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; root[i] = root[v]; } } }   区间询问（两个线段树相减） 区间问题常用的一个思想是 前缀和。\n那么对于一个数组 $a_1,a_2,\u0026hellip;,a_n$，我们可以维护 $n+1$ 个版本的权值线段树。分别维护了 $sum_0, sum_1, sum_2, \u0026hellip;, sum_n$ 的信息。\n例如，$sum_0$ 是一个空的权值线段树（已经 build() 过的），$sum_3$ 这个权值线段树维护的就是 $a_1,a_2,a_3$ 这个数组的信息。\n要求 $sum_3$，我们在 $sum_2$ 的基础上，将 $a_3$ 的信息加进 $sum_2$（单点修改），形成一个新版本的权值线段树即可。\n那么，如果我们要求 $[L,R]$ 这个区间对应的权值线段树，只要求出 $sum_r - sum_{l-1}$ 对应的权值线段树就可以了！\n线段树之间怎么相减？把对应节点维护的值相减一下即可！\n 以上就是主席树的全部内容了，本质上是 节点复制 + 线段树相减。\n这样，对于每一个区间，都可以获得一个权值线段树。\n例题 例2 洛谷P3834 【模板】可持久化线段树 2（主席树） 题意\n给定 $N$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，和 $m$ 个询问，每次询问 $[L,R]$ 之间的第 $k$ 小值。保证询问合法。\n其中，$1 \\leq n,m \\leq 2 \\times 10^5, |a_i| \\leq 10^9$\n 题解 思考一个问题能否用主席树，我们可以先思考，对于整个数组，我们能否用权值线段树解决？\n答案是可以的！如果我们要求整个数组的第 $k$ 小，可以将所有数字先离散化成排名，然后用权值线段树来维护各个排名的数量。求可以求出第 $k$ 小了！\n所以主席树可以解决，步骤如下：\n 对整个数组进行离散化 维护主席树，对于每一个 $[L,R]$ 都可以获得一个权值线段树，然后可以求得第 $k$ 小。   注：离散化的一个很方便的写法是 struct + sort()，然后遍历 sort 后的数组：\nint arr[maxn]; int N = 0, rk[maxn], val[maxn]; // N: 排名数，rk[i]: arr[i]的排名，val[i]: 排名为i的数字的值 void init() { for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i].val, arr[i].id = i; sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026lt; b.val; }); rk[arr[1].id] = ++N; val[1] = arr[1].val; for (int i = 2; i \u0026lt;= n; i++) { if (arr[i].val \u0026gt; arr[i-1].val) N++; rk[arr[i].id] = N; val[N] = arr[i].val; } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 1e7; int n,m; struct Num { int val, id; } arr[maxn]; int rk[maxn], val[maxn]; // rk[1] 代表 arr[1] 离散化后的值（排名）, val[1] 代表整个array中第1小的值 int N = 0; struct node { int lc, rc, cnt; } tr[maxm]; int root[maxn], id = 0; int build(int l, int r) { int cur = ++id; if (l == r) { return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } // pre 是上个版本的节点 // 令 p 位置的 cnt += 1 int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; // 复制一份上个版本 tr[cur].cnt++; // 添加了一个节点 if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) tr[cur].rc = insert(tr[cur].rc, mid+1, r, p); return cur; } // 查询 tr[pre,cur] 之间的第k小，返回具体的值 int query(int pre, int cur, int l, int r, int k) { if (l == r) return val[l]; int prelc = tr[pre].lc, lc = tr[cur].lc; int prerc = tr[pre].rc, rc = tr[cur].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc].cnt - tr[prelc].cnt; if (lcnt \u0026gt;= k) return query(prelc, lc, l, mid, k); // 如果左边有 \u0026gt;= k 个数 else return query(prerc, rc, mid+1, r, k-lcnt); // 否则只看右边 } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i].val, arr[i].id = i; sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026lt; b.val; }); rk[arr[1].id] = ++N; val[1] = arr[1].val; for (int i = 2; i \u0026lt;= n; i++) { if (arr[i].val \u0026gt; arr[i-1].val) N++; rk[arr[i].id] = N; val[N] = arr[i].val; } root[0] = build(1, N); for (int i = 1; i \u0026lt;= n; i++) { root[i] = insert(root[i-1], 1, N, rk[i]); } } int main() { init(); for (int i = 1; i \u0026lt;= m; i++) { int l,r,k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; int ans = query(root[l-1], root[r], 1, N, k); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例3 CF1422F Boring Queries 题意\n给定 $n$ 个正整数 $a_1, a_2, \u0026hellip; , a_n$，$q$ 次询问。\n每次询问 $[x,y]$，为了保证询问在线，记上一次询问的答案为 $last$，然后令 $L = ((x+last) \\text{ mod } n) + 1$，$R = ((y+last) \\text{ mod } n) + 1$，如果 $L \u0026gt; R$，则交换 $L,R$。\n每次询问，回答 $[L,R]$ 之间所有数的 LCM，答案对 $10^9+7$ 取模。\n其中，$1 \\leq n,q \\leq 10^5, 1 \\leq a_i \\leq 2 \\times 10^5, 1 \\leq x,y \\leq 10^5$\n 题解 本题主要有两个难点：\n 所有询问在线。 $LCM$ 数字极大，且需要取模，无法正常维护。  因为 $LCM$ 的值极大，且取模，可以考虑 质因数分解。\n但是，$a_i \\leq 2 \\times 10^5$，我们无法直接维护每一个质因子。\n这时候可以考虑 根号分治，将质因子分为两部分：\n一部分是 $\\leq \\sqrt {(2 \\times 10^5)}$ 的质因子。\n还有一部分是 $\u0026gt; \\sqrt {(2 \\times 10^5)}$ 的质因子。\n 对于 $\\leq \\sqrt {(2 \\times 10^5)}$ 的质因子，我们会发现这种小因子只有 $87$ 个。所以我们只要维护 $87$ 个 ST表 来维护每个小因子在区间内的最大次数即可。\n 对于 $\u0026gt; \\sqrt {(2 \\times 10^5)}$ 的质因子，我们会发现它们的出现次数最多为 $1$，并且对于任意一个 $a_i$，它最多只能包含一个这样的大因子。\n所以对于大因子而言，求 $LCM$ 就转化为：\n求一个区间内，有哪些不同的大因子出现过，将这些 unique 的大因子乘起来就可以了！\n 那么，如何解决如下的问题？\n 给定一个数组，询问一个区间，求该区间内 所有不同的数的乘积。\n 这个问题，我们在 HH的项链 中见到过。\n但是这个题 强制在线，没法用上面的离线方法来解决。\n所以，我们维护一个 pr[] 数组，其中 pr[i] 代表：对于 i，上一个值等于 arr[i] 的 index 的值。\n（即：pr[i] = j，其中 arr[j] = arr[i], j \u0026lt; i）\n在询问 $[L,R]$ 时，我们将问题转化为：\n 求区间内所有 arr[i] 的乘积，使得：\n  $i \\in [L,R]$\n  pr[i] \u0026lt; L\n   这个问题可以用 主席树 解决。我们根据 pr[i] 的值来建主席树，树上节点的值就维护乘积。线段树相减 就用 乘积的逆元 来实现。\n 最后总结一下本题的步骤：\n 欧拉筛求出所有质数。 维护 $87$ 个小于等于 $450$ 的小质因子，建立 $87$ 个ST表。 建好大因子的主席树。   本题空间卡的非常紧，我们将 ST表 的数组改为了 short 类型，可以避免 MLE。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 1e5+2; const int maxm = 2e5+2; vector\u0026lt;int\u0026gt; primes; bool is_prime[maxm]; int n, arr[maxn]; void euler() { fill(is_prime, is_prime+maxm, 1); for (int cur = 2; cur \u0026lt; maxm; cur++) { if (is_prime[cur]) primes.push_back(cur); for (auto p : primes) { if (p * cur \u0026gt;= maxm) break; is_prime[p*cur] = 0; if (cur % p == 0) break; } } } short st[87][maxn][18]; short bin[maxn]; int ask_st(int i, int l, int r) { int len = (r-l+1); int k = bin[len]; return max(st[i][l][k], st[i][r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 0; i \u0026lt;= 86; i++) { int p = primes[i]; for (int j = 1; j \u0026lt;= n; j++) { int cnt = 0; while (arr[j] % p == 0) { arr[j] /= p, cnt++; } st[i][j][0] = cnt; } for (int k = 1; k \u0026lt; 18; k++) { for (int j = 1; j+(1\u0026lt;\u0026lt;k)-1 \u0026lt;= n; j++) { st[i][j][k] = max(st[i][j][k-1], st[i][j+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } } } struct node { int lc,rc; ll val = 1; } tr[maxn\u0026lt;\u0026lt;5]; int id, root[maxn], pr[maxn]; inline ll qpow(ll a, ll b) { if (!b) return 1; ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].val = (tr[lc].val * tr[rc].val) % mod; } int insert(int pre, int l, int r, int p, ll x) { int cur = ++id; tr[cur] = tr[pre]; (tr[cur].val *= x) %= mod; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p, x); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p, x); push_up(cur); return cur; } // 询问 [pre, cur] 之间的大质数之积, 且保证 pr[i] \u0026lt; p ll query(int pre, int cur, int l, int r, int p) { if (r \u0026lt; p) return (tr[cur].val * inv(tr[pre].val)) % mod; if (l \u0026gt;= p) return 1; int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 1; (res *= query(tr[pre].lc, tr[cur].lc, l, mid, p)) %= mod; (res *= query(tr[pre].rc, tr[cur].rc, mid+1, r, p)) %= mod; return res; } int pos[maxm]; void init() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; euler(); build_st(); root[0] = build(0,n); for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; pr[i] = pos[val]; pos[val] = i; } for (int i = 1; i \u0026lt;= n; i++) { root[i] = insert(root[i-1], 0, n, pr[i], arr[i]); } } ll last = 0; ll Query(ll L, ll R) { L += last, R += last; L %= n, R %= n; L++, R++; if (L \u0026gt; R) swap(L,R); ll big = query(root[L-1], root[R], 0, n, L); ll small = 1; for (int i = 0; i \u0026lt;= 86; i++) { ll p = primes[i]; int c = ask_st(i,L,R); (small *= qpow(p,c)) %= mod; } last = (small * big) % mod; return last; } int main() { init(); int q; cin \u0026gt;\u0026gt; q; while (q--) { ll L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; cout \u0026lt;\u0026lt; Query(L,R) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P2468 [SDOI2010]粟粟的书架 题意\n给定一个 $R \\times C$ 的矩阵，矩阵中所有元素均为正整数，有 $M$ 个询问，每次询问：\n$x_1 ~ y_1 ~ x_2 ~ y_2 ~ H$：求 $(x_1,y_1)$ 和 $(x_2,y_2)$ 之间的矩形中，最少取多少个数字可以让数字之和 $\\geq H$？\n数据范围：\n对于 $50$ % 的数据，有 $R,C \\leq 200, M \\leq 2 \\times 10^5$\n对于另外 $50$ % 的数据，有 $R = 1, C \\leq 5 \\times 10^5, M \\leq 2 \\times 10^4$\n矩阵中所有元素满足值在 $[1, 1000]$ 之间，$H \\leq 2 \\times 10^9$\n 题解 我们需要让数字之和尽量大，那么每次询问就选择最大的那些数。\n可以维护主席树，以元素的值作为权值，节点之中维护 $cnt$ 和 $sum$。\n对于 $R = 1$ 的情况很好解决。那么对于 $R \\leq 200$ 呢？\n有两种方法，\n法一：维护 $200$ 棵主席树\n询问的过程中，把每一行的线段树都进行 相加 （具体实现通过维护 vector\u0026lt;int\u0026gt; pre, vector\u0026lt;int\u0026gt; cur）。\n 法二：维护二维前缀和\nsum[i][j][k] 代表 $(1,1)$ 和 $(i,j)$ 之间矩阵之中，数值 $\\geq k$ 的数字的和\ncnt[i][j][k] 代表 $(1,1)$ 和 $(i,j)$ 之间矩阵之中，数值 $\\geq k$ 的数字的数量\n询问的时候，二分一下 $k$ 就可以了。\n以下给出主席树代码。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct node { int lc, rc, sum, cnt; } tr[maxn\u0026lt;\u0026lt;5]; int n,m,Q, id = 0; vector\u0026lt;int\u0026gt; sum[201]; vector\u0026lt;int\u0026gt; arr[201]; vector\u0026lt;int\u0026gt; root[201]; int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].sum += p; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } pii query(vector\u0026lt;int\u0026gt;\u0026amp; pre, vector\u0026lt;int\u0026gt;\u0026amp; cur, int l, int r, int need) { if (need \u0026lt;= 0) return {0,0}; int allsum = 0, allcnt = 0; for (int i = 0; i \u0026lt; pre.size(); i++) { int p = pre[i], c = cur[i]; allsum += tr[c].sum - tr[p].sum; // 200棵线段树相加 allcnt += tr[c].cnt - tr[p].cnt; } if (allsum \u0026lt;= need) return {allcnt, allsum}; if (l == r) return {(need/l + (need % l \u0026gt; 0)), (need/l + (need % l \u0026gt; 0)) * l}; int mid = (l+r) \u0026gt;\u0026gt; 1; vector\u0026lt;int\u0026gt; plc, lc, prc, rc; for (int i = 0; i \u0026lt; pre.size(); i++) { int p = pre[i], c = cur[i]; plc.push_back(tr[p].lc); lc.push_back(tr[c].lc); prc.push_back(tr[p].rc); rc.push_back(tr[c].rc); } int needcnt = 0, needsum = 0; pii res = query(prc, rc, mid+1, r, need); need -= res.second; needcnt += res.first; needsum += res.second; res = query(plc, lc, l, mid, need); needcnt += res.first; needsum += res.second; return {needcnt, needsum}; } bool ok(int x1, int y1, int x2, int y2, int tar) { int res = 0; for (int i = x1; i \u0026lt;= x2; i++) { res += sum[i][y2] - sum[i][y1-1]; } return res \u0026gt;= tar; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= n; i++) { sum[i] = arr[i] = root[i] = vector\u0026lt;int\u0026gt;(m+1,0); root[i][0] = build(1, 1000); for (int j = 1; j \u0026lt;= m; j++) { int val; cin \u0026gt;\u0026gt; val; arr[i][j] = val; sum[i][j] = sum[i][j-1] + val; root[i][j] = insert(root[i][j-1], 1, 1000, val); } } } int main() { init(); while (Q--) { int x1,y1,x2,y2,tar; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; tar; if (!ok(x1,y1,x2,y2,tar)) cout \u0026lt;\u0026lt; \u0026quot;Poor QLW\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else { vector\u0026lt;int\u0026gt; cur,pre; for (int i = x1; i \u0026lt;= x2; i++) cur.push_back(root[i][y2]), pre.push_back(root[i][y1-1]); pii ans = query(pre, cur, 1, 1000, tar); cout \u0026lt;\u0026lt; ans.first \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例5 洛谷P2633 Count on a tree 题意\n给定一棵 $n$ 个节点的树，每个点 $i$ 具有权值 $a_i$。\n有 $m$ 个询问，每次询问 $u ~ v ~ k$，回答 $u \\text { xor } last$ 和 $v$ 的最短路径中，第 $k$ 小的点权。\n其中，$last$ 为上次询问的答案，且保证每次询问均合法。\n点权值的范围在 $[0, 2^{31}-1]$ 之间。\n 题解 树上主席树。\n与普通主席树不同，我们主席树中的 前缀 代表了从 parent 继承而来的部分。即，我们选定 $1$ 作为根，那么一条从上到下的路径，就形成了一个主席树上的 前缀。\ninsert() 的时候，就有如下的代码：\nint root_id = 0, root[maxn], ver_root[maxn]; // ver_root[u] 的值为 u 对应的版本的 root index void dfs(int u, int p) { root_id++; ver_root[u] = root_id; root[root_id] = insert(root[ver_root[p]], 1, N, rk[u]); // 从parent p那里继承而来 // .... }   那么，怎么将 $u,v$ 之间的路径转化为 前缀之间的加减？（也就是线段树之间的加减）\n回忆一下 树上启发式合并中，一道关于形成回文串路径的题目：CF741D\n我们当时采用的是：\n$$f_{u,v} = (f_u \\text{ xor } f_x) \\text{ xor } (f_v \\text{ xor } f_x) = f_u \\text{ xor } f_v$$\n其中 $x = LCA(u,v)$\n 那么本题的思路也一样，将路径问题转化为 $LCA$ 问题。（实际上，本质就是 树上差分）\n所以，令 $x = LCA(u,v)$，令 $f_u$ 为 $1 \\rightarrow u$ 的路径对应的线段树。\n我们发现在线段树上，$u,v$ 之间的路径 $f_{u,v}$，就是 $$f_u + f_v - f_x - f_{par(x)}$$\n那么剩下的就是经典的主席树模版，区间第 $k$ 小问题了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Num { int id, v; } nums[maxn]; struct node { int lc, rc, cnt; } tr[maxn\u0026lt;\u0026lt;5]; int n, m, arr[maxn], rk[maxn], val[maxn], N = 0, id = 0; int root[maxn]; int ecnt = 1, head[maxn], par[maxn][19], dep[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } int query(int pre1, int pre2, int cur1, int cur2, int l, int r, int k) { if (l == r) return l; int plc1 = tr[pre1].lc, prc1 = tr[pre1].rc; int plc2 = tr[pre2].lc, prc2 = tr[pre2].rc; int lc1 = tr[cur1].lc, rc1 = tr[cur1].rc; int lc2 = tr[cur2].lc, rc2 = tr[cur2].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc1].cnt + tr[lc2].cnt - tr[plc1].cnt - tr[plc2].cnt; // 线段树加减 if (k \u0026lt;= lcnt) return query(plc1, plc2, lc1, lc2, l, mid, k); else return query(prc1, prc2, rc1, rc2, mid+1, r, k-lcnt); } int jump(int u, int d) { int c = 0; while (d) { if (d\u0026amp;1) u = par[u][c]; d \u0026gt;\u0026gt;= 1, c++; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; u = jump(u, d); if (u == v) return u; for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } int root_id = 0, ver_root[maxn]; // ver_root[u] 的值为 u 对应的版本的 root index void dfs(int u, int p) { root_id++; ver_root[u] = root_id; root[root_id] = insert(root[ver_root[p]], 1, N, rk[u]); dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int Query(int u, int v, int k) { int lca = LCA(u,v); int res = query(root[ver_root[lca]], root[ver_root[par[lca][0]]], root[ver_root[u]], root[ver_root[v]], 1, N, k); return val[res]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], nums[i] = {i, arr[i]}; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); } // 离散化 sort(nums + 1, nums + 1 + n, [](auto a, auto b) { return a.v \u0026lt; b.v; }); rk[nums[1].id] = ++N; val[1] = nums[1].v; for (int i = 2; i \u0026lt;= n; i++) { if (nums[i].v \u0026gt; nums[i-1].v) { N++; } rk[nums[i].id] = N; val[N] = nums[i].v; } root[0] = build(1, N); dfs(1, 0); } int last = 0; int main() { fastio; init(); while (m--) { int u,v,k; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; k; u ^= last; last = Query(u,v,k); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例6 CF813E Army Creation 题意\n给定 $n$ 个数字 $a_1,a_2,\u0026hellip;,a_n$，给定一个数字 $k$，有 $q$ 次询问，每次询问：\n$x ~ y$：令 $L = ((x+last) \\text { mod } n) + 1, R = ((y+last) \\text { mod } n) + 1$，回答 $[L,R]$ 中，最多可以选多少个数，使得任何一个数字选择的数字次数 $\\leq k$？\n 题解 仍然是 强制在线，还是和例4的做法一样，维护 pr[] 数组：只不过维护的值改了一下：\n$pr[i] = j$，满足 $arr[i] = arr[j]$，且 $i$ 往前走 $k$ 个位置，就得到 $j$ 。\n然后每次询问就回答 $[L,R]$ 之中，有多少个 $i \\in [L,R]$ 满足 $pr[i] \u0026lt; L$。\n 预处理这个 pr[] 数组，可以通过倍增的方式（类似于 LCA）来做。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,k; int par[maxn][19], pr[maxn], id = 0, root[maxn], last = 0, arr[maxn], pos[maxn]; struct node { int lc,rc,cnt; } tr[maxn\u0026lt;\u0026lt;5]; int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } int query(int pre, int cur, int l, int r, int L) { if (r \u0026lt; L) return tr[cur].cnt - tr[pre].cnt; if (l \u0026gt;= L) return 0; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; res += query(tr[pre].lc, tr[cur].lc, l, mid, L); res += query(tr[pre].rc, tr[cur].rc, mid+1, r, L); return res; } int jump(int u, int d) { int c = 0; while (d) { if (d\u0026amp;1) u = par[u][c]; c++; d \u0026gt;\u0026gt;= 1; } return u; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { int val; cin \u0026gt;\u0026gt; val; arr[i] = val; par[i][0] = pos[val]; pos[val] = i; } root[0] = build(0, n); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= 18; j++) { par[i][j] = par[par[i][j-1]][j-1]; } pr[i] = jump(i, k); root[i] = insert(root[i-1], 0, n, pr[i]); } } int main() { init(); int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l = (l + last) % n + 1; r = (r + last) % n + 1; if (l \u0026gt; r) swap(l,r); last = query(root[l-1], root[r], 0, n, l); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例7 CF1404C Fixed Point Removal 题意\n给定长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n我们每次可以选择 $i$ 使得 $a_i = i$，然后将它删掉。删掉后，剩下的部分会合并在一起。\n现在有 $q$ 个询问，每次询问 $(x,y)$，回答：\n如果将 $a_1,a_2,\u0026hellip;,a_x$ 赋值为 $n+1$，$a_n,a_{n-1},\u0026hellip;,a_{n-y+1}$ 赋值为 $n+1$ （实际上，就是让 $a$ 的前 $x$ 个元素 和 后 $y$ 个元素变得无法删除。），我们能最多删除多少个元素？\n询问之间完全独立，互不影响。\n其中，$1 \\leq n,q \\leq 3 \\times 10^5, a_i \\in [1,n], x,y \\geq 0, x+y \u0026lt; n$\n 题解 首先，我们先不考虑询问的问题。\n对于原数组，如何求出最多删除的元素个数？\n我们会发现，当我们删除一个元素时，它右边的所有元素的 index 都会减少 $1$，这可能导致右边的元素又出现了可删除的。\n同时我们发现，如果对于 $i$，有 $a_i \u0026gt; i$，则无论怎么删除，$i$ 只减不增，这样 $a_i = i$ 永远不可能成立。\n这意味着，当出现 $a_i = i$ 时，就要立刻删除，如果它左边的元素被删了，它就再也删不掉了。\n所以对于原数组，最优的删除方法是：\n从右侧开始删，删完一个数字后，判断右边有没有出现新的可删数字，如果有的话继续从右开始。\n 有了贪心的删除策略，我们不能简单的模拟删除过程，因为这是 $O(n^2)$ 的。\n每次删除操作，我们需要对右边的元素的index 进行区间减 $1$，很明显可以用线段树来维护。\n不妨将问题转化一下，令 $b_i = i - a_i$：\n 当 $b_i = 0$ 时，可以删除，删除时，将 $[i+1,n]$ 的所有 $b_i$ 都减去 $1$。 当 $b_i \u0026lt; 0$ 时，永远都不可能删除。 当 $b_i \u0026gt; 0$ 时，如果它未来的某时刻被减为 $0$ 了，则可以被删掉。  那我们在线段树里面维护一个 $min$，代表区间最小值。\n如果一个元素 $\u0026lt; 0$，则直接把它赋值为 $10^9$，无论怎么减，它都不可能等于 $0$，代表着它是一个无效元素（永远不可能被删除，或者已经被删除）。\n每次询问一下区间最小值的位置，如果最小值为 $0$，就把这个位置 $i$ 的元素删掉，然后将 $[i+1,n]$ 都减去 $1$，然后将 $b_i$ 设为 $10^9$（代表已删除）。\n 现在有了 无询问 情况下的解，有询问怎么办？\n我们观察一下样例数组（长度为 $13$）\n$[2,2,3 ,9 ,5 ,4 ,6 ,5 ,7, 8, 3, 11, 13]$\n我们删除的 index 顺序（指原数组的index）是：$13,5,12,7,10,9,3,8,6,2,11$。\n假设我们询问了 $x=3, y=1$，这意味着 $1,2,3$ 和 $13$ 都不能出现在这个删除序列中了（我们给它们 打上标记），并且它后面的 所有 比它大 的数字也被打上标记了（因为它实际上依赖前面的数字，但是前面的这些数字无法被删了）！如下：\n找 $1$，$1$ 不在删除序列中，忽略。\n找 $2$，$2$ 在删除序列中，后面比它大的数字有 $11$，所以 $2,11$ 打上标记。\n找 $3$，$3$ 在删除序列中，后面比它大的数字有 $8,6,2,11$，所以 $3,8,6,2,11$ 打上标记。\n找 $13$，$13$ 在删除序列中，后面不存在比它大的数字。所以 $13$ 打上标记。\n以上，剩下没有被标记的，只有 $5,12,7,10,9$，共 $5$ 个数字，所以答案为 $5$。\n 将上述的模拟过程，总结一下就是：\n设删除序列（就是上面的 $13,5,12,7,10,9,3,8,6,2,11$）为 $c$。\n那么，每次询问 $(x,y)$，所有 未被标记 的index $i$，必须得满足以下的所有条件：\n $c_i \\in [x+1, n-y]$ $pre_i \\geq x+1$  其中，$pre_i$ 代表 $\\min \\{ c_1,c_2,\u0026hellip;,c_{i-1}\\}$。这是因为，如果 $pre_i \\leq x$，则 $i$ 前面必然存在一个数字被标记了，所以 $i$ 也要被标记。\n 现在问题就转化为：\n给定一个长度为 $n$ 的数组，每个元素是 $(c, pre)$ 的形式。\n每次询问 $(x,y)$，求有多少个 $i \\in [1,n]$ 满足以下所有条件：\n $c_i \\in [x+1, n-y]$ $pre_i \\geq x+1$  有离线和在线两种方法。\n 在线做法：\n将数组根据 $c$ 的值，sort一下。\n每次询问的时候，先用二分找到左边界 $l$，满足 $c_l \\geq x+1$，且 $l$ 尽可能小。\n再二分找到右边界 $r$，满足 $c_r \\leq n-y$，且 $r$ 尽可能大。\n然后问题就转化为，求 $[l,r]$ 之间，有多少个元素 $i$，满足：\n $i \\in [l,r]$ $pre_i \\geq x+1$  那这就是一个标准的主席树问题了。\n复杂度：$O(n\\log^2n)$\n 离线做法：\n将所有的询问，根据 $x$ 的值，从大到小 进行sort。\n然后，将数组根据 $pre$ 的值，从大到小 进行sort。\n所以，我们在回答每个询问 $(x,y)$ 的时候，我们只需要考虑 $pre_i \\geq x+1$ 的部分。\n也就是说我们可以开一个线段树，维护 $c_i$ 的值。\n假如我们当前处理到了 询问 $(x,y)$，我们只在线段树内维护所有满足 $pre_i \\geq x+1$ 的 $c_i$ 即可。\n• 这本质上是一个，将数组内的元素，根据 $pre_i$ 的值，逐一插入到线段树中的过程。\n复杂度：$O(n\\log n)$\n 总结：\n本题的思考流程分为以下几个步骤：\n 找到最优的删除策略。 对于无询问状态下，如何模拟删除过程。 对于有询问状态下，如何模拟删除过程。 如何处理一个 类似二维数点 的问题。   在线做法（主席树） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,q; struct node { int idx, val; } arr[maxn]; struct tree_node { int minval, idx; int lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].minval = min(tr[cur\u0026lt;\u0026lt;1].minval, tr[cur\u0026lt;\u0026lt;1|1].minval); } void push_down(int cur) { if (tr[cur].lazy == 0) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].minval += lazy, tr[r].minval += lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].minval = arr[l].val; tr[cur].idx = arr[l].idx; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026gt; R) return; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].minval += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // query if [1,n] has minval = 0, (query right first), if yes, return the idx (original) int query(int cur, int l, int r) { if (tr[cur].minval != 0) return -1; if (l == r) { return tr[cur].idx; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (tr[cur\u0026lt;\u0026lt;1|1].minval == 0) return query(cur\u0026lt;\u0026lt;1|1, mid+1, r); return query(cur\u0026lt;\u0026lt;1, l, mid); } // delete the element in p void del(int cur, int l, int r, int p) { if (l == r) { tr[cur].minval = 1e9; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (p \u0026lt;= mid) del(cur\u0026lt;\u0026lt;1, l, mid, p); if (p \u0026gt; mid) del(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); push_up(cur); } struct Num { int val, pre; } seq[maxn]; int tail = 0; void init() { build(1, 1, n); while (1) { int p = query(1, 1, n); if (p == -1) break; del(1, 1, n, p); seq[++tail] = {p, (int)1e9}; update(1, 1, n, p+1, n, -1); } if (!tail) return; for (int i = 2; i \u0026lt;= tail; i++) { seq[i].pre = min(seq[i-1].pre, seq[i-1].val); } sort(seq+1, seq+tail+1, [](auto a, auto b) { return a.val \u0026lt; b.val; // 根据 c 的值先进行sort }); } void debug() { printf(\u0026quot;tail = %d\\n\u0026quot;,tail); for (int i = 1; i \u0026lt;= tail; i++) { printf(\u0026quot;%d \u0026quot;, seq[i].val); } printf(\u0026quot;\\n\u0026quot;); } struct persistent_tree_node { int lc, rc, cnt; } ptr[maxn\u0026lt;\u0026lt;5]; int root[maxn], id = 0; int insert(int pre, int l, int r, int p) { int cur = ++id; ptr[cur] = ptr[pre]; ptr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) ptr[cur].lc = insert(ptr[pre].lc, l, mid, p); if (p \u0026gt; mid) ptr[cur].rc = insert(ptr[pre].rc, mid+1, r, p); return cur; } int query(int cur, int pre, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return ptr[cur].cnt - ptr[pre].cnt; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(ptr[cur].lc, ptr[pre].lc, l, mid, L, R); if (R \u0026gt; mid) res += query(ptr[cur].rc, ptr[pre].rc, mid+1, r, L, R); return res; } // return the smallest index, where seq[i].val \u0026gt;= x int search_down(int x) { int l = 1, r = tail; int ans = tail+1; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (seq[mid].val \u0026gt;= x) { ans = mid; r = mid-1; } else l = mid+1; } return ans; } // return the largest index, where seq[i].val \u0026lt;= x int search_up(int x) { int l = 1, r = tail; int ans = 0; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (seq[mid].val \u0026lt;= x) { ans = mid; l = mid+1; } else r = mid-1; } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].val; arr[i].idx = i; int val = arr[i].val, idx = i; if (val \u0026gt; idx) arr[i].val = 1e9; else arr[i].val = i - val; } init(); for (int i = 1; i \u0026lt;= tail; i++) { root[i] = insert(root[i-1], 1, n, seq[i].pre); } while (q--) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int ans = 0; int l = search_down(x+1); int r = search_up(n-y); if (l \u0026gt; r) ans = 0; else { ans = query(root[r], root[l-1], 1, n, x+1, n); } // 以下是暴力的做法： // for (int i = 1; i \u0026lt;= tail; i++) { // if (seq[i].val \u0026gt;= x+1 \u0026amp;\u0026amp; seq[i].val \u0026lt;= n-y \u0026amp;\u0026amp; seq[i].pre \u0026gt;= x+1) ans++; // } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   离线做法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,q; struct node { int idx, val; } arr[maxn]; struct tree_node { int minval, idx; int lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].minval = min(tr[cur\u0026lt;\u0026lt;1].minval, tr[cur\u0026lt;\u0026lt;1|1].minval); } void push_down(int cur) { if (tr[cur].lazy == 0) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].minval += lazy, tr[r].minval += lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].minval = arr[l].val; tr[cur].idx = arr[l].idx; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026gt; R) return; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].minval += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // query if [1,n] has minval = 0, (query right first), if yes, return the idx (original) int query(int cur, int l, int r) { if (tr[cur].minval != 0) return -1; if (l == r) { return tr[cur].idx; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (tr[cur\u0026lt;\u0026lt;1|1].minval == 0) return query(cur\u0026lt;\u0026lt;1|1, mid+1, r); return query(cur\u0026lt;\u0026lt;1, l, mid); } // delete the element in p void del(int cur, int l, int r, int p) { if (l == r) { tr[cur].minval = 1e9; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (p \u0026lt;= mid) del(cur\u0026lt;\u0026lt;1, l, mid, p); if (p \u0026gt; mid) del(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); push_up(cur); } struct Num { int val, pre; } seq[maxn]; int tail = 0; void init() { build(1, 1, n); while (1) { int p = query(1, 1, n); if (p == -1) break; del(1, 1, n, p); seq[++tail] = {p, (int)1e9}; update(1, 1, n, p+1, n, -1); } if (!tail) return; for (int i = 2; i \u0026lt;= tail; i++) { seq[i].pre = min(seq[i-1].pre, seq[i-1].val); } sort(seq+1, seq+tail+1, [](auto a, auto b) { return a.pre \u0026gt; b.pre; // 根据 pre 进行 sort }); } struct Query_node { int x,y,id; } que[maxn]; int ans[maxn]; struct tree_node2 { int cnt; } tr2[maxn\u0026lt;\u0026lt;2]; void insert(int cur, int l, int r, int p) { tr2[cur].cnt++; if (l == r) { return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) insert(cur\u0026lt;\u0026lt;1, l, mid, p); else insert(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } int Query(int cur, int l, int r, int L, int R) { if (L \u0026gt; R) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr2[cur].cnt; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += Query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += Query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].val; arr[i].idx = i; int val = arr[i].val, idx = i; if (val \u0026gt; idx) arr[i].val = 1e9; else arr[i].val = i - val; } init(); for (int i = 1; i \u0026lt;= q; i++) { cin \u0026gt;\u0026gt; que[i].x \u0026gt;\u0026gt; que[i].y; que[i].id = i; } sort(que+1, que+q+1, [](auto a, auto b){ return a.x \u0026gt; b.x; }); int p = 0; for (int i = 1; i \u0026lt;= q; i++) { int x = que[i].x, y = que[i].y, id = que[i].id; while (p+1 \u0026lt;= tail \u0026amp;\u0026amp; seq[p+1].pre \u0026gt;= x+1) { // 满足 pre \u0026gt;= x+1 就插入 p++; insert(1, 1, n, seq[p].val); // 逐一插入进线段树 } ans[id] = Query(1, 1, n, x+1, n-y); } for (int i = 1; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://www.luogu.com.cn/blog/Fighting-Naruto/solution-p3834  ","date":"2021-03-31T10:42:02+08:00","permalink":"https://tom0727.github.io/post/036-%E4%B8%BB%E5%B8%AD%E6%A0%91/","tags":["主席树","可持久化"],"title":"主席树"},{"categories":["算法"],"contents":"介绍 权值线段树 权值线段树用于维护一定值域内，各个元素出现的次数，结合动态开点可以 避免离散化的处理。\n举个例子，我们现在有一个长度为 $10$ 的数组 $[1,5,2,3,4,1,3,4,4,4]$\n$1$ 出现了 $2$ 次，$2$ 出现了 $1$ 次，$3$ 出现了 $2$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $1$ 次。\n则这个线段树长这样：\n每个叶子节点的值： 代表 这个值的出现次数。\n非叶子节点的值：代表了某一个值域内，所有值出现次数的和。\n 动态开点 我们会发现，在上面的线段树中，$6,7,8$ 都没有出现过，所以值为 $0$。\n$7,8$ 对应节点的 parent 的值也为 $0$，这样很浪费空间。而且在值域较大的时候（如维护 $[1,10^{18}]$ 的权值线段树）时，这样开点是不可行的。\n所以我们可以用 动态开点 来解决空间问题。\n动态开点与普通线段树的区别，主要在于以下几个方面：\n 一个节点的左右 child 不一定为 cur\u0026lt;\u0026lt;1, cur\u0026lt;\u0026lt;1|1，而是以 lc, rc 的形式储存在 struct 中。 更改某一个节点的值，或者 push_down() 时，如果节点不存在，则创建一个。 询问某一个节点的值时，如果节点不存在，直接返回 $0$。 不需要 build() 线段树，因为在一开始，整个线段树没有任何节点。  这样做有什么好处呢？\n 大幅度节省空间，尤其对于值域较大的权值线段树。 如果一个数组初始状态均为 $0$，就避免了普通线段树需要 build() 的过程。如果需要初始化，则一个个 insert() 进去也可以。 在需要维护多棵线段树时（比如 $HDU ~6183$ 需要开 $51$ 棵动态开点线段树），可以将它们维护在同一个数组上，大幅度节省空间。  例题 例1 洛谷P1908 逆序对 题解 求逆序对，我们可以从左往右遍历数组，遍历到 $i$ 时，检查一下已经遍历的值中，有多少比它大的即可。\n这可以用权值线段树来实现。\n因为每个数字的范围是 $[1,10^9]$，所以需要动态开点。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; struct node { int lc, rc, cnt; // 记录左右child的编号，如果不存在，则为 0 } tr[maxn]; int id = 0; // 动态开点用的pointer int root = 0; // 根节点编号 void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].cnt = tr[lc].cnt + tr[rc].cnt; } // 插入一个值为 p 的元素 void insert(int\u0026amp; cur, int l, int r, int p) { if (!cur) cur = ++id; // 动态开点 if (l == r) { tr[cur].cnt++; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) insert(tr[cur].rc, mid+1, r, p); push_up(cur); } // 询问 值在 [L,R] 之间的元素有多少个 ll query(int cur, int l, int r, int L, int R) { if (!cur) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return (ll)tr[cur].cnt; } int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) res += query(tr[cur].rc, mid+1, r, L, R); return res; } int main() { int n; cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; insert(root, 1, 1e9+1, x); ans += query(1, 1, 1e9+1, x+1, 1e9+1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF69E Subsegments 题意\n给定正整数 $n,k$，给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n输出 $n-k+1$ 个数，每个数字代表 $[a_{i},\u0026hellip;, a_{i+k-1}]$ 中，仅出现一次的元素的最大值。\n如果不存在仅出现一次的元素，输出 $-1$。\n其中，$n \\leq 10^5, 1 \\leq k \\leq n, |a_i| \\leq 10^9$\n 题解 在线段树节点里面额外维护一个信息 bool one，代表这个值域内，是否存在仅出现一次的元素。然后询问时，优先询问右边（值域较大的部分）。\n还有一个问题，$a_i$ 的值可以为负数，怎么维护？\n我们可以将 $a_i$ 都加上一个 delta = 1e9，这样让每一个 $a_i \\geq 0$，然后就可以用权值线段树来维护了。记得在 insert(), query() 时，也要加上这个 delta = 1e9。\n 注：我们用 int mid = (r-l) / 2 + l 来代替 int mid = (l+r) \u0026gt;\u0026gt; 1，防止 overflow。\n证明它们两个的等效性：因为 (r-l) 和 (l+r) 的奇偶性一样，且均为非负数，所以它们等效。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; const int maxm = 1e5+10; int n,k,id = 0, root = 0; struct node { int lc,rc,cnt; bool one; // 这个值域内，是否存在unique的元素 } tr[maxn]; int arr[maxm]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].one = tr[lc].one | tr[rc].one; tr[cur].cnt = tr[lc].cnt + tr[rc].cnt; } void insert(int\u0026amp; cur, int l, int r, int p, int f) { if (!cur) cur = ++id; if (l == r) { tr[cur].cnt += f; if (tr[cur].cnt == 1) tr[cur].one = 1; else tr[cur].one = 0; return; } int mid = (r - l) / 2 + l; if (p \u0026lt;= mid) insert(tr[cur].lc, l, mid, p, f); if (p \u0026gt; mid) insert(tr[cur].rc, mid+1, r, p, f); push_up(cur); } int query(int cur, int l, int r) { if (!tr[cur].one) return -1; if (l == r) return l; int lc = tr[cur].lc, rc = tr[cur].rc; int mid = (r - l) / 2 + l; if (tr[rc].one) return query(rc, mid+1, r); else return query(lc, l, mid); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= k-1; i++) { insert(root, 0, 2e9, arr[i]+1e9, 1); } for (int i = k; i \u0026lt;= n; i++) { insert(root, 0, 2e9, arr[i]+1e9, 1); int a = query(root, 0, 2e9); if (a == -1) { cout \u0026lt;\u0026lt; \u0026quot;Nothing\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; (a - (int)1e9) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } insert(root, 0, 2e9, arr[i-k+1]+1e9, -1); } }   例3 CF474E Pillars 题意\n给定正整数 $n,d$，还有长度为 $n$ 的数组 $h_1,h_2,\u0026hellip;,h_n$。\n求数组中 最长的 subsequence $b$（不一定连续），使得 $\\forall i, |b_{i+1} - b_i| \\geq d$。\n其中，$n \\leq 10^5, 0 \\leq d \\leq 10^9, 1 \\leq h_i \\leq 10^{15}$\n 题解 一个很明显的 dp 思路：\n当我们遍历到 $i$ 时，令 $dp[j]$ 为：目前为止，结尾的值为 $j$ 的 subsequence 的最大长度。\n那么 $dp[h_i] = \\max\\limits_j \\{ dp[j]+1 \\}$，其中 $|h_i - j| \\geq d$\n那么，这个 dp 数组就可以用权值线段树来维护。\n查询的时候，分别查询 $j \\geq h_i + d$ 和 $j \\leq h_i - d$ 的部分即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 8e6; const int maxm = 1e5+10; int n, pre[maxm], dp[maxm]; ll arr[maxm], d; int root,id; struct node { int lc,rc,m,idx; // m: dp数组的值，idx: 该值域内，具有最大的 m 对应的原来array中的index } tr[maxn]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; if (tr[lc].m \u0026gt; tr[rc].m) tr[cur].m = tr[lc].m, tr[cur].idx = tr[lc].idx; else tr[cur].m = tr[rc].m, tr[cur].idx = tr[rc].idx; } void insert(int\u0026amp; cur, ll l, ll r, ll h, ll m, int idx) { if (!cur) cur = ++id; if (l == r) { if (m \u0026gt; tr[cur].m) { tr[cur].m = m; tr[cur].idx = idx; } return; } ll mid = (l+r) \u0026gt;\u0026gt; 1; if (h \u0026lt;= mid) insert(tr[cur].lc, l, mid, h, m, idx); if (h \u0026gt; mid) insert(tr[cur].rc, mid+1, r, h, m, idx); push_up(cur); } // return the index with maximum m value pll query(int cur, ll l, ll r, ll L, ll R) { if (!cur) return {0,0}; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return {tr[cur].m, tr[cur].idx}; } ll mid = (l+r) \u0026gt;\u0026gt; 1; pll r1, r2; if (L \u0026lt;= mid) r1 = query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) r2 = query(tr[cur].rc, mid+1, r, L, R); if (r1.first \u0026gt; r2.first) return r1; return r2; } const ll up = 1e15 + 2e9 - 1LL; const ll delta = 1e9-1; int ans = 0, maxi = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { ll h = arr[i]; pll r1 = query(root, 0, up, 0, h-d+delta); pll r2 = query(root, 0, up, h+d+delta, up); pll r; if (r1.first \u0026gt; r2.first) r = r1; else r = r2; dp[i] = dp[r.second] + 1; pre[i] = r.second; insert(root, 0, up, h+delta, dp[i], i); if (ans \u0026lt; dp[i]) ans = dp[i], maxi = i; } vector\u0026lt;int\u0026gt; vec; while (maxi) { vec.push_back(maxi); maxi = pre[maxi]; } cout \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; for (int i = vec.size()-1; i \u0026gt;= 0; i--) { cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例4 HDU6183 Color it 题意\n给定一个二维平面，初始状态下，整个平面为空，现在有以下 3 种操作：\n$0$： 清空平面\n$1 ~ x ~ y ~ c$：在 $(x,y)$ 添加一种颜色 $c$\n$2 ~x~ y_1~ y_2$：查询所有 $(a,b)$ 的不同颜色数量，其中 $1 \\leq a \\leq x, y_1 \\leq b \\leq y_2$\n其中，$1\\leq x,y \\leq 10^6, 0 \\leq c \\leq 50$\n数据保证，最多有 $150000$ 个连续的询问 $1$，最多有 $10$ 个询问 $0$。\n 题解 首先，发现 颜色 $c$ 只有 $51$ 种，所以我们可以分开维护每一种颜色，统计的时候加起来就可以了。\n其次，发现本题询问 $2 ~x~ y_1~ y_2$ 时，我们只关心 $1 \\leq a \\leq x$ 的部分，也就是说，对于同一种颜色和同一个 $y$ 坐标而言，我们只关心 最小的那个 $x$ 坐标。\n所以，我们可以根据 $y$ 轴开一棵线段树，维护 $y$ 坐标对应的最小 $x$ 值。\n有 $51$ 种颜色，所以我们开 $51$ 棵线段树即可。\n 注：如果开51棵普通的线段树会 $MLE$，所以用动态开点，把它们开在同一个数组上，使用 int root[51] 来维护 $51$ 棵线段树的 root 即可。\n  注：如果询问是 $1 ~ x_1 ~ x_2 ~ y_1 ~ y_2$ 的这种形式，似乎要用 线段树套线段树 （还没学）。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 8e6; int id = 0; int root[51]; struct node { int lc,rc,x = 1e9; } tr[maxn]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].x = min(tr[lc].x, tr[rc].x); } void insert(int\u0026amp; cur, int l, int r, int c, int x, int y) { if (!cur) cur = ++id; if (l == r) { tr[cur].x = min(tr[cur].x, x); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (y \u0026lt;= mid) insert(tr[cur].lc, l, mid, c, x, y); else insert(tr[cur].rc, mid+1, r, c, x, y); push_up(cur); } bool query(int cur, int l, int r, int c, int x, int L, int R) { if (!cur) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].x \u0026lt;= x; } int mid = (l+r) \u0026gt;\u0026gt; 1; bool res = 0; if (L \u0026lt;= mid) res |= query(tr[cur].lc, l, mid, c, x, L, R); if (res) return 1; if (R \u0026gt; mid) res |= query(tr[cur].rc, mid+1, r, c, x, L, R); return res; } void init(int i) { tr[i].lc = tr[i].rc = 0; tr[i].x = (int)1e9; } void clearall() { for (int i = 0; i \u0026lt;= 50; i++) { root[i] = 0; } for (int i = 1; i \u0026lt;= id; i++) init(i); id = 0; } int main() { int op; while (1) { cin \u0026gt;\u0026gt; op; if (op == 0) clearall(); if (op == 1) { int x,y,c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; c; insert(root[c], 1, 1e6, c, x, y); } if (op == 2) { int ans = 0; int x,y1,y2; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; y2; if (y1 \u0026gt; y2) swap(y1,y2); for (int c = 0; c \u0026lt;= 50; c++) { ans += query(root[c], 1, 1e6, c, x, y1, y2); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } if (op == 3) { return 0; } } }   ","date":"2021-03-27T20:13:23+08:00","permalink":"https://tom0727.github.io/post/035-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":["线段树"],"title":"权值线段树（动态开点）"},{"categories":["题解"],"contents":"题目链接 题意\n给定正整数 $c,d,x$，求正整数pair $(a,b)$ 的数量使得 $$c \\times lcm(a,b) - d \\times gcd(a,b) = x$$\n其中，共 $T \\leq 10^4$ 个testcase，$1 \\leq c,d,x \\leq 10^7$\n• $(a,b)$ 和 $(b,a)$ 不同，例如 $(1,6), (6,1)$ 算两个，但是 $(3,3),(3,3)$ 算一个。\n 题解 对于任意一个$(a,b)，$令 $l = lcm(a,b), ~g = gcd(a,b)$，则必然有 $g|l$。\n那么两边同除 $g$，我们有\n$$c \\times \\frac{l}{g} - d = \\frac{x}{g}$$\n这说明： $g|x$\n所以我们可以枚举 $x$的所有因子 $g$ （例如 $x = 12$，因子有 $g=1,2,3,4,6,12$），当我们已知 $g = gcd(a,b)$ 时，$l = lcm(a,b)$ 也可以计算出来。\n  怎么枚举 $x$ 的所有因子 $g$？\n for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } }    问题转化为：已知 $gcd(a,b), ~ lcm(a,b)$，如何求满足条件的 $(a,b)$ 数量？\n 发现 $gcd$ 为所有质因子的 $\\min$，而 $lcm$ 为所有质因子的 $\\max$。\n所以对于 $lcm(a,b)$ 的每一个质因子 $p_i$，看一下 $p_i$ 在 $lcm(a,b)$ 中出现的次数是否大于它在 $gcd(a,b)$ 中出现的次数即可。\n如果大于，我们可以将这个质因子 出现次数较小的分配给 $a$，或者给 $b$，所以答案乘上 $2$。\n如果等于，则这个质因子没有贡献，答案不变。\n实现过程中，直接令 $r = \\frac{lcm(a,b)}{gcd(a,b)}$，然后看一下 $r$ 有多少个质因子就可以了。\n设 $r$ 的质因子数量为 $m$，则 $ans = 2^m$\n  快速求 $r$ 的质因子数量，我们可以预处理出 每一个数的质因子数量，但是数组的上限 maxn 是多少？\n 注意到 $c\\times r - d = \\frac{x}{g}$，所以 $r = \\frac{x}{gc} + \\frac{d}{c}$，分母最小的情况下，$g = c = 1$，所以 $r = (x + d) \\leq 2\\times10^7$，只要预处理 maxn \u0026lt;= 2e7 的部分即可。\n  怎么预处理出每一个数的质因子数量？\n 有两种方法，比较简单的是直接用 Eratosthenes 筛法，还有一种是欧拉筛 + dp。\n法一：Eratosthenes 筛法\nint sum[maxn]; // 每个数的质因子出现个数 void init() { for (int i = 2; i \u0026lt;= maxn-5; i++) { if (sum[i] == 0) { // i为质数 for (int j = i; j \u0026lt;= maxn-5; j += i) sum[j]++; } } }  因为 $j$ 是从 $i$ 开始的，所以复杂度为 $O(n\\log n)$\n法二：欧拉筛 + dp\nbool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; // dp，继承之前的质数数量 if (i % cur) sum[tar]++; // 如果 i 和 cur互质，说明 cur 是一个没用过的质数 if (i % cur == 0) break; } } }  复杂度：$O(n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e7+5; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int sum[maxn]; ll a,b,x,ans = 0; void cal(ll g) { ll l = (b*g + x); if (l % (a * g)) return; ans += (1LL \u0026lt;\u0026lt; (sum[l/(a*g)])); } bool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; if (i % cur) sum[tar]++; if (i % cur == 0) break; } } } int main() { int T; cin \u0026gt;\u0026gt; T; init(); while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; x; ans = 0; for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-22T23:47:16+08:00","permalink":"https://tom0727.github.io/post/034-cf-1499d/","tags":["数学"],"title":"CF 1499D（数学，筛法）"},{"categories":["算法"],"contents":"介绍 数位DP是指这样一类题型：\n给定一些限定条件，求 $[L,R]$ 内满足这些条件的数字数量，一般 $L,R$ 可能非常大（例如$10^{18}, 10^{1000}$）\n限定条件的一些例子：\n例1. 不含前导0，相邻两个数字差至少为2\n例2. 不包含4，不包含62\n例3. 存在长度至少为2的回文子串\n算法 首先，求 $[L,R]$ 内满足条件的数字数量，可以转化为 先求 $[1,R]$，再减去 $[1,L-1]$ 的部分。\n然后，因为数字很大，所以把它拆成每一位数来看，就可以进行 DP 或者 记忆化搜索 了。\n记忆化搜索 经典的搜索状态有：\n 当前在第几位数：int pos 是否含有前导0：bool zero 当前数字的前面部分，是否受到最大值限制：bool limit 前一位使用的数字 int pre  • 上述部分状态，有可能用不到。\n• 可能有额外状态，根据题目具体来定。\n• 一般来说，记忆化用到的 dp 数组，不需要记录 zero 和 limit。\n• 记忆化搜索的代码难度远远小于递推。\n 记忆化搜索时，有以下需要注意的点：\n 将数位 从低到高 进行排列（因为也许可以重复利用），从高位开始，往低位搜。 有前缀 $0$ 时（zero = 1），注意其他的搜索状态全部清零。（因为有前缀 $0$ 就相当于我们刚刚开始搜索） dp 数组初始化为 -1，一般每次搜索都要重新 memset(dp, -1, sizeof(dp)) dp 数组记录的状态是 (!limit \u0026amp;\u0026amp; !zero) 的状态（即，无任何限制的情况），这样才可以利用。当 (limit || zero) 时，我们需要继续搜索。  DP DP • 因为不推荐这么写，所以折叠了。\n本质和记忆化搜索相同，DP速度可能较快，但是一般很难写，一般有两种写法：\n 写法一：\n令 dp 数组记录 严格小于数字 $x$ 的满足条件的数量。\n将数位按照 高位到低位 排好，然后对于前缀等于 $x$ 的那些数，进行单独处理。\n这种写法可以见 ABC194F的题解\n 写法二：\n将数位按照 低位到高位 排好。（注意，和上面相反）\n预处理出 dp 数组（不带任何限制）。\n预处理以后，对于每一个询问，都直接进行处理，有3种情况：\n(以下的 $n$ 指的是当前询问数字 $x$ 的数位个数)\n 数字使用的位数 $\u0026lt; n$，则没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $\u0026lt; arr[n]$，也没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $= arr[n]$，则我们需要从最高位的前一位 n-1 开始，对于每一位 i，都枚举当前使用的数字 j = 0,1,...,arr[i]-1，然后再到前一位 i-1。   为什么不枚举 j = arr[i] 的情况？\n 注意到 dp 数组里表示的是不带任何限制的数量，当 j = arr[i] 时，更高位的数字都被固定为 $x$ 的高位部分了，所以是有限制的，不能算进去。\n以下给出 SCOI2009 windy 数 的写法：\nll dp[12][12]; int arr[12]; void init() { // 处理无限制的部分 for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数 = p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数 = p，最高位 == arr[p] for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果高位固定的部分已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; // 检查一下这个数字 arr[] 本身是否满足条件 return ans; }  注：在DP处理高位 等于 $x$的高位 时，一定要注意 高位的数字都已经被固定了，所以需要算进答案里，或者需要检查一下被固定的数是否满足条件了。\n注：最后要单独检查一下 这个数字 $x$ 本身是否满足条件。\n 例题 例1 洛谷P2657 Windy数 题意\n给定 $a,b \\leq 2 \\times 10^9$，求 $[a,b]$ 内满足以下条件的数字数量：\n 不含前导 $0$ 两个数字之差至少为 $2$   代码-DP法二 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[12][12]; int arr[12]; void init() { for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } int p; bool check() { for (int i = 2; i \u0026lt;= p; i++) { if (abs(arr[i] - arr[i-1]) \u0026lt; 2) return 0; } return 1; } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数=p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数=p，最高位=p for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果前缀已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; return ans; } int main() { init(); int a,b; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; a; int r = solve(a) - solve(b-1); cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; }   例2 洛谷P2602 数字计数 题意\n给定两个正整数 $a \\leq b \\leq 10^{12}$，求 $[a,b]$ 内的所有整数中，每个 digit 出现的次数。\n 题解 我们枚举每一个digit，然后进行记忆化搜索即可。\n记忆化搜索一般比较模版化，其中 zero, limit 的套路是可以背下来的。\n对于本题，枚举每一个digit $cur$，令 $dp[i][j]$ 表示到了 第 $i$ 位，包含 $j$ 个 $cur$的数字数量。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll a,b; ll dp[14][14]; // dp[i][j]: 到第i位，包含j个cur的数的数量 int arr[14]; // 数字x的各个数位 （从低位到高位） int n; // 数字x的长度 int cur; // 当前枚举的数字 (0...9) // pos: 当前到了第几位 // cnt: 当前数字包含了 cnt 个 cur // zero: 是否有前缀 0 // limit: 前面部分是否完全等于高位 ll dfs(int pos, int cnt, bool zero, bool limit) { if (pos \u0026lt;= 0) { return cnt; } if (!zero \u0026amp;\u0026amp; !limit \u0026amp;\u0026amp; dp[pos][cnt] != -1) // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时获得dp值，否则继续往下搜索 return dp[pos][cnt]; int ed = 9; if (limit) ed = arr[pos]; // 如果前面完全等于高位，那么这一位不能超过当前位 ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) res += dfs(pos-1, 0, 1, 0); // 如果仍然保持前缀 0，那么记得将 cnt 清零，limit也要清零。 else { res += dfs(pos-1, cnt + (j == cur), 0, limit \u0026amp;\u0026amp; (j == arr[pos])); } } if (!zero \u0026amp;\u0026amp; !limit) dp[pos][cnt] = res; // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时记录dp值 return res; } ll solve(ll x) { n = 0; memset(dp, -1, sizeof(dp)); while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 1, 1); // 从高位开始 } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (cur = 0; cur \u0026lt;= 9; cur++) { cout \u0026lt;\u0026lt; solve(b) - solve(a-1) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例3 洛谷P3413 萌数 题意\n给定两个正整数 $L \\leq R \\leq 10^{1000}$，求满足以下条件的数字数量：\n $x \\in [L,R]$ $x$ 包含长度至少为2的回文子串 $x$ 没有前缀 $0$   题解 我们只需要考虑长度为 $2$ 或者 $3$ 的回文子串即可（因为 $\u0026gt;3$ 的情况已经被它们两个包含了）。\n那么我们可以设定 dp 数组为：\n$dp[i][j][k][0/1]$：我们当前在第 $i$ 位，往前 $2$ 位的数字为 $j$，往前 $1$ 位的数字为 $k$，且 不包含（0）/ 包含（1） 回文子串 的数字数量。\n注意到，最后一维度判断了是否包含回文子串。因为一个数有可能 前面几位没有回文子串，但是 后来又有了。如果我们只记录 包含 的情况，会漏掉很多答案。\n而 dfs() 函数的意思是：我们从当前这个状态出发，能获得多少符合条件的数字。\n 注：有的时候，前 $1$ 位，前 $2$ 位上可能没有数字，我们可以设定这些空着的位为 $10$。\n  注：因为本题数字过大，所以不采用减去 $dfs(L-1)$ 的形式，而是 减去 $dfs(L)$，然后特判一下 $L$ 本身是否满足。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[1002][11][11][2]; string s; int n; ll dfs(int pos, int pre2, int pre1, bool zero, bool limit, bool moe) { if (pos \u0026gt;= n) { return moe; } int ed = 9; if (limit) ed = s[pos] - '0'; if (!limit \u0026amp;\u0026amp; !zero \u0026amp;\u0026amp; dp[pos][pre2][pre1][moe] != -1) return dp[pos][pre2][pre1][moe]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) (res += dfs(pos+1, 10, 10, 1, 0, 0)) %= mod; else { (res += dfs(pos+1, pre1, j, 0, limit \u0026amp;\u0026amp; (j == ed), moe || (j == pre1 || j == pre2))) %= mod; } } if (!limit \u0026amp;\u0026amp; !zero) dp[pos][pre2][pre1][moe] = res; return res; } ll solve(string a) { n = a.size(); if (n \u0026lt;= 1) return 0; memset(dp, -1, sizeof(dp)); s = a; return dfs(0, 10, 10, 1, 1, 0); } bool check(string s) { int n = s.size(); for (int i = 0; i \u0026lt; n-1; i++) { if (s[i] == s[i+1]) return 1; if (i+2 \u0026lt; n \u0026amp;\u0026amp; s[i] == s[i+2]) return 1; } return 0; } int main() { string a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll r = solve(b) - solve(a); r += check(a); cout \u0026lt;\u0026lt; (r % mod + mod) % mod \u0026lt;\u0026lt; endl; }   例4 洛谷P4127 同类分布 题意\n给定两个正整数 $a,b \\leq 10^{18}$，求 $[a,b]$ 中，各位置上数字之和 能够整除该数字 的数字个数。\n 题解 可以发现最大的数字只有 $18$ 个 $9$，所以最大的数位和就是 $18 \\times 9 = 162$。\n所以我们可以枚举数位和 $cur$，然后找到符合以下条件的数字 $x$ 的数量：\n $x \\in [a,b]$ $x$ 各位置上数位和 等于 $cur$ $x \\text{ mod } cur = 0$  令 dp 数组为：\n$dp[i][j][k]$：当前到了第 $i$ 位，数位和为 $j$，数字本身 $\\text{mod } cur = k$ 的数字数量。\n 注意到本题不关心前缀 $0$，因为就算有前缀 $0$，也不会对 dfs() 内的其他参数 $sum, v$ 产生任何影响，也不会对枚举当前位使用的数字 $j$ 产生影响，所以可以舍去了。\n 有一个很重要的优化（在多testcase的情况下，优化程度极大）：\n注意到代码里面：\nfor (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); }  我们在 solve(b) 结束后，并没有 memset(dp, -1, sizeof(dp));\n这是因为我们的 dfs() 是从高位开始，枚举到低位。因为 dp[] 数组里保存的都是 !limit 的无限制情况，所以这里面的内容是可以重复利用的！\n但是对于 不同的 cur 就不能重复利用了，因为数组本身的意义已经不同了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[19][163][163]; int arr[19]; int n; int cur; ll dfs(int pos, int sum, int v, bool limit) { // sum为数位和，v为 x % cur 的值 if (!pos) { return (sum == cur) \u0026amp;\u0026amp; (!v); } if (!limit \u0026amp;\u0026amp; dp[pos][sum][v] != -1) return dp[pos][sum][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { res += dfs(pos-1, sum + j, (v * 10 + j) % cur, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][sum][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } int main() { memset(dp, -1, sizeof(dp)); ll a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll ans = 0; for (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 CF55D Beautiful numbers 题意\n给定正整数 $L \\leq R \\leq 9 \\times 10^{18}$，求满足以下条件的数字 $x$ 的数量：\n $x \\in [L,R]$ $x$ 能够被它每一位上的数字整除  共有 $T \\leq 10$ 个 testcase\n 题解 $x$ 可以被每一位上的数字整除 $\\iff$ $x \\text { mod } lcm = 0$\n其中 $lcm$ 是 $x$ 每一位上的数字的 $lcm$。\n发现 $lcm(1,2,\u0026hellip;,9) = 2520$，所以我们可以大致得出以下的状态：\n$dp[i][j][k]$：我们来到了第 $i$ 位，$j$ 表示我们使用了哪些数字，$k$ 代表当前数字 $x \\text { mod } 2520$ 的值。\n这样最后在 pos == 0 时，判断一下 $j$ 对应的 $lcm$，然后判断 $k \\text { mod } lcm_j = 0$ 是否成立即可。\n 现在问题是，这个 $j$ 怎么表示？（$j$ 代表 $x$ 用了 $0,1,2,\u0026hellip;9$ 中的哪些数字）\n可以用状压来实现，其中忽略掉 $0,1$，只记录是否包含 $2,3,\u0026hellip;,9$。大概有 $2^8 - 1$ 种状态，但是这样仍然会 $TLE$，怎么办？\n我们发现，记录使用了哪些数字，只是为了求出这些数字的 $lcm$，那我们直接记录 $lcm$ 作为状态即可！\n但是好像维度反而变大了，因为 $lcm$ 最大可以达到 $2520$，比之前状压的 $2^8 - 1$ 还大。\n 再观察一下，发现我们只关心有效的 $lcm$ 值，$2520$ 内的绝大多数值是无效的，所以我们可以枚举出所有 有效的 $lcm$，而这些有效的 $lcm$ 就是 $2520$ 的所有因子。总共只有 $48$ 个。\n所以我们只需要进行一次 离散化 的操作，将这些因子 map 到 $0,1,2,\u0026hellip;,47$，这样 $j$ 就可以只用 $48$ 个数字来表示了。\n 最后就是 memset(dp, -1, sizeof(dp)) 的优化了，因为本题的 dp[] 数组在不同的 case 之间的含义没有任何变化（都是 $\\text {mod } 2520$），所以只在一开始 memset 一次，之后就一直重复利用。\n• 本题的 memset 优化非常重要，因为有 $T = 10$ 个 case ，大概会有 $2 \\times T = 20$ 倍左右的速度差（如果不优化会 $TLE$ 的很惨）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 2520; ll dp[20][49][2520]; int idx[2521]; int n = 0, arr[20]; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int LCM(int a, int b) { return a/gcd(a,b)*b; } vector\u0026lt;int\u0026gt; fac; void init() { for (int i = 1; i \u0026lt;= sqrt(mod); i++) { if (mod % i == 0) { fac.push_back(i); if (i != mod/i) fac.push_back(mod/i); } } sort(fac.begin(), fac.end()); for (int i = 0; i \u0026lt; fac.size(); i++) { idx[fac[i]] = i; // 离散化，例如 idx[1] = 0, idx[2520] = 47 } } // lc 代表当前的 lcm, v 代表 x % 2520 的值 ll dfs(int pos, int lc, int v, bool limit) { if (pos \u0026lt;= 0) { return v % lc == 0; // 注意，只有在 pos == 0时，才判断 % lc，其余情况都是 % 2520 } if (!limit \u0026amp;\u0026amp; dp[pos][idx[lc]][v] != -1) return dp[pos][idx[lc]][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { int newval = (v * 10 + j) % mod; if (j \u0026lt; 2) res += dfs(pos-1, lc, newval, limit \u0026amp;\u0026amp; (j == ed)); else res += dfs(pos-1, lcm(lc, j), newval, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][idx[lc]][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n,1,0,1); } int main() { init(); int T; cin \u0026gt;\u0026gt; T; memset(dp, -1, sizeof(dp)); // 注意，只进行一次 memset while (T--) { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; cout \u0026lt;\u0026lt; solve(r) - solve(l) \u0026lt;\u0026lt; endl; } }   例6 HDU4507 恨7不成妻 题意\n给定两个正整数 $L \\leq R \\leq 10^{18}$，求满足以下条件的数字的平方之和：\n 整数中不含 $7$ 整数中每一位加起来的和 不是 $7$ 的整数倍 这个整数不被 $7$ 整除  输出对 $10^9+7$ 取模的结果，共有 $T \\leq 50$ 个 testcase\n 错误做法 $dp[i][j][k]$：使用到 $i$ 位，每一位的和 $\\text{mod } 7 = j$，数字本身 $\\text{mod } 7 = k$ 的平方和。\n将返回值设定为该数字的平方，然后将 dp 数组的值作为平方之和。\n 为什么是错的？\n 考虑记忆化状态：\n那么，数字 $10,80$ 的状态完全相同，但是因为我们先 dfs 到了 $10$，然后到了 $80$ 的时候就会直接返回，没有计算 $80^2$ 的值，导致答案错误。\n 正确做法 注意这个题和其他例题完全不一样，因为其他题求的都是 数字的数量，而只有这个题求的是 平方之和。\n这直接导致，我们在状态转移的时候 不能简单的相加。\n上面做法的 dp 状态没有问题：\n$dp[i][j][k]$：使用到 $i$ 位，每一位的和 $\\text{mod } 7 = j$，数字本身 $\\text{mod } 7 = k$\n但是 dp[] 数组对应的值，不能简单的设定为平方和。\n  如果这个题求的是满足条件的数字数量，是不是就可以了？\n 是的！比如 $2$ 和 $9$ 对应的状态相同，无论后缀是什么，只要满足条件，它们就完全等价。\n比如后缀是数字 $3$，那么 $23, 93$ 就完全等价，所以我们来到前缀 $9$ 的时候就可以直接利用前缀 $2$ 的信息。\n但是在本题中，$23$ 和 $93$ 并不等价，因为 $23^2 \\neq 93^2$。\n 所以我们要考虑一下组合数学/计数题中的 贡献 套路。\n我们在 dfs 过程中，先算出来了前缀 $2$ 的相关信息。我们假设前缀 $2$ 有着 三个有效的后缀 $2,3,4$，那么数字就是 $22,23,24$。\n此时，我们已经算出了这些后缀的相关信息，怎么把它合并上去？\n$$22^2 + 23 ^ 2 + 24^2 = (20+2)^2 + (20+3)^2 + (20+4)^2$$ $$= 3\\times 20^2 + 2 \\times 20 \\times (2+3+4) + (2^2+3^2+4^2)$$\n如果这里还不太清楚，还可以再举一个例子：\n我们有一个前缀 $1$，后缀是 $21,22$，那么合并的过程就是：\n$$121^2+122^2 = (100+21)^2 + (100+22)^2 $$ $$=2 \\times 100^2 + 2 \\times 100 \\times (21+22) + (21^2+22^2)$$\n 更 General 的写法是，给定一个digit $a$（$a$ 实际上就是 dfs() 过程中，当前使用的数字），然后假设我们有 $n$ 个后缀 $b_1,b_2,\u0026hellip;,b_n$，那么：\n$$(ab_1)^2 + (ab_2)^2 + \u0026hellip; + (ab_n)^2 = (a \\times 10^p + b_1) ^ 2 + (a \\times 10^p + b_2) ^ 2 + \u0026hellip;+(a \\times 10^p + b_n) ^ 2$$\n$$= n \\times a^2 \\times 10^{2p} + 2\\times10^p \\times (b_1+b_2+\u0026hellip;+b_n) + (b_1^2+b_2^2+\u0026hellip;+b_n^2)$$\n$$= \\sum\\limits_{i=1}^n ((a^2\\times 10^{2p}) + (2\\times10^p\\times b_i) + (b_i^2))$$\n• 其中，$p$ 就是 $pos-1$\n但是注意到，$b_i$ 是一个后缀，它代表的是 dp[] 数组里面，pos-1 的部分，所以它本身也是一个贡献（它并不是一个数字）。\n比如上面的第二个例子中，前缀为 $1$，后缀 $b_1$ 实际上是 $2$，这个 $b_1$ 有两个后缀 $2,3$，所以 $c_1 = 2, c_2 = 3$\n 那么，我们单独看一下每一个 $b$ 带来的贡献是多少。\n对于某一个后缀 $b$，我们继续考虑它的后缀 $c_j$，$b$ 带给 前缀 $a$ 的贡献可以这么表示：\n$$\\sum\\limits_{j=1}^m ((a^2\\times 10^{2p}) + (2\\times10^p\\times c_j) + (c_j^2))$$\n$$=m\\times a^2\\times 10^{2p} + (2\\times 10^p \\times \\sum\\limits_{j=1}^mc_j) + (\\sum\\limits_{j=1}^m c_j^2)$$\n其中，$m$ 是 $b$ 的 后缀数量，$\\sum\\limits_{j=1}^mc_j$ 是 $b$ 的后缀的值之和， $\\sum\\limits_{j=1}^m c_j^2$ 是 $b$ 的后缀的平方和。\n 由上，我们可以看出，对于每一个后缀 $b$，我们都要维护它的\n 后缀 数量 $cnt$ 后缀值 之和 $sum_1$ 后缀值的 平方和 $sum_2$  则，这个 $b$ 带给 $a$ 的 平方和 的贡献就是：\n$$\\sum ((a^2\\times 10^{2p}) + (2\\times10^p\\times c_j) + (c_j^2))$$\n$$= (\\sum a^2\\times 10^{2p}) + (2\\times10^p\\times \\sum c_j) + \\sum c_j^2$$\n$$ = cnt \\times (a^2\\times 10^{2p}) + (2\\times10^p\\times sum_1) + (sum_2)$$\n 那么 $b$ 带给 $a$ 的 后缀和 的贡献呢？\n$$a \\times 10^p + b$$\n$$= \\sum (a \\times 10^p) + \\sum c_j$$\n$$= (cnt \\times a \\times 10^p) + sum_1$$\n 那么 $b$ 带给 $a$ 的 后缀数量 的贡献呢？\n$$1= \\sum_j 1 = cnt$$\n 下面会给一个并不严谨，但是比较好理解的公式推导。\n 注：实现过程中，我们用 struct node 来维护这些信息。\n  公式 平方和：\n$$(a \\times 10^p + b)^2$$\n$$= (a^2\\times 10^{2p}) + (2\\times10^p) \\times b + (b^2)$$\n然后对其进行求和操作，有：\n$$\\sum (a^2\\times 10^{2p}) + (2\\times10^p) \\times \\sum b + \\sum b^2$$\n$$= cnt \\times (a^2\\times 10^{2p}) + (2\\times10^p\\times sum_1) + (sum_2)$$\n 值的和：\n$$(a \\times 10^p + b)$$\n对其进行求和操作：\n$$\\sum a\\times10^p + \\sum b$$\n$$=cnt \\times a \\times 10^p + sum_1$$\n 数量之和：\n$$1$$\n对其进行求和：\n$$\\sum 1$$\n$$=cnt$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct node { ll cnt, sum1, sum2; }; ll pow10[20]; node dp[20][7][7]; bool vis[20][7][7]; int n, arr[20]; node dfs(int pos, int sum, int md, bool limit) { if (!pos) { if (!md) return {0,0,0}; if (!sum) return {0,0,0}; return {1,0,0}; // 注意这里是 {1,0,0}，因为没有选择任何值 } if (!limit \u0026amp;\u0026amp; vis[pos][sum][md]) { return dp[pos][sum][md]; } ll cnt = 0, sum1 = 0, sum2 = 0; int ed = 9; if (limit) ed = arr[pos]; for (ll j = 0; j \u0026lt;= ed; j++) { if (j == 7) continue; node res = dfs(pos-1, (sum+j) % 7, (md*10+j) % 7, limit \u0026amp;\u0026amp; (j==ed)); ll c = res.cnt, s1 = res.sum1, s2 = res.sum2; cnt = (cnt + c) % mod; sum1 = (sum1 + j * pow10[pos-1] % mod * c % mod + s1) % mod; sum2 = (sum2 + j * j * pow10[pos-1] % mod * pow10[pos-1] % mod * c % mod) % mod; sum2 = (sum2 + 2LL * j * pow10[pos-1] % mod * s1 % mod) % mod; sum2 = (sum2 + s2) % mod; } if (!limit) { vis[pos][sum][md] = 1; dp[pos][sum][md] = {cnt, sum1, sum2}; } return {cnt, sum1, sum2}; } node solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } int main() { memset(vis, 0, sizeof(vis)); pow10[0] = 1LL; for (int i = 1; i \u0026lt;= 19; i++) pow10[i] = pow10[i-1] * 10LL % mod; int T; cin \u0026gt;\u0026gt; T; while (T--) { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll ans = solve(r).sum2 - solve(l-1).sum2; // 如果是求值的和，改成 sum1 即可 ans = (ans + (ll)(mod)) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } }   • 这个代码中，一定要注意到 base case 返回的是 {1, 0, 0}（后面两个 0 是因为 sum1, sum2 是在选择当前digit时才计算）。\n例7 CF1073E Segment Sum 题意\n给定正整数 $L, R, K$，求 $[L,R]$ 之间满足：distinct digit 的数量 $\\leq K$ 的数字之和。\n其中，$1 \\leq L \\leq R \\leq 10^{18}, K \\leq 10$\n 题解 和例6是一样的做法，更简单了一些。\n回顾一下状态转移：\n如果当前 digit 为 $a$，后缀为 $b$，则 $b$ 给 $a_{sum}$ 带来的贡献为：\n$$\\sum_{i=1}^{cnt} (a * 10^p + b_i) = cnt * a * 10^p + b_{sum}$$\n而 $a_{sum}$ 就等于所有后缀 $b$ 的贡献之和。\n 状态比较容易想：\ndp[i][mask] 代表到了第 $i$ 个字符，当前使用的digit组成了 $mask$，dp 的值就是 {cnt, sum}。\n• 这里需要注意，在写 dfs() 函数时要考虑是否有前导 $0$。因为如果有前导 $0$，这个 $mask$ 不应包含前导 $0$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = 4e5+5; int K; int a[20], n; struct node { ll cnt, sum; }; node dp[20][(1\u0026lt;\u0026lt;10)+5]; bool vis[20][(1\u0026lt;\u0026lt;10)+5]; inline int popcount(int mask) { int res = 0; while (mask) { res += (mask \u0026amp; 1); mask \u0026gt;\u0026gt;= 1; } return res; } ll ten[20]; node dfs(int i, int mask, bool zero, bool limit) { if (i \u0026lt;= 0) return {1, 0}; if (!limit \u0026amp;\u0026amp; vis[i][mask]) return dp[i][mask]; ll cnt = 0, sum = 0; int ed = (limit ? a[i] : 9); for (ll j = 0; j \u0026lt;= ed; j++) { if (popcount(mask | (1\u0026lt;\u0026lt;j)) \u0026lt;= K) { int newmask = mask | (1\u0026lt;\u0026lt;j); if (zero \u0026amp;\u0026amp; (!j)) newmask = 0; node res = dfs(i-1, newmask, zero \u0026amp;\u0026amp; (!j), limit \u0026amp;\u0026amp; (j == ed)); cnt += res.cnt, cnt %= mod; sum = ((res.sum + (ten[i-1] * res.cnt % mod * j % mod)) % mod + sum) % mod; } } if (!limit) vis[i][mask] = 1, dp[i][mask] = {cnt, sum}; return {cnt, sum}; } ll solve(ll x) { n = 0; memset(a, 0, sizeof(a)); memset(dp, 0, sizeof(dp)); memset(vis, 0, sizeof(vis)); while (x) { a[++n] = x % 10; x /= 10; } return dfs(n, 0, 1, 1).sum; } int main() { fastio; ll L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; K; ten[0] = 1; for (int i = 1; i \u0026lt;= 19; i++) ten[i] = ten[i-1] * 10LL % mod; ll ans = (solve(R) - solve(L-1) + mod) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-03-18T10:53:51+08:00","permalink":"https://tom0727.github.io/post/033-%E6%95%B0%E4%BD%8Ddp/","tags":["数位dp","数学","dp"],"title":"数位DP"},{"categories":["题解"],"contents":"主要记录一些遇到的线段树/分块例题。\n例1 CF438D 题意\n给定 $N$ 个正整数和 $M$ 个询问，询问有 3 种：\n$1 ~ l ~ r$：输出 $\\sum\\limits_{i=l}^r a_i$\n$2 ~ l ~ r ~ x$：将 $a_l$ 到 $a_r$ 的所有数取 $\\text{mod } x$\n$3 ~ k ~ x$：将 $a_k = x$\n其中，$1 \\leq N,M \\leq 10^5, 1 \\leq a_i,x \\leq 10^9$\n 题解 本题分块和线段树都可以做，我们这里用 线段树 来做。\n主要是需要考虑 区间取模 怎么办？\n回忆一下分块例题中的 区间开方，我们维护了一个额外的tag表示这个区间是否为 全0/全1，如果不是 全0/全1 就暴力开方。\n取模操作同理，我们发现，如果 $a_i \u0026gt; x$，那么 $a_i \\text{ mod } x \\leq \\frac{a_i}{2}$，所以对于每个 $a_i$，最多只会被 $\\text{mod}$ $\\log (a_i)$ 次！\n所以，我们维护一个 区间最大值，取模时，检查一下 区间最大值是否大于 $x$：\n 如果大于 $x$，就继续往下递归。 如果小于 $x$，就直接返回。  base case 就是区间长度为 $1$ 时，直接对这个元素开方即可。\n 例2 CF558E 题意\n给定一个长度为 $n$ 的string，仅包含小写字母。给 $q$ 个询问：\n$l,r,k$：将string的 $[l,r]$ 进行sort，如果 $k=1$ 就升序，$k=0$ 降序。\n输出所有询问结束后的string。\n其中，$1\\leq n \\leq 10^5, 1 \\leq q\\leq 50000$\n 题解 线段树来处理。\n首先，string只包含小写字母。所以每个 node 可以维护一个 cnt[26] 代表这个node里的每个字母出现的次数。\n其次，对于排序，我们在每个 node 中维护一个标记 $k$ 来代表该区间是否排序好了。若 $k=0$ 代表降序，$k=1$ 代表升序，$k = -1$ 代表乱序。\n最后，维护一个 $lazy$ 标记，我们会注意到对于一个node而言，若 $lazy = 1$，那么这个 node 必然是排序好了的！（要么 $k=0$ ，要么 $k=1$）。\n有了以上信息，我们就可以进行 sort 操作了！\n sort $[L,R]$ 的时候，步骤如下：\n 提取出 $[L,R]$ 内每个字母出现的次数。 求出 $[L,R]$ 与 $[l,mid]$（当前node 左child的范围）的区间交集 $[l_1,r_1]$ 求出 $[L,R]$ 与 $[mid+1, r]$（当前node 右child的范围）的区间交集 $[l_2,r_2]$ 用指针遍历 $a-z$（或者 $z-a$），根据升序/降序 将 字母出现的次数分别填充 到 左child和右child的 cnt[] 中。（注意，这里的填充是指：先填充进一个 int* buf = new int[26]; 的动态数组，然后将 buf[] 作为参数，再往下传递，直到区间完全覆盖，再将 buf[] 的内容复制进 cnt[] 里）。   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+10; int n,q; char arr[maxn]; struct Node { int l,r,k,cnt[26]; bool lazy = 0; } tr[4*maxn]; int tmp[26]; inline int len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; for (int i = 0; i \u0026lt; 26; i++) { tr[cur].cnt[i] = tr[lc].cnt[i] + tr[rc].cnt[i]; } if (tr[lc].k != -1 \u0026amp;\u0026amp; tr[lc].k == tr[rc].k) tr[cur].k = tr[lc].k; // k = 1: increasing, k = 0: decreasing else tr[cur].k = -1; } void put(int cur, int k) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; memset(tr[lc].cnt, 0, sizeof(tr[lc].cnt)); memset(tr[rc].cnt, 0, sizeof(tr[rc].cnt)); memcpy(tmp, tr[cur].cnt, sizeof(tmp)); int lsz = len(lc), rsz = len(rc); if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } } assert(lsz == 0); assert(rsz == 0); } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; tr[cur].lazy = 0; tr[lc].lazy = tr[rc].lazy = 1; assert(tr[cur].k != -1); int k = tr[cur].k; tr[lc].k = k; tr[rc].k = k; put(cur,k); } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { memset(tr[cur].cnt, 0, sizeof(tr[cur].cnt)); tr[cur].cnt[arr[L]-'a'] = 1; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } int ress[26]; // 每次query的结果会存到这里 void clear(int* buf) { for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; } int inter(int l1, int r1, int l2, int r2) { // 求区间交集的长度 int l = max(l1,l2), r = min(r1,r2); return max(0,r-l+1); } void update(int cur, int L, int R, int k, int* res) { // 注意参数里有个动态数组 res int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].k = k; tr[cur].lazy = 1; for (int i = 0; i \u0026lt; 26; i++) tr[cur].cnt[i] = res[i]; // 区间完全覆盖，复制到 cnt 中。 clear(res); // 记得清空，之后可能还要用 return; } int mid = (l+r) \u0026gt;\u0026gt; 1; int lsz = inter(l,mid,L,R), rsz = inter(mid+1,r,L,R); int* buf = new int[26]; // 这里采用了动态数组 for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; //注意new出来的需要先清空一下，另外不能使用 memset(因为是指针) if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } delete[] buf; assert(lsz == 0); assert(rsz == 0); push_up(cur); } void query(int cur, int L, int R) { // 求区间内每个字母出现的个数 int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { for (int i = 0; i \u0026lt; 26; i++) ress[i] += tr[cur].cnt[i]; return; } int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(lc, L, R); if (R \u0026gt; mid) query(rc, L, R); push_up(cur); } void printans() { for (int i = 1; i \u0026lt;= n; i++) { memset(ress, 0, sizeof(ress)); query(1,i,i); for (int j = 0; j \u0026lt; 26; j++) { if (ress[j]) { printf(\u0026quot;%c\u0026quot;,(char)('a'+j)); ress[j]--; break; } } } printf(\u0026quot;\\n\u0026quot;); } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;q); scanf(\u0026quot;%s\u0026quot;, arr+1); build(1, 1, n); while (q--) { int l,r,k; scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;l,\u0026amp;r,\u0026amp;k); memset(ress, 0, sizeof(ress)); query(1,l,r); update(1,l,r,k,ress); } printans(); }   例3 洛谷P1972 HH的项链 题意\n给定一个长度为 $N$ 的数组 $a_1,a_2,\u0026hellip;,a_n$，以及 $m$ 个询问，每次询问 $[L,R]$ 之间有多少个不同的数。\n其中，$1 \\leq n,m,a_i \\leq 10^6$\n 题解 我们可以发现，如果我们固定了询问的右端点 $R$，那么无论 $L$ 为多少，在 $R$ 的左侧的所有重复数字中，仅保留最靠右的一个 copy 即可。\n例如 $arr = 1,3,2,1,7,1$，那么我们在遍历到 $i = 4$ 时，我们仅需要保留最后一个 $1$ （也就是 index 为 $4$ 的数字）。\n由上，在处理 区间内不同的数 时，一个常见的套路是：\n 离线处理所有询问，按右端点 $R$ 排序。 从左到右遍历数组，遍历到 $i$ 时，对于所有 $a_i$ 的 copy，仅保留最靠右的那一个（也就是 $i$），之前的所有 copy 全部删除。 回答所有 $[L, i]$ 的询问。  那么对于本题，第一步是离线处理询问，按右端点 $R$ 排序。\n第二步是遍历数组，遍历过程中维护一个 int pos[] 数组，其中 pos[val] 代表：在 $arr[1\u0026hellip;i]$ 中，值为 val 的数 最靠右的 index。\n当我们遍历到 $i$ 时，令 int val = arr[i]，将 pos[val] 处的数字 删掉（更新线段树），然后将 $i$ 处的数字 加入线段树，最后更新一下 pos[val] = i;\n•本题中，删掉就是将 线段树的位置 $i$ 的值 减去$1$，加上就是将 线段树的位置 $i$ 的值 加上$1$。\n然后回答所有 以 $i$ 为右端点的询问（求 $[L,i]$ 的和即可）。\n 注：如果询问 在线 怎么办？可以使用主席树！（对于 pr[i] 建主席树）\n具体做法参考：CF1422F Boring Queries\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 1e6+5; int n, m, arr[maxn]; struct node { int sum; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void update(int cur, int l, int r, int p, int x) { if (l == r) { tr[cur].sum += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].sum; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int ans[maxn]; int pos[maxn]; struct Query { int id,l,r; } q[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; q[i] = {i,l,r}; } sort(q+1,q+m+1, [](auto a, auto b) { return a.r \u0026lt; b.r; // 根据右端点离线 }); int ptr = 1; for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; if (pos[val]) update(1, 1, n, pos[val], -1); // 删去 pos[val] update(1, 1, n, i, 1); // 加上 i pos[val] = i; // 更新 pos[val] while (ptr \u0026lt;= m \u0026amp;\u0026amp; q[ptr].r == i) { // 回答所有以 i 作为右端点的询问 int id = q[ptr].id, L = q[ptr].l, R = q[ptr].r; ans[id] = query(1, 1, n, L, R); ptr++; } if (ptr \u0026gt; m) break; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF1000F One Occurrence 题意\n给定一个长度为 $n$ 的数组，$m$ 个询问，每次询问一个区间 $[l,r]$，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出 $0$。\n其中 $n,m \\leq 5 \\times 10^5$。\n 题解 和例3类似的套路，也是离线处理询问（根据右端点sort），从左往右遍历，仅保留最靠右的复制。\n问题在于怎么删除 和 加入数字？因为本题不再是求数量了，所以不能简单的加 $1$ 或者 减 $1$。\n会发现，我们仅关心一个区间内是否存在 unique 的数字，对于一个询问 $[L,R]$ 内，我们只要看，是否存在 $i$ 使得 $arr[i]$ 的前一个复制 不在 $[L,R]$ 内。（也就是说，pos[val] 是否小于 $L$）\n那么，我们用线段树维护一下 区间最小值 即可，其中 $[L,R]$ 的区间最小值就代表着所有$i \\in [L,R]$ 中，pos[arr[i]] 的最小值。如果一个区间 $[L,R]$ 的最小值 $\\geq L$，那么答案不存在，否则答案存在。\n那么，删除位置 $i$ 就是将它这个位置上的值设为 $inf$。\n加入位置 $i$ 的数，就是将它这个位置上的值设为 pos[arr[i]]。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct node { int pre = 1e9, idx = 0; // pre 代表 pos[val] 的值，idx代表这个最小值对应的 index } tr[maxn\u0026lt;\u0026lt;2]; int pos[maxn], n, m, arr[maxn]; struct Query { int id,l,r; } q[maxn]; void push_up(int cur) { int lpre = tr[cur\u0026lt;\u0026lt;1].pre, rpre = tr[cur\u0026lt;\u0026lt;1|1].pre; if (lpre \u0026lt; rpre) tr[cur].pre = lpre, tr[cur].idx = tr[cur\u0026lt;\u0026lt;1].idx; else tr[cur].pre = rpre, tr[cur].idx = tr[cur\u0026lt;\u0026lt;1|1].idx; } void update(int cur, int l, int r, int p, int x) { if (l == r) { tr[cur].pre = x, tr[cur].idx = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); push_up(cur); } pii query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return {tr[cur].pre, tr[cur].idx}; int mid = (l+r) \u0026gt;\u0026gt; 1; pii r1 = {1e9, 0}, r2 = {1e9, 0}; if (L \u0026lt;= mid) r1 = query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) r2 = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (r1.first \u0026gt; r2.first) return r2; else return r1; } int ans[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; q[i] = {i,l,r}; } sort(q+1, q+m+1, [](auto a, auto b) { return a.r \u0026lt; b.r; }); int ptr = 1; for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; update(1, 1, n, i, pos[val]); // 在i处 加入数字 pos[val] if (pos[val]) update(1, 1, n, pos[val], 1e9); // 在pos[val] 处删除数字（设为 inf） pos[val] = i; while (ptr \u0026lt;= m \u0026amp;\u0026amp; q[ptr].r == i) { int L = q[ptr].l, R = q[ptr].r; pii res = query(1, 1, n, L, R); int id = q[ptr].id; if (res.first \u0026gt;= L) ans[id] = 0; // 如果这个区间内，所有 pos[val] 都 \u0026gt;= L else ans[id] = arr[res.second]; // 否则，答案存在 ptr++; } if (ptr \u0026gt; m) break; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例5 CF803G Periodic RMQ Problem 题意\n给定一个长度为 $n$ 的数组，将这个数组复制为 $k$ 份并且拼接在一起。\n然后回答 $Q$ 个询问，分两种询问：（所有询问都在拼接后的数组上进行）\n$1 ~ l ~ r ~ x$：将 $[l,r]$ 中的所有元素改为 $x$。\n$2 ~ l ~ r$：询问 $[l,r]$ 中的最小值。\n其中，$1 \\leq n \\leq 10^5, 1 \\leq k \\leq 10^4, 1 \\leq Q \\leq 10^5, ~l,r \\in [1,n]$\n 题解 注意到数组的总长度可以达到 $10^9$。但是询问只有 $Q=10^5$，我们于是想到了动态开点线段树。\n但是注意到，这个数组是有初始值的，按理说应该把树建好，不能动态开点。\n所以我们考虑 不建树，而是在开点的时候，把这个点的初始状态处理好（就是在没有任何修改的情况下，这个点的初始状态），然后再对这个点进行操作。\n所以，对于一个点对应的区间 $[l,r]$，怎么处理初始状态？\n注意到，由于数组是一个循环节，所以可以分以下三种情况：\n $[l,r]$ 的长度 $\\geq n$，它的初始最小值就是数组 $[1,n]$ 的最小值。 $[l,r]$ 的长度 $\u0026lt; n$，且属于同一个循环节，那么用 ST表 预处理一下 $[l \\text{ mod } n,r\\text{ mod } n]$ 的最小值即可。 $[l,r]$ 的长度 $\u0026lt; n$，且不属于同一个循环节，那么它的初始最小值就是 $[l \\text{ mod } n, n] \\bigcup [1, r\\text{ mod } n]$  开点的函数是代码里的 build()，注意到只要我们访问到了 cur，并且需要访问它的任意一个 child 时，需要把左右两个子树都开点，这保证了 pushup() 的正确性。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e7+5; const int maxm = 1e5+5; int n,k,Q; int a[maxm]; int belong(int x) { return (x-1) / n + 1; } struct Node { int lc, rc, lazy, val; } tr[maxn]; int id = 0; int st[maxm][18]; int bin[maxm]; void build_st() { bin[1] = 0, bin[2] = 1; for (int i = 3; i \u0026lt; maxm; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; j \u0026lt; 18; j++) { for (int i = 1; i + (1\u0026lt;\u0026lt;j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j-1], st[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } } } int ask_st(int l, int r) { if (l \u0026gt; r) swap(l,r); int j = bin[r-l+1]; return min(st[l][j], st[r-(1\u0026lt;\u0026lt;j)+1][j]); } void build(int\u0026amp; cur, int l, int r) { if (cur) return; cur = ++id; if (r-l+1 \u0026gt;= n) { tr[cur].val = ask_st(1, n); return; } int bl = belong(l), br = belong(r); l %= n, r %= n; if (!l) l = n; if (!r) r = n; if (bl == br) { tr[cur].val = ask_st(l,r); return; } // bl != br tr[cur].val = min(ask_st(l, n), ask_st(1, r)); } void push_down(int cur) { if (!tr[cur].lazy) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int lc = tr[cur].lc, rc = tr[cur].rc; tr[lc].lazy = tr[lc].val = tr[rc].lazy = tr[rc].val = lazy; } void push_up(int cur) { tr[cur].val = min(tr[tr[cur].lc].val, tr[tr[cur].rc].val); } void update(int cur, int l, int r, int L, int R, int x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = tr[cur].val = x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(tr[cur].lc, l, mid); build(tr[cur].rc, mid+1, r); push_down(cur); if (L \u0026lt;= mid) update(tr[cur].lc, l, mid, L, R, x); if (R \u0026gt; mid) update(tr[cur].rc, mid+1, r, L, R, x); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].val; int mid = (l+r) \u0026gt;\u0026gt; 1; build(tr[cur].lc, l, mid); build(tr[cur].rc, mid+1, r); push_down(cur); int lres = 1e9, rres = 1e9; if (L \u0026lt;= mid) lres = query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) rres = query(tr[cur].rc, mid+1, r, L, R); push_up(cur); return min(lres, rres); } int rt = 0; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build_st(); cin \u0026gt;\u0026gt; Q; build(rt, 1, n*k); for (int i = 1; i \u0026lt;= Q; i++) { int op,l,r,x; cin \u0026gt;\u0026gt; op; if (op == 1) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; update(1, 1, n*k, l, r, x); } else { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int res = query(1, 1, n*k, l, r); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   ","date":"2021-03-16T22:10:22+08:00","permalink":"https://tom0727.github.io/post/032-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BE%8B%E9%A2%98/","tags":["暴力优化","线段树"],"title":"线段树/分块 例题"},{"categories":["算法"],"contents":"介绍 树上启发式合并 一般用于 满足以下条件的问题：\n 所有询问离线，无修改，仅询问子树的信息（不能用于链的询问） $ans[u]$ 可以转化为 $\\sum\\limits_{v}ans[v]$ 的形式（其中，$v$ 是 $u$ 的child） 如果已知 $ans[v]$，可以在 $O(1)$ 的时间（或者无需任何操作）添加到 $ans[u]$ (其中，$v$ 是 $u$ 的child）   先用 CF600E 来举个例子。\n题意\n已知一棵包含 $N$ 个节点的有根树（root为 $1$），每个节点 $i$ 有一个颜色 $c_i$。\n对于每一个节点 $i$，我们都要求出它的 subtree（包含自己）中，出现颜色次数最多的所有颜色编号和（可能不止一种颜色）。\n例：$1$ 的subtree中，共有 5 个节点，颜色分别为 $2,2,5,5,1$，那么出现颜色次数最多的颜色编号为 $2,5$，所求的和为 $2+5 = 7$，所以 $ans_1 = 7$。\n输出对于每一个 $i$ 的 $ans_i$\n其中，$1\\leq n \\leq 10^5, 1 \\leq c_i \\leq n$\n 思想 暴力做法 首先，我们开一个全局的数组 cnt[]，记录每一种颜色出现的次数。再开一个全局数组 sum[]，其中 sum[i] 代表出现次数为 i 的颜色的编号和。\n然后，对于每一个节点 $i$，遍历它 subtree 中的所有节点，统计答案。统计完以后，清空这两个全局数组，再换下一个节点重复此步骤。\n复杂度：$O(n^2)$\n优化思路 • 注：以下 $u$ 均表示parent，$v$ 表示 $u$ 的child。\n我们发现，对于任何一个节点 $u$ ，$cnt[u] = \\sum\\limits_v cnt[v]$ ，$sum[u] = \\sum\\limits_v sum[v]$ （这里不是指真的sum，而是说我们可以通过所有child的信息合并，得到 $u$ 的信息）。\n那么，我们的暴力思路是：\n来到节点 $u$ 时，\n 先统计所有 $v$ 的答案 $ans_v$（代表 $v$ 对应subtree的答案），每统计完一个 $v$ 就清空一次全局数组。 全部的 $v$ 统计完以后，再遍历所有的 $v$ 的subtree，把所有 $v$ 的 cnt[], sum[] 进行合并。 加上 $u$ 本身，就得到了 $u$ 所在subtree的答案 $ans_u$。  这里我们发现了一个可以优化的地方：\n对于最后一个 $v$，我们统计完它以后，不需要清空全局数组，因为我们马上就要进行 Step 2，刚好需要合并所有 $v$ 的信息，所以保留它就可以节省一些时间。\n那么这最后一个 $v$，所对应的subtree 自然是 size 越大越好。所以我们就选择 $u$ 的重儿子作为最后一个 $v$。\n这就是树上启发式合并了，复杂度为 $O(n\\log n)$，证明见下面。\n算法步骤  创建全局数组（一般是 cnt[] 一类的数颜色数组）。 进行第一次 $DFS$（$dfs_1$），获得每个节点的 sz[]（subtree大小），son[]（重儿子）。 进行第二次 $DFS$（$dfs_2$），来到节点 $u$ 后：  先递归 $DFS(v)$，对于每一个 $v$（除了重儿子以外），获得 $ans_v$。然后清空全局数组。 递归 $DFS(x)$，获得 $ans_x$（其中，$x$ 是 $u$ 的重儿子）。不清空全局数组。 遍历所有 $v$ 的subtree（除了重儿子以外），把信息加到全局数组上。（注意，这里的遍历并不是上面的 $DFS(v)$，一般实现过程中，用 add(v, 1) 来表示）。 加上 $u$ 自己的信息，得到 $ans_u$。    伪代码 void dfs1(int u, int p) { //略，普通的统计 sz[] 和 son[] } void add(int u, int f) { // 单点更新信息 cnt[u] += f; if (f \u0026lt; 0) maxcnt = 0; //因为 f \u0026lt; 0 时意味着全局数组清空，所以一些额外的全局变量也会清空 } void add(int u, int p, int f) { // 遍历subtree，加到数组上。f = 1（加上信息）或者 -1（清空信息） add(u, f); // 单点更新 for (v : child[u]) { if (v == p) continue; add(v, u, f); } } void dfs2(int u, int p, bool keep) { // keep 代表该节点是否为重儿子（如果keep = 1就不清空数组） for (v : child[u]) { if (v == p || v == son[u]) continue; dfs2(v, u, 0); // Step1: 轻儿子不保留信息，keep = 0表示，在dfs2(v)结束后，全局数组不会有任何变化。 } if (son[u]) dfs2(son[u], u, 1); // Step2: 重儿子保留信息 for (v : child[u]) { if (v == p || v == son[u]) continue; add(v, u, 1); // Step3: 遍历所有v（除了重儿子以外），加上信息 } add(u, 1); // Step 4: 单点更新 u 的信息 ans[u] = (cnt[u] + ...); // Step4: 得到 ans[u] if (!keep) add(u, p, -1); // 如果keep = 0，说明需要清空数组，就把整个subtree(u)的影响再减掉就可以了 } int main() { init(); // 建树，预处理查询等 dfs(1, 0); dfs2(1, 0, 1); }  复杂度证明 对于任何一个节点 $u$，如果它被清空了，那么这说明它的某个祖先是轻儿子。而轻儿子的数量 = 重链数量 = $O(\\log n)$，所以每个节点最多被清空 $\\log n$ 次。总复杂度为 $O(n\\log n)$\n例题 例1 CF600E 题意和题解都讲了，就直接放代码了：\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int n, sz[maxn], head[maxn], ecnt = 1, color[maxn], son[maxn]; ll cnt[maxn], sum[maxn], ans[maxn], maxcnt = 0; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { sz[u] = 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void update(int u, int f) { // 单点更新 int c = color[u]; cnt[c] += (ll)f; sum[cnt[c]-f] -= (ll)c; sum[cnt[c]] += (ll)c; while (f \u0026gt; 0 \u0026amp;\u0026amp; sum[maxcnt+1]) maxcnt++; if (f \u0026lt; 0) maxcnt = 0; } void add(int u, int p, int f) { // f = 1: add, f = -1: del update(u, f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } update(u, 1); ans[u] = sum[maxcnt]; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; color[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例2 CF208E 题意\n已知一棵包含 $N$ 个节点的森林（可能有多个root），并且给出 $M$ 个询问。\n$v, p$：输出存在多少个点 $u$，使得 $u$ 和 $v$ 的第 $p$ 个祖先相同。\n其中，$1\\leq n,m \\leq 10^5$\n 法一树上莫队 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n那么，用 DFS序 先把树上问题转化为区间问题，就变成了：\n在区间 $[L,R]$ 内，有多少个 $u \\in [L,R]$ 使得 dep[u] = dep[x] + p ？\n然后用 莫队 来处理每个询问即可。\n 树上莫队代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, tmp[maxn]; int par[maxn][22]; int cnt[maxn], id[maxn], idcnt = 1; struct Edge { int to, nxt; } edges[maxm]; struct Query { int l,r,id,d; } q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; id[u] = idcnt++; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { // 注意这里先处理parent，之后再 dfs(to) par[u][j] = par[par[u][j-1]][j-1]; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; } } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void add(int x) { cnt[dep[x]]++; } void del(int x) { cnt[dep[x]]--; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } memcpy(tmp, dep, sizeof(dep)); for (int i = 1; i \u0026lt;= n; i++) dep[id[i]] = tmp[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int l,r,d; if (!p) l = 0; else l = id[p]; r = l + sz[p] - 1; d = dep[id[u]]; // find number of vertices in subtree of u, which has depth d q[i] = {l,r,i,d}; } int BLOCK = sqrt(n); sort(q+1, q+m+1, [\u0026amp;](auto a, auto b) { int be1 = (a.l-1) / BLOCK, be2 = (b.l-1) / BLOCK; if (be1 == be2) return a.r \u0026lt; b.r; return be1 \u0026lt; be2; }); int l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int L,R,ID,D; L = q[i].l, R = q[i].r, ID = q[i].id, D = q[i].d; if (!L) { ans[ID] = 0; continue; } while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026gt; L) add(--l); while (l \u0026lt; L) del(l++); ans[ID] = cnt[D] - 1; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   法二树上启发式合并 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n可以发现，如果我们求出来了 child $v$ 的 cnt[] 信息（即，在 $v$ 的subtree内，每个 dep 对应的节点数量），则直接把 cnt[] 数组加到 parent $u$ 上即可。所以在继承重儿子 cnt[] 信息时，无需任何操作。\n这样就可以 树上启发式合并了！\n 树上启发式合并代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, son[maxn]; int par[maxn][22]; int cnt[maxn]; struct Edge { int to, nxt; } edges[maxm]; struct Query { int id, d; }; vector\u0026lt;Query\u0026gt; q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { par[u][j] = par[par[u][j-1]][j-1]; } int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void add(int u, int f) { cnt[dep[u]] += f; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; add(to, f); } } void dfs2(int u, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; dfs2(to, 0); } if (son[u]) dfs2(son[u], 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; add(to, 1); } cnt[dep[u]]++; for (Query que : q[u]) { int id = que.id, d = que.d; ans[id] = cnt[d] - 1; } if (!keep) add(u, -1); } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void debug() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 2; j++) { printf(\u0026quot;i = %d, j = %d, par = %d\\n\u0026quot;,i,j,par[i][j]); } } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int d = dep[u]; // find number of vertices in subtree of u, which has depth d if (!p) ans[i] = 0; else { q[p].push_back({i,d}); } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs2(i, 0); } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 CF1009F 题意\n已知一棵包含 $N$ 个节点的有根树。\n设 $d(u,k)$ 为 $u$ 的subtree中，到 $u$ 距离为 $k$ 的节点数量。\n对于每一个点 $u$，输出一个最小的 $k$，使得 $d(u,k)$ 最大。\n其中，$1\\leq N \\leq 10^6$\n 题解  注意对于这一类型的问题，有些信息看起来是 vertex-dependent（和vertex本身有关，例如 到 $u$ 距离为 $k$）。但是我们转化一下，就可以将它变成一个静态的信息，比如：\n到 $u$ 距离为 $k$ $\\iff$ 深度等于 $dep[u] + k$\n这样，这个信息用一个 cnt[] 数组就可以继承了，例二也是同理。\n 用 cnt[] 数组记录每一个深度 $d$ 对应的数量，维护一个 maxcnt 和 cur，分别代表 $\\max\\limits_k \\{d(u,k)\\}$ 和 $k$ 的值。\n剩下就是启发式合并的板子了。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e6+5; const int maxm = 2e6+10; int head[maxn], dep[maxn], sz[maxn], son[maxn], n, ecnt = 1, cnt[maxn], ans[maxn]; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) maxsz = sz[to], son[u] = to; } } int maxcnt = 0, cur = 1e9; void add(int u, int f) { int d = dep[u]; if (f \u0026gt; 0) { cnt[d]++; if (maxcnt \u0026lt; cnt[d]) { maxcnt = cnt[d]; cur = d; } if (maxcnt == cnt[d] \u0026amp;\u0026amp; cur \u0026gt; d) cur = d; } else { cnt[d]--; maxcnt = 0, cur = 1e9; } } void add(int u, int p, int f) { add(u,f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); add(u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } ans[u] = cur; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] - dep[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF741D 题意\n已知一棵包含 $N$ 个节点的有根树，每条边上有一个字符（a-v共22种）。\n定义 Dokhtar-kosh 路径为满足以下条件的路径：\n 简单路径（无环） 路径上的字符经过重新排序后，可以形成一个回文串  对于每一个节点 $u$，求 $u$ 所在子树中，最长的 Dokhtar-kosh 路径长度。\n其中，$1\\leq N \\leq 5 \\times 10^5$\n 题解 2900分的压轴题，很难。\n首先定义 $f_u$ 为：从 $1$（root）开始，一直到节点 $u$ 的路径所组成的字符序列。\n因为字符只有 a-v 22种，并且我们并不关心字符具体数量，只关心奇偶性，所以可以用 状压 来表示一个字符序列。\n例如：$1 \\rightarrow u$ 的路径上有 $a,a,b,b,b,c$，则对应的bitmask为：$000\u0026hellip;110$（$a$有偶数个，$b,c$有奇数个）。\n我们可以预处理出所有的 $f_u$，怎么得到 $u,v$ 之间路径对应的 $f$ 值？\n会发现：\n$$f_{u,v} = (f_u \\text{ xor } f_x) \\text{ xor } (f_v \\text{ xor } f_x) = f_u \\text{ xor } f_v$$\n其中，$f_{u,v}$ 代表 $u,v$ 之间路径对应的 $f$ 值，$x = LCA(u,v)$。\n 又发现，一个 Dokhtar-kosh 路径只要满足：$f_{u,v}$ 所包含的 $1$ 的数量 $\\leq 1$ 即可。\n例如 $f_{u,v} = 000\u0026hellip;000$ 或 $000\u0026hellip;001$ 或 $000\u0026hellip;010$ 等等…… 均满足条件。\n 所以，问题转化为：\n对于每一个节点 $x$，求 $x$ 所在子树中，距离最长的 $u,v$，使得 $f_{u,v} = f_u \\text{ xor } f_v$ 包含最多一个 $1$。\n 那么这就是一个比较标准的 树形dp 问题：\n定义 $dp[mask]$ 为，在当前的节点 $x$ 的 已探索子树 中，$f_u = mask$ 的 最深深度。（因为 $x$ 太多了，所以不能定义二维数组，只能用一个全局数组）。\n又发现这是关于深度的信息，可以直接向上传递，所以可以采用 树上启发式合并 进行转移。\n对于每一个节点 $u$，dp的转移方程如下：\n  路径完全存在于某一个child的子树内：从所有的child的子树中取最大值即可！ $$ans_u = \\max\\limits_v \\{ ans_v \\}$$\n  $u$ 本身和某一个 child 的子树中某一个节点 $v$ 组成路径： $$ans_u = \\max\\limits_v \\{dp[f_v] + dep[u]\\} - 2\\times dep[u]$$\n其中 $f_u \\text{ xor } f_v$ 只能包含最多一个 $1$。\n  $u$ 的子树中有两个节点 $a,b$ 跨过了 $u$，组成一条路径： $$ans_u = \\max\\limits_b \\{dp[f_a] + dep[b]\\} - 2 \\times dep[u]$$\n其中 $f_a \\text{ xor } f_b$ 只能包含最多一个 $1$。\n  其中，Case $1,2$ 都比较好处理。对于第三种情况，我们可以在 add() 函数中，遍历子树的时候顺便处理。\n 注意，树形dp中一定要注意更新的先后顺序，以免出现某个节点自己和自己形成路径的情况！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; const int maxm = 1e6+10; int head[maxn], ecnt = 1, dep[maxn], sz[maxn], son[maxn], ans[maxn], f[maxn], dp[(1\u0026lt;\u0026lt;22) + 5], masks[25], n; struct Edge { int to, nxt; char c; } edges[maxm]; void addEdge(int u, int v, char c) { Edge e = {v, head[u], c}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p, int mask) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; f[u] = mask; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; int c = edges[e].c - 'a' + 1; dfs(to, u, mask ^ masks[c]); sz[u] += sz[to]; if (maxsz \u0026lt; sz[to]) { maxsz = sz[to]; son[u] = to; } } } int ori; void add(int u, int p, int sgn) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, sgn); } if (sgn \u0026gt; 0) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[ori] = max(ans[ori], dp[tar] + dep[u]); // 注意这里是 ori，因为更新的是 ans[ancestor] } } if (sgn \u0026lt; 0) dp[f[u]] = -1e9; // 这里清空，必须初始化为负无穷 } void update(int u, int p) { dp[f[u]] = max(dp[f[u]], dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; update(to, u); } } void add(int u) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[u] = max(ans[u], dp[tar] + dep[u]); // Case 2: u 本身和 子树内某个节点 } } void update(int u) { dp[f[u]] = max(dp[f[u]], dep[u]); } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); ori = u; // Case 3: 因为 add过程中，需要更新的是 ans[u]，所以用全局变量 ori 来传递。 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); // 树形dp注意点：先更新ans update(to, u); // 更新ans后，再更新dp数组！ } add(u); // 注意这里单点更新 update(u); // 注意这里单点更新 ans[u] -= 2 * dep[u]; // 这里要减去 2*dep[u] ans[u] = max(ans[u], 0); // 需要大于0，因为有可能是负数 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // Case1: 取每个子树的最大值 ans[u] = max(ans[u], ans[to]); // 注意，是在减去 2*dep[u] 以后，才取的max！ } if (!keep) add(u, p, -1); } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; i++) { int p; char c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; addEdge(i, p, c); addEdge(p, i, c); } for (int i = 1; i \u0026lt;= 22; i++) masks[i] = (1\u0026lt;\u0026lt;(i-1)); fill(dp, dp+(1\u0026lt;\u0026lt;22)+5, -1e9); dfs(1, 0, 0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/pb122401/article/details/84648993 https://codeforces.com/blog/entry/44351  ","date":"2021-03-15T20:53:14+08:00","permalink":"https://tom0727.github.io/post/031-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","tags":["树上启发式合并"],"title":"树上启发式合并（DSU on Tree）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc131/tasks/abc131_f\n题意\n给定 $N$ 个二维平面中的点 $(x_i,y_i)$，我们可以一直重复以下操作：\n选择 4 个整数 $a,b,c,d$，保证 $(a,b),(a,d),(c,b),(c,d)$ 中 有且仅有 3 个点存在，并在剩下的那个位置添加一个点。（即，形成一个长方形）\n我们一直重复此操作，求可以进行多少次？（可以证明，一定是有限次）\n其中，$1 \\leq N,x_i,y_i \\leq 10^5$，每个点互不相同。\n 题解 把每一个 $x$ 坐标当作一个 vertex，每一个 $y$ 坐标也当作一个 vertex。\n每个平面上的点当作一个 edge：例如一个点为 $(x_i,y_i)$，就把 $x_i$ 和 $y_i$ 之间连一个 edge。\n我们会发现：一个包含4个点的长方形，刚好就是 4个vertex + 4个edge。所以有：\n能够加一个点 $\\iff$ 4个点连通，且只有3个edge。\n扩展一下，如果有 $n$ 个 $x$ 坐标和 $m$ 个 $y$ 坐标形成同一个连通块，那么我们最多可以有 $n \\times m$ 个点（edge）（长方形中的每一个点都被填上了）。\n 所以，用并查集维护一下所有点形成的连通块，然后找到每个连通块的 $x,y$ 坐标个数。最终减去所有edge数量，即：\n$$ans = \\sum\\limits_i (n_i \\times m_i) - e$$\n  这题主要是学习一下 以坐标为 vertex，点为 edge 的思想\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 2e5+5; const int maxm = 1e5; int n; int par[maxn]; // [1...1e5] 储存x坐标，[1e5+1...2e5] 储存y坐标 int l[maxn], r[maxn]; //记录每个par对应的块有几个x，y坐标 int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u \u0026gt; v) swap(u,v); par[v] = u; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2*maxm; i++) par[i] = i; for (int i = 1; i \u0026lt;= n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unions(x, y+maxm); // y坐标对应的是 y+1e5 } for (int i = 1; i \u0026lt;= maxm; i++) { int u = finds(i); // x坐标 l[u]++; u = finds(i+maxm); // y坐标 r[u]++; } ll ans = 0; for (int i = 1; i \u0026lt;= 2*maxm; i++) { ans += (ll)(l[i]) * (ll)(r[i]); } ans -= n; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题  https://codeforces.com/contest/1012/problem/B （完全一样的思想）  ","date":"2021-03-12T21:48:23+08:00","permalink":"https://tom0727.github.io/post/030-at-abc131f/","tags":["图论","并查集"],"title":"Atcoder ABC 131F（图论）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/165/problem/E\n题意\n给定 $n$ 个数 $a_1,a_2,\u0026hellip;,a_n$，对于每一个 $a_i$，找出是否存在 $a_j$ 使得 $a_i$ \u0026amp; $a_j = 0$？\n其中 $1 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 4\\times10^6$\n 题解 结论1：如果 $a_i$ \u0026amp; $a_j = 0$，则对于 $a_j$ 的任何一个子集 $b$（$b \\subset a_j$），都有 $a_i$ \u0026amp; $b = 0$\n结论2：$\\forall i, ~a_i$ \u0026amp; $($~$a_i) = 0$\n 由上，对于每一个 $a_i$，我们都知道 ~$a_i$ 必然满足条件。所以只要找是否存在 $a_j$ 使得 $a_j \\subset$ ~$a_i$ 即可。\n换而言之，我们可以从高往低进行 dp，从每一个 ~$a_i$ 开始，枚举 ~$a_i$ 的子集，将满足条件的信息传递到子集中，最后看是否存在 $a_j$ 被传递了即可。\n然而直接枚举子集复杂度太高，我们可以考虑按照 位数 进行dp：\n我们从 $111\u0026hellip;111$ 开始枚举，然后枚举少一个 $1$ 的情况：即 $011\u0026hellip;11, 101\u0026hellip;11, 110\u0026hellip;11$ 等等。然后继续往下传递即可。\n 状态转移方程：\n令 dp[mask] 为：这个mask是否存在 $a_j$ 使得 $mask$ \u0026amp; $a_j = 0$，如果存在，就是 $a_j$ 的值，否则为 $-1$\n转移过程就是上述的，枚举 少一个 $1$ 的子集过程。\n• 实现代码中，是从 多一个 $1$ 转移过来的，本质相同。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = (1\u0026lt;\u0026lt;22); // 1\u0026lt;\u0026lt;22 == 4.1e6 int n; int arr[maxn]; int dp[maxm]; int INF = (1\u0026lt;\u0026lt;22) - 1; // 注意INF \u0026gt; 4e6，我们要根据 位数 取INF，而不是根据数据范围 int inv(int x) { return (~x) \u0026amp; INF; // 注意这里有 \u0026amp; INF 的操作，否则会得到负数 } int main() { fill(dp, dp+maxm, -1); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], dp[inv(arr[i])] = arr[i]; for (int mask = INF; mask \u0026gt;= 1; mask--) { // 注意从 INF开始，而不是从 4e6开始，因为 inv(arr[i]) 有可能 \u0026gt; 4e6 if (dp[mask] != -1) continue; for (int j = 0; j \u0026lt; 22; j++) { int a = mask | (1\u0026lt;\u0026lt;j); // 枚举多一位 if (a == mask) continue; if (dp[a] != -1) { dp[mask] = dp[a]; break; } } } for (int i = 1; i \u0026lt;= n; i++) { int a = arr[i]; cout \u0026lt;\u0026lt; dp[a] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   高维前缀和 本题似乎与高维前缀和有关，这里介绍一下高维前缀和的知识。\n高维前缀和主要用于解决 $dp[S] = \\sum\\limits_{T \\subset S}a[T]$ 的问题。\n在我们求一个多维度的前缀和时，有两种方法：（以下，使用求一个矩阵的前缀和来举例）\n法一：枚举dp数组位置 + 容斥： $O(n2^d)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];  法二：枚举维度，不用容斥： $O(nd)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i][j - 1]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j];  • 如上，先枚举了第一维，然后枚举第二维。\n• 这种方法的复杂度远低于法一！\n 如果有更多维度的话，也是枚举每一个维度，然后求每个维度的前缀和：\nfor (int i = 0; i \u0026lt; d; i++) { // 枚举每一个维度 for (int mask = 0; mask \u0026lt; (1\u0026lt;\u0026lt;d); mask++) { //求前缀和 if (mask \u0026amp; (1\u0026lt;\u0026lt;i)) dp[mask] += dp[mask ^ (1\u0026lt;\u0026lt;i)]; } }  ","date":"2021-03-11T23:20:32+08:00","permalink":"https://tom0727.github.io/post/029-cf-165e/","tags":["状压dp"],"title":"CF 165E题解（状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1188/problem/B\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，和一个非负整数 $k$，求满足以下条件的 $(i,j)$ 数量：\n $1\\leq i \u0026lt; j \\leq n$ $(a_i+a_j)(a_i^2+a_j^2) \\equiv k \\text{ mod } p$  其中，$2 \\leq n \\leq 3 \\times 10^5, 2 \\leq p \\leq 10^9, 0\\leq k \\leq p-1, p$ 是质数。\n 题解 一般这种求 $(i,j)$ 的数量，一个常规操作是构造出 $f(i) = g(j)$，然后在遍历过程中维护一个 cnt，直接加到 ans 上。\n所以我们想个办法 把 $i,j$ 分到两边：\n$(a_i+a_j)(a_i^2+a_j^2) = k$，两边同乘 $(a_i-a_j)$，有 $a_i^4-a_j^4 = k(a_i-a_j)$，移项得到\n$$a_i^4 - ka_i = a_j^4-ka_j$$\n所以维护一个 cnt 来记录 $a_i^4 - ka_i$ 的值就可以了，代码略。\n","date":"2021-03-11T14:37:13+08:00","permalink":"https://tom0727.github.io/post/028-cf-1188b/","tags":["枚举"],"title":"CF 1188B（枚举优化）"},{"categories":["算法"],"contents":"介绍 数论分块一般用于解决 含有 $\\lfloor \\frac{N}{i} \\rfloor$ 的求和问题。\n数论分块主要利用了 $\\lfloor \\frac{N}{i} \\rfloor$ 的取值范围相当有限的特点，所以有\n$$i \\leq j, ~\\lfloor \\frac{N}{i} \\rfloor = \\lfloor \\frac{N}{j} \\rfloor$$\n这样一些求和问题就可以转化为 $(j-i+1) \\times \\lfloor \\frac{N}{j} \\rfloor$ （或者类似的形式）\n时间复杂度：$O(\\sqrt n)$\n证明 $\\forall i \\leq n,$ $\\exists$ 最大的 $j$ 使得 $~i \\leq j \\leq n$，且 $\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloor$\n则 $$j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$$\n 证明：\n显然 $j \\leq n$，只要证 $j \\geq i$：\n因为 $j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$，又因为 $i = \\lfloor \\frac{n}{\\frac{n}{i}} \\rfloor$ （分母没有下取整）\n因为 $\\lfloor \\frac{n}{i} \\rfloor \\leq \\frac{n}{i}$，所以有 $j \\geq i$\n例题 例1 求 $\\sum\\limits_{i=1}^N \\lfloor \\frac{N}{i} \\rfloor$  以下的代码中，我们令 l,r 代表上文的 i,j\n int r; for (int l = 1; l \u0026lt;= n; l = r + 1) { // 注意这里是 l = r+1 r = n / (n / i); ans += (n / l) * (r - l + 1); }  • 可以发现，数论分块的本质思想是 枚举 $\\lfloor \\frac{N}{i} \\rfloor$ 的值。\n例2 洛谷P2261 余数求和 题意\n给定正整数 $n,k \\leq 10^9$，求 $\\sum\\limits_{i=1}^n k \\text{ mod } i$\n 题解 因为 （以下略去 下取整符号） $$k \\text{ mod } i = k - \\frac{k}{i} \\times i$$\n对于 $n \u0026gt; k$ 的部分，就加上 $(n-k) \\times k$。\n对于 $n \\leq k$ 的部分，有 $$\\sum\\limits_{i=1}^n k \\text{ mod } i = n\\times k - \\sum\\limits_{i=1}^n \\frac{k}{i} \\times i$$\n然后数论分块枚举 $\\lfloor \\frac{k}{i} \\rfloor$ 的值，每个块分别用等差数列求和即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll ans = 0; if (n \u0026gt; k) { ans += (n-k) * k; n = k; } ll r; ans += (n*k); for (ll l = 1; l \u0026lt;= n; l = r+1) { r = min(n, k / (k/l)); // 注意这里取 min，因为 k/(k/l) 有可能超过n ans -= (k/l) * ((l+r) * (r-l+1) / 2LL); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 Atcoder ABC132F Small Products 题意\n给定正整数 $n \\leq 10^9$，$2 \\leq k \\leq 100$，求满足以下条件的序列数量：\n 长度为 $k$ 任意两个相邻元素的乘积 $\\leq n$  答案对 $10^9+7$ 取模。\n 题解 很容易发现 dp 思路：\n设 $dp[i][j]$ 为：当前用到第 $i$ 个元素，结尾的元素的值为 $j$ 的数量。则答案为 $\\sum\\limits_{j=1}^{n}dp[k][j]$\n但是 $n \\leq 10^9$，dp数组开不了这么大。\n我们可以考虑只将 dp[][] 的第二维开到 $\\sqrt n$ 的大小，对于 $j \u0026gt; \\sqrt n$ 的部分用数论分块解决。\n令 $m = \\sqrt n$，且维护前缀和 $sum[i][j] = \\sum\\limits_{k=1}^j dp[i][j]$，转移方程有：\n$$dp[i][1] = \\sum\\limits_{j=1}^n dp[i-1][j] = \\sum\\limits_{j=1}^m dp[i-1][j] + \\sum\\limits_{j=m+1}^n dp[i-1][j]$$\n其中，\n$$\\forall j \u0026gt; m, ~dp[i-1][j] = \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k]$$\n会发现，对于不同的 $j$，$\\lfloor \\frac{n}{j} \\rfloor$ 的取值相当有限，所以可以用数论分块。所以有：\n$$dp[i][1] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n sum[i-2][\\frac{n}{j}]$$\n第二项用数论分块处理即可，注意到随着 $j$ 的增大，$\\frac{n}{j}$ 逐渐减小，所以可以反着枚举 $j$ （即 $j = m~\u0026hellip;~1$）\n最后，答案就是 $dp[k+1][1] = \\sum\\limits_{j=1}^{n}dp[k][j]$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k,m; ll dp[103][31642]; ll sum[103][31642]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; m = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) dp[1][i] = 1, sum[1][i] = sum[1][i-1] + 1; for (int i = 1; i \u0026lt;= m; i++) dp[2][i] = n/i, sum[2][i] = (sum[2][i-1] + dp[2][i]) % mod; for (int i = 3; i \u0026lt;= k+1; i++) { ll cur = 0; ll l = m+1,r; for (int j = m; j \u0026gt;= 1; j--) { //倒序枚举 j dp[i][j] = sum[i-1][m]; if (n/j \u0026lt;= m) { // 注意这里需要特判，否则 n/j \u0026lt;= m 是有可能的，导致RE continue; } r = min(n/j, n / (n/l)); cur = (cur + ((r-l+1) * (sum[i-2][n/l]) % mod)) % mod; l = r + 1; dp[i][j] = (dp[i][j] + cur) % mod; } for (int j = 1; j \u0026lt;= m; j++) sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod; } ll ans = dp[k+1][1]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-10T15:49:46+08:00","permalink":"https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","tags":["数学"],"title":"数论分块"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1243/problem/E\n题意\n给定 $k$ 个 box，每个 box $i$ 里有 $n_i$ 个整数，所有整数均不同。\n现在我们需要执行 Exactly Once 以下操作：\n从每一个box中拿一个数出来，然后以permutation的形式放回每一个box（即每一个box放入且仅放入一个数）。\n判断是否存在这样的操作使得所有box里的sum相同，如果有，输出具体方案。\n其中，$k \\leq 15, n \\leq 5000$\n 题解 首先，所有box的sum必须被 $k$ 整除，否则无解。\n令 $tar$ 为最终每个box的sum。\n我们可以枚举 $box ~1$ 要拿哪个数出来（叫做 $a_1$），这样我们就可以知道它需要被放入哪个数（叫做 $b_1$）。又因为所有数字都不相同，故我们就可以知道 $b_1$ 的来源是哪个box，假设来自 $box_i$，那么我们就可以得到 $a_i = b_1$，于是就可以计算出 $b_i$，一直这么继续下去。\n如果最终形成了一个 完整环（以 $box_1$ 作为起点，并且以 $box_1$ 作为终点）的话，就说明这个方案可行。\n但是，这个环不一定覆盖了所有的点。所以我们需要找到所有的环，我们分别以 $1,2,3,\u0026hellip;,k$ 作为起点，并且对于每个box都枚举一下要拿的数。这样我们可以最多形成 $\\sum\\limits_{i=1}^k n_i \\leq 75000$ 个环。并且每个环一定互不相同。\n 现在的问题就转化为：给定了这些环，我们能否从中挑选出几个环，使得每个 $box$ 被访问，且仅被访问一次？\n用 Bitmask ！\n因为 $k \\leq 15$，我们将每个环表示为一个bitmask，比如某个环是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 1$，那么对应的bitmask就是 $000\u0026hellip;1011$。\n我们会发现，可能会有很多个环对应同一个bitmask，但是没关系，我们只需要输出一个解即可。\n 最后，问题转化为：给定一些bitmask，如何让它们组合成 $2^k-1$，且每个bit仅被覆盖一次？\n用 状压dp！\n定义 bool ori[(1\u0026lt;\u0026lt;16)+2], dp[(1\u0026lt;\u0026lt;16)+2];\n其中 ori[mask] 代表这个mask是否由 单独一个环 所组成，而 dp[mask] 代表这个mask能否由 $1$ 个 或多个环 组成。\n然后就是一个很经典的模版了：\nfor (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { // 枚举mask的子集，使用 (sub-1) \u0026amp; mask来加速枚举 if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { // 使用xor保证同一个bit只被覆盖一次 dp[mask] = 1; break; } } }   最后就是实现了，本题实现起来相当麻烦，找 完整环 用的是 $dfs$ + $bitmask$ + 记录起点（和起点使用的数），每次找到一个环，就把 起点 放在对应的 $bitmask$ 数组 plan[] 里。\n在找完所有的环之后，再根据每个 $bitmask$，再进行一次 $dfs$ 来找到这个环的具体路径。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define pii pair\u0026lt;int,int\u0026gt; int k; int adj[16][5002]; //记录第i个box的第j个数 int sz[16]; //记录第i个box的大小 ll sum[16]; ll diff[16]; // 记录第i个box的sum和target的差 unordered_map\u0026lt;ll, int\u0026gt; belong; // 记录某个数属于第几个box pii plan[(1\u0026lt;\u0026lt;16)+2]; // 储存每个bitmask对应的起点 {start, a} bool ori[(1\u0026lt;\u0026lt;16)+2]; bool dp[(1\u0026lt;\u0026lt;16)+2]; int from[(1\u0026lt;\u0026lt;16)+2]; // 记录每个bitmask在dp过程中由哪个子集转移过来的 pii ans[16]; void dfs(int cur, ll a, int mask, int start, ll oa) { //cur: current vertex, a: the number we are taking OUT from cur, start: the starting vertex, oa: the \u0026quot;a\u0026quot; for starting vertex ll need = a - diff[cur]; if (!belong.count(need)) return; // no vertex to go int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); if (to == start \u0026amp;\u0026amp; need == oa) { ori[mask] = 1; plan[mask] = {start, oa}; return; } if (mask \u0026amp; (1\u0026lt;\u0026lt;(to-1))) return; // form a cycle, but not a cycle start with \u0026quot;start\u0026quot; dfs(to, need, mask, start, oa); } void dfs2(int cur, ll a, int mask, int start) { ll need = a - diff[cur]; int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); ans[to] = {need, cur}; if (to == start) { return; } dfs2(to, need, mask, start); } void findans(int mask) { if (!ori[mask]) { findans(from[mask]); findans(from[mask] ^ mask); return; } int start = plan[mask].first; ll a = plan[mask].second; dfs2(start, a, 0, start); } int main() { cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { int n; cin \u0026gt;\u0026gt; n; sz[i] = n; for (int j = 1; j \u0026lt;= n; j++) { ll a; cin \u0026gt;\u0026gt; a; adj[i][j] = a; sum[i] += a; belong[a] = i; } } ll tar = 0; for (int i = 1; i \u0026lt;= k; i++) tar += sum[i]; if (tar % k) { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl; return 0; } tar = tar/k; for (int i = 1; i \u0026lt;= k; i++) { diff[i] = sum[i] - tar; } for (int start = 1; start \u0026lt;= k; start++) { for (int j = 1; j \u0026lt;= sz[start]; j++) { dfs(start, (ll)adj[start][j], 0, start, adj[start][j]); } } for (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { dp[mask] = 1; from[mask] = sub; break; } } } if (dp[(1\u0026lt;\u0026lt;k)-1]) { cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; findans((1\u0026lt;\u0026lt;k)-1); for (int i = 1; i \u0026lt;= k; i++) printf(\u0026quot;%d %d\\n\u0026quot;, ans[i].first, ans[i].second); } else { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-09T12:34:01+08:00","permalink":"https://tom0727.github.io/post/026-cf-1243e/","tags":["图论","dp"],"title":"CF1243E 题解（图论，状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1154/problem/G\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，求 $i \\neq j$ 使得 $\\text{lcm}(a_i, a_j)$ 最小？\n其中 $2 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 10^7$\n 题解 一般和 $gcd, lcm$ 相关的题，一般就 $2$ 种trick：\n 质因子分解 枚举 $gcd$ 的值  这道题是 枚举 $gcd$ 的值。因为 $lcm(a_i,a_j) = \\frac{a_ia_j}{\\gcd(a_i,a_j)}$，所以我们枚举一下 $gcd(a_i,a_j)$ 的值即可。\n设 $g$ 为可能的 $gcd$ 的值，从 $1$ 枚举到 $10^7$，对于每一个 $g$，只要找出 最小的两个 $a_i,a_j$ 使得 $g|a_i, g|a_j$ 即可。\n时间复杂度：$T(n) = \\frac{10^7}{1} + \\frac{10^7}{2} + \u0026hellip; + \\frac{10^7}{10^7} = 10^7(1+\\frac{1}{2} + \u0026hellip; \\frac{1}{10^7}) = O(10^7 \\log(10^7))$\n 证明正确性：\n无论最终答案是什么，$\\gcd(a_i,a_j)$ 必然会被枚举到。所以不会漏解。\n如果我们枚举到的 $g$ 不一定是真的 $gcd$ 呢？比如 $g = 2$，然后 $a_i$ 中最小的两个倍数为 $4, 8$？\n答：我们总会枚举到真正的 $gcd$，如果 $g$ 不是真实的 $gcd$，它只会比真实的 $gcd$ 更小，所以获得的 $lcm$ 更大，所以不影响答案的正确性。\n  另：枚举 $gcd$ 的trick之前在 Atcoder-ABC-162E 也出现过。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e6+5; const int maxm = 1e7+5; int arr[maxn]; int vis[maxm]; // 不要用 unordered_set, 会TLE int n; ll ans = 1e18; int ai,aj; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); if (vis[arr[i]] \u0026amp;\u0026amp; arr[i] \u0026lt; ans) ans = arr[i], ai = vis[arr[i]], aj = i; vis[arr[i]] = i; } for (int g = 1; g \u0026lt;= 1e7; g++) { int cur = 0; if ((g\u0026lt;\u0026lt;1) \u0026gt; ans) break; // 优化时间 for (int j = g; j \u0026lt;= 1e7; j += g) { if (vis[j]) { if (cur) { int d = j / g; ll r = 1LL * cur * d; if (r \u0026lt; ans) { ai = vis[cur]; aj = vis[j]; ans = r; } break; } else cur = j; } } } if (ai \u0026gt; aj) swap(ai, aj); printf(\u0026quot;%d %d\\n\u0026quot;, ai,aj); }  ","date":"2021-03-08T21:36:22+08:00","permalink":"https://tom0727.github.io/post/025-cf-1154g/","tags":["枚举","数论"],"title":"CF1154G 题解（gcd/lcm的枚举优化）"},{"categories":["算法"],"contents":"介绍 莫队算法是一种基于分块思想的暴力算法，一般应用于同时满足以下条件的区间问题中：\n 已知 $[L,R]$ 之间的答案，能在 $O(1)$ 时间内转移到 $[L+1,R], [L-1,R], [L,R+1], [L,R-1]$ 的答案。 所有询问均离线。 不存在修改。  我们用模版举个例子：\n题意\n给定一个长度为 $N$ 的正整数序列 $a$，给定一个 $k$，满足 $\\forall i, a_i \\in [1,k]$。\n现在有 $M$ 个询问，每个询问给定一个区间 $[l,r]$，求 $\\sum_{i=1}^kc_i^2$\n其中 $c_i$ 为数字 $i$ 在 $[l,r]$ 中的出现次数。\n数据范围：$1 \\leq n,m,k \\leq 5\\times10^4$\n 算法 Part1 O(1)的状态转移 对于上面的例题，我们可以发现从 $[L,R]$ 转移到 $[L,R+1]$ 是 $O(1)$ 的。\n我们维护两个指针 $l,r$，并且维护一个 cnt[] 数组来记录当前区间的 $c_i$，在 $r$ 右移一格的时候，加上对应的 $cnt$，然后要维护的 $\\sum_{i=1}^kc_i^2$ 也很好转移，计算一下，就会得到\n$$s_{l,r+1} = s_{l,r} + 2\\times c_{a_{r+1}} + 1$$\n同理对于其他三种情况，转移都是 $O(1)$ 的。\n所以，假设我们有两个询问 $[L_1, R_1], [L_2, R_2]$，我们在询问完 $[L_1, R_1]$ 后，将左右指针一个个移动到 $[L_2, R_2]$ 似乎就可以节省一点时间了。（如果它们离得比较近的话）\nPart2 莫队思路 既然我们可以通过维护两个指针 $l,r$ 来快速转移，我们又事先知道所有的询问（因为询问离线），那有什么办法将这些询问靠近一些，来节省更多时间呢？\n分块思想！\n我们将区间划分为 $\\sqrt n$ 块，然后对于每个询问 $[L_i,R_i]$，我们根据 $L_i$ 的值，把它放进对应的块中。\n然后，我们将所有的询问首先根据 所在块的编号 来sort，对于同一块内的询问，根据 $R_i$ 从小到大 来sort。\n最后，根据sort的顺序来处理每个询问，询问之间的转移 就按照上面的左右指针移动来处理。这样我们能在 $O(n\\sqrt n)$ 时间内处理好每一个区间。\n算法步骤  预处理所有询问，记录询问的 l,r，记录 be （代表 l 对应是哪个块），记录 id（代表原先是第几个询问）。 根据 be 作为第一关键字，r 作为第二关键字进行sort。 定义global variable int l = 1, r = 0, ans = 0。 按照sort后的顺序进行询问，调整 l,r 指针，并相应更新 ans，然后将 ans 根据 id 放入答案数组中。  需要注意的点  注意在转移过程中，使用的是 --l 还是 l++。r 还有更新 ans 的时候也类似，要根据具体情况来看。 注意初始情况下， l = 1, r = 0。 be 是根据 l 的位置决定的。  复杂度证明 先注意：\n 同一个块内的 $L_i$ 并没有顺序。 同一个块内的 $R_i$ 没有限制，可以横跨整个区间。  左指针在块内移动 的复杂度：注意到，同一个块内的 $L_i$ 并没有顺序，所以每次询问可能有 $O(B)$ 的复杂度（$B$为块的大小）。总复杂度为 $O(mB)$\n右指针在块内移动 的复杂度：因为是 $R_i$ 是有序的，所以在同一个块内移动的总复杂度为 $O(n)$\n左指针在块之间移动 的复杂度：每次移动复杂度为 $O(2B)$。总复杂度为 $O(\\frac{n}{B} * 2B) = O(2n)$\n右指针在块之间移动 的复杂度：总共有 $\\frac{n}{B}$ 个块，每次在块之间移动没有限制，复杂度为 $O(n)$。总复杂度为 $O(\\frac{n^2}{B})$\n综上，复杂度为 $O(mB) + O(n) + O(\\frac{n^2}{B})$\n当我们取 $B = \\sqrt n$ 时，复杂度为 $O(n \\sqrt n)$\n• 实际上最优复杂度应该取 $B = \\frac{n}{\\sqrt m}$，总复杂度为 $O(n \\sqrt m)$\n例题 例1 小B的询问 就是上面的例题，这里直接放代码。\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m,k; int sz; int arr[maxn]; ll cnt[maxn]; ll ans[maxn]; struct query { int l,r,be,id; } q[maxm]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 1,r = 0; ll add(int x) { ll res = 2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]++; return res; } ll del(int x) { ll res = -2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]--; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; q[i].be = (q[i].l-1) / sz; } sort(q+1, q+m+1, cmp); ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r; while (r \u0026lt; qr) res += add(++r); while (r \u0026gt; qr) res += del(r--); while (l \u0026lt; ql) res += del(l++); while (l \u0026gt; ql) res += add(--l); ans[q[i].id] = res; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 小Z的袜子 题意\n有 $N$ 个袜子，每个袜子 $i$ 有一个颜色 $c_i$，给定 $M$ 个询问 $[L,R]$，每次询问回答 $[L,R]$ 区间内随机抽两个袜子，颜色相同的概率？\n其中 $N,M \\leq 50000, c_i \\in [1,N]$\n 题解 维护 分子和分母：\n每次区间长度加 $1$：分母增加 $len$（$len$ 为增加前的区间长度），分子增加 $cnt_{c_i}$ （$cnt_{c_i}$ 为新增的颜色 $c_i$ 原来的数量）。\n每次区间长度减 $1$：分母减少 $len-1$（$len$ 为减少前的区间长度），分子减少 $cnt_{c_i} - 1$ （$cnt_{c_i}$ 为减少的颜色 $c_i$ 原来的数量）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m; struct query { int l,r,be,id; ll nu,de; } q[maxm]; int arr[maxn]; int cnt[maxn]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) { return a.r \u0026lt; b.r; } return a.be \u0026lt; b.be; } ll nu = 0, de = 0; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int sz; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); for (int i = 1; i \u0026lt;= m; i++) { int l,r; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r); q[i].id = i; q[i].be = (l-1)/sz; q[i].l = l, q[i].r = r; } sort(q+1, q+m+1, cmp); ll l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r, id = q[i].id; if (ql == qr) { q[id].nu = 0, q[id].de = 1; continue; } while (r \u0026lt; qr) de += (r-l+1), r++, nu += cnt[arr[r]], cnt[arr[r]]++; while (r \u0026gt; qr) de -= (r-l), nu -= (cnt[arr[r]] - 1), cnt[arr[r]]--, r--; while (l \u0026gt; ql) de += (r-l+1), l--, nu += cnt[arr[l]], cnt[arr[l]]++; while (l \u0026lt; ql) de -= (r-l), nu -= (cnt[arr[l]] - 1), cnt[arr[l]]--, l++; q[id].nu = nu, q[id].de = de; } for (int i = 1; i \u0026lt;= m; i++) { nu = q[i].nu, de = q[i].de; if (nu == 0) { printf(\u0026quot;0/1\\n\u0026quot;); continue; } ll g = gcd(nu,de); nu /= g, de /= g; printf(\u0026quot;%lld/%lld\\n\u0026quot;,nu,de); } }   例3 CF617E 题意\n给定 $n$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，还有一个整数 $k$ ，以及 $m$ 个询问 $[l,r]$，每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $a_i \\text{ xor } a_{i+1} \\text{ xor } \u0026hellip; \\text{ xor } a_j = k$  其中，$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^6, 0 \\leq a_i \\leq 10^6$\n 题解 首先定义一个前缀 $\\text{ xor }$ 数组满足 $s_i = a_1 \\text{ xor } a_2 \\text{ xor } \u0026hellip; \\text{ xor } a_i$，这样问题转化为：\n每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $s_i \\text{ xor } s_j = k$  注意到，$s_j = s_i \\text{ xor } k$，所以我们可以维护一个 cnt[] 数组，记录一下当前区间每个元素出现了多少次。\n然后，比如在区间扩张的过程中，就检查 cnt[] 中当前元素 cur 出现的次数，给 ans 加上，然后 cnt[cur ^ k]++;\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 1e6+5; int n,m,k; struct query { int l,r,id,be; } q[maxn]; bool cmp(query a, query b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 0, r = -1; int cnt[2*maxm]; int s[maxn]; ll b[maxn]; double start; ll ans = 0; void add(int x) { ans += (ll)cnt[s[x]]; cnt[s[x] ^ k]++; } void del(int x) { cnt[s[x] ^ k]--; ans -= (ll)cnt[s[x]]; } void ask(int L, int R) { while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 1; i \u0026lt;= n; i++) s[i] ^= s[i-1]; int sz = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].l--; q[i].id = i; q[i].be = (q[i].l-1)/sz; } sort(q+1, q+m+1, cmp); for (int i = 1; i \u0026lt;= m; i++) { ask(q[i].l, q[i].r); b[q[i].id] = ans; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   带修莫队 略。例题参考：https://www.luogu.com.cn/problem/P1903\n参考链接  https://ouuan.github.io/post/%E8%8E%AB%E9%98%9F%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/#%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F https://www.cnblogs.com/WAMonster/p/10118934.html  ","date":"2021-03-07T21:50:41+08:00","permalink":"https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/","tags":["莫队"],"title":"莫队"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc194/tasks/abc194_f\n题意\n给定一个数 $1\\leq N \\leq 16^{2\\times10^5}$，求：\n在 16进制 下，满足以下条件的整数 $x$ 数量：\n 拥有 Exactly $K$ 个不同的digit （例如 $x = 1F21$，就有3个不同的digit） $x \\in [1,N]$   题解 我们使用 dp，为了方便处理 $x \\leq N$ 的问题，我们从最高位（Most significant digit）开始处理。\n我们设 dp[i][j] 为，我们处理到了第 i 位，使用了 j 个不同的digit，且满足以下条件的数字 $x$ 的数量：\n $x$ 严格小于 $N$ 的前 i 位 $x \\neq 0$   注意，$x$ 不一定完全有 i 个digit，但是它至少有一个有效的digit。\n 由上，因为第一个条件，我们无论在这一位选择什么digit，都必然会仍然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第一个转移方程：\nfor (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; }   我们发现，这样只考虑到了前 i-1 位至少有一个有效digit的情况，没有考虑全部为前缀0的情况。\n如果前 i-1 位全是前缀0，那么无论在这一位选择任何数，都必然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第二个转移方程：\ndp[i][1] = (dp[i-1][1] + 15) % mod;   注意到，我们的 dp 数组里，并没有包含 $x$ 的前 i-1 位 完全等同于 $N$ 的前 i-1 位的情况。我们需要单独处理它！\n我们在当前这一位（第i位），能够计入 dp 数组的只有 第 i 位小于 $N$ 的第 i 位的情况。\n并且，我们可以很容易得到 $N$ 的前 i-1 位有多少个不同的digit（这样就得到了 dp 数组里的 j）。\n所以，我们只要枚举一下，第 i 位可以选择的所有digit，计算一下不同的digit数量，然后计入 dp 数组即可。\n所以我们得到了第三个转移方程：\nmap\u0026lt;char, int\u0026gt; dict; // 用于将 0123456789ABCDEF map到对应的int set\u0026lt;int\u0026gt; used; // 记录N的前i-1位用了哪些数字 char c = s[i-1]; // N的第i位数字 int cur = dict[c]; int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { //枚举所有可以选择的digit if (!used.count(j)) { // 计算不同digit的数量 dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur);   最后别忘记，看一下 $N$ 自己是否也满足条件（拥有Exactly $K$ 个不同的digit）。\n 小结：\n本题是一个非常不错的dp，主要用了以下几个关键的trick：\n 对于 Exactly $K$ 不同的digit，我们不关心具体是哪几个digit，只需知道不同的digit数量就可以计数了。 通过限制 dp 数组的定义，让 dp 数组仅记录 严格小于 $N$ 的数字，方便计数。 单独处理 $x$ 与 $N$ 的前 i 位相同的情况，并且将符合条件的计数加到 dp 数组当中去。  需要重点关注的是这个 DP并不记录最终答案，而是记录 满足某种条件的部分答案，其余特殊情况单独处理的思想。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll dp[maxn][18]; string s; int k; map\u0026lt;char, int\u0026gt; dict; set\u0026lt;int\u0026gt; used; int main() { fastio; for (int i = 0; i \u0026lt;= 9; i++) dict[(char)(i+'0')] = i; int o = 10; for (char c = 'A'; c \u0026lt;= 'F'; c++) dict[c] = o++; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int n = s.size(); dp[1][1] = dict[s[0]] - 1; used.insert(dict[s[0]]); for (ll i = 2; i \u0026lt;= n; i++) { char c = s[i-1]; dp[i][1] = (dp[i-1][1] + 15) % mod; int cur = dict[c]; for (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; } int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { if (!used.count(j)) { dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur); } if (used.size() == k) dp[n][k]++; ll ans = dp[n][k] % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-03-06T22:16:46+08:00","permalink":"https://tom0727.github.io/post/023-at-abc194f/","tags":["数位dp","进制"],"title":"Atcoder ABC 194F（数位DP，进制处理）"},{"categories":["算法"],"contents":"介绍 树链剖分主要用于将 树上修改/查询 通过 DFS序 变成 区间修改/查询，然后利用 线段树 进行修改/查询。\n我们可以用模版来举个例子：\n题意\n已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n$1\\ x\\ y\\ z$ ：将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n$2\\ x\\ y$ ：求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n$3\\ x\\ z$ ：将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n$4\\ x$ ：求以 $x$ 为根节点的子树内所有节点值之和。\n 主要知识点有三个：DFS序，LCA，线段树\n前置知识回顾 DFS序 DFS序的作用是，根据DFS的顺序将节点编号，就可以得到以下性质：\n 同一个subtree内的编号是连续的，且parent的编号最小。 在从上到下的DFS过程中，一条链上的编号也是连续的，且越靠上，编号越小。   注：记得将原array中的节点权值（或者其他信息） map 到dfs序上的新节点。\n  LCA（最近公共祖先） 在 LCA 中，寻找共同祖先的过程中，要注意不能往上跳过头了，在树链剖分中也一样，只不过没有采用倍增思想。\n 线段树 在树链剖分中，线段树的应用并没有什么变化。\n 概念定义   重儿子：每一个节点的child中，所在subtree（包括它自己）节点数最多的child 叫做该节点的重儿子（每个节点有且仅有一个重儿子）。\n  轻儿子：除了重儿子的所有节点，都是轻儿子。（我们可以把 root 看作一个轻儿子）\n  重边：一个节点连接它的重儿子的edge就是重边。\n  重链：以轻儿子作为起点，向下延伸，连接子树内的所有重儿子，形成的链叫做重链。\n（对于一个leaf，如果它是一个轻儿子，那么它自己形成一条重链）\n  算法 算法步骤如下：\n 进行第一次DFS dfs1() 进行第二次DFS dfs2() 建线段树 将树上操作 对应到 区间上，然后用线段树解决  第一次DFS 第一次DFS，我们需要维护的信息有：\n 记录每个点的 深度： dep[] 记录每个点的 parent： par[] 记录每个点的 subtree大小（包括它自己）：sz[] 记录每个点的 重儿子：son[]  int dep[maxn], par[maxn], sz[maxn], son[maxn]; void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // subtree包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 判断重儿子 maxsz = sz[to]; son[cur] = to; } } }  第二次DFS 第二次DFS，我们需要维护的信息有：\n 记录每个点的 DFS序编号：id[] 记录每个点 所在重链的最顶端：top[] （如果有），将树上的信息通过DFS序编号 转移到 区间上   注意：dfs2() 过程中，我们需要 优先处理重儿子，这是为了保证 同一条重链 对应的必然是 一段连续的区间。\n 这样处理以后，我们能得到如下的DFS序编号：\nint w[maxn]; //weight int arr[maxn]; // array for segment tree to use int top[maxn], id[maxn]; int cnt = 1; //current id void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // 这个节点是leaf dfs2(son[cur], t); // 优先处理重儿子 for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; //重儿子处理过了 dfs2(to, to); // 轻儿子是重链的开始 } }  建线段树 常规操作，并没有什么不同。\n将树上操作对应到区间上 操作 $3,4$ （更新/查询一个子树内的值）：\n在DFS序中，同一个子树内的DFS序编号是连续的，我们有了 parent 对应的编号，就有了区间上的左端点，利用 sz[] 来找到 右端点，左右端点都有了，就用线段树处理即可。\nvoid update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); }   操作 $1,2$ （更新/查询两个点之间最短路径的值）：\n给定两个点 u,v：\n  如果 u,v 在同一条重链上，那么对应的是区间上的一段连续区间（dep 较小的那个对应左端点，dep较深的那个对应右端点），直接用线段树即可。\n  否则，比较 top[u] 和 top[v]，如果 dep[top[u]] \u0026gt; dep[top[v]] （top[u] 比 top[v] 更深），就将 u 往上跳，在线段树上操作 u 到 top[u] 的这一段操作，然后跳到 par[top[u]] 上（即，重链顶端再往上一格），然后重新执行上述判断。\n   为什么要让 top 更深的来跳？为了保证不会跳过头！\n 证明：无论怎么跳，我们都不能超过 u,v 的LCA。设 LCA(u,v) = x，因为它们不在同一条链上，那么 u,v 必然在 x 的两边（或者，其中之一刚好等于 x，另外一个被一个轻儿子挡住了）。无论是哪种情况，因为重链有可能直接从 root 一直延伸下来，所以肯定不能选 top 更靠上层的那个。\n而选择 top 更深的那个，能够保证我们 最远只能刚好跳到x处（因为 x 有且仅有一个重儿子，如果不跳这个重儿子，必然不会跳出 x 的范围）。\n• 由上分析，我们还能发现：在往上跳的过程中，如果发现 u,v 在同一条重链上，那么 dep 较小的那个节点，就是 u,v 的LCA！\nvoid update_path(int u, int v, ll x) { while (top[u] != top[v]) { // u,v 还不是同一个重链上 if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; // 往上跳 } if (dep[u] \u0026gt; dep[v]) swap(u,v); // dep较小的是左端点 update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; }  树链剖分变种（询问边） 如果我们把问题稍微改一下：\n假如现在不再是点上有权值，而是 边上有权值，修改/询问 $(u,v)$ 之间路径上所有边的权值，怎么处理？\n注意到树有一个特别的性质：\n每个节点只有 $1$ 个parent。\n所以我们可以将 边 转化为 点。\n对于一个节点 $u$，如果它有一个parent $p$，那么我们就可以将 $(u,p)$ 这条边，转化为 $u$ 这个点。\n对于每次修改/询问 $(u,v)$，先找到 $LCA(u,v) = x$，然后正常更新，最后将 $x$ 的修改/询问全部撤销掉即可。\n 如上图，$(6,2)$ 这个边，就可以用 $6$ 这个点来表示。\n修改 $6,5$ 之间的路径，就相当于修改 $[6,2]$ 和 修改 $[5,3]$。\n时间复杂度 性质1 如果 $v$ 是 $u$ 的轻儿子，那么 $size(v) \\leq \\frac{size(u)}{2}$\n证明：根据定义即可。\n 性质2 树中任意两条节点之间，重链的数量 $\\leq \\log_2(n)$\n证明：因为每出现一个重链，意味着出现了一个轻儿子，根据性质1，size减少一半，所以\n#重链 $=$ #轻儿子 $= log_2(n)$\n 由性质1，2，我们可知：\n  路径修改/查询：每个重链进行一次线段树操作，有 $log_2(n)$ 个重链，每次线段树操作复杂度为 $log_2(n)$，所以每次路径操作的总复杂度为 $(log_2(n))^2$\n  子树修改/查询：只有一次线段树操作，所以复杂度为 $log_2(n)$\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; const int maxm = 2e5+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int n,m,root,mod; int w[maxn]; //weight int dep[maxn], par[maxn], sz[maxn], son[maxn]; int top[maxn], id[maxn]; int arr[maxn]; // array for segment tree to use int cnt = 1; //current id void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // 包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 更新重儿子 maxsz = sz[to]; son[cur] = to; } } } void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // leaf dfs2(son[cur], t); for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; dfs2(to, to); // 轻儿子是重链的开始 } } struct node { int l,r; ll sum = 0; ll lazy = 0; } tr[4*maxn]; inline ll len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { tr[cur].sum = (tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum) % mod; } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc|1; tr[lc].lazy = (tr[lc].lazy + tr[cur].lazy) % mod; tr[rc].lazy = (tr[rc].lazy + tr[cur].lazy) % mod; tr[lc].sum = (tr[lc].sum + len(lc) * tr[cur].lazy) % mod; tr[rc].sum = (tr[rc].sum + len(rc) * tr[cur].lazy) % mod; tr[cur].lazy = 0; } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { tr[cur].sum = arr[L]; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } void update(int cur, int L, int R, ll x) { int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = (tr[cur].lazy + x) % mod; tr[cur].sum = (tr[cur].sum + x * len(cur)) % mod; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, L, R, x); push_up(cur); } ll query(int cur, int L, int R) { ll res = 0; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].sum; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, L, R); push_up(cur); return res % mod; } void update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); } void update_path(int u, int v, ll x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int u,v,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; x; update_path(u,v,x); } else if (op == 2) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; ll res = query_path(u,v); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 3) { int u,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; x; update_tree(u, x); } else { int u; cin \u0026gt;\u0026gt; u; ll res = query_tree(u); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }  例题 例1 洛谷P2486 [SDOI2011]染色 题意\n给定 $n$ 个节点的树，每个节点都有一个初始的颜色 $c_i$。\n有 $m$ 个操作，操作共两种：\n$C ~ a ~ b ~ c$：将 $a$ 到 $b$ 的路径上的所有节点染色为 $c$。\n$Q ~ a ~ b$：输出 $a$ 到 $b$ 的路径上的颜色段数量。\n• 颜色段的定义：每个最长的同颜色的连续子序列，叫做一个颜色段。例如 $[2,1,1,2,2,1]$ 具有 $4$ 个颜色段。\n 题解 比较明显的树剖思路。问题在于如何维护颜色段的数量？\n先思考一下在一个 数组 上，如何维护？\n 如果两个相邻的区间，相邻的部分的颜色相同，那么它们将合并为一个颜色段。\n 所以，对于每一个区间，我们维护它 左端点的颜色 和 右端点的颜色，并且维护 区间内颜色段的数量。\n在 push_up() 的时候，记得检查一下左区间的右端点 和 右区间的左端点颜色是否相同即可。\n 那么如何在树上进行查询？\n需要注意的是 在树剖中，查询的不一定是数组上的连续区间，但是在树上是连续的。\n所以每次查询完一段区间 $[top[u], u]$，要记录这段区间的左端点 $top[u]$ 的颜色。\n继续往上跳的时候，下一段区间的右端点是 $par[top[u]]$。\n所以要比较一下 $top[u]$ 和 $par[top[u]]$ 的颜色是否相同。相同的话，把答案减 $1$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct node { int l,r; int lc, rc, cnt; //left color, right color bool lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; int color[maxn], last, ori[maxn], par[maxn]; // ori[u] 代表u的颜色 int n,m; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[cur].cnt = tr[l].cnt + tr[r].cnt; tr[cur].lc = tr[l].lc, tr[cur].rc = tr[r].rc; if (tr[l].rc == tr[r].lc) tr[cur].cnt--; // 合并颜色段 } void push_down(int cur) { if (!tr[cur].lazy) return; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[cur].lazy = 0; tr[l].cnt = tr[r].cnt = 1; tr[l].lazy = tr[r].lazy = 1; int c = tr[cur].lc; tr[l].lc = tr[r].lc = tr[l].rc = tr[r].rc = c; } void build(int cur, int l, int r) { tr[cur].l = l, tr[cur].r = r; if (l == r) { tr[cur].cnt = 1; tr[cur].lc = tr[cur].rc = color[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int c) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].cnt = 1; tr[cur].lc = tr[cur].rc = c; tr[cur].lazy = 1; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, c); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, c); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].cnt; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (L \u0026lt;= mid \u0026amp;\u0026amp; R \u0026gt; mid \u0026amp;\u0026amp; tr[cur\u0026lt;\u0026lt;1].rc == tr[cur\u0026lt;\u0026lt;1|1].lc) res--; // 合并颜色段 return res; } int head[maxn], ecnt = 1, son[maxn], id[maxn], idcnt = 0, top[maxn], sz[maxn], dep[maxn]; struct Edge { int to,nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { sz[u] = 1; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) son[u] = to, maxsz = sz[to]; } } void dfs2(int u, int p, int topf) { id[u] = ++idcnt; color[idcnt] = ori[u]; top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } void update(int u, int v, int c) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); int p = top[u]; int L = id[p], R = id[u]; update(1, 1, n, L, R, c); u = par[p]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, 1, n, id[u], id[v], c); } int query_color(int cur, int l, int r, int p) { if (l == r) return tr[cur].lc; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query_color(cur\u0026lt;\u0026lt;1, l, mid, p); else return query_color(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } void query(int u, int v) { int ans = 0; int lastu = -1, lastv = -1; // u和v 的上一次查询的左端点 while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v), swap(lastu, lastv); int p = top[u]; int L = id[p], R = id[u]; ans += query(1, 1, n, L, R); if (lastu == query_color(1, 1, n, R)) { // 如果上一次查询的左端点，等于这次查询的右端点 ans--; } lastu = query_color(1, 1, n, L); // u和v 的上一次查询的左端点 u = par[p]; } if (dep[u] \u0026gt; dep[v]) swap(u,v), swap(lastu, lastv); ans += query(1, 1, n, id[u], id[v]); if (lastv == query_color(1, 1, n, id[v])) ans--; if (lastu == query_color(1, 1, n, id[u])) ans--; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; ori[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); dfs2(1, 0, 1); build(1, 1, n); while (m--) { char op; int u,v; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (op == 'Q') { query(u,v); } else { int c; cin \u0026gt;\u0026gt; c; update(u,v,c); } } }   其他例题  https://codeforces.com/problemset/problem/343/D  参考链接  https://www.luogu.com.cn/problem/P3384 （模版题，上面的AC代码） https://www.cnblogs.com/chinhhh/p/7965433.html （强烈推荐） https://www.cnblogs.com/zwfymqz/p/8094500.html  ","date":"2021-03-06T15:58:27+08:00","permalink":"https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","tags":["树链剖分"],"title":"树链剖分"},{"categories":["算法"],"contents":"介绍 给定一棵有根树（不一定为binary tree），求两个节点的最近公共祖先？\n算法 LCA的思路和ST表比较相似，都是利用了倍增思想，大概流程如下：\n预处理：   用dfs预处理出每一个节点 $u$ 的第$1,2,4,8,\u0026hellip;,$ 个parent（即，如果从$u$ 开始，往上跳 $1,2,4,8,\u0026hellip;,$ 格，是哪个节点）\n  记录每一个节点的深度(depth)\n  预处理parent的时候，利用了倍增的思想：\nfor (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1];   询问 $u,v$ 的LCA：   先比较 $u,v$ 的深度，将深的那个往上跳（使用倍增来跳），跳到同一深度。\n  比较一下当前 $u,v$ 是否相等，如果已经相等了就直接返回 $u$。\n  否则，尝试同时将 $u,v$ 往上跳，从 步幅最大 的开始尝试，如果发现 步幅过大（即 $u,v$ 的第 $j$ 个parent相同），就不跳（防止跳过头了），否则就两者同时往上跳。\n  最后，$u,v$ 必然不相同，此时再让它们同时往上跳 $1$ 格就是LCA了。\n  代码 Luogu-P3379-代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 5e5+5; const int maxm = 1e6+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][33]; //记录parent int d[maxn]; //深度 int n,m,s; int lg[maxn]; //log2预处理 void dfs(int cur, int p) { par[cur][0] = p; d[cur] = d[p] + 1; for (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1]; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, cur); } } int query(int u, int v) { if (d[u] \u0026lt; d[v]) swap(u,v); int diff = d[u] - d[v]; for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= diff; j++) { if (diff \u0026amp; (1\u0026lt;\u0026lt;j)) { u = par[u][j]; } } if (u == v) return u; for (int j = lg[d[u]]; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { // 不相同就往上跳 u = par[u][j], v = par[v][j]; } } return par[u][0]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // s是树的root for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } lg[1] = 0, lg[2] = 1; for (int i = 3; i \u0026lt;= 5e5; i++) lg[i] = lg[i\u0026gt;\u0026gt;1] + 1; } int main() { init(); dfs(s, 0); while (m--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int a = query(u,v); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","date":"2021-03-06T11:57:25+08:00","permalink":"https://tom0727.github.io/post/021-lca/","tags":["LCA","最近公共祖先"],"title":"最近公共祖先 LCA"},{"categories":["算法"],"contents":"介绍 三分法 (tenary search) 和 二分法(binary search) 类似，只不过三分法可以用于搜索一个 二次函数 的最值。\n以搜索二次函数最值为例，假如有一个二次函数存在最大值。\n要搜索这个最大值，可以令 $mid = \\frac{l+r}{2}$，然后令 $lmid = mid - eps$，$rmid = mid + eps$，然后比较一下 $f(lmid)$ 和 $f(rmid)$ 的大小。\n $f(lmid) \u0026lt; f(rmid)$：最大值一定在 $[lmid, r]$ 之间。 $f(lmid) \u0026gt; f(rmid)$：最大值一定在 $[l, rmid]$ 之间。   证明：假如 $f(lmid) \u0026lt; f(rmid)$，那么如果最大值在 $lmid$ 的左边则必然不可能，因为 $rmid$ 离最大值比 $lmid$ 更远。另外一种情况亦然。\n 例题 例1 洛谷P3382 题意\n给定一个 $N$ 次函数，保证 $[l,r]$ 内存在一个点 $x$，使得 $[l,x]$ 单调增，$[x,r]$ 单调减，求 $x$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-7; int n; double l,r; double arr[16]; double get(double x) { double res = 0; double cur = 1.0; for (int i = 1; i \u0026lt;= n+1; i++) { res += cur * arr[i]; cur *= x; } return res; } int main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = n+1; i \u0026gt;= 1; i--) cin \u0026gt;\u0026gt; arr[i]; double low = l, high = r; while (high - low \u0026gt; 5e-7) { double mid = (low + high) * 0.5; double lmid = mid - eps, rmid = mid + eps; if (get(lmid) \u0026lt; get(rmid)) low = lmid; else high = rmid; } printf(\u0026quot;%.7f\\n\u0026quot;, low); }   例2 CF1355E 题意\n有 $N$ 个柱子，高度分别为 $h_1, h_2, \u0026hellip; h_N$。现在有3种操作：\n 令一个柱子的高度+1，cost为 $A$ 令一个柱子的高度-1，cost为 $R$ 令一个柱子的高度+1，且令另外一个柱子的高度-1，cost为 $M$  求最小的cost使得所有柱子高度相等？\n其中 $1 \\leq N \\leq 10^5, 0 \\leq h_i \\leq 10^9$\n 题解 如果我们枚举最终的高度 $h$，对于每一个 $h$ 都可以在 $\\log(N)$ 的时间内计算出来对应的 $cost$。\n然后我们会发现，随着 $h$ 的增加，$cost$ 是一个二次函数，具有一个最小值。（证明略）\n所以就可以使用三分搜索了！\n 因为三分搜索的边界不太好处理，所以可以限定一个范围，在范围之内就停止搜索开始暴力枚举。\n 搜索的部分代码：\nll low = 1, high = 1e9; while (high - low \u0026gt;= 10) { ll mid = (low + high) \u0026gt;\u0026gt; 1; ll lmid = mid-1, rmid = mid+1; ll lv = solve(lmid), rv = solve(rmid); if (lv \u0026gt; rv) low = lmid; else high = rmid; } for (ll p = low; p \u0026lt;= high; p++) { ll r = solve(p); ans = min(ans, r); }  ","date":"2021-03-05T22:20:54+08:00","permalink":"https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/","tags":["三分搜索"],"title":"三分法"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P5664\n题意\n有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的菜。所以总共有 $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m a_{ij}$ 道不同的菜。\n现在需要求做菜方案 （设总共有 $k$ 道菜，$k$ 可以取任何数），满足：\n $k \\geq 1$ 每道菜的烹饪方法 $i$ 各不相同 每种主要食材 $j$ 最多在一半（$\\lfloor \\frac{k}{2} \\rfloor$）的菜中出现  求满足上述条件的做菜方案个数？\n$1 \\leq n \\leq 100, 1 \\leq m \\leq 2000, 0 \\leq a_{ij} \u0026lt; 998244353$\n 题解 首先考虑条件1和2，满足这些条件的总方案数有 $((s_1+1) * (s_2+1) * (s_3+1) * \u0026hellip; * (s_n+1) - 1)$ 种，其中 $s_i = \\sum\\limits_{j=1}^m a_{ij}$\n（因为对于每种烹饪方法 $i$，还可以 不选，所以是 $(s_i+1)$，最后减去 全部不选 的情况）\n这样，我们减去 不满足条件3 的方案数即可！\n我们枚举超过限制的主要食材 $j$，然后设 $dp[i][k]$ 为：当前到了第 $i$ 种烹饪方法，使用了 $k$ 种主要食材 $j$ 的方案数。\n那么问题关键在于，对于某一种烹饪方法 $i$，我们可以不选任何菜，这怎么办？\n我们假设有 $t$ 个不选的，那么总共就选了 $n-t$ 个菜，要保证 $k \u0026gt; \\lfloor \\frac{n-t}{2} \\rfloor$，即 $2k + t \u0026gt; n$。\n所以，我们可以改变一下状态的定义，我们可以将 不选 变成 选了一种主要食材 $j$，而 选择主要食材 $j$ 就变成 选择了两个主要食材 $j$。这样，只要满足 2 * 选择主要食材 + 不选的数量 = 2k + t \u0026gt; n，就不满足条件3了！\n转移方程就很好写了，对于每一种烹饪方法 $i$，有 $3$ 种决策方案：\n 选择主要食材 $j$：dp[i][k] += dp[i-1][k-2] * a[i][j]; 不选任何菜： dp[i][k] += dp[i-1][k-1]; 选择非主要食材：dp[i][k] += (dp[i-1][k] * (sum[i] - a[i][j]));   注意，不能将 dp 数组变成一维然后倒序转移！\n比如，在第三种转移时，(sum[i] - a[i][j]) == 0，那么如果是二维的，此时 dp[i][k] = 0，而如果是一维的，就会变成 dp[i][k] = dp[i-1][k]。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 998244353; const int maxn = 1e5+5; ll dp[103][205]; ll sum[105]; ll a[103][2003]; int n,m; int main() { fastio; ll ans = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; sum[i] = (sum[i] + a[i][j]) % mod; } ans = (ans * (sum[i]+1LL)) % mod; } ll delta = 1LL; for (int j = 1; j \u0026lt;= m; j++) { memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 2*n; k++) { dp[i][k] = (dp[i][k] + dp[i-1][k] * (sum[i] - a[i][j]) % mod) % mod; if (k \u0026gt;= 1) { (dp[i][k] += dp[i-1][k-1]) %= mod; } if (k \u0026gt;= 2) { dp[i][k] = (dp[i][k] + dp[i-1][k-2] * a[i][j] % mod) % mod; } } } for (int k = n+1; k \u0026lt;= 2*n; k++) (delta += dp[n][k]) %= mod; } ans -= delta; (ans %= mod) += mod; ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-05T14:58:19+08:00","permalink":"https://tom0727.github.io/post/019-luogu-p5664/","tags":["数学","计数","dp"],"title":"Luogu P5664 Emiya家今天的饭（计数，dp）"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$\n某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请问每次有多少种付款方法。\n其中，$1 \\leq c_i,d_i,s \\leq 10^5, 1 \\leq n \\leq 1000$\n 题解 先考虑每个硬币有 无限 个的情况。\n设 $dp[i][j]$ 为：使用 前 $i$ 种硬币，购买 价值为 $j$ 的物品的方案数，那么有：\n$dp[i][j] = \\sum\\limits_{k=1}dp[i-1][j-c_i*k]$。\n很明显，这是一个 无穷背包，所以可以直接优化为：\ndp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - c[i] \u0026gt;= 0) dp[j] += dp[j-c[i]]; } }  那么，现在考虑 只有一种硬币有限制 的情况：\n由于 $dp[j]$ 都是从 $dp[j-c_i]$ （实际上就是从 $dp[j-k*c_i]$）转移过来的，那么我们只要把 硬币超出限制的转移情况 删掉即可！\n所以，$dp[j] - dp[(d_i+1) * c_i]$ 就是答案了！\n那么如果 多个硬币有限制 呢？考虑 容斥 ！\n假设有 $3$ 种硬币，那我们就 减去 $1$ 种硬币超限的情况，加上 $2$ 种硬币超限的情况，减去 $3$ 种硬币超限的情况。\n枚举这些情况，使用 bitmask 即可！(具体的见代码)\n 容斥中，每一项的符号根据 bitmask 中 bit 的个数来决定！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; ll dp[maxn]; int arr[5]; int d[5]; int q,s; int main() { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; q; dp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - arr[i] \u0026gt;= 0) dp[j] += dp[j-arr[i]]; } } while (q--) { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; d[i]; cin \u0026gt;\u0026gt; s; ll ans = dp[s]; for (int mask = 1; mask \u0026lt;= (1\u0026lt;\u0026lt;4)-1; mask++) { // 枚举容斥 int cnt = 0; int cur = 0; for (int j = 1; j \u0026lt;= 4; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;(j-1))) { cur += ((d[j]+1) * arr[j]); cnt++; // 判断加号还是减号 } } if (s \u0026gt;= cur) { if (cnt \u0026amp; 1) ans -= dp[s - cur]; else ans += dp[s - cur]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   其他例题(TODO) ","date":"2021-03-04T23:29:54+08:00","permalink":"https://tom0727.github.io/post/018-luogu-p1450/","tags":["数学","计数","容斥"],"title":"Luogu P1450 硬币购物（计数，容斥）"},{"categories":["算法"],"contents":"记录一些组合数学的公式。\n公式 组合数 $C(n,m)$  $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \\frac{n!}{k!(n-k)!}$   注：$0! = 1, (0!)^{-1} = 1$\n 证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素：\n 如果它被选中，有 $C_{n-1}^{k-1}$ 种。 如果它没有被选中，有 $C_{n-1}^k$ 种。    二项式定理 $(a+b)^n = \\sum\\limits_{k=0}^n C_n^ka^kb^{n-k}$\n 卡特兰数 (Catalan) 通项公式：\n $H_n = 1 ~ (n=0,1)$\n  $H_n = \\frac{C_{2n}^n}{n+1}~(n \\geq 2)$\n  $H_n = C_{2n}^n - C_{2n}^{n-1}$\n  递推式：\n  $H_n = \\sum\\limits_{i=0}^{n-1}H_{i}H_{n-i-1} = H_0H_{n-1} + H_1H_{n-2} + \u0026hellip; + H_{n-1}H_0$\n  $H_n = \\frac{(4n-2)}{n+1} H_{n-1}$\n   第二类斯特林数 $S(n,m)$ 代表将 $n$ 个不同的小球，放进 $m$ 个相同，非空盒子的方案数\n通项公式：\n$S(n,m) = \\sum\\limits_{i=0}^m (-1)^{m-i}\\frac{i^n}{i!(m-i)!}$\n递推式：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n证明 考虑第一个小球，有两种情况：\n 独占一个盒子：相当于，其他 $n-1$ 个小球要放进 $m-1$ 个盒子中，且盒子不为空，所以为 $S(n-1,m-1)$ 不独占一个盒子：相当于，先将其他 $n-1$ 个小球放进 $m$ 个盒子中，且盒子不为空，然后从 $m$ 个盒子中选一个，把当前小球放进去，所以为 $m*S(n-1,m)$   经典例题 例1 男女生排列问题 题意\n三个女生和五个男生站成一排。\n  如果女生必须全排在一起，有多少种排法？\n  如果女生不能相邻，有多少种排法？\n  如果两端都不排女生，有多少种排法？\n  如果两端不都排女生，有多少种排法？\n   第一题答案 将3个女生看作1个，所以就有 $A_6^6$ 种。对于女生内部的排列有 $A_3^3$ 种。所以总共为 $A_6^6A_3^3$ 种。\n 第二题答案 先排男生，有 $A_5^5$ 种，然后将女生插入6个空位中，有 $A_6^3$ 种。所以总共为 $A_5^5A_6^3$ 种。\n 第三题答案 先排好两个男生在两边，有 $A_5^2$ 种，两个男生中间的人就可以随便排了，就有 $A_6^6$ 种。所以总共为 $A_5^2A_6^6$ 种。\n也可以这么想，让女生在中间的6个位置先选好3个，有 $A_6^3$ 种，剩下的男生随便排，有 $A_5^5$ 种。所以总共为 $A_6^3A_5^5$ 种，答案和上面一样。\n 第四题答案 所有排列情况有 $A_8^8$ 种，如果两边都排女生，有 $A_3^2A_6^6$ 种。所以总共为 $A_8^8 - A_3^2A_6^6$ 种。\n  例2 小球放盒子问题 假设有 $n$ 个小球，$m$ 个盒子。\n小球无区别-盒子无区别-不允许空盒 略（还没遇到）\n 小球无区别-盒子无区别-允许空盒 略（还没遇到）\n 小球无区别-盒子有区别-不允许空盒 使用隔板法，在 $n$ 个小球中间放置 $m-1$ 块挡板，将小球分为不为空的 $m$ 部分。小球之间的空位有 $n-1$ 个。所以答案为\n$C_{n-1}^{m-1}$\n 小球无区别-盒子有区别-允许空盒 先多加 $m$ 个小球，转化为 不允许空盒 的问题后，再把多加的 $m$ 个小球拿出来即可。所以答案为\n$C_{n+m-1}^{m-1}$\n 小球有区别-盒子无区别-不允许空盒 答案就是第二类斯特林数 $S(n,m)$，递推式如上：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n 小球有区别-盒子无区别-允许空盒 在 不允许空盒 的基础上，枚举一下 空盒的个数。所以答案为\n$\\sum\\limits_{i=1}^{\\min(n,m)}S(n,i)$\n 小球有区别-盒子有区别-不允许空盒 在 盒子无区别 的基础上，乘上盒子的排列 $m!$ 即可，所以答案为：\n$S(n,m) * m!$\n 小球有区别-盒子有区别-允许空盒 每个小球可以随便选，互不影响，所以答案为：\n$n^m$\n  例3 错排问题 题意\n有 $1,2,3,\u0026hellip;,n$ 这些数字，重新排序使得不存在任何一个数字的位置和原来相同，有多少种方法？\n 答案 $D_n = (n-1)(D_{n-1} + D_{n-2})$，其中 $D_1 = 0, D_2 = 1$\n证明：初始情况下如图：\n在图中，上下两行对应的元素需要错开。我们设这种情况下，排序的方法有 $f(n)$ 种。\n对于元素 $1$，我们可以选择除 $1$ 以外的任何一个元素，所以有 $n-1$ 种。\n假设我们选了 $1 \\rightarrow 2$，就会变成下图：\n那么，再看元素 $2$：\n  如果 $2 \\rightarrow 1$，那么就会变成下图，即 $f(n-2)$ 种。   如果 $2 \\rightarrow 3 ~ or ~ 4 ~ or ~ \u0026hellip; ~ n$，就相当于 $2$ 和 $1$ 必须错开，那就相当于下图，即 $f(n-1)$ 种。\n  所以最终就可以得到 $f(n) = (n-1)(f(n-1) + f(n-2))$\n","date":"2021-03-02T18:35:43+08:00","permalink":"https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["数学"],"title":"组合数学"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f\n题意\n初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种：\n1 a b：令 $f(x) = f(x) + |x-a| + b$\n2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值\n 题解 $f(x)$ 必然长这样：$f(x) = |x-a_1| + |x-a_2| + \u0026hellip; + |x-a_n| + \\sum\\limits_{i=1}^{n}b_i$\n要让 $f(x)$ 最小，就令 $x$ 等于 $a_1,a_2,\u0026hellip;,a_n$ 的中位数。\n那么已知中位数 $a_k$ 的话，如何找到 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ ？\n假设 $n$ 为奇数，那如果我们将 $a_i$ sort 一下，有：\n$\\sum\\limits_{i=1}^{n} |a_{\\frac{n+1}{2}} - a_i| = \\sum\\limits_{i=1}^{\\frac{n}{2}}(a_{\\frac{n+1}{2}+i} - a_{\\frac{n+1}{2}-i})$\n如果我们分开维护中位数 $a_{\\frac{n+1}{2}}$ 左右两边的 sum 就可以 $O(1)$ 求和了！\n 用对顶堆！\n我们维护两个 multiset\u0026lt;ll\u0026gt;，一个是大顶堆（叫做small），维护小于等于中位数的部分。一个是小顶堆（叫做big），小顶堆维护大于等于中位数的部分，并且保证两者的 size 之差 $\\leq 1$。\n 插入新值的时候，就和当前中位数比较一下，如果小于等于中位数就插入small，否则插入big，然后看一下size之差，如果 size之差 $\u0026gt; 1$ 就从多的那个堆取出来，插入另外一个堆，这样就动态调整了中位数。\n 这样我们可以 $O(1)$ 求出中位数，并且 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ 也可以 $O(1)$ 得出，用big的$sum$ 减去 small的 $sum$ 即可。（写的时候需要讨论一下 size 之差为 1,0,-1 的三种情况）。\n细节部分直接看代码吧。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e5+10; ll c = 0, ssum = 0, bsum = 0; multiset\u0026lt;ll\u0026gt; big; multiset\u0026lt;ll, greater\u0026lt;ll\u0026gt; \u0026gt; small; void ins(ll a, ll b) { c += b; if (!small.size()) { ssum += a; small.insert(a); return; } if (a \u0026lt;= *small.begin()) { small.insert(a); ssum += a; } else { big.insert(a); bsum += a; } if (small.size() \u0026gt; big.size() + 1) { auto p = small.begin(); bsum += *p, ssum -= *p; big.insert(*p); small.erase(p); } if (big.size() \u0026gt; small.size() + 1) { auto p = big.begin(); bsumssum += *p; small.insert(*p); big.erase(p); } } void query() { ll ans = bsum if (small.size() == big.size()) { cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (small.size() == big.size() + 1) { ans += *small.begin(); cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (big.size() == small.size() + 1) { ans -= *big.begin(); cout \u0026lt;\u0026lt; *big.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { fastio; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ins(a,b); } else { query(); } } }   其他例题(TODO)  https://www.luogu.com.cn/problem/P3644  ","date":"2021-03-01T21:35:11+08:00","permalink":"https://tom0727.github.io/post/016-at-abc127f/","tags":["数据结构","堆"],"title":"Atcoder ABC 127F（对顶堆动态维护中位数）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e\n题意\n给定一个矩阵，包含 $N \\times M$ 个格子，现在从中选出 $K \\leq N \\times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), \u0026hellip; , (x_K, y_K)$ ，记\n$cost = \\sum\\limits_{i=1}^{K-1}\\sum\\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$\n求：对于所有不同的 $K$ 个格子的选法，$cost$ 的sum为多少？\n 法一概率 选 $k$ 个格子的方案数为 $C(n+m, k)$，在 $k$ 个格子中，任选 $2$ 个出来，有 $C(k,2)$ 种，考虑它们的贡献：\n因为是全部方案，所以可以考虑用 期望值 来做！\n问题转化为，从 $N \\times M$ 的矩阵中，选择 $2$ 个不同的点 $(x_i, y_i), (x_j,y_j)$ ，求 $|x_i - x_j| + |y_i-y_j|$ 的期望？\n期望为： $\\frac{n+m}{3}$\n 如果推式子很难，这里是一些小技巧（仅用于 分母中无 $n,m$ ，并且分子中不存在 $nm$ 之类的项）：\n 打表找规律：假设期望值 $E(n,m)$ 是一个关于 $n,m$ 的多项式，那么固定一下 $n$ 的值，然后让 $m = 1,2,3\u0026hellip;$ 来打表找出 $E(n,m)$ 和 $m$ 的关系。同理可以找出 $E(n,m)$ 和 $n$ 的关系，相加一下就可以了。\n  拉格朗日插值法：设 $ans = F(n,m) = E(n,m) * C(nm, 2)$，我们可以固定 $n$，然后用插值法找出 $F(n,m)$ 和 $m$ 的关系。（这个函数有两个变量，按理说应该是固定每一个 $n$ 然后对每一个 $n$ 都进行一次插值法的，以后遇到了可以尝试一下。）\n  严谨证明：\n考虑一个点 $(x,y)$，那么\n纵向贡献 为： $v_{x,y} = [(1+2+\u0026hellip;+x-1) + (1+2+\u0026hellip;+n-x)] * m$\n横向贡献 为： $h_{x,y} = [(1+2+\u0026hellip;y-1) + (1+2+\u0026hellip;+m-y)] * n$\n期望就是 $E(n,m) = \\frac{\\sum\\limits_{x=1}^n \\sum\\limits_{y=1}^m (v_{x,y} + h_{x,y})}{C(nm,2)} = \\frac{n+m}{3}$\n 以上，最终的答案就是\n$ans = C(nm,k) * C(k,2) * \\frac{n+m}{3}$\n 法二计数 我们选择 $2$ 个格子，有 $C(nm-2, k-2)$ 种。\n对于横坐标的差值为 $d_x$ 的情况，有 $(n-d_x) m^2$ 种。贡献就是 $(n-d_x)m^2*d_x$\n对于纵坐标的差值为 $d_y$ 的情况，有 $(m-d_y) n^2$ 种。贡献就是 $(m-d_y) n^2*d_y$\n所以答案就是\n$ans = C(nm-2, k-2) (\\sum\\limits_{d_x=1}^{n-1} (n-d_x)m^2*d_x + \\sum\\limits_{d_y=1}^{m-1} (m-d_y)n^2*d_y)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll n,m,k; ll fac[maxn]; void init() { fac[0] = 1; fac[1] = 1; for (int i = 2; i \u0026lt;= n*m; i++) { fac[i] = (fac[i-1] * (ll)(i)) % mod; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; init(); ll nu = fac[n*m] * k % mod * (k-1) % mod * (n+m) % mod; ll de = inv(fac[k]) * inv(fac[n*m-k]) % mod * inv(6) % mod; cout \u0026lt;\u0026lt; (nu * de) % mod \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/weixin_30323631/article/details/96351727 https://blog.csdn.net/qq_40655981/article/details/90642350  一些数学知识 Q1. 如果不限定坐标为整数，长度为 $n$ 的线段上任取两个点，距离期望值是？\nA1. 答案为 $\\frac{n}{3}$，有两种方法。\n第一种：先假设坐标只能为 $1,2,\u0026hellip;,n$ 的整数，那么求出的期望是 $E_n = 2\\times \\frac{\\sum\\limits_{i=1}^{n}i(n-i)}{n^2} = \\frac{n^2-1}{3n}$，取一个 $n$ 趋向无穷，就有 $E = \\lim_{n \\to \\infty} \\frac{n^2-1}{3n} = \\frac{n}{3}$\n 上述推导需要用到 $1^2 + 2^2 + \u0026hellip; + n^2 = \\frac{1}{6}n(n+1)(2n+1)$\n 第二种：先假设线段长度为 $1$，则有期望为 $\\frac{\\int_{0}^1 \\int_{0}^1 |x-y| ~dydx}{\\int_{0}^1 \\int_{0}^1 1~ dydx} = \\int_{0}^1 \\int_{0}^x (x-y) ~ dydx + \\int_{0}^1 \\int_{x}^1 (y-x) ~dydx = \\frac{1}{3}$，对于线段长度为 $n$，乘上 $n$ 即可。（记得分母要除以样本空间，即 $\\int_{0}^1 \\int_{0}^1 1~ dydx$）\n Q2. 如果不限定坐标为整数，$n \\times n$ 的正方形中任取两个点，距离期望值是？\nA2. 答案约为 $0.521$，具体分析可以见 这里 和 这里\n其他例题(TODO)  https://www.luogu.com.cn/problem/P4781  ","date":"2021-02-28T23:20:51+08:00","permalink":"https://tom0727.github.io/post/015-at-abc127e/","tags":["数学","计数","概率"],"title":"Atcoder ABC 127E（数学，计数，概率）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e\n题意\n给定 $2 \\leq N \\leq 10^5, 2 \\leq K \\leq 10^5$，现有长度为 $N$ 的序列 $\\{ a_1, a_2, \u0026hellip;, a_N \\}$，其中 $1 \\leq a_i \\leq K$\n这样的序列总共有 $K^N$ 个，求所有这些序列的 $\\sum \\gcd(a_1,a_2,\u0026hellip;,a_N)$？\n 题解 发现我们可以根据 $\\gcd$ 的值进行枚举，我们设 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = x$ 的序列数量为 $d_x$，则有：\n$d_1 = K^N - d_2 - d_3 - \u0026hellip; - d_k$\n那么 $d_2$ 呢？我们发现如果 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = 2$，则所有的 $a_i$ 必然为 2的倍数，所以每个位置上有 $\\frac{K}{2}$ 种选法，即：\n$d_2 = (\\frac{K}{2})^N - d_4 - d_6 - \u0026hellip; - d_{\\frac{K}{2} \\times 2}$\n同理有：\n$d_3 = (\\frac{K}{3})^N - d_6 - d_9 - \u0026hellip; - d_{\\frac{K}{3} \\times 3}$\n\u0026hellip;\n$d_K = 1$\n这样，直接用一个 dp[] 记录一下 $d_x$ 的值，然后倒着枚举，暴力计算即可。\n最终的答案为 $\\sum\\limits_{i=1}^K i \\times dp[i]$\n时间复杂度：$T(K) = K + \\frac{K}{2} + \\frac{K}{3} + \u0026hellip; + \\frac{K}{K} = K(1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K})$\n发现这个是 harmonic series 的和，复杂度大概为： $1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K} = O(\\log k)$\n所以最终时间复杂度是 $O(K\\log K)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; int n,k; ll dp[maxn], ans = 0; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = k; i \u0026gt;= 1; i--) { ll d = 0; for (int j = 2; i * j \u0026lt;= k; j++) { d += dp[i*j]; } d %= mod; ll r = qpow(k/i, n); dp[i] = (r-d+(ll)mod) % mod; ans = (ans + (ll)(i) * (ll)(dp[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   一些拓展 在洛谷上看题解的时候，看到了莫比乌斯反演的方法，如果未来学了的话可以重新来做一下，loj上有加强版的题目 ($K \\leq 10^{11}$)\n其他例题(TODO)  https://loj.ac/p/6491 (需要莫比乌斯反演)  ","date":"2021-02-27T14:59:58+08:00","permalink":"https://tom0727.github.io/post/014-at-abc162e/","tags":["数学","计数"],"title":"Atcoder ABC 162E（数学，计数）"},{"categories":["算法"],"contents":"定义 最小环：指图中的一个环，它不包含任何更小的环。\n在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-loop的情况）\n无权无向图求最小环 例题: https://codeforces.com/contest/1364/problem/D\n题意\n给定一个 connected undirected graph:\n$n$个vertex, 和一个int $k$, 其中 $3 \\leq k \\leq n$, 请找出 以下的其中之一:\n  一个独立集(set of vertex， 两两之间没有edge)， 包含 $\\lceil\\frac{k}{2}\\rceil$ 个vertex\n  一个simple cycle (set of vertex, 不包含重复vertex)， 其中 $len \\leq k$\n   题解   如果这是一个tree ($m = n-1$), 则 (1)很容易找, 只要dfs一下，做一个图的染色 (染成 $0,1$)即可, 最后取 全部的 $0$ 或者 全部的 $1$\n  如果不是tree, 必然存在cycle, 那么我们可以找到一个最小环, 最小环必然满足 (1) 或者 (2)！（易证）\n  •怎么找最小环? 用DFS!\n 维护一个环的长度 len 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 pre[] 数组, pre[u] 代表dfs过程中 u的parent 维护一个 int c, 代表找到的cycle的 终点!  然后，\n  从vertex 1开始dfs， dep[to] = dep[cur] + 1 这样来更新 dep[]\n  当我们找到一个backward edge时, 更新最小环长度\nlen = min(len, abs(dep[to] - dep[cur]) + 1))  并且更新c, 使得 c = cur, 然后继续探索！\n  dfs结束后, 直接用\nvector\u0026lt;int\u0026gt; cycle; void findcycle() { while (len--) cycle.push_back(c), c = pre[c]; }  即可找到最小环！\n  时间复杂度：$O(n+m)$\n 无权有向图求最小环 例题：https://atcoder.jp/contests/abc142/tasks/abc142_f\n题意\n给定一个 directed graph，求它的一个 subgraph 满足：\n $V'$ 是 $V$ 的 non-empty subset $E'$ 是 $E$ 中，所有两端均在 $V'$ 内的edges $V'$ 中，所有的 vertex 的 in-degree 和 out-degree 均为1   题解 易知，最小环满足这个条件！\n如何求最小环？可以用 $N$ 次 DFS！\n 维护 ed 代表环的终点，维护最小环长度 final 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 par[] 数组, par[u] 代表dfs过程中 u的parent 维护一个 in[] 数组，代表在dfs过程中，当前的某个vertex是否存在于递归stack中！  dfs过程如下：\nint n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { // 必须得在递归栈内 int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; }   为什么要加 in[] 数组？\n 如下图：\n我们需要保证这个环必然全部同时出现在递归stack内，否则可能会出问题！\n（如上图，如果不考虑 in[] 数组的话，就有可能错误的把 1-\u0026gt;3-\u0026gt;2 当作一个环！\n 为什么要使用 $N$ 次 dfs ？\n 如下图：\n如果我们从 $1$ 开始进行 dfs，那么如果是按照图上的访问顺序，会导致我们找不到最小环！\n但是如果从 $7$ 开始进行 dfs，就可以找到了！\n所以我们需要每一个点都开始一次dfs，总共 $N$ 次 dfs。\n 注：优化：可以在每次dfs中找到的环中找最小环，如果不是环中的节点，就不需要考虑了。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define abs(a) ((a\u0026gt;0)?a:-(a)) const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e3+10; struct Edge { int to,nxt; } edges[maxm]; int head[maxn], ecnt = 1; int n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); } } void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; } void renew() { fill(dep, dep+n+1, 0); fill(par, par+n+1, 0); fill(in, in+n+1, 0); ans = 1e9; } int main() { fastio; init(); for (int i = 1; i \u0026lt;= n; i++) { dfs(i); if (ans \u0026lt; final) { final = ans; cycle.clear(); while (ans--) cycle.push_back(ed), ed = par[ed]; } renew(); } if (final == 1e8) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; final \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int a : cycle) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   有权图求最小环 Floyd $O(n^3)$ 可求！\n","date":"2021-02-25T23:41:02+08:00","permalink":"https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/","tags":["图论","最小环","dfs"],"title":"最小环"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1395/problem/E\n题意\n给定一个 directed and weighted graph，$2 \\leq n \\leq 2\\cdot10^5, 2 \\leq m \\leq \\min(2\\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\\leq k \\leq 9$，每个edge的weight均不相同。\n现在定义一个tuple $(c_1,c_2,\u0026hellip;,c_k)$，其中， $\\forall j \\in [1,k]$，有 $1\\leq c_j \\leq j$。\n且对于所有 out-degree 等于 $j$ 的vertex，只保留它的out-going edges中，weight第 $c_j$ 小的那个edge。\n 例如，对于vertex 5，有 $3$ 条out-going edges (以(u,v,w)的形式)： $(5,2,233), (5,4,25), (5,6,999)$\n如果 $c_3 = 1$，因为 vertex 5 具有 out-degree = $3$，所以 $c_3$ 生效，因为 $c_3 = 1$，所以保留第 $1$ 小的edge，也就是$(5,4,25)$。\n 现在求 $(c_1,c_2,\u0026hellip;,c_k)$ 的数量，使得整个图是强连通的。\n 题解 首先可以发现，因为每个edge的weight都不同，所以对于每一个vertex来说，必然只能保留最多 $1$ 个out-going edge。所以整个图中，只有 $n$ 个edge。\n又因为需要强连通，所以它只有可能是 一个环！所以只要看 每个vertex的 in-degree 是否都等于$1$即可！\n再转化一下，我们只要看在 $(c_1,c_2,\u0026hellip;,c_k)$ 的情况下，所有out-going edge所指向的vertex，并起来，形成的 可重复集合(multiset) 是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n我们可以预处理出 对于每一个 $j$，如果 $c_j = x$，所指向的vertex组成的集合。然后在枚举 $(c_1,c_2,\u0026hellip;,c_k)$ 的时候，判断一下这些集合的并集是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n那么，如何快速的\n 判断集合是否相等 和 求可重复并集 呢？  使用Hashing！\n 我们要定义一种Hash函数，使得上述两个操作的速度为 $O(1)$ 。\n在字符串哈希中，我们用字符的位置来hash，但是因为我们不关心集合中元素的顺序，所以可以用集合中元素的value来hash！\n假设给定一个集合 $\\{a_1,a_2,\u0026hellip;,a_m\\}$，定义哈希值为：$\\sum\\limits_{i=1}^mp^{a_i} = p^{a_1} + p^{a_2} + \u0026hellip; + p^{a_m}$，这样：\n 判断集合是否相等：直接比较两个集合的哈希值 求两个集合的可重复并集：直接将两个集合的哈希值相加   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 2e5+5; const ll p = 31; int n,m,k; vector\u0026lt;pii\u0026gt; adj[maxn]; // {w, to} int out[maxn]; vector\u0026lt;int\u0026gt; deg[10]; // store vertices with deg x ll pow31[maxn]; ll ha[10][10]; //ha[i][j] 代表 c_i=j时，所指向的vertex的并集的哈希值 ll tar = 0; // {1,2,3...,n}对应的哈希值 int ans = 0; void init() { pow31[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) pow31[i] = (pow31[i-1] * p) % mod; for (ll i = 1; i \u0026lt;= n; i++) tar += pow31[i]; tar %= mod; for (int i = 1; i \u0026lt;= k; i++) { // calculate all vertex with deg i for (int j = 1; j \u0026lt;= i; j++) { // if c_i = j for (int a : deg[i]) { int to = adj[a][j-1].second; (ha[i][j] += pow31[to]) %= mod; } } } } void dfs(int dep, ll cur) { //cur: current hash value if (dep == k+1) { if (tar == cur) ans++; return; } for (int j = 1; j \u0026lt;= dep; j++) { dfs(dep+1, (cur + ha[dep][j]) % mod); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({w,v}); out[u]++; } for (int i = 1; i \u0026lt;= n; i++) { sort(adj[i].begin(), adj[i].end()); deg[out[i]].push_back(i); } init(); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题(TODO)  https://www.luogu.com.cn/problem/P6688 https://www.luogu.com.cn/problem/P3792  ","date":"2021-02-25T15:25:22+08:00","permalink":"https://tom0727.github.io/post/012-cf-1395e/","tags":["哈希","图论"],"title":"CF 1395E(集合哈希)"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \\geq 2, m \\geq 1, n \\times m \\leq 250000$\n问是否存在一个array，使得这个array 与 其他每个array的difference（不同元素的个数） $\\leq 2$？\n 题解 暴搜，我们可以先令 $ans$ 等于第一个array，然后看一下其他array中，有没有 $diff \u0026gt; 2$ 的，如果有，尝试更改 $ans$ 中的一个元素，更改后再看一下其他array的difference情况，如果还是不行，就继续尝试更改其他元素。 直到所有array的 $diff \\leq 2$\n注意到，因为$ans$基于第一个array，所以最多只能更改两个元素，我们可以给在搜索的时候设置一个深度 left，代表还可以更改几个元素。一开始就是dfs(2)。\n 注1: 本题时限卡的比较紧，时限为2s，我们可以设定2s内如果搜索不出结果就直接返回\u0026quot;No\u0026rdquo;。\ndouble start = clock(); double passed = clock() - start; if (passed \u0026gt; 1950.0) { // 1950ms cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; exit(0); }    注2: 暴搜的时候记得回溯！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; arr; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; cnt; double start; inline bool check() { for (int i = 0; i \u0026lt; n; i++) { if (cnt[i] \u0026gt; 2) return 0; } return 1; } void dfs(int left) { if (left \u0026lt; 0) return; if (clock()-start \u0026gt; 1950) { printf(\u0026quot;No\\n\u0026quot;); exit(0); } for (int i = 0; i \u0026lt; n; i++) { cnt[i] = 0; vector\u0026lt;int\u0026gt; pos; for (int j = 0; j \u0026lt; m; j++) { if (ans[j] != arr[i][j]) { cnt[i] += 1; pos.push_back(j); } } if (cnt[i]-left \u0026gt; 2) { return; } if (cnt[i] \u0026gt; 2) { for (int j : pos) { int pre = ans[j]; ans[j] = arr[i][j]; dfs(left-1); ans[j] = pre; //记得回溯 } } } if (check()) { printf(\u0026quot;Yes\\n\u0026quot;); for (int j = 0; j \u0026lt; m; j++) printf(\u0026quot;%d \u0026quot;, ans[j]); printf(\u0026quot;\\n\u0026quot;); exit(0); } } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); start = clock(); arr = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n, vector\u0026lt;int\u0026gt;(m,0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i][j]); } } ans = arr[0]; cnt = vector\u0026lt;int\u0026gt;(n,0); dfs(2); printf(\u0026quot;No\\n\u0026quot;); }  ","date":"2021-02-24T22:27:41+08:00","permalink":"https://tom0727.github.io/post/011-cf-1492e/","tags":["搜索","dfs优化"],"title":"CF 1492E(暴搜)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于HTML,CSS,JS的知识点\nCSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测当前在哪个页面，然后让当前页面对应的link的img更换一个，怎么办？（不使用javascript，仅用CSS）\n方案 可以用CSS中的 Pseudo-classes 中的 target，当网页链接中存在 #some_id 时，所有 id = \u0026quot;some_id\u0026quot; 的tag就会变成 :target 的状态。\n所以可以给每个 a 的 href 加上一个 #some_id，然后给 img 加上 id = some_id，如下：\nHTML代码 \u0026lt;nav\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026quot;index.html#index\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; id=\u0026quot;index\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;aboutus.html#about\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/2.jpg\u0026quot; id=\u0026quot;about\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;staff.html#staff\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/3.jpg\u0026quot; id=\u0026quot;staff\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt;   CSS代码 这里以index为例：\nnav \u0026gt; div \u0026gt; a[href*=\u0026quot;index\u0026quot;] \u0026gt; img:target { content:url(\u0026quot;images/index_selected.jpg\u0026quot;); }   参考链接  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target  HTML/CSS 手机字体大小不一 在手机上发现 font-size 相同的字体大小不一致，怎么办？\n方案   在HTML文件前面加上\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt;    添加上述代码后，网页中可能会出现 horizontal scrollbar。可以在css中添加：\n@media only screen and (max-width: 600px) { html, body { overflow-x: hidden; } body { position: relative; } }  然后在 media query 里面调整一下字体大小，图片大小之类的属性，保证 overflow-x: hidden; 不会隐藏内容。\n  参考链接  https://stackoverflow.com/questions/27074259/html-css-table-font-size-different-in-mobile-device https://stackoverflow.com/questions/4192277/disable-horizontal-scroll-on-mobile-web  Hot Reload 网页 使用 browser-sync 即可：\n npm install -g browser-sync browser-sync start --server --files \u0026quot;.\u0026quot;  • 注意需要把HTML文件改名为 index.html。\n动态网页（带PHP）  cd 进到目标文件夹。 输入 php -S 127.0.0.1:8000。 输入 browser-sync start --proxy 127.0.0.1:8000 --files \u0026quot;./\u0026quot;。 在弹出的窗口中浏览（一般是 127.0.0.1:3000）  JQuery \u0026lt;script src='https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js'\u0026gt;\u0026lt;/script\u0026gt;  ","date":"2021-02-21T23:39:36+08:00","permalink":"https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","tags":["前端","HTML","js","css"],"title":"HTML/CSS/JS笔记"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于vim的知识点\nHTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening tag跳转到closing tag怎么做？\n方案  在vscode下载一个叫 Highlight Matching Tag 的插件 下载叫做 matchit 的vim插件，放在本地的 ~/.vimrc/plugin/ 下（如果没有plugin文件夹，就创建一个），在.vimrc里添加 filetype plugin on runtime macros/matchit.vim  这样就可以用 % 进行跳转了。\n vscode上似乎不能装插件，可以把cursor移动到tag上，然后按 esc 进入normal mode，然后 v a t 跳转到matching tag  参考链接  https://stackoverflow.com/questions/7281459/matchit-not-working https://vi.stackexchange.com/questions/780/how-to-jump-between-matching-html-xml-tags  ","date":"2021-02-20T23:15:28+08:00","permalink":"https://tom0727.github.io/post/009-vim/","tags":["vim"],"title":"vim笔记"},{"categories":["算法"],"contents":"介绍 树形dp就是在树上进行dp，常用于 \u0026ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大\u0026rdquo; 的问题。\n一般来说，DP的形式为：\n设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个元素得到的最大值。\n这样，状态转移就有：\n$$dp[u][j] = \\max\\limits_{to} \\{ dp[u][j-k] + dp[to][k]\\}$$\n代码如下：\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  需要注意的点：\n 类似于 $01$ 背包，在枚举 j 的值时，要从大到小，防止一个child被重复选择。 对于依赖关系（例如，child需要依赖parent），可以利用DP过程中，调整状态转移的 上下限 来达到！  时间复杂度：$O(nm^2)$，其中 $n$ 为节点数，$m$ 为第二维的大小。\n优化 子树 size 优化 对于一个子树，可能它第二维的上限并没有这么高，我们需要尽量避免枚举一些无用的范围。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  例题可见 例1\n复杂度：$O(nm)$\nDFS序 优化 有的时候，第二维表示的不一定是 选择 $j$ 个元素，而可能是某一种权值，此时上面的优化的效果就不显著了。\n我们可以利用 DFS序 进行优化。\n令 $i$ 为 $u$ 的DFS序编号，则对于当前节点 $u$，我们有两种选择：\n  选择当前节点：$dp[i+1][j+w_u] = \\max \\{dp[i][j] + v_u \\}$\n  不选当前节点：$dp[i + sz_i][j] = \\max \\{ dp[i][j]\\}$\n  解释：\n如果选择当前节点，说明可以继续往子树里传递，所以传递到 $dp[i+1][j+w_u]$。\n如果不选择当前节点，由于依赖关系，就必须跳过子树，所以传递到 $dp[i + sz_i][j]$。\n最终的答案就是 $ans = \\max\\limits_{j=0}^m \\{dp[n+1][j] \\}$。\n复杂度：$O(nm)$\n例题可见 例2\n例题 例1 洛谷P2014 题意\n有 $N$ 门课程，每门课程有 $1$ 或 $0$ 门前置课程，需要上了前置课程才能上这门课。每门课 $i$ 有 $s_i$ 学分。\n现要选 $M$ 门课，使得学分总和最大。\n 题解 设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个课程得到的最大值\n根据前置课程的关系建图(会发现这是一棵树)，因为有前置课程，所以必须选了root才能选别的，故:\n$$dp[i][1] = s_i$$\n在处理某一个节点i的时候，$dp[i][j]$ 代表的是： 以它为root的 \u0026ldquo;已探索\u0026rdquo; 子树中的最大值，所以在探索各个子树过程中有：\n$dp\\left[cur\\right]\\left[j\\right]=\\max\\left(dp\\left[cur\\right]\\left[j\\right],dp\\left[cur\\right]\\left[k\\right]+dp\\left[nei\\right]\\left[j-k\\right]\\right),\\ k=\\left[1,j-1\\right]$\n 实现细节\n 我们利用 $dp[i][1] = s_i$ 来处理前置课程，是非常高效的做法！ 状态转移的时候，要 倒序枚举 $j$， 也就是 $j = m \u0026hellip; 1$， 因为此时 $dp[cur][k]$ 代表的是已探索的部分，不能包括 $nei$ (因为 $nei$ 正在被探索)。为了防止同一个 $nei$ 被考虑多次，要倒序枚举！ 给定的图可能是一个森林，所以创建一个超级root $0$，并且将 $M$++ (因为 $0$ 肯定要包含进去)，最终答案就是 $dp[0][M+1]$   算法优化\n注意，在dp状态转移的时候，我们可能用的是如下loop:\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  每个节点 cur 都这样loop一次，总复杂度是 $O(nm^2)$，看起来不可接受。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  时间复杂度：$O(n^2)$\n证明：我们考虑每一个 nei 被用来转移 的次数，会发现它只会在计算它的 parent 的dp值时才会被拿来统计，又因为每一个节点只有1个parent，所以每个节点对应的子树都只会被统计一次。\n所以时间复杂度就是 $T(\\sum\\limits_{i=1}^n i * sz[i]) = O(n^2)$\n更严谨的数学证明可以参见 https://www.luogu.com.cn/blog/Chenxiao-Yan/solution-p4322\n luogu-P2014-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 305; const int maxm = 305; int n,m; int s[maxn]; int dp[maxn][maxn]; int sz[maxn]; //记录i的子树大小 struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); fill(head, head+n+2, -1); //因为存在编号为0的节点，所以初始化为-1 for (int i = 1; i \u0026lt;= n; i++) { int sc,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,\u0026amp;sc); s[i] = sc; add(k, i); } } void dfs(int cur, int par) { if (sz[cur]) return; // visited dp[cur][1] = s[cur]; sz[cur] = 1; for (int e = head[cur]; ~e; e = edges[e].nxt) { int nei = edges[e].to; if (par == nei) continue; dfs(nei, cur); sz[cur] += sz[nei]; for (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } } } } int main() { init(); m++; dfs(0, -1); printf(\u0026quot;%d\\n\u0026quot;, dp[0][m]); }    如果每门课的前置课程不止1门，就不再是一棵树了，这样的话似乎可以用状压dp来解，leetcode某次比赛中出现过。\n 例2 洛谷P2515 [HAOI2010]软件安装 题意\n给定 $N$ 个软件，每个软件 $i$ 要占用 $W_i$ 的空间，价值为 $V_i$，并且每个软件 $i$ 会依赖最多一个软件 $D_i$。\n如果要安装软件 $i$，必须要安装所有的直接/间接依赖软件。\n电脑的空间为 $M$，求最大价值。\n其中，$1 \\leq N \\leq 100, 0 \\leq M \\leq 500, 0 \\leq W_i \\leq M, 0 \\leq V_i \\leq 1000, D_i \\in [0,N], D_i \\neq i$\n 题解 注意到，本题可能有 循环依赖。\n对于循环依赖，直接用 SCC 缩点，剩下的就是一个标准的有依赖背包（本质上，树形DP）问题了：\n如果 $i$ 依赖 $D_i$，那么将 $D_i$ 所在的 SCC 连一条有向边，指向 $i$ 所在的 SCC 即可。\n另外需要注意，本题可能是一个森林。所以缩点后，对于所有入度为 $0$ 的点 $u$，需要用 $0$ 连一条有向边指向 $u$。\n最后，从 $0$ 开始 DP 即可。\n DP 的核心代码：\nvoid dfs(int u) { if (wei[u] \u0026lt;= m) dp[u][wei[u]] = val[u]; for (int to : adj2[u]) { dfs(to); for (int i = m; i \u0026gt;= wei[u]; i--) { for (int j = wei[to]; j \u0026lt;= i - wei[u]; j++) { dp[u][i] = max(dp[u][i], dp[u][i-j] + dp[to][j]); } } } }  注意几点：\n dp[u][wei[u]] = val[u]; 放在最前面。 DP的过程中，类似于 $01$ 背包，$i$ 是从大到小的，并且下限是 wei[u]。 DP的过程中，$j$ 的下限是 wei[to]，上限是 i - wei[u]（因为 i-j 的有效值必须 $\\geq$ wei[u]）。  • 另外，别忘记 tarjan 过程中，更新 low[] 要判断是否在栈内。\n 树形DP（无优化版本）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, w[105], v[105], d[105]; int dp[103][503]; vector\u0026lt;int\u0026gt; adj1[103]; set\u0026lt;int\u0026gt; adj2[103]; int dfn[103], low[103], id = 0, st[103], tail = -1; bool in[103]; int from[103], scc = 0; void tarjan(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int to : adj1[u]) { if (!dfn[to]) { tarjan(to); low[u] = min(low[u], low[to]); } else if (in[to]) { // 注意这里有 in[to] low[u] = min(low[u], dfn[to]); } } if (low[u] == dfn[u]) { from[u] = ++scc; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail--]; in[cur] = 0; from[cur] = scc; } tail--; in[u] = 0; } } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; d[i]; if (d[i] == 0) continue; adj1[d[i]].push_back(i); } for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) tarjan(i); } } int wei[103], val[103], ind[103]; void rebuild() { for (int i = 1; i \u0026lt;= n; i++) { int fu = from[i]; wei[fu] += w[i]; val[fu] += v[i]; int fv = from[d[i]]; if (fu == fv || fv == 0) continue; adj2[fv].insert(fu); ind[fu]++; } for (int i = 1; i \u0026lt;= scc; i++) { if (!ind[i]) adj2[0].insert(i); } } void dfs(int u) { if (wei[u] \u0026lt;= m) dp[u][wei[u]] = val[u]; for (int to : adj2[u]) { dfs(to); for (int i = m; i \u0026gt;= wei[u]; i--) { // 注意从大到小，注意下限 for (int j = wei[to]; j \u0026lt;= i - wei[u]; j++) { // 注意上下限 dp[u][i] = max(dp[u][i], dp[u][i-j] + dp[to][j]); } } } } int main() { init(); rebuild(); dfs(0); int ans = 0; for (int i = 0; i \u0026lt;= m; i++) ans = max(ans, dp[0][i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   DFS序 优化 我们可以利用 DFS序 进行优化，让时间复杂度从 $O(nm^2)$ 降到 $O(nm)$。\n令 $i$ 为 $u$ 的DFS序编号，则对于当前节点 $u$，我们有两种选择：\n  选择当前节点：$dp[i+1][j+w_u] = \\max \\{dp[i][j] + v_u \\}$\n  不选当前节点：$dp[i + sz_i][j] = \\max \\{ dp[i][j]\\}$\n  解释：\n如果选择当前节点，说明可以继续往子树里传递，所以传递到 $dp[i+1][j+w_u]$。\n如果不选择当前节点，由于依赖关系，就必须跳过子树，所以传递到 $dp[i + sz_i][j]$。\n最终的答案就是 $ans = \\max\\limits_{j=0}^m \\{dp[n+1][j] \\}$。\n 另外需要注意，由于依赖问题，我们需要 记录每一个节点 $u$ 的所有ancestor的权值和，在枚举的时候，将下限设置为这个权值和。（在代码中，pre[u] 代表 $u$ 所有ancestor的权值和。）\n 优化代码 // 注意 idcnt = -1，因为我们是从 0 开始 DFS的！ int mp[103], idcnt = -1, sz[103]; // mp[i]: DFS序为 i 的节点编号 u int pre[103]; // pre[u] 代表 u 的 ancestor 的 weight的和 void dfs(int u) { mp[++idcnt] = u; sz[u] = 1; for (int to : adj2[u]) { pre[to] = pre[u] + wei[u]; // ancestor的权值和 dfs(to); sz[u] += sz[to]; } } void solve() { for (int i = 1; i \u0026lt;= scc; i++) { int u = mp[i]; for (int j = pre[u]; j \u0026lt;= m; j++) { // 注意枚举下限从 pre[u] 开始 dp[i+sz[u]][j] = max(dp[i+sz[u]][j], dp[i][j]); // 不选 if (j + wei[u] \u0026lt;= m) // 选择（要保证 j+wei[u] \u0026lt;= m） dp[i+1][j+wei[u]] = max(dp[i+1][j+wei[u]], dp[i][j] + val[u]); } } } int main() { init(); rebuild(); dfs(0); solve(); int ans = 0; for (int j = 0; j \u0026lt;= m; j++) ans = max(ans, dp[scc+1][j]); // 注意是 scc+1 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P4395 [BOI2003]Gem 气垫车 题意\n给一棵 $n$ 个节点的树，要求给所有节点标上正整数权值，使得相邻节点不能权值相同，求最小总权值。\n其中，$n \\leq 10^4$。\n 题解 第一眼看过去是个树染色问题，要么权值为 $1$，要么为 $2$。\n很遗憾这个做法是错的，考虑一下这个数据，两个菊花接在一起：\n这里很明显应该给 $1,2$ 分别标上 $2,3$ 的权值，其余全部标 $1$。\n所以我们暴力枚举一下每个节点上可能标什么权值就好了，直觉上告诉我们这个上限不会太大。\n然后利用树形DP来求最小值即可。\n代码中取了上限 $M = 55$，所以复杂度就是 $O(55^2 * n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 10005; const int M = 55; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, m; int dp[maxn][M+3]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); for (int j = 1; j \u0026lt;= M; j++) { int r = 1e9; for (int k = 1; k \u0026lt;= M; k++) { if (j == k) continue; r = min(r, dp[to][k]); } dp[u][j] += r; } } for (int j = 1; j \u0026lt;= M; j++) dp[u][j] += j; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); int ans = 1e9; for (int j = 1; j \u0026lt;= M; j++) ans = min(dp[1][j], ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例4 洛谷P3177 [HAOI2015]树上染色 题意\n给定一棵 $n$ 个节点的树，树的边上有权值。\n给定一个整数 $k \\in [0,n]$，要求从树上选择 $k$ 个点，将其染成黑色，剩余的染成白色。\n染色后，获得的价值为 黑点两两之间的距离之和 + 白点两两之间的距离之和。\n求最大价值？\n其中，$n,k \\leq 2000$。\n 题解 数据范围看起来就非常树形DP。\n设 dp[u][i] 为在 $u$ 的子树内，染 $i$ 个黑点的总价值。\n现在考虑一下怎么转移？\n如果我们直接进行转移，就需要维护节点的深度之和，然而这很明显不现实，所以我们可以 考虑每条边 的贡献。\n假设考虑的子树 $v$ 中，染了 $j$ 个黑点，那么一条边 $(u,v,w)$ 的贡献刚好就是：\n$$w * (j * (k-j) + (sz[to] - j) * (n - k - sz[to] + j))$$\n其中 j * (k-j) 是这条边两端的黑点数量的乘积，而 (sz[to] - j) * (n - k - sz[to] + j) 就是这条边两端的白点数量的乘积。\n然后直接转移就可以了（注意第二维度的转移顺序是从 $0$ 开始，否则会导致 $dp[u][i]$ 被更新两次），注意一下使用 sz[] 进行时间复杂度优化到 $O(n^2)$，否则是 $O(n^3)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2003; ll dp[maxn][maxn]; ll sz[maxn]; int n,k; struct Edge { int to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int ecnt = 1, head[maxn]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; } } void dfs(int u, int p) { dp[u][0] = dp[u][1] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); ll w = edges[e].w; for (ll i = (ll)min((ll)k, sz[u]); i \u0026gt;= 0; i--) { // u 用多少个黑 for (ll j = 0; j \u0026lt;= min(i,sz[to]); j++) { // v 用多少个黑 ll cnt = j * (k - j) + (sz[to] - j) * (n - k - sz[to] + j); dp[u][i] = (ll)max(dp[u][i], dp[u][i-j] + dp[to][j] + cnt * w); // j = 0 开始: dp[u][i], dp[u][i-1] ... (正确) // j = min(i,sz[to]) 开始: dp[u][0], dp[u][1], ..., dp[u][i] -\u0026gt; 这导致 dp[u][i] 被更新了两次 } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= n; i++) for (int j = 2; j \u0026lt;= k; j++) dp[i][j] = -1e18; dfs1(1, 0); dfs(1, 0); cout \u0026lt;\u0026lt; dp[1][k] \u0026lt;\u0026lt; endl; }   注意事项\n 本题枚举 $i,j$ 时，注意要加上 $sz[u], sz[to]$ 作为上限来优化。 注意初始化 $dp[i][j]$ 为负无穷，并且设 $dp[i][0] = dp[i][1] = 0$。 注意第二维度的转移顺序（第一维倒序这个是必须的）。   ","date":"2021-02-18T15:42:09+08:00","permalink":"https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/","tags":["树形dp","dp优化"],"title":"树形dp"},{"categories":["算法"],"contents":"介绍 01分数规划用于 求一个分式的极值\n例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大/最小？\n方法 (二分) 一般使用二分答案的方法进行求解，假设我们要求最大值，那么 二分一个答案 $mid$，有\n$\\frac{\\sum a_i}{\\sum b_i} \\geq mid$, 所以\n$\\sum a_i- (mid \\times b_i) \\geq 0$\n所以只要求出左边的最大值，判断是否 \u0026gt;= 0 即可！\n 如果左边最大值 \u0026gt;= 0，说明当前答案 $mid$ 可行，提高下边界 如果左边最大值 \u0026lt; 0，说明当前答案 $mid$ 不可行，降低上边界  例题 例1 POJ2976 Dropping tests 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大。\n 题解 二分答案，当前答案为 $mid$ 时，把第 $i$ 个物品的权值设为 $a_i - mid \\times b_i$，然后取最大的 $k$ 个即可得到最大值。\n 例2 洛谷P1419 题意\n给定 $n$ 个整数，求一个长度在 $[S,T]$ 之间的subarray(连续)，使得平均值最大？\n 题解 二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1}$ 最大。\n令 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1} \\geq mid$，有 $\\sum\\limits_{i=l}^r(a_i - mid) \\geq 0$，\n定义一个新的数组$b$，其中 $b_i = a_i - mid$。\n左边的最大值就是 $b$ 这个数组中最大的连续区间，用前缀和即可。\n 另外一种思考方法:\n二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{sum[r] - sum[l-1]}{r-l+1}$ 最大。\n$\\frac{sum[r] - sum[l-1]}{r-l+1} \\geq mid$ ，有 $(mid \\times (l-1) - sum[l-1]) - (mid \\times r - sum[r]) \\geq 0$\n因为 $r$ 固定，所以只要找 $mid*l - sum[l]$ 的最大值，其中 $l \\in [\\max(0, r-T), r-s]$。\n遍历 $r$ 的时候，维护一个单调队列即可。\n luogu-P1419-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; const int maxn = 1e5+5; int n, s, t; int arr[maxn]; int sum[maxn]; double a[maxn]; int q[maxn]; int head = 0, tail = -1; double ans = -1e4; bool check(double cur) { for (int i = 0; i \u0026lt;= n; i++) a[i] = cur * (double)(i) - (double)(sum[i]); double res = -1e18; head = 0, tail = -1; for (int r = s; r \u0026lt;= n; r++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; q[head] \u0026lt; r-t) head++; while (head \u0026lt;= tail \u0026amp;\u0026amp; a[q[tail]] \u0026lt; a[r-s]) tail--; q[++tail] = r-s; res = max(res, a[q[head]] - a[r]); } // for (int r = 1; r \u0026lt;= n; r++) { // double tmp = -1e18; // for (int i = max(0, r-t); i \u0026lt;= r-s; i++) { // tmp = max(tmp, a[i]); // } // res = max(res, tmp - a[r]); // } if (res \u0026gt;= 0) return 1; return 0; } int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } double l = -1e4, r = 1e4; while (abs(l-r) \u0026gt; eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = mid; } else { r = mid; } } printf(\u0026quot;%.3f\\n\u0026quot;, ans); }   例3 洛谷P4377 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n你可以选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大, 且 $\\sum b_i \\geq W$\n 题解 和例1几乎一样，但是多了一个 $\\sum b_i \\geq W$ 的限制。\n设 $d_i = a_i - mid \\times b_i$，然后我们要做的事就是：\n选取一组$i$，保证在 $\\sum b_i \\geq W$ 的前提下，使得 $\\sum d_i$ 最大\n可以用01背包解决，令 $dp[n][k]$ 为：使用前 $n$ 个元素，$\\sum b_i = k$ 时， $\\sum d_i$ 的最大值。\n那么答案就是 $dp[n][W]$。\n如果在状态转移过程中出现 $k \u0026gt; W$，直接转移到 $k = W$ 的状态上即可。\n 注: 写01背包的时候不要忘了 倒序枚举 ！\n  luogu-P4377-AC代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const double eps = (double)1e-6; const int maxn = 255; int n,W; int w[maxn], t[maxn]; double dp[1001]; struct node { double d; int w; } arr[maxn]; bool check(double cur) { for (int i = 1; i \u0026lt;= n; i++) { arr[i] = {(double)t[i] - cur * (double)w[i], w[i]}; } fill(dp, dp+1001, -1e9); dp[0] = 0.0; for (int i = 1; i \u0026lt;= n; i++) { for (int d = 1000; d \u0026gt;= 0; d--) { int tar = min(d + arr[i].w, 1000); dp[tar] = max(dp[tar], dp[d] + arr[i].d); } } for (int d = W; d \u0026lt;= 1000; d++) { if (dp[d] \u0026gt;= 0.0) return 1; } return 0; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;W); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;w[i], \u0026amp;t[i]); } double l = 0.0, r = 1e6, ans = 0.0; while (abs(l-r) \u0026gt;= eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = max(ans, mid); } else { r = mid; } } printf(\u0026quot;%d\\n\u0026quot;, (int)((ans+5e-5) * 1000)); }   例4 洛谷P4322 题意\n给定一棵$N$个节点的树，每个节点 $i$ 具有两个权值 $P_i, S_i$，求树中的一组节点，满足：\n $\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大 如果 节点 $i$ 被选中了，那么它的parent $R_i$ 也必须被选中 选中的节点数量 刚好为$K$  求满足条件的最大比值？\n 题解 首先看条件1：$\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大，仍然是分数规划的套路，二分答案。令 $d_i = P_i - mid \\times S_i$\n所以问题转化为求一组节点使得 $\\sum d_i$ 最大。\n然后就会发现，这是一个经典的树形dp模型，和 选课(洛谷P2014) 几乎一样。\n具体做法和注意事项见下一篇博客。\n","date":"2021-02-17T17:20:49+08:00","permalink":"https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":["01分数规划","二分"],"title":"01分数规划"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1159/problem/B\n题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\frac{\\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \\in [1,n], i \\neq j$\n 题解 对于这类的枚举问题，一般套路都是 \u0026ldquo;固定一个数\u0026rdquo;，这里很明显是固定一下 $\\min(a_i, a_j)$。\n所以只要从 $a_1$ 遍历到 $a_n$，把当前遍历到的值作为最小值，然后不管最左侧或者最右侧元素是否小于它，直接最大化分母就可以了。\n为什么不会漏解？因为 每一个 $a_i$ 都当了一次分子！\n 代码 const int maxn = 3e5+5; int n, arr[maxn]; int ans = 1e9; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { int d = max(i-1, n-i); ans = min(ans, arr[i] / d); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-02-17T15:19:54+08:00","permalink":"https://tom0727.github.io/post/006-cf-1159b/","tags":["枚举"],"title":"CF1159B 题解(枚举优化)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些爬虫相关的知识点：\n分段下载 如果我们需要设定下载的timeout怎么办？\n直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout参数意义是 \u0026ldquo;从服务器返回任意数据\u0026rdquo; 的时间差。如果我们想要设定 timeout 使得在一定时间内下载不完就break，可以用分段下载！\n分段下载由stream=True实现\ndef download_img(img_url, path): timeout = 150 # 设定150秒如果下载不完就停止下载 try: img_html = requests.get(img_url, headers=get_download_header(), timeout=10, stream=True) if img_html.status_code != 200: return body = [] start = time.time() for chunk in img_html.iter_content(1024): body.append(chunk) if time.time() \u0026gt; start + timeout: print(\u0026quot;Time out!\u0026quot;) break else: # 下载完毕 with open(path, 'wb') as file: file.write(b''.join(body)) file.flush() except BaseException as err: print(err)  多进程下载 多进程下载经常在访问一些速度较慢的网站时很有用，因为本地的带宽不是主要限制，所以可以开很多个进程同时访问然后进行下载，这样更快。\ndef f(arg): ... # 下载程序 if __name__ == '__main__': processes = [] for _ in range(20): p = multiprocessing.Process(target=f, args=(some_arg, )) p.start() processes.append(p) for p in processes: p.join()  正则表达式Regex的注意事项   匹配时注意区分懒惰匹配和贪婪匹配，懒惰匹配可以在匹配符号后加上?，如 .*?\n  如果在匹配过程中需要用到()，但是需要获取整个匹配结果（不想被()框起来的部分干扰），可以使用non-capturing group，即，(?:)，如:\nre.findall(\u0026quot;https://abc.net/images/.*?(?:jpg|png|jpeg)\u0026quot;, txt)\n这样，返回的就是整个匹配的网址，而不是()框起来的部分\n  ","date":"2021-02-10T22:52:26+08:00","permalink":"https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","tags":["爬虫","python"],"title":"爬虫笔记"},{"categories":["算法"],"contents":"定义 给定正整数$n$，求$\\varphi(n)$， 即\n 小于等于$n$ 且 与$n$互质  的正整数个数。\n性质  $\\varphi(p) = p-1, ~\\forall \\text{prime } p$ $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ $\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  证明 证明性质1 求证： $\\varphi(p) = p-1, ~\\forall \\text{prime } p$\n 由质数的定义可知，小于等于$p$ 且 与$p$互质的数，在$[1,p]$中，除了 $p$以外均满足！\n 注： $\\varphi(1) = 1$\n 证明性质2 求证： $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$\n 首先，易知 $\\varphi(n) = |\\mathbb{Z}_n^{\\times}|$ , 即 $\\mathbb{Z}_n$ 中 unit(存在关于$\\bmod~ n$乘法逆元的元素)的数量\n因为 $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$\n所以 $\\mathbb{Z}_{mn}$的units $\\mathbb{Z}_{mn}^{\\times}$ ， 与\n$\\mathbb{Z}_m \\times \\mathbb{Z}_n$的 units $(\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times}$ 之间存在一个 bijection, 即\n$\\mathbb{Z}_{mn}^{\\times} \\cong (\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times} = \\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}$\n所以 $\\varphi(mn) = |\\mathbb{Z}_{mn}^{\\times}| = |\\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}| = |\\mathbb{Z}_m^{\\times}||\\mathbb{Z}_n^{\\times}| = \\varphi(m)\\varphi(n)$\n 注：\n $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$ 的证明见 这里 更严格的证明需要用到抽代里的中国剩余定理 （以Ring和Ideal表示的）   证明性质3 求证：$\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$\n $\\forall n = p^k$，所有与它不互质的数$m$必然包含$p$这个质数因子，因此满足条件的$m$为：$1p, 2p, 3p, \u0026hellip; , p^{k-1}p$，共 $p^{k-1}$个。\n所以，与$n = p^k$互质的数共有 $p^k-p^{k-1}$个。\n  证明性质4 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，且$p_1,p_2,\u0026hellip;,p_r$都是质数（所以两两互质）\n由性质2， $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3，$\\varphi(p_i^{k_i}) = p_i^{k_i} - p_i^{k_i-1} = p_i^{k_i}(1-\\frac{1}{p_i})$\n所以 $\\varphi(n) = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n  证明性质5 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，\n由性质2，$\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3， $\\varphi(p^k) = p^k - p^{k-1}$, 我们可以推出 $\\varphi(p^{k+1}) = \\varphi(p^{k}) * p$\n因为 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$，由上可得出 $\\varphi(p_i^{k_i}) = \\varphi(p_i^{k_i-1}) * p_i$\n即 $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip; (\\varphi(p_i^{k_i-1})*p_i)\u0026hellip;\\varphi(p_r^{k_r}) = \\varphi(\\frac{n}{p_i})*p_i$\n  求单个数的欧拉函数值 $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，直接质因数分解，由性质4即可求出！\n时间复杂度：$O(\\sqrt n)$\n代码 ll phi(ll x) { ll res = x; for (ll p = 2; p * p \u0026lt;= x; p++) { if (x % p == 0) { res = (res / p) * (p-1); } while (x % p == 0) x /= p; } if (x \u0026gt; 1) res = res / x * (x-1); return res; }  线性筛求1~n的欧拉函数值 和线性筛的基本思路一样，只不过要分类讨论 i % p == 0 与否。（i是当前处理到的数, p是当前用到的质数）\n  如果 i % p == 0，说明 i * p 这个数里，包含了至少2个质因子$p$ (即$p^2$)。\n由性质5，有 $\\varphi(i * p) = \\varphi(i) * p$\n  如果 i % p != 0，说明 $\\gcd(i,p) = 1$。\n由性质2，有 $\\varphi(i * p) = \\varphi(i) * \\varphi(p)$\n  时间复杂度： $O(n)$\n代码 luogu-P2158-AC代码 题目链接: https://www.luogu.com.cn/problem/P2158\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244352; const int maxn = 4e4+5; int phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } phi[1] = 1; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= n; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } int ans = 3; for (int i = 2; i \u0026lt;= n-1; i++) ans += 2*phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 CF1295D 题意\n给定两个正整数 $a$, $m$, 求满足以下条件的 $x$ 的数量？\n $0 \\leq x \u0026lt; m$ $\\gcd(a,m) = \\gcd(a+x,m)$  其中，$1 \\leq a \u0026lt; m \\leq 10^{10}$\n 题解 设 $g = \\gcd(a,m)$，则 $g = \\gcd(a+x,m)$，所以 $\\gcd(\\frac{a+x}{g}, \\frac{m}{g}) = 1~$ 且 $~g|(a+x)$，又因为 $g|a$，所以 $~g|x$\n所以问题转化为：\n设 $c = \\frac{a}{g}, x = \\frac{m}{g}$，求 $k \\in [c,c+x)$，使得 $k$ 满足：$gcd(x, k) = 1$ 的 $k$ 的数量？\n我们会发现当 $k \u0026gt; x$ 时，因为 $\\gcd(x,k) = \\gcd(x, k-x)$，所以我们可以将 $k \\in (x,c+x)$ 的这一段，映射到 $k \\in (0,c)$ 上。\n所以最后我们要求的$k$就是： $k \\in [1,x]$ 使得 $\\gcd(k, x) = 1$，所以满足条件的 $k$ 的数量就等于 $\\varphi(x)$\n 参考链接  https://blog.csdn.net/paxhujing/article/details/51353672 https://www.luogu.com.cn/blog/JustinRochester/solution-p2158 https://blog.nowcoder.net/n/0cbf747dc0874027b5c48cf7fbf27060  后记 写这篇文章的时候出了几个数学公式上的问题:\n 如果排版炸了，可以试着在 _ 的前面加上 \\  ","date":"2021-02-06T17:23:34+08:00","permalink":"https://tom0727.github.io/post/004-euler-function/","tags":["数学","抽代"],"title":"欧拉函数"},{"categories":["算法"],"contents":"中国剩余定理 (crt) 定义 给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$, 且 $m_i$ 之间两两互质。\n求满足条件的最小非负整数解 $x$ ？\n结论 令 $M = m_1 \\cdot m_2 ~\u0026hellip; ~m_k$, $M_i = \\frac{M}{m_i}$\n令 $M_i^{-1}$ 为 $M_i$ 在 $\\color{red} \\text{mod }m_i$ 意义下的逆元\n则，答案为: $x = \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} ~ (\\text{mod }M)$\n证明 因为 $\\forall i \\neq j, M_i \\equiv 0 ~(\\text{mod } m_j)$\n所以 $\\forall i \\neq j, a_iM_iM_i^{-1} \\equiv 0~ (\\text{mod } m_j)$\n所以 $\\forall i, x \\equiv \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} \\equiv a_iM_iM_i^{-1} ~ (\\bmod ~m_i)$\n又因为 $\\forall i, M_iM_i^{-1} \\equiv 1 ~(\\text{mod } m_i)$\n所以 $\\forall i, x \\equiv a_iM_iM_i^{-1} \\equiv a_i ~ (\\text{mod } m_i)$\n证明推导过程 证明推导过程 这里直接放参考链接一中的片段：\n 由于 $M = 3\\times5\\times7 = 105$\n所以最后的解就是 $x = (n_1 + n_2 + n_3) ~\\bmod ~ 105 = 233 ~ \\bmod 105 = 23$\n  例题  https://www.luogu.com.cn/problem/P3868  快速乘 在题目中，有可能出现 $\\bmod$ 接近 $1e18$ 的情况，有可能会爆 long long，所以在计算大数乘法时，要用快速乘（原理类似于快速幂）：\nll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % mod; b \u0026gt;\u0026gt;= 1; a = (a + a) % mod; } return ans; }  模版 luogu-P3868-AC代码 题目链接: https://www.luogu.com.cn/problem/P3868\n#include \u0026lt;bits/stdc++.h\u0026gt; #define fastio ios::sync_with_stdio(false); cin.tie(0); #define ll long long ll M = 1; ll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % M; b \u0026gt;\u0026gt;= 1; a = (a + a) % M; } return ans; } ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll curx = y; ll cury = x - (a/b) * y; x = curx; y = cury; return g; } ll a[15], b[15]; int k; ll crt() { ll ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ll m = M / b[i]; ll x,y; exgcd(m, b[i], x, y); if (x \u0026lt; 0) x += b[i]; ans = (ans + qmul(qmul(a[i], m), x)) % M; } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; b[i], M *= b[i]; for (int i = 1; i \u0026lt;= k; i++) { a[i] -= (a[i]/b[i]) * b[i]; //将a[i]变成正数 a[i] += b[i]; a[i] %= b[i]; } cout \u0026lt;\u0026lt; crt() \u0026lt;\u0026lt; endl; }   参考链接  https://zhuanlan.zhihu.com/p/103394468  拓展中国剩余定理 (excrt) 定义 用于 $m_1,m_2,\u0026hellip;,m_k$ 并不互质的情况\n给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$，（$m_i$ 之间无特殊关联）\n求满足条件的最小非负整数解 $x$ ？\nIntuition 先看一些简单的例子：\n$$\\begin{cases} x\\equiv 2 ~(\\text{mod }4) \\\\\n\\\\\nx\\equiv 4 ~(\\text{mod }6) \\\\\n\\end{cases}\\Longrightarrow x \\equiv 10 ~(\\text{mod } 12)$$\n$$\\begin{cases} x\\equiv 4 ~(\\text{mod }6) \\\\\n\\\\\nx\\equiv 3 ~(\\text{mod }5) \\\\\n\\end{cases}\\Longrightarrow ~\\varnothing$$\n可以看出几个特点：\n 答案的 $\\text{mod}$ 为 $\\text{lcm}(m_1, m_2)$ 有可能无解 （若$m_1,m_2$互质则必然有解）  推导 考虑 $x$ 满足：\n$$\\begin{cases} x\\equiv a_1 ~(\\text{mod }m_1) \\\\\n\\\\\nx\\equiv a_2 ~(\\text{mod }m_2) \\\\\n\\end{cases}$$\n则有 $x = k_1m_1 + a_1 = k_2m_2 + a_2$\n 即：$k_1m_1 - k_2m_2 = a_2 - a_1$\n这个方程有解 $\\iff \\gcd(m_1,m_2) | (a_2 - a_1)$ （即 $(a_2 - a_1)$ 是 $\\gcd(m_1,m_2)$ 的倍数）。\n 如果无解，就直接退出。\n如果有解，就用 $exgcd(m_1, m_2, x\u0026rsquo;, y\u0026rsquo;)$ 解出 $k_1$ 的值。\n设 $\\gcd(m_1, m_2) = g$，则 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$\n然后将 $k_1$ 代入 $x = k_1m_1 + a_1$，得到 $x$ 的值，答案就是 $x \\equiv (k_1m_1 + a_1) (\\text{mod ~lcm}(m_1,m_2))$\n这样，$2$个同余方程就转化为了$1$个，用同样的方法继续进行下去，即可化为一个同余方程。\n最终的 $\\text{mod}$ 数就是 $M = \\text{lcm}(m_1, m_2, m_3 \u0026hellip; , m_n)$\n模版 luogu-P4777-AC代码 题目链接: https://www.luogu.com.cn/problem/P4777\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll mul(ll a, ll b, ll mod) { ll res = 0; while (b) { if (b\u0026amp;1) (res += a) %= mod; (a += a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } int n; ll a[maxn], m[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; m[i] \u0026gt;\u0026gt; a[i]; ll cura = a[1], curm = m[1]; for (int i = 2; i \u0026lt;= n; i++) { /* m1 = curm, m2 = m[i], a1 = cura, a2 = a[i] */ ll x,y; ll g = exgcd(curm, m[i], x, y); // g = gcd(curm, m[i]) ll c = a[i] - cura; // c = a2 - a1 c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) if (c % g) { // 无解 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } ll M = (m[i] * (curm / g)); // M = lcm(m1, m2) ll k = mul(x, c / g, M); // k1 = x' * (a2-a1) / g cura = (mul(k, curm, M) + cura) % M; // x = k1m1 + a1 curm = M; } cout \u0026lt;\u0026lt; (cura % curm + curm) % curm \u0026lt;\u0026lt; endl; }   注意事项   我们需要处理可能出现的负数！（比如在快速乘的时候，如果 $b$ 为负数就会炸）\n 在 $exgcd(a,b,x\u0026rsquo;,y\u0026rsquo;)$ 中，$x'$ 有可能为负数。 $c = a_2 - a_1$，则 $c$ 也有可能为负数。  那么如何处理负数？我们需要找到这个负数对应的 $\\text{mod}$为多少，我们可以在等式 $k_1m_1 - k_2m_2 = a_2 - a_1$ 中找到！\n因为我们要求的是 $k_1$ 的值，实际上 $k_1m_1 = (a_2-a_1) + k_2m_2$，即 $k_1m_1 \\equiv (a_2-a_1) \\text{ (mod } m_2)$\n所以无论是 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$ 还是 $(a_2-a_1)$，都取一个 $\\text{mod } m_2$ 即可！\n代码段：\nll c = a[i] - cura; c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) ll k = mul(x, c / g, M); // k = ((k % m[i]) + m[i]) % m[i]; 可以处理，但是没有必要，因为快速乘中的 a 可以为负数    注意快速乘过程中的 $\\text{mod}$ ！因为快速乘求的实际上是 $x$ 的值，所以 $\\text{mod } M$，其中 M = lcm(curm, m[i])\n  我们用 cura, curm 来维护当前的 同余方程，之后记得更新一下 curm = lcm(curm, m[i])\n  参考链接  https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li  ","date":"2021-02-06T10:46:42+08:00","permalink":"https://tom0727.github.io/post/003-crt/","tags":["数学","中国剩余定理","crt"],"title":"中国剩余定理介绍"},{"categories":["工程"],"contents":"写博客好累啊，是我太久没有写作了吗\n这次来记录一下我第一次学习爬虫的经历\n起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とにかくかわいい的生肉漫画，但是这网站广告特别多，还会检测我adblocker，禁用javascript的话漫画就加载不出来了，气死我了，一怒之下决定学习爬虫把漫画爬下来看。\n爬虫教程有很多，这里特别推荐一个Jack Cui的教程：\n [资源分享] Python3 网络爬虫：漫画下载，动态加载、反爬虫这都不叫事\n 爬 manga1001.com 这个网站设置的比较粗糙，图片都是静态加载的(F12就能看见图片链接)，根据标签soup.find_all()一下即可。对于这个网站的话，简单说一下爬虫的基本流程吧。\n基本流程\n  观察一下页面的HTML，用F12打开可以看到大致结构，如果要看源代码的话，可以选择：\n1.1. res = requests.get(url), print(res.txt) 或\n1.2. 在url前加上view-source:，然后用浏览器打开。\n  找到包含图片的tag， 找一下规律，然后用 soup.find_all() 即可。\n  获取所有章节的URL，然后分别去每个URL里抓取。\n   参考代码 import requests from bs4 import BeautifulSoup import os import random import time def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] # get content of one chapter def get_content(folder, prefix, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('figure') i = 1 folder_name = os.path.join(folder, f'Chapter_{prefix:03}/') create_dir(folder_name) for item in items: for child in item.children: if i != 1: img_url = child.get('data-src') else: img_url = child.get('src') print(img_url) headers = random.choice(USER_AGENTS) img_html = requests.get(img_url, headers) img_name = os.path.join(folder_name, f'{i:02}.jpg') with open(img_name, 'wb') as file: file.write(img_html.content) file.flush() i += 1 time.sleep(random.uniform(0, 3.33)) # sleep random time # get manga url list def get_url_list(manga_name, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('option') for i in range(len(items) - 2, -1, -1): if items[i] == items[-1]: # get manga chapter url list without duplicates items = items[i+1:] break chapter = 1 folder = os.path.join(root_folder, f'{manga_name}/') for item in items: manga_url = item.get('value') get_content(folder, chapter, manga_url) print(manga_url) chapter += 1 def main(): url1 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e3%83%88%e3%83%8b%e3%82%ab%e3%82%af%e3%82%ab%e3%83%af%e3%82%a4%e3%82%a4-raw/\u0026quot; name1 = 'Tonikaku_Kawaii' get_url_list(name1, url1) url2 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e5%b9%b2%e7%89%a9%e5%a6%b9%e3%81%86%e3%81%be%e3%82%8b%e3%81%a1%e3%82%83%e3%82%93-raw/\u0026quot; name2 = 'Umaru_Chan' get_url_list(name2, url2) main()    注: 这里用的USER_AGENT和sleep()都是为了防止被发现然后封IP\n 爬 manhuagui.com 上面那个太没挑战性了，于是我打算再爬一个。\n打开漫画网站， 发现没有图片链接，说明是动态加载的图片(用javascript加载的)，那怎么办呢？\nStep 1 先在网页里找找链接长啥样，毕竟用浏览器浏览的话，图片总是会被加载出来的，然后就能看到链接了，果然，在chrome的Elements这个tag里，我们翻到了图片链接：\n不过直接把链接复制到浏览器里打开的话会403，所以我们先搁置一下。\nStep 2 我们要获得某一话的所有图片链接，可以从图上看出似乎有一大段像是加密后的字符串，我们打开第一话和第二话的HTML，用命令行diff一下以后，会发现差异就刚好出现在这串字符串上：我们可以肯定这里面包含了图片链接相关的信息。\nStep 3 既然找到了加密串，那就要找一个钥匙来解码，看一下网页里内容不多，看起来并没有其他有用信息了，但是还有几个.js文件，一个个打开来看一下，终于在其中一个文件里找到了一大堆代码，然后这一大堆里面，有一段看起来又被加密了（有点此地无银三百两啊）： 把这段代码复制到chrome的console里，发现被自动解码了，得到了一个js函数： 我们点开这个函数，看一下里面的内容：\n函数内容 var LZString=(function(){var f=String.fromCharCode;var keyStrBase64=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026quot;;var baseReverseDic={};function getBaseValue(alphabet,character){if(!baseReverseDic[alphabet]){baseReverseDic[alphabet]={};for(var i=0;i\u0026lt;alphabet.length;i++){baseReverseDic[alphabet][alphabet.charAt(i)]=i}}return baseReverseDic[alphabet][character]}var LZString={decompressFromBase64:function(input){if(input==null)return\u0026quot;\u0026quot;;if(input==\u0026quot;\u0026quot;)return null;return LZString._0(input.length,32,function(index){return getBaseValue(keyStrBase64,input.charAt(index))})},_0:function(length,resetValue,getNextValue){var dictionary=[],next,enlargeIn=4,dictSize=4,numBits=3,entry=\u0026quot;\u0026quot;,result=[],i,w,bits,resb,maxpower,power,c,data={val:getNextValue(0),position:resetValue,index:1};for(i=0;i\u0026lt;3;i+=1){dictionary[i]=i}bits=0;maxpower=Math.pow(2,2);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(next=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 2:return\u0026quot;\u0026quot;}dictionary[3]=c;w=c;result.push(c);while(true){if(data.index\u0026gt;length){return\u0026quot;\u0026quot;}bits=0;maxpower=Math.pow(2,numBits);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(c=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 2:return result.join('')}if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}if(dictionary[c]){entry=dictionary[c]}else{if(c===dictSize){entry=w+w.charAt(0)}else{return null}}result.push(entry);dictionary[dictSize++]=w+entry.charAt(0);enlargeIn--;w=entry;if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}}}};return LZString})();String.prototype.splic=function(f){return LZString.decompressFromBase64(this).split(f)};   获得这个函数以后，我们尝试着把之前获得的加密串放进去看看： 这看起来就正常多了，而且这里面的 04|05|06|... 之类的信息看起来也能和之前找到的图片链接对应上。但是它似乎并没有按照某个特定的规律来，所以可以肯定还有一个函数来处理这个字符串。\nStep 4 有了这个信息，我们就接着找处理这个字符串的函数，再次观察一下HTML，发现这个Base64的串被包含在了一个\u0026lt;script\u0026gt;当中，长这样：\nscript内容 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;window[\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();',62,70,'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['\\x73\\x70\\x6c\\x69\\x63']('\\x7c'),0,{})) \u0026lt;/script\u0026gt;   看起来这也是一个函数啊，而且这个Base64的串似乎作为参数了，再次动用chrome的console帮助我们解析一下：\n这下我们大概可以明白几个事情：\n 这段代码实际上是 window[\u0026quot;eval\u0026quot;](...) 省略号部分是一个函数 function(p,a,c,k,e,d), 以 {} 包起来的是函数内容，那return p;} 后面的想必就是这6个参数。  观察一下这6个参数，我们会发现：\n p = 'X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();'\n  a = 62, c = 70\n  k = 'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['split']('|')\n  e = 0, d = {}\n 唯一需要处理的似乎就是k了，虽然k里没有|这个符号，不过刚才使用LZString.decompressfromBase64()函数解析出来的东西倒是有很多|。\n自此真相大白了，我们需要做的事情很简单：\n 提取出p,a,c,k,e,d这6个参数。 将k放进LZString.decompressfromBase64()解析一下。 调用 decode_func （也就是 function(p,a,c,k,e,d) ），得到结果。  结果长这样：\n我们要的图片链接就找到啦！在 files 里。\nStep 5: 我们还剩下最后一个问题：有了图片链接但是访问不了（403）怎么办？这似乎是一种简单的反爬虫方式，google一下，只要假装我们是从本站（即这个漫画的网站）进去的，而不是从其他地方进去的，就可以访问了。虽然在浏览器上做不到，但是python里可以通过更改Referer的方式来达到：\ndef get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;}  Step 6: 最后的最后，就是爬虫的基本过程了，不过我们有一段javascript代码需要运行，怎么在python中运行javascript呢？\n 首先保存一下javascript代码，叫 decode_func.js。内容如下：  const jsdom = require(\u0026quot;jsdom\u0026quot;); const { JSDOM } = jsdom; const dom = new JSDOM(`\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;`); window = dom.window; document = window.document; XMLHttpRequest = window.XMLHttpRequest; decode_func = window[\u0026quot;eval\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;})  然后用以下这段代码就可以了：  def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js()  调用的时候就用 res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d)\n最终代码如下：\n参考代码 import requests from bs4 import BeautifulSoup import os import time import random import lzstring import execjs import re import json def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] def get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;} def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js() def decode(s): x = lzstring.LZString() decoded_str = x.decompressFromBase64(s) return decoded_str.split(\u0026quot;|\u0026quot;) # p = \u0026quot;\u0026quot;\u0026quot;1h.14({\u0026quot;q\u0026quot;:7,\u0026quot;r\u0026quot;:\u0026quot;s t u v w x\u0026quot;,\u0026quot;y\u0026quot;:\u0026quot;7.1\u0026quot;,\u0026quot;A\u0026quot;:B,\u0026quot;C\u0026quot;:\u0026quot;6\u0026quot;,\u0026quot;D\u0026quot;:[\u0026quot;E.1.2\u0026quot;,\u0026quot;F.1.2\u0026quot;,\u0026quot;G.1.2\u0026quot;,\u0026quot;H.1.2\u0026quot;,\u0026quot;o.1.2\u0026quot;,\u0026quot;I.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;a.1.2\u0026quot;,\u0026quot;9.1.2\u0026quot;,\u0026quot;8.1.2\u0026quot;,\u0026quot;l.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;i.1.2\u0026quot;,\u0026quot;j.1.2\u0026quot;,\u0026quot;p.1.2\u0026quot;,\u0026quot;J.1.2\u0026quot;,\u0026quot;Y.1.2\u0026quot;,\u0026quot;L.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;K.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;18.1.2\u0026quot;,\u0026quot;1a.1.2\u0026quot;,\u0026quot;1g.1.2\u0026quot;,\u0026quot;1b.1.2\u0026quot;,\u0026quot;1c.1.2\u0026quot;,\u0026quot;1d.1.2\u0026quot;,\u0026quot;%1e%5%3%4%5%1f%4%3%12.1.2\u0026quot;],\u0026quot;19\u0026quot;:10,\u0026quot;Z\u0026quot;:11,\u0026quot;X\u0026quot;:\u0026quot;/W/z/V/6/\u0026quot;,\u0026quot;U\u0026quot;:0,\u0026quot;T\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;S\u0026quot;:R,\u0026quot;Q\u0026quot;:P,\u0026quot;O\u0026quot;:{\u0026quot;e\u0026quot;:N,\u0026quot;m\u0026quot;:\u0026quot;M\u0026quot;}}).n();\u0026quot;\u0026quot;\u0026quot; # a,c = 62,80 # k=['', 'jpg', 'webp', '9B', 'E5', '8B', '第02回', '27099', 'P0056', 'P0055', 'P0054', 'P0058', 'P0053', 'P0052', '', 'P0059', 'P0060', 'P0051', 'P0061', 'P0062', 'P0050', 'P0057', '', 'preInit', 'P0048', 'P0063', 'bid', 'bname', '总之就是非常可爱', 'fly', 'me', 'to', 'the', 'moon', 'bpic', '', 'cid', '354852', 'cname', 'files', 'P0044', 'P0045', 'P0046', 'P0047', 'P0049', 'P0064', 'P0068', 'P0066', 'GYeIdl7ujUrxJ1ls7JvwpQ', '1612951385', 'sl', '354596', 'prevId', '356912', 'nextId', 'block_cc', 'status', 'zzjsfckafmttm_lj2l', 'ps1', 'path', 'P0065', 'len', 'false', '35', 'BE', 'P0067', 'imgData', 'P0069', 'P0070', 'P0071', 'P0072', 'finished', 'P0073', 'P0075', 'P0076', 'P0077', 'E6', '9F', 'P0074', 'SMH'] # e = 0 # d = dict() # res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) # print(type(res)) # print(res) # get content of one chapter def get_content(title, url): create_dir(os.path.join(root_folder, title)) res = requests.get(f\u0026quot;https://manhuagui.com{url}\u0026quot;, random.choice(USER_AGENTS)) # print(res.text) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all(lambda tag:tag.name=='script', recursive=True) for item in items: txt = item.string # 必须是item.string, 不能是item.txt if txt and \u0026quot;return p;\u0026quot; in txt: # 如果tag里没有文字，txt==None parts = txt.split(\u0026quot;return p;}(\u0026quot;) part = parts[1][:-2] split_res = re.split(r',([0-9]+,[0-9]+,)', part) p = split_res[0][1:-1] split_res[1] = split_res[1][:-1] a, c = map(int, split_res[1].split(',')) k = split_res[2].split(\u0026quot;'['\u0026quot;)[0][1:] k = decode(k) e = 0 d = dict() res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) s = re.search('({.+})', res).group(0) # 找到一个由 {} 包裹的group info_dict = json.loads(s) files_list = info_dict[\u0026quot;files\u0026quot;] path_prefix = 'https://i.hamreus.com' + info_dict[\u0026quot;path\u0026quot;] i = 1 for file_name in files_list: complete_path = path_prefix + file_name[:-5] print(complete_path) res = requests.get(complete_path, headers=get_download_header()) img_name = os.path.join(root_folder, title, f'{i}.jpg') with open(img_name, 'wb') as file: file.write(res.content) file.flush() time.sleep(random.uniform(5.0, 10.0)) i += 1 # get manga url list def get_url_list(url): res = requests.get(url, random.choice(USER_AGENTS)) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('div', {\u0026quot;id\u0026quot;: \u0026quot;chapter-list-1\u0026quot;}) for manga_list in items: links = manga_list.find_all(\u0026quot;a\u0026quot;, recursive=True) links = links[1:] for link in links: title = link.get(\u0026quot;title\u0026quot;) ref = link.get(\u0026quot;href\u0026quot;) if title[-1] == '卷': continue print(f\u0026quot;{title}, {ref}\u0026quot;) get_content(title, ref) url = \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot; get_url_list(url)    注：上面这块代码被识别成lua语言了，样式出了点问题，可以在markdown里面指定语言，在第一个 ``` 后面加上语言名即可，如 ```python\n 后记 写这篇blog比玩爬虫本身还累啊，看来我果然不适合写作文（虽然我从小就深刻的明白这个道理）。不过这篇博客很大程度上也是写给自己看的，作为下次爬虫的参考（不知道下次爬虫要等到什么时候了）。\n以后可能会补点儿算法笔记，或者题解之类的。\n","date":"2021-02-01T22:45:03+08:00","permalink":"https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/","tags":["爬虫","python"],"title":"初学爬虫小记"},{"categories":["工程"],"contents":"起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动手开始构建咕咕已久的个人网站。\n由于我对自己的前端水平十分有数，所以想都没想就立刻放弃了“要不自己写一个网站？”的想法。\n后来想起之前逛过的ouuan大佬的博客非常好看，我的收藏夹里甚至还有他搭建博客的指南，就直接拿来用了，采用的是 hugo + even主题 + github actions，参考资料如下:\n https://ouuan.gitee.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 阅读指南 首先阅读ouuan的指南(上述链接)，然后使用他的hugo模版，按照模版里指示的进行clone。\nStep 2 Config的修改 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  Step 2.5 创建repository 因为我打算部署到github pages上，就在github上创建一个新的repository，叫tom0727.github.io\nStep 3 本地测试 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果(也可以边写边看效果，热加载真香)。最后用hugo命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了。\n注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 Github Settings 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5 Github Actions 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\n push到master以后，可以在repository的Actions页面查看一下deploy的情况：  Step 6 gitee镜像 因为github.io似乎被墙了，所以学ouuan弄了一个gitee镜像，教程的话参照这两个就可以了：\n https://jasonkayzk.github.io/2020/09/18/%E5%9C%A8Gitee%E6%90%AD%E5%BB%BAGithub-Pages/\n  https://github.com/yanglbme/gitee-pages-action\n gitee镜像的访问网址：tom0727.gitee.io\n注：在 hugo-blog/.github/workflows/sync.yml里记得设置一下on，不然触发不了自动部署。\n我这里设置的是：\non: push: branches: - master workflow_dispatch:  Step 7 评论区 评论区用很多种，我选用了utterances，部署步骤如下：\n 在Github上安装 utterances app，选择这个博客的repo 在 config.toml 中更改配置，将 [params.utterances] 下的 repo 改成这个repo的名字即可。（可以新开一个repo来储存评论，不过评论会以issues的形式出现在repo里，所以没必要新开一个）  一些其他的魔改 更改右上方的导航栏 先打开 view-source 的博客，找到导航栏的 class=\u0026quot;post-toc\u0026quot;。\n然后利用 Linux的根据content搜索文件，使用 grep -rnwl '.' -e 'post-toc-title' 找到相应的文件。最后在 ./themes/even/assets/sass/_partial/_post/_toc.scss 和 ./themes/even/assets/sass/_variables.scss 找到了相关信息。\n修改内容的宽度 ouuan大佬在 2021年04月11日 更新了一下博客的内容宽度，在大屏上显示效果更加优秀了。\n以下是ouuan的commit链接：\nfeat: use scrollbar for TOC feat: adjust widths\n修改了 themes/even/assets/js/even.js，themes/even/assets/sass/_partial/_post/_toc.scss，themes/even/assets/sass/_variables.scss。\n我在 2021年04月20日 直接复制并替换了这三个文件，之后如果需要revert，可以从github里找对应版本。\n增强搜索功能 ouuan大佬在 2021年05月16日 更新了博客的搜索功能，再复制粘贴就显得我很low了所以我选择 cherry-pick，步骤如下：\n git add remote ouuan https://github.com/ouuan/hugo-blog-template.git git fetch ouuan git log ouuan/master 查看得到这个修改的 commit ID git cherry-pick 01798429c1585662c50cf890fa7f92c9e3ca9c96  自定义 shortcodes 所谓 shortcode 就是一些模版，比如 {% question %} 之类的。\n如果要自定义 shortcode，可以在\nhugo-blog/themes/even/layouts/shortcodes/ 下面创建新的html文件，修改一下里面的 class，然后直接用就可以了。\n同样，shortcode也有一个图标，我至今没有找到这些图标是从哪里来的，但是可以在：\nhugo-blog/themes/even/assets/sass/_partial/_post/_admonition.scss 看到 shortcode 的其他样式，还有\n./themes/even/assets/sass/_iconfont.scss 看到一些图标的名称和对应 unicode 编号。\n自定义页面 在 2021年06月09日，我参考 https://kenkoooo.com/atcoder#/table/ ，利用 Codeforces API 高仿一个类似的页面。经 kenkoooo 本人同意，现在已经上线在 这里 了。主要的技术点如下：\n 利用 python 和 Codeforces API 进行交互（因为 requests 有自动重试功能，而 CF 的 API 并不是太稳定）。数据以 contests.json 的形式存在 /static/ 中，/scripts/UpdateCF_Problems.py 用于更新这个 json，这个更新的过程已经设置在 Github Action 中了。 将写好的 html 文件放在 /layouts/_default/cf-problems.html 中（需要更改一下才能正常使用导航栏等模版，具体的看这个文件里的内容即可），再创建 /content/cf-problems.md（其中需要更改 layout = 'cf-problems'），最后在 /config.toml 中把这个页面挂在导航栏里面。对应的 css 和 js 文件我分别放在了 /static/css/cf-problems.css 和 /static/js/cf-problem.js（在 cf-problems.html 中引用的时候也要注意使用变量名）。 为了使得用户体验更好，/static/css/cf-problems.css 还 override 了部分模版的 style，比如使得 CF-problems 页面的宽度变成 95% 等等。 在电脑上测试手机端的 media query 的时候最好使用 Safari（在 Develop \u0026gt; Enter Responsive Design Mode，如果导航栏里面没有 Develop 的话需要手动打开一下），chrome 的体验真的挺差的。  • 附：kenkoooo 大佬用的是 react，我一是不会写 react，二是不太清楚 hugo 是否支持 react 写的页面，如果以后有需求的时候可以尝试一下。\n修改样式 我觉得数学公式字体有点小，发现可以更改模版里的 css 来修改样式。同理也可以增添一些其他的东西进去，比如 class 为 center 的 div。\n/Users/huzhenwei/hugo-blog/themes/even/assets/sass/_custom/_custom.scss\n一些注意事项  博客默认模版的最底部有一个 --more--，要把它删掉，否则预览的时候整个博客都会被预览出来。  结语 新的一轮折腾结束了，总体来说还是比较满意这个博客的，个人很喜欢这种极简风的博客，功能也比较全，某种意义上算是告别了在Microsoft Word里做笔记的生活（？），之后打算先补上爬虫的一些笔记，还有搬运一点Word上的笔记吧。\n","date":"2021-02-01T21:21:41+08:00","permalink":"https://tom0727.github.io/post/001-hugo-tutorial/","tags":["hugo","博客"],"title":"Hugo博客搭建小记"},{"categories":null,"contents":"Hello, this is Tom from China! If you have trouble visiting this site (especially for mainland China users), please try visit\nhttps://tom0727.gitee.io/\nAbout me  Year 4 Undergraduate student @ HKU (The University of Hong Kong), 2018-2022 Major in Computer Science Competitive programming as hobby   Resume  Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu.pdf Resume (in Chinese): https://github.com/tom0727/Resume/blob/master/%E8%83%A1%E6%8C%AF%E4%B8%BA.pdf  Contact  Email: huzhenweitom@gmail.com QQ/Wechat: 980409152  Links  Codeforces:  Leetcode: tom0727  ","date":"2021-01-31T22:57:58+08:00","permalink":"https://tom0727.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://tom0727.github.io/search/","tags":null,"title":"搜索"}]