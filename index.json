[{"categories":[""],"contents":"注意事项 Set中的Comparator定义 在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如：\n• 注意这里用了更精简的写法，利用 tuple 可以直接快速比较多个元素。\nint cnt[maxn]; struct Cmp { bool operator()(int i, int j) const { return tuple {cnt[i], i} \u0026lt; tuple {cnt[j], j}; // 一定要加上 i,j! // if (cnt[i] == cnt[j]) return i \u0026lt; j; // 一定要加！！！ // return cnt[i] \u0026lt; cnt[j]; } }; set\u0026lt;int, Cmp\u0026gt; s;  这里 if (cnt[i] == cnt[j]) return i \u0026lt; j; 非常关键，如果不加的话，那么 cnt[i] == cnt[j] 将会被判定为重复元素，导致 i,j 只能加入一个。\nswap函数的时间复杂度 注意如果 $f,g$ 是两个数组，那么 swap(f,g) 的时间复杂度是 $O(n)$ 级别的！\nvector的unique + resize写法 vector\u0026lt;int\u0026gt; a {...}; sort(a.begin(), a.end()); // unique 之前需要sort a.resize(unique(a.begin(), a.end()) - a.begin());  通用模版 Z自动取模整数 Z自动取模整数 const int mod = 998244353; template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} Z(ll x) : x(norm((int)(x % mod))) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, Z \u0026amp;a) { ll v; is \u0026gt;\u0026gt; v; a = Z(v); return is; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const Z \u0026amp;a) { return os \u0026lt;\u0026lt; a.val(); } };   树状数组 树状数组 struct BIT { int tr[maxn]; inline int lowbit(int x) { return x \u0026amp; -x; } void update(int p, int val) { while (p \u0026lt;= n) { tr[p] += val; p += lowbit(p); } } // return sum[1...p] int query(int p) { int ans = 0; while (p \u0026gt; 0) { ans += tr[p]; p -= lowbit(p); } return ans; } };   ST表 ST表 struct SparseTable { int st[maxn][18], bin[maxn]; int ask_st(int l, int r) { int len = r-l+1; int k = bin[len]; return min(st[l][k], st[r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) st[i][0] = a[i]; for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) st[i][k] = min(st[i][k-1], st[i+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } };   线段树 线段树 int n, m, a[maxn]; struct Node { ll sum, tag = 0; }; struct SegmentTree { Node tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void push_down(int cur, int l, int r) { if (!tr[cur].tag) return; ll tag = tr[cur].tag; tr[cur].tag = 0; int lc = cur\u0026lt;\u0026lt;1, rc = lc + 1; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[lc].sum += tag * (mid-l+1); tr[rc].sum += tag * (r-mid); tr[lc].tag += tag; tr[rc].tag += tag; } void update(int cur, int l, int r, int L, int R, ll x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].tag += x; tr[cur].sum += x * (r-l+1); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } void update(int cur, int l, int r, int p, ll x) { if (l == r) { tr[cur].sum += x; return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].sum; push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } void build(int cur, int l, int r) { if (l == r) { tr[cur].sum = a[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } } tr;   计时程序 • clock() / CLOCKS_PER_SEC 可以返回程序运行的 ms 数。\nconst int MAX_TIME = 950; // 950 ms while ((double)clock() / CLOCKS_PER_SEC \u0026lt; MAX_TIME) doSomething();  几何模版 kuangbin的板子：\n链接：https://kuangbin.github.io/2019/04/28/20190428/\nkuangbin // `计算几何模板` const double eps = 1e-8; const double inf = 1e20; const double pi = acos(-1.0); const int maxp = 1010; //`Compares a double to zero` int sgn(double x){ if(fabs(x) \u0026lt; eps)return 0; if(x \u0026lt; 0)return -1; else return 1; } //square of a double inline double sqr(double x){return x*x;} /* * Point * Point() - Empty constructor * Point(double _x,double _y) - constructor * input() - double input * output() - %.2f output * operator == - compares x and y * operator \u0026lt; - compares first by x, then by y * operator - - return new Point after subtracting curresponging x and y * operator ^ - cross product of 2d points * operator * - dot product * len() - gives length from origin * len2() - gives square of length from origin * distance(Point p) - gives distance from p * operator + Point b - returns new Point after adding curresponging x and y * operator * double k - returns new Point after multiplieing x and y by k * operator / double k - returns new Point after divideing x and y by k * rad(Point a,Point b)- returns the angle of Point a and Point b from this Point * trunc(double r) - return Point that if truncated the distance from center to r * rotleft() - returns 90 degree ccw rotated point * rotright() - returns 90 degree cw rotated point * rotate(Point p,double angle) - returns Point after rotateing the Point centering at p by angle radian ccw */ struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } void input(){ scanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;x,\u0026amp;y); } void output(){ printf(\u0026quot;%.2f %.2f\\n\u0026quot;,x,y); } bool operator == (Point b)const{ return sgn(x-b.x) == 0 \u0026amp;\u0026amp; sgn(y-b.y) == 0; } bool operator \u0026lt; (Point b)const{ return sgn(x-b.x)== 0?sgn(y-b.y)\u0026lt;0:x\u0026lt;b.x; } Point operator -(const Point \u0026amp;b)const{ return Point(x-b.x,y-b.y); } //叉积 double operator ^(const Point \u0026amp;b)const{ return x*b.y - y*b.x; } //点积 double operator *(const Point \u0026amp;b)const{ return x*b.x + y*b.y; } //返回长度 double len(){ return hypot(x,y);//库函数 } //返回长度的平方 double len2(){ return x*x + y*y; } //返回两点的距离 double distance(Point p){ return hypot(x-p.x,y-p.y); } Point operator +(const Point \u0026amp;b)const{ return Point(x+b.x,y+b.y); } Point operator *(const double \u0026amp;k)const{ return Point(x*k,y*k); } Point operator /(const double \u0026amp;k)const{ return Point(x/k,y/k); } //`计算pa 和 pb 的夹角` //`就是求这个点看a,b 所成的夹角` //`测试 LightOJ1203` double rad(Point a,Point b){ Point p = *this; return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) )); } //`化为长度为r的向量` Point trunc(double r){ double l = len(); if(!sgn(l))return *this; r /= l; return Point(x*r,y*r); } //`逆时针旋转90度` Point rotleft(){ return Point(-y,x); } //`顺时针旋转90度` Point rotright(){ return Point(y,-x); } //`绕着p点逆时针旋转angle` Point rotate(Point p,double angle){ Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c); } }; /* * Stores two points * Line() - Empty constructor * Line(Point _s,Point _e) - Line through _s and _e * operator == - checks if two points are same * Line(Point p,double angle) - one end p , another end at angle degree * Line(double a,double b,double c) - Line of equation ax + by + c = 0 * input() - inputs s and e * adjust() - orders in such a way that s \u0026lt; e * length() - distance of se * angle() - return 0 \u0026lt;= angle \u0026lt; pi * relation(Point p) - 3 if point is on line * 1 if point on the left of line * 2 if point on the right of line * pointonseg(double p) - return true if point on segment * parallel(Line v) - return true if they are parallel * segcrossseg(Line v) - returns 0 if does not intersect * returns 1 if non-standard intersection * returns 2 if intersects * linecrossseg(Line v) - line and seg * linecrossline(Line v) - 0 if parallel * 1 if coincides * 2 if intersects * crosspoint(Line v) - returns intersection point * dispointtoline(Point p) - distance from point p to the line * dispointtoseg(Point p) - distance from p to the segment * dissegtoseg(Line v) - distance of two segment * lineprog(Point p) - returns projected point p on se line * symmetrypoint(Point p) - returns reflection point of p over se * */ struct Line{ Point s,e; Line(){} Line(Point _s,Point _e){ s = _s; e = _e; } bool operator ==(Line v){ return (s == v.s)\u0026amp;\u0026amp;(e == v.e); } //`根据一个点和倾斜角angle确定直线,0\u0026lt;=angle\u0026lt;pi` Line(Point p,double angle){ s = p; if(sgn(angle-pi/2) == 0){ e = (s + Point(0,1)); } else{ e = (s + Point(1,tan(angle))); } } //ax+by+c=0 Line(double a,double b,double c){ if(sgn(a) == 0){ s = Point(0,-c/b); e = Point(1,-c/b); } else if(sgn(b) == 0){ s = Point(-c/a,0); e = Point(-c/a,1); } else{ s = Point(0,-c/b); e = Point(1,(-c-a)/b); } } void input(){ s.input(); e.input(); } void adjust(){ if(e \u0026lt; s)swap(s,e); } //求线段长度 double length(){ return s.distance(e); } //`返回直线倾斜角 0\u0026lt;=angle\u0026lt;pi` double angle(){ double k = atan2(e.y-s.y,e.x-s.x); if(sgn(k) \u0026lt; 0)k += pi; if(sgn(k-pi) == 0)k -= pi; return k; } //`点和直线关系` //`1 在左侧` //`2 在右侧` //`3 在直线上` int relation(Point p){ int c = sgn((p-s)^(e-s)); if(c \u0026lt; 0)return 1; else if(c \u0026gt; 0)return 2; else return 3; } // 点在线段上的判断 bool pointonseg(Point p){ return sgn((p-s)^(e-s)) == 0 \u0026amp;\u0026amp; sgn((p-s)*(p-e)) \u0026lt;= 0; } //`两向量平行(对应直线平行或重合)` bool parallel(Line v){ return sgn((e-s)^(v.e-v.s)) == 0; } //`两线段相交判断` //`2 规范相交` //`1 非规范相交` //`0 不相交` int segcrossseg(Line v){ int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2)==-2 \u0026amp;\u0026amp; (d3^d4)==-2 )return 2; return (d1==0 \u0026amp;\u0026amp; sgn((v.s-s)*(v.s-e))\u0026lt;=0) || (d2==0 \u0026amp;\u0026amp; sgn((v.e-s)*(v.e-e))\u0026lt;=0) || (d3==0 \u0026amp;\u0026amp; sgn((s-v.s)*(s-v.e))\u0026lt;=0) || (d4==0 \u0026amp;\u0026amp; sgn((e-v.s)*(e-v.e))\u0026lt;=0); } //`直线和线段相交判断` //`-*this line -v seg` //`2 规范相交` //`1 非规范相交` //`0 不相交` int linecrossseg(Line v){ int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); if((d1^d2)==-2) return 2; return (d1==0||d2==0); } //`两直线关系` //`0 平行` //`1 重合` //`2 相交` int linecrossline(Line v){ if((*this).parallel(v)) return v.relation(s)==3; return 2; } //`求两直线的交点` //`要保证两直线不平行或重合` Point crosspoint(Line v){ double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); } //点到直线的距离 double dispointtoline(Point p){ return fabs((p-s)^(e-s))/length(); } //点到线段的距离 double dispointtoseg(Point p){ if(sgn((p-s)*(e-s))\u0026lt;0 || sgn((p-e)*(s-e))\u0026lt;0) return min(p.distance(s),p.distance(e)); return dispointtoline(p); } //`返回线段到线段的距离` //`前提是两线段不相交，相交距离就是0了` double dissegtoseg(Line v){ return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e))); } //`返回点p在直线上的投影` Point lineprog(Point p){ return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) ); } //`返回点p关于直线的对称点` Point symmetrypoint(Point p){ Point q = lineprog(p); return Point(2*q.x-p.x,2*q.y-p.y); } }; //圆 struct circle{ Point p;//圆心 double r;//半径 circle(){} circle(Point _p,double _r){ p = _p; r = _r; } circle(double x,double y,double _r){ p = Point(x,y); r = _r; } //`三角形的外接圆` //`需要Point的+ / rotate() 以及Line的crosspoint()` //`利用两条边的中垂线得到圆心` //`测试：UVA12304` circle(Point a,Point b,Point c){ Line u = Line((a+b)/2,((a+b)/2)+((b-a).rotleft())); Line v = Line((b+c)/2,((b+c)/2)+((c-b).rotleft())); p = u.crosspoint(v); r = p.distance(a); } //`三角形的内切圆` //`参数bool t没有作用，只是为了和上面外接圆函数区别` //`测试：UVA12304` circle(Point a,Point b,Point c,bool t){ Line u,v; double m = atan2(b.y-a.y,b.x-a.x), n = atan2(c.y-a.y,c.x-a.x); u.s = a; u.e = u.s + Point(cos((n+m)/2),sin((n+m)/2)); v.s = b; m = atan2(a.y-b.y,a.x-b.x) , n = atan2(c.y-b.y,c.x-b.x); v.e = v.s + Point(cos((n+m)/2),sin((n+m)/2)); p = u.crosspoint(v); r = Line(a,b).dispointtoseg(p); } //输入 void input(){ p.input(); scanf(\u0026quot;%lf\u0026quot;,\u0026amp;r); } //输出 void output(){ printf(\u0026quot;%.2lf %.2lf %.2lf\\n\u0026quot;,p.x,p.y,r); } bool operator == (circle v){ return (p==v.p) \u0026amp;\u0026amp; sgn(r-v.r)==0; } bool operator \u0026lt; (circle v)const{ return ((p\u0026lt;v.p)||((p==v.p)\u0026amp;\u0026amp;sgn(r-v.r)\u0026lt;0)); } //面积 double area(){ return pi*r*r; } //周长 double circumference(){ return 2*pi*r; } //`点和圆的关系` //`0 圆外` //`1 圆上` //`2 圆内` int relation(Point b){ double dst = b.distance(p); if(sgn(dst-r) \u0026lt; 0)return 2; else if(sgn(dst-r)==0)return 1; return 0; } //`线段和圆的关系` //`比较的是圆心到线段的距离和半径的关系` int relationseg(Line v){ double dst = v.dispointtoseg(p); if(sgn(dst-r) \u0026lt; 0)return 2; else if(sgn(dst-r) == 0)return 1; return 0; } //`直线和圆的关系` //`比较的是圆心到直线的距离和半径的关系` int relationline(Line v){ double dst = v.dispointtoline(p); if(sgn(dst-r) \u0026lt; 0)return 2; else if(sgn(dst-r) == 0)return 1; return 0; } //`两圆的关系` //`5 相离` //`4 外切` //`3 相交` //`2 内切` //`1 内含` //`需要Point的distance` //`测试：UVA12304` int relationcircle(circle v){ double d = p.distance(v.p); if(sgn(d-r-v.r) \u0026gt; 0)return 5; if(sgn(d-r-v.r) == 0)return 4; double l = fabs(r-v.r); if(sgn(d-r-v.r)\u0026lt;0 \u0026amp;\u0026amp; sgn(d-l)\u0026gt;0)return 3; if(sgn(d-l)==0)return 2; if(sgn(d-l)\u0026lt;0)return 1; } //`求两个圆的交点，返回0表示没有交点，返回1是一个交点，2是两个交点` //`需要relationcircle` //`测试：UVA12304` int pointcrosscircle(circle v,Point \u0026amp;p1,Point \u0026amp;p2){ int rel = relationcircle(v); if(rel == 1 || rel == 5)return 0; double d = p.distance(v.p); double l = (d*d+r*r-v.r*v.r)/(2*d); double h = sqrt(r*r-l*l); Point tmp = p + (v.p-p).trunc(l); p1 = tmp + ((v.p-p).rotleft().trunc(h)); p2 = tmp + ((v.p-p).rotright().trunc(h)); if(rel == 2 || rel == 4) return 1; return 2; } //`求直线和圆的交点，返回交点个数` int pointcrossline(Line v,Point \u0026amp;p1,Point \u0026amp;p2){ if(!(*this).relationline(v))return 0; Point a = v.lineprog(p); double d = v.dispointtoline(p); d = sqrt(r*r-d*d); if(sgn(d) == 0){ p1 = a; p2 = a; return 1; } p1 = a + (v.e-v.s).trunc(d); p2 = a - (v.e-v.s).trunc(d); return 2; } //`得到过a,b两点，半径为r1的两个圆` int gercircle(Point a,Point b,double r1,circle \u0026amp;c1,circle \u0026amp;c2){ circle x(a,r1),y(b,r1); int t = x.pointcrosscircle(y,c1.p,c2.p); if(!t)return 0; c1.r = c2.r = r; return t; } //`得到与直线u相切，过点q,半径为r1的圆` //`测试：UVA12304` int getcircle(Line u,Point q,double r1,circle \u0026amp;c1,circle \u0026amp;c2){ double dis = u.dispointtoline(q); if(sgn(dis-r1*2)\u0026gt;0)return 0; if(sgn(dis) == 0){ c1.p = q + ((u.e-u.s).rotleft().trunc(r1)); c2.p = q + ((u.e-u.s).rotright().trunc(r1)); c1.r = c2.r = r1; return 2; } Line u1 = Line((u.s + (u.e-u.s).rotleft().trunc(r1)),(u.e + (u.e-u.s).rotleft().trunc(r1))); Line u2 = Line((u.s + (u.e-u.s).rotright().trunc(r1)),(u.e + (u.e-u.s).rotright().trunc(r1))); circle cc = circle(q,r1); Point p1,p2; if(!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2); c1 = circle(p1,r1); if(p1 == p2){ c2 = c1; return 1; } c2 = circle(p2,r1); return 2; } //`同时与直线u,v相切，半径为r1的圆` //`测试：UVA12304` int getcircle(Line u,Line v,double r1,circle \u0026amp;c1,circle \u0026amp;c2,circle \u0026amp;c3,circle \u0026amp;c4){ if(u.parallel(v))return 0;//两直线平行 Line u1 = Line(u.s + (u.e-u.s).rotleft().trunc(r1),u.e + (u.e-u.s).rotleft().trunc(r1)); Line u2 = Line(u.s + (u.e-u.s).rotright().trunc(r1),u.e + (u.e-u.s).rotright().trunc(r1)); Line v1 = Line(v.s + (v.e-v.s).rotleft().trunc(r1),v.e + (v.e-v.s).rotleft().trunc(r1)); Line v2 = Line(v.s + (v.e-v.s).rotright().trunc(r1),v.e + (v.e-v.s).rotright().trunc(r1)); c1.r = c2.r = c3.r = c4.r = r1; c1.p = u1.crosspoint(v1); c2.p = u1.crosspoint(v2); c3.p = u2.crosspoint(v1); c4.p = u2.crosspoint(v2); return 4; } //`同时与不相交圆cx,cy相切，半径为r1的圆` //`测试：UVA12304` int getcircle(circle cx,circle cy,double r1,circle \u0026amp;c1,circle \u0026amp;c2){ circle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r); int t = x.pointcrosscircle(y,c1.p,c2.p); if(!t)return 0; c1.r = c2.r = r1; return t; } //`过一点作圆的切线(先判断点和圆的关系)` //`测试：UVA12304` int tangentline(Point q,Line \u0026amp;u,Line \u0026amp;v){ int x = relation(q); if(x == 2)return 0; if(x == 1){ u = Line(q,q + (q-p).rotleft()); v = u; return 1; } double d = p.distance(q); double l = r*r/d; double h = sqrt(r*r-l*l); u = Line(q,p + ((q-p).trunc(l) + (q-p).rotleft().trunc(h))); v = Line(q,p + ((q-p).trunc(l) + (q-p).rotright().trunc(h))); return 2; } //`求两圆相交的面积` double areacircle(circle v){ int rel = relationcircle(v); if(rel \u0026gt;= 4)return 0.0; if(rel \u0026lt;= 2)return min(area(),v.area()); double d = p.distance(v.p); double hf = (r+v.r+d)/2.0; double ss = 2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d)); double a1 = acos((r*r+d*d-v.r*v.r)/(2.0*r*d)); a1 = a1*r*r; double a2 = acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d)); a2 = a2*v.r*v.r; return a1+a2-ss; } //`求圆和三角形pab的相交面积` //`测试：POJ3675 HDU3982 HDU2892` double areatriangle(Point a,Point b){ if(sgn((p-a)^(p-b)) == 0)return 0.0; Point q[5]; int len = 0; q[len++] = a; Line l(a,b); Point p1,p2; if(pointcrossline(l,q[1],q[2])==2){ if(sgn((a-q[1])*(b-q[1]))\u0026lt;0)q[len++] = q[1]; if(sgn((a-q[2])*(b-q[2]))\u0026lt;0)q[len++] = q[2]; } q[len++] = b; if(len == 4 \u0026amp;\u0026amp; sgn((q[0]-q[1])*(q[2]-q[1]))\u0026gt;0)swap(q[1],q[2]); double res = 0; for(int i = 0;i \u0026lt; len-1;i++){ if(relation(q[i])==0||relation(q[i+1])==0){ double arg = p.rad(q[i],q[i+1]); res += r*r*arg/2.0; } else{ res += fabs((q[i]-p)^(q[i+1]-p))/2.0; } } return res; } }; /* * n,p Line l for each side * input(int _n) - inputs _n size polygon * add(Point q) - adds a point at end of the list * getline() - populates line array * cmp - comparision in convex_hull order * norm() - sorting in convex_hull order * getconvex(polygon \u0026amp;convex) - returns convex hull in convex * Graham(polygon \u0026amp;convex) - returns convex hull in convex * isconvex() - checks if convex * relationpoint(Point q) - returns 3 if q is a vertex * 2 if on a side * 1 if inside * 0 if outside * convexcut(Line u,polygon \u0026amp;po) - left side of u in po * gercircumference() - returns side length * getarea() - returns area * getdir() - returns 0 for cw, 1 for ccw * getbarycentre() - returns barycenter * */ struct polygon{ int n; Point p[maxp]; Line l[maxp]; void input(int _n){ n = _n; for(int i = 0;i \u0026lt; n;i++) p[i].input(); } void add(Point q){ p[n++] = q; } void getline(){ for(int i = 0;i \u0026lt; n;i++){ l[i] = Line(p[i],p[(i+1)%n]); } } struct cmp{ Point p; cmp(const Point \u0026amp;p0){p = p0;} bool operator()(const Point \u0026amp;aa,const Point \u0026amp;bb){ Point a = aa, b = bb; int d = sgn((a-p)^(b-p)); if(d == 0){ return sgn(a.distance(p)-b.distance(p)) \u0026lt; 0; } return d \u0026gt; 0; } }; //`进行极角排序` //`首先需要找到最左下角的点` //`需要重载号好Point的 \u0026lt; 操作符(min函数要用) ` void norm(){ Point mi = p[0]; for(int i = 1;i \u0026lt; n;i++)mi = min(mi,p[i]); sort(p,p+n,cmp(mi)); } //`得到凸包` //`得到的凸包里面的点编号是0$\\sim$n-1的` //`两种凸包的方法` //`注意如果有影响，要特判下所有点共点，或者共线的特殊情况` //`测试 LightOJ1203 LightOJ1239` void getconvex(polygon \u0026amp;convex){ sort(p,p+n); convex.n = n; for(int i = 0;i \u0026lt; min(n,2);i++){ convex.p[i] = p[i]; } if(convex.n == 2 \u0026amp;\u0026amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 if(n \u0026lt;= 2)return; int \u0026amp;top = convex.n; top = 1; for(int i = 2;i \u0026lt; n;i++){ while(top \u0026amp;\u0026amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) \u0026lt;= 0) top--; convex.p[++top] = p[i]; } int temp = top; convex.p[++top] = p[n-2]; for(int i = n-3;i \u0026gt;= 0;i--){ while(top != temp \u0026amp;\u0026amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) \u0026lt;= 0) top--; convex.p[++top] = p[i]; } if(convex.n == 2 \u0026amp;\u0026amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 convex.norm();//`原来得到的是顺时针的点，排序后逆时针` } //`得到凸包的另外一种方法` //`测试 LightOJ1203 LightOJ1239` void Graham(polygon \u0026amp;convex){ norm(); int \u0026amp;top = convex.n; top = 0; if(n == 1){ top = 1; convex.p[0] = p[0]; return; } if(n == 2){ top = 2; convex.p[0] = p[0]; convex.p[1] = p[1]; if(convex.p[0] == convex.p[1])top--; return; } convex.p[0] = p[0]; convex.p[1] = p[1]; top = 2; for(int i = 2;i \u0026lt; n;i++){ while( top \u0026gt; 1 \u0026amp;\u0026amp; sgn((convex.p[top-1]-convex.p[top-2])^(p[i]-convex.p[top-2])) \u0026lt;= 0 ) top--; convex.p[top++] = p[i]; } if(convex.n == 2 \u0026amp;\u0026amp; (convex.p[0] == convex.p[1]))convex.n--;//特判 } //`判断是不是凸的` bool isconvex(){ bool s[2]; memset(s,false,sizeof(s)); for(int i = 0;i \u0026lt; n;i++){ int j = (i+1)%n; int k = (j+1)%n; s[sgn((p[j]-p[i])^(p[k]-p[i]))+1] = true; if(s[0] \u0026amp;\u0026amp; s[2])return false; } return true; } //`判断点和任意多边形的关系` //` 3 点上` //` 2 边上` //` 1 内部` //` 0 外部` int relationpoint(Point q){ for(int i = 0;i \u0026lt; n;i++){ if(p[i] == q)return 3; } getline(); for(int i = 0;i \u0026lt; n;i++){ if(l[i].pointonseg(q))return 2; } int cnt = 0; for(int i = 0;i \u0026lt; n;i++){ int j = (i+1)%n; int k = sgn((q-p[j])^(p[i]-p[j])); int u = sgn(p[i].y-q.y); int v = sgn(p[j].y-q.y); if(k \u0026gt; 0 \u0026amp;\u0026amp; u \u0026lt; 0 \u0026amp;\u0026amp; v \u0026gt;= 0)cnt++; if(k \u0026lt; 0 \u0026amp;\u0026amp; v \u0026lt; 0 \u0026amp;\u0026amp; u \u0026gt;= 0)cnt--; } return cnt != 0; } //`直线u切割凸多边形左侧` //`注意直线方向` //`测试：HDU3982` void convexcut(Line u,polygon \u0026amp;po){ int \u0026amp;top = po.n;//注意引用 top = 0; for(int i = 0;i \u0026lt; n;i++){ int d1 = sgn((u.e-u.s)^(p[i]-u.s)); int d2 = sgn((u.e-u.s)^(p[(i+1)%n]-u.s)); if(d1 \u0026gt;= 0)po.p[top++] = p[i]; if(d1*d2 \u0026lt; 0)po.p[top++] = u.crosspoint(Line(p[i],p[(i+1)%n])); } } //`得到周长` //`测试 LightOJ1239` double getcircumference(){ double sum = 0; for(int i = 0;i \u0026lt; n;i++){ sum += p[i].distance(p[(i+1)%n]); } return sum; } //`得到面积` double getarea(){ double sum = 0; for(int i = 0;i \u0026lt; n;i++){ sum += (p[i]^p[(i+1)%n]); } return fabs(sum)/2; } //`得到方向` //` 1 表示逆时针，0表示顺时针` bool getdir(){ double sum = 0; for(int i = 0;i \u0026lt; n;i++) sum += (p[i]^p[(i+1)%n]); if(sgn(sum) \u0026gt; 0)return 1; return 0; } //`得到重心` Point getbarycentre(){ Point ret(0,0); double area = 0; for(int i = 1;i \u0026lt; n-1;i++){ double tmp = (p[i]-p[0])^(p[i+1]-p[0]); if(sgn(tmp) == 0)continue; area += tmp; ret.x += (p[0].x+p[i].x+p[i+1].x)/3*tmp; ret.y += (p[0].y+p[i].y+p[i+1].y)/3*tmp; } if(sgn(area)) ret = ret/area; return ret; } //`多边形和圆交的面积` //`测试：POJ3675 HDU3982 HDU2892` double areacircle(circle c){ double ans = 0; for(int i = 0;i \u0026lt; n;i++){ int j = (i+1)%n; if(sgn( (p[j]-c.p)^(p[i]-c.p) ) \u0026gt;= 0) ans += c.areatriangle(p[i],p[j]); else ans -= c.areatriangle(p[i],p[j]); } return fabs(ans); } //`多边形和圆关系` //` 2 圆完全在多边形内` //` 1 圆在多边形里面，碰到了多边形边界` //` 0 其它` int relationcircle(circle c){ getline(); int x = 2; if(relationpoint(c.p) != 1)return 0;//圆心不在内部 for(int i = 0;i \u0026lt; n;i++){ if(c.relationseg(l[i])==2)return 0; if(c.relationseg(l[i])==1)x = 1; } return x; } }; //`AB X AC` double cross(Point A,Point B,Point C){ return (B-A)^(C-A); } //`AB*AC` double dot(Point A,Point B,Point C){ return (B-A)*(C-A); } //`最小矩形面积覆盖` //` A 必须是凸包(而且是逆时针顺序)` //` 测试 UVA 10173` double minRectangleCover(polygon A){ //`要特判A.n \u0026lt; 3的情况` if(A.n \u0026lt; 3)return 0.0; A.p[A.n] = A.p[0]; double ans = -1; int r = 1, p = 1, q; for(int i = 0;i \u0026lt; A.n;i++){ //`卡出离边A.p[i] - A.p[i+1]最远的点` while( sgn( cross(A.p[i],A.p[i+1],A.p[r+1]) - cross(A.p[i],A.p[i+1],A.p[r]) ) \u0026gt;= 0 ) r = (r+1)%A.n; //`卡出A.p[i] - A.p[i+1]方向上正向n最远的点` while(sgn( dot(A.p[i],A.p[i+1],A.p[p+1]) - dot(A.p[i],A.p[i+1],A.p[p]) ) \u0026gt;= 0 ) p = (p+1)%A.n; if(i == 0)q = p; //`卡出A.p[i] - A.p[i+1]方向上负向最远的点` while(sgn(dot(A.p[i],A.p[i+1],A.p[q+1]) - dot(A.p[i],A.p[i+1],A.p[q])) \u0026lt;= 0) q = (q+1)%A.n; double d = (A.p[i] - A.p[i+1]).len2(); double tmp = cross(A.p[i],A.p[i+1],A.p[r]) * (dot(A.p[i],A.p[i+1],A.p[p]) - dot(A.p[i],A.p[i+1],A.p[q]))/d; if(ans \u0026lt; 0 || ans \u0026gt; tmp)ans = tmp; } return ans; } //`直线切凸多边形` //`多边形是逆时针的，在q1q2的左侧` //`测试:HDU3982` vector\u0026lt;Point\u0026gt; convexCut(const vector\u0026lt;Point\u0026gt; \u0026amp;ps,Point q1,Point q2){ vector\u0026lt;Point\u0026gt;qs; int n = ps.size(); for(int i = 0;i \u0026lt; n;i++){ Point p1 = ps[i], p2 = ps[(i+1)%n]; int d1 = sgn((q2-q1)^(p1-q1)), d2 = sgn((q2-q1)^(p2-q1)); if(d1 \u0026gt;= 0) qs.push_back(p1); if(d1 * d2 \u0026lt; 0) qs.push_back(Line(p1,p2).crosspoint(Line(q1,q2))); } return qs; } //`半平面交` //`测试 POJ3335 POJ1474 POJ1279` //*************************** struct halfplane:public Line{ double angle; halfplane(){} //`表示向量s-\u0026gt;e逆时针(左侧)的半平面` halfplane(Point _s,Point _e){ s = _s; e = _e; } halfplane(Line v){ s = v.s; e = v.e; } void calcangle(){ angle = atan2(e.y-s.y,e.x-s.x); } bool operator \u0026lt;(const halfplane \u0026amp;b)const{ return angle \u0026lt; b.angle; } }; struct halfplanes{ int n; halfplane hp[maxp]; Point p[maxp]; int que[maxp]; int st,ed; void push(halfplane tmp){ hp[n++] = tmp; } //去重 void unique(){ int m = 1; for(int i = 1;i \u0026lt; n;i++){ if(sgn(hp[i].angle-hp[i-1].angle) != 0) hp[m++] = hp[i]; else if(sgn( (hp[m-1].e-hp[m-1].s)^(hp[i].s-hp[m-1].s) ) \u0026gt; 0) hp[m-1] = hp[i]; } n = m; } bool halfplaneinsert(){ for(int i = 0;i \u0026lt; n;i++)hp[i].calcangle(); sort(hp,hp+n); unique(); que[st=0] = 0; que[ed=1] = 1; p[1] = hp[0].crosspoint(hp[1]); for(int i = 2;i \u0026lt; n;i++){ while(st\u0026lt;ed \u0026amp;\u0026amp; sgn((hp[i].e-hp[i].s)^(p[ed]-hp[i].s))\u0026lt;0)ed--; while(st\u0026lt;ed \u0026amp;\u0026amp; sgn((hp[i].e-hp[i].s)^(p[st+1]-hp[i].s))\u0026lt;0)st++; que[++ed] = i; if(hp[i].parallel(hp[que[ed-1]]))return false; p[ed]=hp[i].crosspoint(hp[que[ed-1]]); } while(st\u0026lt;ed \u0026amp;\u0026amp; sgn((hp[que[st]].e-hp[que[st]].s)^(p[ed]-hp[que[st]].s))\u0026lt;0)ed--; while(st\u0026lt;ed \u0026amp;\u0026amp; sgn((hp[que[ed]].e-hp[que[ed]].s)^(p[st+1]-hp[que[ed]].s))\u0026lt;0)st++; if(st+1\u0026gt;=ed)return false; return true; } //`得到最后半平面交得到的凸多边形` //`需要先调用halfplaneinsert() 且返回true` void getconvex(polygon \u0026amp;con){ p[st] = hp[que[st]].crosspoint(hp[que[ed]]); con.n = ed-st+1; for(int j = st,i = 0;j \u0026lt;= ed;i++,j++) con.p[i] = p[j]; } }; //*************************** const int maxn = 1010; struct circles{ circle c[maxn]; double ans[maxn];//`ans[i]表示被覆盖了i次的面积` double pre[maxn]; int n; circles(){} void add(circle cc){ c[n++] = cc; } //`x包含在y中` bool inner(circle x,circle y){ if(x.relationcircle(y) != 1)return 0; return sgn(x.r-y.r)\u0026lt;=0?1:0; } //圆的面积并去掉内含的圆 void init_or(){ bool mark[maxn] = {0}; int i,j,k=0; for(i = 0;i \u0026lt; n;i++){ for(j = 0;j \u0026lt; n;j++) if(i != j \u0026amp;\u0026amp; !mark[j]){ if( (c[i]==c[j])||inner(c[i],c[j]) )break; } if(j \u0026lt; n)mark[i] = 1; } for(i = 0;i \u0026lt; n;i++) if(!mark[i]) c[k++] = c[i]; n = k; } //`圆的面积交去掉内含的圆` void init_add(){ int i,j,k; bool mark[maxn] = {0}; for(i = 0;i \u0026lt; n;i++){ for(j = 0;j \u0026lt; n;j++) if(i != j \u0026amp;\u0026amp; !mark[j]){ if( (c[i]==c[j])||inner(c[j],c[i]) )break; } if(j \u0026lt; n)mark[i] = 1; } for(i = 0;i \u0026lt; n;i++) if(!mark[i]) c[k++] = c[i]; n = k; } //`半径为r的圆，弧度为th对应的弓形的面积` double areaarc(double th,double r){ return 0.5*r*r*(th-sin(th)); } //`测试SPOJVCIRCLES SPOJCIRUT` //`SPOJVCIRCLES求n个圆并的面积，需要加上init\\_or()去掉重复圆（否则WA）` //`SPOJCIRUT 是求被覆盖k次的面积，不能加init\\_or()` //`对于求覆盖多少次面积的问题，不能解决相同圆，而且不能init\\_or()` //`求多圆面积并，需要init\\_or,其中一个目的就是去掉相同圆` void getarea(){ memset(ans,0,sizeof(ans)); vector\u0026lt;pair\u0026lt;double,int\u0026gt; \u0026gt;v; for(int i = 0;i \u0026lt; n;i++){ v.clear(); v.push_back(make_pair(-pi,1)); v.push_back(make_pair(pi,-1)); for(int j = 0;j \u0026lt; n;j++) if(i != j){ Point q = (c[j].p - c[i].p); double ab = q.len(),ac = c[i].r, bc = c[j].r; if(sgn(ab+ac-bc)\u0026lt;=0){ v.push_back(make_pair(-pi,1)); v.push_back(make_pair(pi,-1)); continue; } if(sgn(ab+bc-ac)\u0026lt;=0)continue; if(sgn(ab-ac-bc)\u0026gt;0)continue; double th = atan2(q.y,q.x), fai = acos((ac*ac+ab*ab-bc*bc)/(2.0*ac*ab)); double a0 = th-fai; if(sgn(a0+pi)\u0026lt;0)a0+=2*pi; double a1 = th+fai; if(sgn(a1-pi)\u0026gt;0)a1-=2*pi; if(sgn(a0-a1)\u0026gt;0){ v.push_back(make_pair(a0,1)); v.push_back(make_pair(pi,-1)); v.push_back(make_pair(-pi,1)); v.push_back(make_pair(a1,-1)); } else{ v.push_back(make_pair(a0,1)); v.push_back(make_pair(a1,-1)); } } sort(v.begin(),v.end()); int cur = 0; for(int j = 0;j \u0026lt; v.size();j++){ if(cur \u0026amp;\u0026amp; sgn(v[j].first-pre[cur])){ ans[cur] += areaarc(v[j].first-pre[cur],c[i].r); ans[cur] += 0.5*(Point(c[i].p.x+c[i].r*cos(pre[cur]),c[i].p.y+c[i].r*sin(pre[cur]))^Point(c[i].p.x+c[i].r*cos(v[j].first),c[i].p.y+c[i].r*sin(v[j].first))); } cur += v[j].second; pre[cur] = v[j].first; } } for(int i = 1;i \u0026lt; n;i++) ans[i] -= ans[i+1]; } };   以下记录一些用法：\n用法 int main() { // 求凸包 int n; cin \u0026gt;\u0026gt; n; poly2.input(n); // 先 input 到其他的 polygon 里面去 poly2.getconvex(poly); printf(\u0026quot;%.15lf\\n\u0026quot;, poly.getarea()); }   注意事项\n如果题目中给的点都是整数，要将板子中的 Point 的 double 改成 ll，以避免精度问题！\n ","date":"2022-09-19T10:26:35-05:00","permalink":"https://tom0727.github.io/post/072-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E9%80%9A%E7%94%A8%E6%A8%A1%E7%89%88/","tags":["",""],"title":"[置顶]竞赛注意事项/通用模版"},{"categories":[""],"contents":"介绍 线性筛不仅能用 $O(n)$ 求出每一个数是否为质数，它还能求出每一个数的因数数量，因数和，甚至更加general的除数函数，莫比乌斯函数等等。\n总结来说，线性筛可以在 $O(n)$ 中求出一些积性函数的值。\n原理 线性筛之所以是 $O(n)$，是因为对于每一个数 $x$，我们只考虑它 最小 的那个质因数。\n在当前使用 $i$ 来筛的时候，如果 i % primes[j] == 0，说明 $i$ 中包含了 primes[j]，那么再往后的话筛掉 cur = i * primes[j+1] 时用到的最小质因数就是 primes[j] 了，所以可以直接break。\nbool isPrime[M+5]; int small[M+5]; vector\u0026lt;int\u0026gt; primes; void preprocess() { // 线性筛 memset(isPrime, 1, sizeof(isPrime)); small[1] = 1; for (int i = 2; i \u0026lt;= M; i++) { if (isPrime[i]) primes.push_back(i), small[i] = i; for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = i * primes[j]; isPrime[cur] = 0; small[cur] = primes[j]; // 最小的质因子 if (i % primes[j] == 0) break; } } }  那么观察上述过程，其实我们发现了：\n 当 i % primes[j] == 0 时，说明 cur = i * primes[j] 里面至少有 $2$ 个 $p_j$（后文中 $p_j$ 代指 primes[j]），并且 cur 与 i 的最小质因子均为 $p_j$。 当 i % primes[j] != 0 时，说明 cur = i * primes[j] 里面只有 $1$ 个 $p_j$。  这个重要性质在后面我们求欧拉函数，因数个数时都有重大用处。\n• 简单证明一下第一条中的 cur 与 $i$ 的最小质因子均为 $p_j$：首先 cur 肯定满足，因为线性筛的本质就是只用最小质因子筛掉一个数。对于 $i$ 来说，$i = \\frac{cur}{p_j}$，说明 $i$ 只是比 cur 少了一个 $p_j$ 而已，所以 $i$ 的最小质因子也是 $p_j$。\n应用 欧拉函数 欧拉函数的两个性质：\n 积性函数：$\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ 质因数：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  运用上面的性质就可以用线性筛了。\n代码 const int M = 1e7; int phi[M+5]; bool isPrime[M+5]; vector\u0026lt;int\u0026gt; primes; void euler_function() { phi[1] = 1; memset(isPrime, 1, sizeof(isPrime)); for (int i = 2; i \u0026lt;= M; i++) { if (isPrime[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = i * primes[j]; isPrime[cur] = 0; if (i % primes[j] == 0) { phi[cur] = phi[i] * primes[j]; break; } else { phi[cur] = phi[i] * phi[primes[j]]; } } } }   因数个数 用 $d_i$ 表示 $i$ 的因数个数（有多少个数整除它），用 cnt[i] 表示 $i$ 的最小质因数个数。\n$d_i$ 是积性函数，所以可以用线性筛。\n注意到因为 $n=\\prod\\limits_{i=1}^m p_i^{c_i}$，则\n$$d_n = \\prod\\limits_{i=1}^m (c_i+1) = (1+c_1)(1+c_2)\u0026hellip;(1+c_m)$$\n所以需要统计 cnt[i] 表示 $i$ 的最小质因数个数。\n代码 const int M = 1e7; int d[M+5], cnt[M+5]; // d[i]: i 的因数数量，cnt[i]: i 的最小质因数次数 bool isPrime[M+5]; vector\u0026lt;int\u0026gt; primes; void divisor_count() { cnt[1] = d[1] = 1; memset(isPrime, 1, sizeof(isPrime)); for (int i = 2; i \u0026lt;= M; i++) { if (isPrime[i]) { cnt[i] = 1; d[i] = 2; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = i * primes[j]; isPrime[cur] = 0; if (i % primes[j] == 0) { cnt[cur] = cnt[i] + 1; d[cur] = d[i] / (cnt[i] + 1) * (cnt[i] + 2); // 已经有的质因数，所以把原来的次数+1除掉，再乘上次数+2 break; } else { cnt[cur] = 1; d[cur] = d[i] * 2; // 出现了一个新的质因数，出现次数为 1，所以直接 *2 } } } }   因数和 对于一个数 $n$ 的因数和，我们将它质因数分解后有 $n=\\prod\\limits_{i=1}^m p_i^{c_i}$，则\n$$sum_n = \\prod\\limits_{i=1}^m (\\sum\\limits_{j=1}^{c_i} p_j) = (1+p_1+p_1^2+\u0026hellip;+p_1^{c_1})(1+p_2+p_2^2+\u0026hellip;+p_2^{c_2})\u0026hellip;(1+p^m+p_m^2+\u0026hellip;+p_m^{c_m})$$\n所以与因数个数不同的地方在于，我们需要处理 small_sum[i] 代表：\n若 $i$ 的最小质因数为 $p$，出现次数为 $c$，那么\n$$smallsum[i] = p^0 + p^1 + \u0026hellip; + p^c$$\n代码 const int M = 1e7; ll sum[M+5], small_sum[M+5]; // sum[i]: i 的因数和 // small_sum[i]: i 的最小质因数为 p，出现次数为 c，那么 small_sum[i] = p^0 + p^1 + ... + p^c bool isPrime[M+5]; vector\u0026lt;int\u0026gt; primes; void divisor_sum() { sum[1] = small_sum[1] = 1; memset(isPrime, 1, sizeof(isPrime)); for (int i = 2; i \u0026lt;= M; i++) { if (isPrime[i]) { small_sum[i] = i + 1; sum[i] = i + 1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = i * primes[j]; isPrime[cur] = 0; if (i % primes[j] == 0) { sum[cur] = sum[i] / small_sum[i]; small_sum[cur] = small_sum[i] * primes[j] + 1; sum[cur] *= small_sum[cur]; break; } else { small_sum[cur] = primes[j] + 1; sum[cur] = sum[i] * small_sum[cur]; } } } }   ","date":"2023-06-04T18:25:03-05:00","permalink":"https://tom0727.github.io/post/112-%E7%BA%BF%E6%80%A7%E7%AD%9B/","tags":["",""],"title":"线性筛"},{"categories":["解题报告"],"contents":"A. Fair Bandwidth Sharing 题意\n给定 $n$ 个区间 $[l_i, r_i]$，并且给定 $n$ 个权值 $d_i$，和一个常数 $t$。\n定义 $y_i = t \\frac{d_i}{\\sum\\limits_{j=1}^n d_j}$。\n求一组 $x_i$，使得满足以下所有条件：\n $\\forall i \\in [1,n], x_i \\in [a_i, b_i]$。 $\\sum\\limits_{i=1}^n x_i = t$。 $\\sum\\limits_{i=1}^n \\frac{(x_i-y_i)^2}{y_i}$ 最小。  其中，$n \\leq 10^5, t \\in [1,10^6], 0 \\leq l_i \\leq r_i \\leq 10^6, r_i \u0026gt; 0, d_i \\in [1,10^6]$。\n 题解 假设对于所有的 $i$，$d_i=1$，那么我们可以二分一个值 $z$，然后对于 $z$ 穿过的区间，就让 $x_i$ 取那个值，剩下的没有穿过的就让 $x_i$ 取边界，然后判断这个 $z$ 的值导致的 $\\sum x_i$ 是 $\u0026gt;t$ 还是 $\u0026lt;t$。\n现在考虑 $d_i$ 不一定为 $1$ 的情况。首先我们处理一下使得 $\\sum d_i = 1$。\n那么对于式子 $\\frac{(x_i-y_i)^2}{y_i}$ 中的变量 $x_i$ 求导可以得到 $\\frac{2}{t}(\\frac{x_i}{d_i} - t)$。由于 $t$ 是常数我们可以忽略不计。注意到这个导数是随着 $x_i$ 增大而增大的，而如果多个 $x_i$ 的导数相同，那么它们应该是根据 $d_i$ 的值等比例的。\n于是衍生出了基于上述方法的新方法：\n同样二分 $z$，但是 $x_i = z * d_i$，边界的话仍然取边界值，然后判断 $\\sum x_i$ 是 $\u0026gt;t$ 还是 $\u0026lt;t$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; int n; long double t; int l[maxn], r[maxn]; double d[maxn], x[maxn]; // 取 bool check(long double z) { long double res = 0.0; for (int i = 1; i \u0026lt;= n; i++) { x[i] = z * d[i]; x[i] = max(x[i], (double)l[i]); x[i] = min(x[i], (double)r[i]); res += x[i]; } return res \u0026gt;= t; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t; long double sumd = 0.0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i] \u0026gt;\u0026gt; r[i] \u0026gt;\u0026gt; d[i], sumd += d[i]; for (int i = 1; i \u0026lt;= n; i++) d[i] /= sumd; long double low = 0.0, high = 1e12; int T = 100; while (high - low \u0026gt; 1e-6 \u0026amp;\u0026amp; T--) { long double mid = (low + high) * 0.5; if (check(mid)) { high = mid; } else low = mid; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   F. Factor-Free Tree 题意\n给定一个长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$。\n是否存在一个二叉树，使得这个二叉树的 in-order 遍历的sequence等于这个数组，且保证对于每一个节点 $i$，它与它所有的祖先节点都互质。\n样例如上图。\n如果有，输出方案。\n其中，$n \\leq 10^6, a_i \\in [1, 10^7]$。\n 题解 很明显递归解决。对于 solve(l, r) 来说，确定一个根节点以后，保证这个根节点 $i \\in [l,r]$ 并且 $i$ 与所有的 $[l,r]$ 内的数都互质即可。\n但可能有很多这样的可行根节点。\n一个重要猜想：随便选一个满足条件的根节点即可。\n证明：假设我们找出了所有可行的根节点，那一个最佳方案是将这些根节点都split掉。这和我们按照顺序来split其实并无区别。所以随便选一个可行根节点即可。\n那么只要知道，给定一个index的范围 $[L,R]$，从里面随便找出一个和其他都互质的数字即可。\n这个好办，每个数字质因数分解一下，然后对于每一个质因数找到它们所在的位置，这样可以处理出两个数组 nxt[i] 表示 $a_i$ 右侧距离它最近的 $j$ 使得 $a_j$ 与 $a_i$ 不互质。同理可以得到 pre[i] 就是左侧最近的。\n然后只要满足 nxt[i] \u0026gt; R \u0026amp;\u0026amp; pre[i] \u0026lt; L 即可。\n 最后一个问题：复杂度是多少？\n对于一个长度为 $n$ 的区间，我们最多需要 $O(n)$ 的时间找到这样的根 $i$，而最坏情况下可能会 split 成 $1, n-1$ 两个大小，所以看起来 $T(n) = T(1) + T(n-1) + O(n) = O(n^2)$？\n一个很重要的优化：\n 我们在找这样的根 $i$ 时，不要从 $L$ 遍历到 $R$，而是从两边开始遍历，也就是 $L,R,L+1,R-1,L+2,R-2\u0026hellip;$。\n 这样复杂度来到 $O(n\\log n)$。\n为什么呢？\n因为这样可以最快的找到满足条件的根 $i$。假设 $\\min(i-L+1, R-i+1) = k$，也就是根距离两个端点的最近距离，那么有\n$$T(n) = T(k) + T(n-k-1) + 2k$$\n那么最坏情况下是 $k=\\frac{n}{2}$，也就是\n$$T(n) = 2T(\\frac{n}{2}) + n = O(n\\log n)$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+55; const int maxm = 1e7+5; int n, a[maxn]; bool isPrime[maxm]; int small[maxm]; vector\u0026lt;int\u0026gt; primes; void preprocess() { // 线性筛优化 memset(isPrime, 1, sizeof(isPrime)); small[1] = 1; for (int i = 2; i \u0026lt;= maxm-5; i++) { if (isPrime[i]) primes.push_back(i), small[i] = i; for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= maxm-5; j++) { int cur = i * primes[j]; isPrime[cur] = 0; small[cur] = primes[j]; if (i % primes[j] == 0) break; } } } vector\u0026lt;int\u0026gt; pos[maxm]; int nxt[maxn], pre[maxn]; int par[maxn]; // if ok: return index of root // if not ok: return 0 // if empty: return -1 int solve(int l, int r) { if (l \u0026gt; r) return -1; if (l == r) return l; // l, r, l+1, r-1, l+2, r-2 int i = l, j = r; while (i \u0026lt;= j) { if (pre[i] \u0026lt; l \u0026amp;\u0026amp; nxt[i] \u0026gt; r) { int lres = solve(l, i-1), rres = solve(i+1, r); if (lres == 0 || rres == 0) return 0; if (lres \u0026gt; 0) par[lres] = i; if (rres \u0026gt; 0) par[rres] = i; return i; } swap(i, j); if (pre[i] \u0026lt; l \u0026amp;\u0026amp; nxt[i] \u0026gt; r) { int lres = solve(l, i-1), rres = solve(i+1, r); if (lres == 0 || rres == 0) return 0; if (lres \u0026gt; 0) par[lres] = i; if (rres \u0026gt; 0) par[rres] = i; return i; } swap(i, j); i++, j--; } return 0; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; preprocess(); fill(nxt, nxt+maxn, n+1); fill(pre, pre+maxn, 0); for (int i = 1; i \u0026lt;= n; i++) { int x = a[i]; while (x \u0026gt; 1) { int sp = small[x]; while (x % sp == 0) x /= sp; pos[sp].push_back(i); } } for (int sp = 2; sp \u0026lt;= maxm-5; sp++) { for (int i = 0; i \u0026lt; pos[sp].size(); i++) { int curp = pos[sp][i]; if (i \u0026gt; 0) { pre[curp] = max(pre[curp], pos[sp][i-1]); } if (i \u0026lt; pos[sp].size() - 1) { nxt[curp] = min(nxt[curp], pos[sp][i+1]); } } } if (!solve(1, n)) { cout \u0026lt;\u0026lt; \u0026quot;impossible\\n\u0026quot;; } else { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; par[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2023-05-27T17:07:31-04:00","permalink":"https://tom0727.github.io/post/111-nac2023-day2/","tags":["",""],"title":"NAC2023 Training Camp Day2"},{"categories":[""],"contents":"构造题的应用 在 $n$ 较小时，确定一个随机数的seed mt19937 rng(SOME_SEED);，如果在本地成功跑出来结果，就直接把这个seed交上去，这样就可以deterministic保证答案是对的。\ncolor coding 一个很有趣的概念，意思是对于一个很难解决的问题，可以考虑先将问题中的一些变量染色，对于不同颜色分别解决。或者是染色后，根据某些与颜色有关的性质进行操作。\n例题见例2和例3。\n破坏input的性质 如果input是一些较小的正整数，并且它们之间可能有一定规律，将input map到一个较大的范围可以破坏掉input的一些限制。从而获得一些有用的特性。\n例题 例1 CF364D. Ghd 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$，定义其ghd为：\n最大的一个数 $g$，使得 $a_i$ 中有至少一半的数 divisible by $g$。\n求一个数组的 ghd。\n其中，$n \\leq 10^6, a_i \\in [1,10^{12}]$。\n 题解 好题。考虑随机化：\n显然，我们随机选一个 $a_i$，并且求出它的所有因数，那么有 50% 的概率使得ghd在 $a_i$ 的因数中。\n但众所周知一个数的因数数量是 $O(n^{\\frac{1}{3}})$ 级别的（证明见这里），$a_i \\leq 10^{12}$，很明显这有点太大了。\n我们需要快速解决以下问题：\n 给定一个数 $x$，求 $x$ 的每一个因数能够被多少个 $a_i$ 整除。\n 有一个 $O(d^2)$ 的基于 dp 的方法（$d$ 是 $x$ 的因数数量）。\n先将 $x$ 的所有因数求出来，然后sort一下，我们维护一个 cnt[] 数组，其中 cnt[i] 代表 $x$ 的第 $i$ 个因数能够被多少个 $a_i$ 整除。\n然后将 $x$ 与每一个 $a_i$ 取 gcd，得到 $g_i$，那么 $g_i$ 就是满足 既是 $x$ 的因数，又是 $a_i$ 的因数 的最大因数。\n那么我们先找到 $g_i$ 对应 $x$ 的第几个因数，先让对应的 cnt[j]++。\n然后从小到大 dp，对于小的因数，如果某个更大的因数能够整除它，那么就将大的 cnt 加到小的上去。\n这样 cnt[] 有了就可以更新答案了。\n这样随机个10次左右即可（我代码中随机3秒停止）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } ll ans = 0; int n; ll a[maxn]; vector\u0026lt;ll\u0026gt; factorize(ll x) { vector\u0026lt;ll\u0026gt; vec; for (int i = 1; i \u0026lt;= sqrt(x); i++) { if (x % i == 0) { vec.push_back(i); if (x / i != i) vec.push_back(x/i); } } sort(vec.begin(), vec.end()); return vec; } void solve() { ll x = a[randint(1,n)]; vector\u0026lt;ll\u0026gt; fac = factorize(x); vector\u0026lt;int\u0026gt; cnt(fac.size(), 0); for (int i = 1; i \u0026lt;= n; i++) { ll g = gcd(x, a[i]); int p = lower_bound(fac.begin(), fac.end(), g) - fac.begin(); cnt[p]++; } // 从小到大 dp for (int i = 0; i \u0026lt; cnt.size(); i++) { for (int j = i+1; j \u0026lt; cnt.size(); j++) { if (fac[j] % fac[i] == 0) cnt[i] += cnt[j]; } } for (int i = cnt.size()-1; i \u0026gt;= 0; i--) { if (cnt[i] * 2 \u0026gt;= n) { ans = max(ans, fac[i]); return; } } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; while ((double)clock() / CLOCKS_PER_SEC \u0026lt;= 3) { solve(); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 Vacuum Tubes 题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$ 和两个正整数 $L_1, L_2$。\n从中选出四个数，$a_i, a_j, a_l, a_k$ 使得：\n $a_i+a_j \\leq L_1$ $a_l+a_k \\leq L_2$ $i,j,l,k$ 互不相同  并且求出 $a_i+ a_j+ a_l+ a_k$ 可能的最大值，如果无解输出 $-1$。\n其中，$n \\leq 2000, a_i, L_1,L_2 \\in [1,10000]$。\n 题解 显然 $a_i,a_j$ 和 $a_l,a_k$ 是两个独立的问题。\n对于其中一个问题，显然可以用二分来做。但现在有两个问题。\n所以不妨将原数组随机分成两等份，然后分别对两份数组进行操作。\n假设最优答案为 $a_i',a_j',a_l',a_k'$，那么 $a_i', a_j'$ 在第一份数组，且 $a_l',a_k'$ 在第二份的数组的概率为 $\\frac{1}{8}$。\n重复很多次即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; const int maxm = 4e4+55; int l1, l2, n, a[maxn]; int solve(int l, int r, int L) { sort(a+l, a+r+1); int res = -1; for (int i = l; i \u0026lt;= r; i++) { int p = upper_bound(a+l, a+r+1, L - a[i]) - a; p = max(p, l); p = min(p, i-1); while (p-1 \u0026gt;= l \u0026amp;\u0026amp; a[p] + a[i] \u0026gt; L) p--; if (p \u0026lt; i \u0026amp;\u0026amp; p \u0026gt;= l \u0026amp;\u0026amp; a[i] + a[p] \u0026lt;= L) res = max(res, a[i] + a[p]); } return res; } int main() { cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = 0; while ((double)clock() / CLOCKS_PER_SEC * 1000 \u0026lt;= 2000) { shuffle(a+1, a+n+1, rng); int r1 = solve(1, n/2, l1); int r2 = solve(n/2+1, n, l2); if (r1 \u0026gt; 0 \u0026amp;\u0026amp; r2 \u0026gt; 0) ans = max(ans, r1 + r2); } if (!ans) cout \u0026lt;\u0026lt; \u0026quot;Impossible\\n\u0026quot;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例3 Dragon Ball II 题意\n给定一个 $n$ 个点，$m$ 条边的无向图。边有边权。\n现在有 $k$ 个龙珠，每个龙珠会拥有一个颜色 $d_i$，并且这个龙珠会存在于节点 $c_i$ 中。\n我们从节点 $1$ 出发，经过一个节点时会获得这个节点里的所有龙珠。\n求最短路径的长度，使得我们收集了至少 $7$ 个不同颜色的龙珠。如果无解输出 $-1$。\n其中，$n,k \\leq 1000, m \\leq 10000, w_i \\in [0,10000], c_i, d_i \\in [1,n]$。\n 题解 我们只需要收集 $7$ 个不同的颜色，但原图中的颜色有 $n$ 种，怎么办？\n考虑 color coding 的思想：\n我们不妨假设只有 $7$ 种颜色，然后对于原图中的每一种颜色，将它们随机 map 到七种颜色中的一种，然后就只有 $7$ 种颜色了。\n只有 $7$ 种颜色后，明显可以直接维护大小为 $2^7$ 的mask，然后跑dijkstra。\n 什么情况下答案会出错呢？\n假设答案需要颜色 $d_{i_1}, d_{i_2} \u0026hellip; d_{i_7}$，那么如果有任意两个颜色被map到同一种，就说明答案错误了。\n因此，答案正确的情况有 $A_7^7 = 7!$ 种。\n答案正确的概率为 $\\frac{7!}{7^7} = 0.006$。\n这个题目时限为 $16$ 秒，大概可以跑 $10^9$。这个dijkstra相当于在 $M = 10^4 * 2^7 = 1.28 * 10^6$ 的情况下跑 $O(M\\log M)$（实际上吃不了这么满）。\n实际上大概可以跑 $800-1000$ 次。失败概率约为 $5$ % 左右，运气好还是可以跑过去的。\n• 另外如果我们提升随机颜色的数量，运行次数只会大幅度缩小，而成功概率不会提升很多，所以 $7$ 种颜色就是最好的。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 7; struct Edge { int v, w; }; vector\u0026lt;Edge\u0026gt; adj[maxn]; int n, m, k; vector\u0026lt;int\u0026gt; ball[maxn], cur[maxn]; ll ans = 1e18; ll dis[maxn][(1\u0026lt;\u0026lt;M) + 5]; bool vis[maxn][(1\u0026lt;\u0026lt;M) + 5]; struct Node { int u; ll d; int mask = 0; bool operator\u0026lt;(const Node\u0026amp; other) const { return d \u0026gt; other.d; } }; void solve() { map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= n; i++) { cur[i].clear(); for (int x : ball[i]) { if (!mp.count(x)) { mp[x] = randint(0, M-1); } cur[i].push_back(mp[x]); } } memset(vis, 0, sizeof(vis)); memset(dis, 63, sizeof(dis)); int smask = 0; for (int x : cur[1]) smask |= (1\u0026lt;\u0026lt;x); dis[1][smask] = 0; priority_queue\u0026lt;Node\u0026gt; pq; pq.push({1, 0, smask}); while (pq.size()) { auto [u, d, mask] = pq.top(); pq.pop(); if (vis[u][mask]) continue; vis[u][mask] = 1; for (auto [v, w] : adj[u]) { int nmask = mask; for (int x : cur[v]) { nmask |= (1\u0026lt;\u0026lt;x); } if (dis[v][nmask] \u0026gt; dis[u][mask] + w) { dis[v][nmask] = dis[u][mask] + w; pq.push({v, dis[v][nmask], nmask}); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int mask = (1\u0026lt;\u0026lt;7) - 1; mask \u0026lt; (1\u0026lt;\u0026lt;M); mask++) { if (__builtin_popcount(mask) \u0026gt;= 7) { ans = min(ans, dis[i][mask]); } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({v, w}); adj[v].push_back({u, w}); } for (int i = 1; i \u0026lt;= k; i++) { int c, d; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; ball[c].push_back(d); } while ((double)clock() / CLOCKS_PER_SEC \u0026lt; 14.5) { solve(); } cout \u0026lt;\u0026lt; (ans \u0026gt; 1e16 ? -1 : ans) \u0026lt;\u0026lt; endl; }   例4 Spooky Scary Skeletons 题意\n给定一个长度为 $n$ 的正整数数组 $a_1,a_2,\u0026hellip;,a_n$。\n有 $q$ 个询问，每次询问 $[L,R]$ 之间是否存在恰好一个出现次数为奇数的数字，如果存在，输出它，否则输出 $0$。\n其中，$n \\leq 3 \\times 10^6, q \\leq 10^6, a_i \\in [1,10^5]$。\n 题解 我们知道一个区间 $[L,R]$ 内，如果恰好有一个出现次数为奇数的数字，那么这个区间的XOR和就是这个数字。\n但，有一些例外，比如有多个出现次数为奇数的数字时，XOR和不能说明任何问题。\n例如对于 $[1,2,3]$，有 1 ^ 2 ^ 3 = 0，更关键的是 $0$ 甚至都没出现过。\n所以我们考虑将每个数字随机 map 到一个很大的范围，如 $[1,2^{63}]$。\n这样，询问 $[L,R]$ 时，我们计算这个 XOR 和，假设为 $x$。那么 $x$ 就很有可能是我们的答案。\n当然，也有可能 $x$ 压根就没出现在 $[L,R]$ 这个范围内，所以我们预处理一下每一个数出现的位置，然后二分一下验证 $x$ 是否在 $[L,R]$ 范围内即可。\n 什么情况下会失败？\n假设有 $n$ 个出现次数为奇数的数字，而我们得到的XOR和 $x$ 恰好是这 $n$ 个数字中的一个，就会错误的判断 $x$ 为答案。\n不过这样的概率只有 $\\frac{n}{2^{63}} = 3 \\times 10^{-13}$。\n$10^6$ 次询问均正确的概率为 $(1-3 \\times 10^{-13})^{10^6} = 0.999999\u0026hellip;$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e6+55; const int maxm = 1e5+55; int n, k, q; ll a[maxn], sum[maxn]; unordered_map\u0026lt;int, ll\u0026gt; mp; unordered_map\u0026lt;ll, int\u0026gt; rev_mp; vector\u0026lt;int\u0026gt; pos[maxm]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; pos[a[i]].push_back(i); if (!mp.count(a[i])) { ll r = randll(1, (1LL\u0026lt;\u0026lt;63)); mp[a[i]] = r; rev_mp[r] = a[i]; } a[i] = mp[a[i]]; } for (int i = 1; i \u0026lt;= n; i++) sum[i] = sum[i-1] ^ a[i]; while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll x = sum[r] ^ sum[l-1]; if (!x) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else { // 答案很可能是 x，查询 x 是否在 [L,R] 中出现过？ x = rev_mp[x]; // 先 map 回原来的样子 auto itr = lower_bound(pos[x].begin(), pos[x].end(), l); if (itr != pos[x].end() \u0026amp;\u0026amp; *itr \u0026gt;= l \u0026amp;\u0026amp; *itr \u0026lt;= r) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例5 Zero Sum 题意\n给定一个 $n \\times (2k+1)$ 的矩阵。column的编号是从 $-k$ 到 $k$。\n求一串数字 $x_1,x_2,\u0026hellip;,x_n$，其中：\n $x_i \\in [-k, k]$。 $x_1+x_2+\u0026hellip;x_n = 0$。 $a_{1,x_1} + a_{2,x_2} + \u0026hellip; + a_{n,x_n}$ 尽可能小。  其中，$n \\leq 35000, 1 \\leq k \\leq 3$，矩阵元素在 $[-10^9, 10^9]$。\n 题解 注意到 $k$ 很小。\n我们想象一下，答案是一条从第一行从上到下走到最后一行的一条路径。\n这条路径一定是左拐右拐，最后才能保证 $x_1+x_2+\u0026hellip;x_n = 0$。\n那么一个很简单的思路是 dp[i][j] 代表走到第 $i$ 行，当前的 column 的编号和为 $j$ 的最小值。\n但是 $j$ 的绝对值可能会很大，因为这条路径有可能是先拐到最右，再拐回最左。\n于是我们想到利用随机化打乱input。将所有的row随机shuffle以后，答案不大可能出现上述的情况。\n所以我们可以在shuffle之后，认为 dp[i][j] 里的 j 的绝对值不会很大。然后再跑 dp 就可以了。\n• 需要滚动数组否则 MLE。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 35000+5; const int M = 1500; ll a[maxn][9]; ll pre[maxn], dp[maxn]; int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= 2*k+1; j++) cin \u0026gt;\u0026gt; a[i][j]; } vector\u0026lt;int\u0026gt; perm; for (int i = 1; i \u0026lt;= n; i++) perm.push_back(i); shuffle(perm.begin(), perm.end(), rng); for (int j = 1; j \u0026lt;= 2*M+1; j++) dp[j] = pre[j] = 1e18; pre[M+1] = 0; for (int i = 0; i \u0026lt; n; i++) { int p = perm[i]; for (int j = 1; j \u0026lt;= 2*M+1; j++) { for (int d = -k; d \u0026lt;= k; d++) { if (j + d \u0026gt;= 1 \u0026amp;\u0026amp; j + d \u0026lt;= 2*M+1) { dp[j+d] = min(dp[j+d], pre[j] + a[p][d+k+1]); } } } memcpy(pre, dp, sizeof(dp)); for (int j = 1; j \u0026lt;= 2*M+1; j++) dp[j] = 1e18; } cout \u0026lt;\u0026lt; pre[M+1] \u0026lt;\u0026lt; endl; }   例6 KTH Challenge 2014 - Pizza Problems 题意\n我们有一个pizza，上面需要有一些种类的配料。\n有 $n$ 个人，每个人有 $[1,30]$ 个愿望，每个愿望可以是希望某一种配料存在，也可以是希望某一种配料不存在。\n保证一定存在一种pizza使得每个人至少有 $\\frac{2}{3}$ 的愿望被满足，而我们只需要找出一种pizza使得每个人有严格大于 $\\frac{1}{3}$ 的愿望被满足即可。\n其中，$n\\leq 10000$，总配料种类不超过 $250$ 种。\n 题解 我们从没有配料的pizza开始，我们设当前pizza与理想pizza的共同点有 $k$ 个。\n我们每一步随机选择一个尚未被满足的人，随机的满足他的一个愿望。注意由于理想的pizza一定保证 $\\frac{2}{3}$ 的愿望被满足，而这个人尚未被满足说明他被满足的愿望比例 $\u0026lt;\\frac{1}{3}$。这意味着这次修改至少有 $\\frac{1}{2}$ 使得我们离理想的pizza的共同点 +1，有 $\\leq \\frac{1}{2}$ 的概率使得共同点 -1。\n接下来要解决：大概需要随机走多少步才能使得当前pizza与理想pizza的共同点数量达到一个值？（这个值最高为 $250$），我们不关心这个值具体是多少，因为我们只要走到满足题目条件停止即可，而我们知道每走一步，共同点+1的概率都是 $\\geq \\frac{1}{2}$ 的。\n 这是一个随机游走（random walk）问题：\n 从 $x=0$ 出发，每次随机向左/向右走一步，问第一次走到 $x=\\pm n$ 的期望步数？\n 结论：期望步数为 $O(n^2)$，证明见 这个知乎回答。\n• 注意这个题不太一样，不能走到负数位置，而且要走到的是 $x=n$。我们可以理解成可以走到负数，但是走到负数时就进行一次反射，把 $x$ 轴翻了过来，所以本质上还是走到 $x=\\pm n$ 的期望步数，而本题中，期望步数为 $O(250^2)$。\n 最后一些注意点：\n 由于有 $n=10000$ 个人，每个人至多 $30$ 个愿望，而总共 $250$ 种配料，这意味着每一种配料至多与 $10000*30/250 = 1200$ 个人有关，所以每次满足愿望以后不需要修改所有人，只要记录和这个配料有关的人即可。 必须是随机满足愿望，无论这个愿望是希望某个配料存在，或者是不存在。不能将存在/不存在分开随机，否则会陷入死循环。在代码中利用了 void fulfill(int i) { int r = randint(0,1); if (r == 0) { if (!fulfillgood(i)) fulfillbad(i); } else { if (!fulfillbad(i)) fulfillgood(i); } }  来实现。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 15000+5; int n; vector\u0026lt;int\u0026gt; g[maxn], b[maxn]; map\u0026lt;string, int\u0026gt; mp; string revmp[maxn]; int cnt[maxn], all[maxn]; bool cur[maxn]; vector\u0026lt;int\u0026gt; yes[maxn], no[maxn]; void upd(int x, int f) { if (f == 1) { cur[x] = 1; for (int i : yes[x]) cnt[i]++; for (int i : no[x]) cnt[i]--; } else { cur[x] = 0; for (int i : no[x]) cnt[i]++; for (int i : yes[x]) cnt[i]--; } } bool fulfillgood(int i) { shuffle(g[i].begin(), g[i].end(), rng); for (int x : g[i]) { if (!cur[x]) { upd(x, 1); return 1; } } return 0; } bool fulfillbad(int i) { shuffle(b[i].begin(), b[i].end(), rng); for (int x : b[i]) { if (cur[x]) { upd(x, -1); return 1; } } return 0; } void fulfill(int i) { int r = randint(0,1); if (r == 0) { if (!fulfillgood(i)) fulfillbad(i); } else { if (!fulfillbad(i)) fulfillgood(i); } } int main() { fastio; cin \u0026gt;\u0026gt; n; int id = 0; for (int i = 1; i \u0026lt;= n; i++) { int m; cin \u0026gt;\u0026gt; m; while (m--) { string s; cin \u0026gt;\u0026gt; s; int f = ((s[0] == '+') ? 1 : 0); s.erase(s.begin()); int x; if (!mp.count(s)) mp[s] = ++id, revmp[id] = s; x = mp[s]; if (f) g[i].push_back(x), yes[x].push_back(i); else b[i].push_back(x), no[x].push_back(i); } all[i] = g[i].size() + b[i].size(); cnt[i] = b[i].size(); } while (1) { for (int i = 1; i \u0026lt;= n; i++) { if (cnt[i] * 3 \u0026lt;= all[i]) { fulfill(i); goto nxt; } } for (int j = 1; j \u0026lt;= 250; j++) { if (cur[j]) cout \u0026lt;\u0026lt; revmp[j] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } return 0; nxt:; } }   参考PDF NAC2023 - Randomized\n","date":"2023-05-27T09:22:42-04:00","permalink":"https://tom0727.github.io/post/110-%E9%9A%8F%E6%9C%BA%E5%8C%96/","tags":["",""],"title":"随机化"},{"categories":["解题报告"],"contents":"L. Blooper Game 题意\n给定 $n$ 个概率 $S_1, S_2, \u0026hellip;, S_n$，同时给定一个实数 $P \\in (0,1)$。\n现在有 $L$ 次操作机会，每次操作可以选择一个 $S_i$，让 $S_i = (S_i)^P$。\n求操作结束后，所有概率乘起来得到的最大值？\n其中，$n \\leq 10^5, L \\leq 10^9, S_i \\in (0,1]$。\n 题解 很巧妙的思路。\n如果我们一次次分配，显然是用一个 pq 每次优先操作当前最小的那个概率。但 L 太大了怎么办？\n考虑 pigeon-hole principle。无论我们怎么分配这些操作次数，至少有一个 $S_i$ 会被分配到 $\\lceil \\frac{L}{n} \\rceil$ 次。显然，我们仍然选择当前最小的那个概率执行这些操作。\n而我们知道一个概率 $x$ 被操作 $k$ 次，得到的值就是 $x^{P^k}$，这个用快速幂就可以实现。\n取 $L=10^9, n=10^5$ 可以发现，这样我们只会至多操作 $10^6$ 次。\n所以按照这个 pq 思路就行，利用 pigeon-hole principle 大幅度减少了操作次数。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n, L; long double P, S[maxn]; long double pp[31]; // pp[i]: P^(2^i) // 返回 P^k long double qpow(int k) { if (!k) return 1; long double res = 1; for (int j = 30; j \u0026gt;= 0; j--) { if (k \u0026amp; (1\u0026lt;\u0026lt;j)) { res *= pp[j]; } } return res; } // 将一个概率 x, 执行 k 次 pow 操作，返回的值应该是 x ^ (P^k) long double po(long double x, int k) { // long double p = qpow(P, k); long double p = qpow(k); return pow(x, p); } // 返回 x 的执行k次pow操作的值 long double get(long double x, int k) { if (k == 0) return x; return po(x, k); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; P; for (int j = 1; j \u0026lt;= 30; j++) pp[j] = qpow(P, (1\u0026lt;\u0026lt;j)); pp[0] = P; priority_queue\u0026lt;long double, vector\u0026lt;long double\u0026gt;, greater\u0026lt;long double\u0026gt;\u0026gt; pq; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; S[i], S[i] = 1/S[i], pq.push(S[i]); while (L) { int use = (L + n - 1) / n; // ceil(L/n) auto d = pq.top(); pq.pop(); d = get(d, use); pq.push(d); L -= use; } long double res = 1; while (pq.size()) res *= pq.top(), pq.pop(); cout \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   M. Toads 题意\n给定一个 $n$ 个点的图，有 $n$ 条边，每条边有边权 $w_i$。\n现在加上 $L$ 条额外的带权边。\n然后给定 $Q$ 个询问，每次询问 $a,b$ 两个点之间的最短距离。\n其中，$n,Q \\leq 10^5, L \\leq 7, 1 \\leq w_i \\leq 10^9$，无自环，可能有重边，图可能不联通。\n 题解 注意到 $n$ 个点和 $n$ 条边！基环树吗？错误的，这只是个误导。\n又注意到 $L \\leq 7$。\n对于每一个联通分量，我们可以求出一个生成树，然后两个点在生成树上的最短距离很好算。不过任意一个联通分量中，由一个生成树加上至多 $L+1$ 条边组成。\n所以两点 $(u,v)$ 间的最短路如果因为一个额外的边 $(a,b)$ 更优了，那么这个最短路肯定经过了 $(a,b)$ 这条边，也就是经过了 $a$ 这个点。\n那么我们从 $a$ 开始跑一个 dijkstra，然后 $u,v$ 之间的最短路要么是树上的距离，要么是 $d(u,a) + d(v,a)$，取最小值即可。\n 实现的时候有一些需要注意的点：\n 处理重边的时候我们只保留最小的权值即可，一开始先读入所有的边，把所有的边sort一下，再加入图中。 我们不必区分这 $L$ 条新边，把它们全都当成普通边来看即可，用 dfs 树跑一个生成树出来，剩下的非树边就是额外的边。 对于每一个非树边 $(a,b)$，我们只需要从 $a$ 跑 dijkstra 即可，$b$ 不用跑（否则会T）。 注意到每个联通分量都至少有 $1$ 条非树边。总的非树边数量是 $M + L$，$M$ 为联通分量的数量。然而对于 dijkstra 来说我们需要储存 $a$ 到每个点的距离，所以储存 $M+L$ 个 dijkstra 的数组显然会 MLE。所以我们需要根据联通分量，一个个处理（我的方式是离线询问）。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; const int maxm = 4e4+55; struct Edge { int u, v, w; }; int n; vector\u0026lt;Edge\u0026gt; adj[maxn]; vector\u0026lt;Edge\u0026gt; edges; bool vis[maxn]; int par[maxn][18], de[maxn], from[maxn]; ll dep[maxn]; vector\u0026lt;Edge\u0026gt; nontree; int jump(int x, int d) { for (int j = 17; j \u0026gt;= 0; j--) { if (d\u0026amp;(1\u0026lt;\u0026lt;j)) x = par[x][j]; } return x; } int LCA(int u, int v) { if (from[u] != from[v]) return -1; if (de[u] \u0026lt; de[v]) swap(u, v); int d = de[u] - de[v]; u = jump(u, d); if (u == v) return u; for (int j = 17; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } int cid = 0; ll treedis(int u, int v) { int x = LCA(u,v); if (x == -1) return -1; return dep[u] + dep[v] - 2 * dep[x]; } void dfs(int u, int p) { from[u] = cid; vis[u] = 1; de[u] = de[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt; 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (auto\u0026amp; [_, v, w] : adj[u]) { if (v == p) continue; if (vis[v]) { if (de[u] \u0026lt; de[v]) nontree.push_back({u,v,w}); } else { dep[v] = dep[u] + w; dfs(v, u); } } } struct Node { int v; ll d; bool operator\u0026lt;(const Node\u0026amp; other) const { return d \u0026gt; other.d; } }; struct Dijkstra { int x; ll dis[maxn]; priority_queue\u0026lt;Node\u0026gt; pq; void run() { memset(dis, -1, sizeof(dis)); memset(vis, 0, sizeof(vis)); pq.push({x, 0}); dis[x] = 0; while (pq.size()) { auto [u, d] = pq.top(); pq.pop(); if (vis[u]) continue; vis[u] = 1; for (auto [_, v, w] : adj[u]) { if (dis[v] == -1 || dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; pq.push({v, dis[v]}); } } } } }; vector\u0026lt;Dijkstra\u0026gt; vec; struct Query { int u, v, cid, id; }; ll ans[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u = i, v, w; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u \u0026gt; v) swap(u, v); edges.push_back({u,v,w}); } int L; cin \u0026gt;\u0026gt; L; for (int _ = 0; _ \u0026lt; L; _++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u \u0026gt; v) swap(u, v); edges.push_back({u,v,w}); } sort(edges.begin(), edges.end(), [](auto a, auto b) { if (a.u == b.u) { if (a.v == b.v) return a.w \u0026lt; b.w; return a.v \u0026lt; b.v; } return a.u \u0026lt; b.u; }); for (int i = 0; i \u0026lt; edges.size(); i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; edges[i].u == edges[i-1].u \u0026amp;\u0026amp; edges[i].v == edges[i-1].v) continue; auto [u, v, w] = edges[i]; adj[u].push_back({u,v,w}); adj[v].push_back({v,u,w}); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) cid++, dfs(i, 0); } // nontree 里面已经按照 cid 排好了 int Q; cin \u0026gt;\u0026gt; Q; vector\u0026lt;Query\u0026gt; que; for (int i = 1; i \u0026lt;= Q; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int cid = -1; if (from[u] == from[v]) cid = from[u]; que.push_back({u, v, cid, i}); } sort(que.begin(), que.end(), [](auto a, auto b) { return a.cid \u0026lt; b.cid; }); int idx = -1; for (auto [u, v, curid, id] : que) { if (curid == -1) ans[id] = -1; else { // 判断一下这个 cid 的dijkstra是否都被处理完了 if (vec.size() \u0026amp;\u0026amp; from[vec[0].x] == curid) { // 处理完了，无需处理 } else { vec.clear(); while (idx + 1 \u0026lt; nontree.size() \u0026amp;\u0026amp; from[nontree[idx+1].u] \u0026lt; curid) idx++; while (idx + 1 \u0026lt; nontree.size() \u0026amp;\u0026amp; from[nontree[idx+1].u] == curid) { Dijkstra di; di.x = nontree[idx+1].u; di.run(); vec.push_back(di); idx++; } } ans[id] = treedis(u, v); assert(vec.size() \u0026lt;= L+1); for (auto\u0026amp; di : vec) { assert(from[u] == from[di.x]); ans[id] = min(ans[id], di.dis[u] + di.dis[v]); } } } for (int i = 1; i \u0026lt;= Q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2023-05-22T10:56:21-05:00","permalink":"https://tom0727.github.io/post/109-codesprintla2023/","tags":["",""],"title":"CodeSprint UCLA 2023"},{"categories":["解题报告"],"contents":"L. Barkley 题意\n给定长度为 $n$ 的数组 $a_i$，有 $q$ 个询问，每次询问为 $l~r~k$\n回答在 $[l,r]$ 这个区间内，可以去掉至多 $k$ 个数后，得到的最大 gcd 是多少？\n其中，$n \\leq 10^5, q \\leq 66666, k \\in [1,3], a_i \\in [1,10^{18}]$，并且保证 $k = 2$ 的询问不超过 $600$ 个，$k=3$ 的询问不超过 $6$ 个。保证每次询问的区间长度 $\u0026gt; k$。\n 题解 设 $g(l,r) = \\gcd([a_l, \u0026hellip;, a_{r}])$\n注意到，如果 $k=1$，那么问题变成了求\n$$\\max\\limits_{x \\in [l,r]} \\gcd(g(l,x-1), g(x+1,r))$$\n那么注意到，固定一个 $l$，那么 $g(l,r)$ 的取值最多只有 $\\log(10^{18})$ 种，因为 $r$ 增大时 gcd 随之减小，而每次至少 / 2。\n并且注意到，如果希望答案最佳，那么如果 $g(l,r_1) = g(l,r_2)$ 且 $r_1\u0026lt;r_2$，那么肯定选择 $r_2$。\n所以可以二分，预处理出来每一个 $l$，对应的不同的 gcd 的最大右端点 $j$。对于一个 $l$，这样的 $j$ 只有 $\\log(10^{18})$ 种。\n对于 $k=1$ 就可以暴力枚举了。\n对于 $k=2,3$ 的情况可以递归解决。\n• 对于 $k=2,3$ 的情况，注意递归时，并不是让 $k-1$ 的情况得到的 gcd 值最大，而是应该将 $g(l,x-1)$ 的值也传进去，让 $k-1$ 对应的值与 $g(l,x-1)$ 的gcd最大。\n在代码实现里，用参数 $g$ 来表示。\nll solve(int l, int r, int k, ll g) { if (r-l+1 \u0026lt;= k || l \u0026gt; r) return g; if (k == 0) return gcd(g, st.ask_st(l,r)); ll ans = 0; for (int j : nxt[l]) { ll G = gcd(g, st.ask_st(l, j)); ans = max(ans, solve(j+2, r, k-1, G)); } ans = max({ans, solve(l, r-1, k-1, g), solve(l+1, r, k-1, g)}); return gcd(g,ans); }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,q; ll gcd(ll a, ll b) { if (a \u0026lt; b) swap(a, b); if (!b) return a; return gcd(b, a%b); } ll a[maxn]; struct SparseTable { ll st[maxn][18], bin[maxn]; ll ask_st(int l, int r) { int len = r-l+1; int k = bin[len]; return gcd(st[l][k], st[r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) st[i][0] = a[i]; for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) st[i][k] = gcd(st[i][k-1], st[i+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } } st; vector\u0026lt;int\u0026gt; nxt[maxn]; // nxt[i]: 储存了从 i 开始，所有不同的 gcd 的右端点j的最大值 ll solve(int l, int r, int k, ll g) { if (r-l+1 \u0026lt;= k || l \u0026gt; r) return g; if (k == 0) return gcd(g, st.ask_st(l,r)); ll ans = 0; for (int j : nxt[l]) { ll G = gcd(g, st.ask_st(l, j)); ans = max(ans, solve(j+2, r, k-1, G)); } ans = max({ans, solve(l, r-1, k-1, g), solve(l+1, r, k-1, g)}); return gcd(g,ans); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; st.build_st(); for (int i = 1; i \u0026lt;= n; i++) { int j = i; while (j \u0026lt;= n) { int low = j, high = n, res = j; ll g = st.ask_st(i, j); while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; if (st.ask_st(i, mid) == g) res = mid, low = mid+1; else high = mid-1; } nxt[i].push_back(res); j = res + 1; } } while (q--) { int l,r,k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; solve(l,r,k,0) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2023-05-18T23:54:00-05:00","permalink":"https://tom0727.github.io/post/108-universal15/","tags":["",""],"title":"Universal Cup 15 (Hangzhou)"},{"categories":["算法"],"contents":"介绍 线段树分治一般用于处理一些 “只存在/不存在 权值为 $w$“，或者 ”某个特定时间点” 对应状态的问题。\n原理是在线段树上进行 DFS，进入 DFS 时加入节点上的所有信息，回溯时则删除这些信息，当达到了叶子节点时就可以得到对应答案。\n• 由于有撤销操作，所以题目一般得是支持撤销的才行。\n经典例题 题意\n有一个 $n$ 个节点的无向图，现在给定一个时间轴 $1\u0026hellip;k$，有 $m$ 条边，每条边 $(u,v)$ 将会在时间段 $[l,r]$ 出现，其他时间消失。\n现在对于每一个时间点，都回答：在这个时间点时，图是否为二分图。\n其中，$n,k \\leq 10^5, m \\leq 2 \\times 10^5, [l,r] \\in [1,k]$。\n 首先注意到，可以利用权值并查集来动态维护是否为二分图。\n然后我们构造一个线段树，当我们有一条在 $[l,r]$ 时间段的边 $(u,v)$ 时，就将这条边塞到 线段树的 $[l,r]$ 区间里，这样每个线段树节点维护一个 vector\u0026lt;Edge\u0026gt; 来保存这个时间段，存在哪些边。\n然后对线段树进行 DFS，进入一个节点时就将它上面的所有边加入并查集，回溯时就将这些边从并查集删除（所以需要可撤销并查集）。\n• 线段树其实就是一个容器，用来储存 Edge 的，本质上并没有维护 “区间信息”（有点类似 这道题 中线段树的作用），所以也没有 push_up, push_down。\n• 当我们检测到已经不是二分图的时候就可以停止继续往里面 DFS，直接回溯即可，这样也避免了一些复杂的问题，比如非二分图撤销边以后如何判断是不是二分图。\n复杂度：每条边对应的时间段 $[l,r]$ 至多会被拆成 $O(\\log k)$ 个线段树区间，而每条边都只会被加入和删除一次。而可撤销并查集的复杂度是 $O(\\log n)$ 的，所以总复杂度为 $O(n \\log n \\log k)$。\n例1 洛谷P5787 二分图 /【模板】线段树分治 题意\n如上。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 6e5+55; struct State { int u, v, szu, szv; } st[maxm]; // 注意这里是 maxm，应该是边的数量 bool ok = 1; int n, m, k; struct DSU { int par[maxn], sz[maxn], tail = 0; inline void init() { for (int i = 1; i \u0026lt;= n*2; i++) par[i] = i, sz[i] = 1; tail = 0; } int finds(int u) { if (par[u] == u) return u; return finds(par[u]); // 无路径压缩 } void unions(int u, int v) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); // sz[u] \u0026gt;= sz[v] st[++tail] = {u, v, sz[u], sz[v]}; // 无论是否 union 成功都要push到 stack 里 if (u == v) return; par[v] = u; sz[u] += sz[v]; } void cancel() { if (tail \u0026gt; 0) { int u = st[tail].u, v = st[tail].v; par[v] = v; sz[u] = st[tail].szu; sz[v] = st[tail].szv; tail--; } } } dsu; struct Edge { int u, v, l, r; }; struct TreeNode { vector\u0026lt;Edge\u0026gt; vec; }; bool ans[maxn]; int bad = 0; struct SegmentTree { TreeNode tr[maxn\u0026lt;\u0026lt;2]; void insert(int cur, int l, int r, int L, int R, Edge e) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].vec.push_back(e); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) insert(cur\u0026lt;\u0026lt;1, l, mid, L, R, e); if (R \u0026gt; mid) insert(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, e); } void dfs(int cur, int l, int r) { for (Edge\u0026amp; e : tr[cur].vec) { if (dsu.finds(e.u) == dsu.finds(e.v)) bad++; dsu.unions(e.u, e.v + n); dsu.unions(e.u + n, e.v); } if (bad) { for (int i = l; i \u0026lt;= r; i++) ans[l] = 0; bad = 0; } else { if (l == r) { ans[l] = 1; } else { int mid = (l+r) \u0026gt;\u0026gt; 1; dfs(cur\u0026lt;\u0026lt;1, l, mid); dfs(cur\u0026lt;\u0026lt;1|1, mid+1, r); } } for (Edge\u0026amp; e : tr[cur].vec) { dsu.cancel(); dsu.cancel(); } } } tr; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; dsu.init(); for (int i = 1; i \u0026lt;= m; i++) { int u, v, l, r; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l++; if (l \u0026lt;= r) { tr.insert(1, 1, k, l, r, {u,v,l,r}); } } tr.dfs(1, 1, k); for (int i = 1; i \u0026lt;= k; i++) cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 洛谷P5631 最小mex生成树 题意\n给定一个带权的无向联通图。\n求这个图的生成树，使得边权集合的 mex 最小，输出最小mex即可。\n其中，$n \\leq 10^6, m \\leq 2 \\times 10^6, w \\in [0,10^5]$。\n 题解 求出最小 mex 只需要对于每一个 $w$，将权值等于 $w$ 的边全部去掉，剩下的都加上，看是否能形成生成树即可。\n上一个例题中，线段树分治用于解决 “只包含权值为 $w$ 的边”，这个题我们可以反过来。例如有一条权值为 $3$ 的边，那么我们将它加入 $[0,2] \\cup [4,10^5]$ 这两个区间内，然后再跑线段树分治，在 $3$ 的时候就代表 “仅不包含权值为 $w$ 的边” 了。\n 但是注意到这个方法 不能用于求最大 mex 生成树！\n比如有三条边的权值分别为 $0,0,1$，任取两条边可以组成生成树，那么首先我们在去掉任意 $\\geq 1$ 的边后都能形成生成树，答案看起来是 $1$，但实际上应该选权值为 $0,1$ 的两条边，答案可以得到 $2$。\n简单来说，去掉一个特定权值 $w$，能得到生成树，并不代表这个生成树的 mex 就等于 $w$。\n为什么最小mex就可以呢？\n假如我们去掉一个特定权值 $w$，能得到生成树，但实际上这个生成树的 mex 不等于 $w$，那么真实的 mex $m$ 一定是 $\u0026lt; w$ 的，那么我们在继续判断更小的权值时，一定会判断到真实的 mex $m$（因为线段树分治本质上是暴力枚举）。枚举到 $m$ 时也肯定能组成一个生成树，所以答案为 $m$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = 4e6+55; struct State { int u, v, szu, szv; } st[maxm]; // 注意这里是 maxm，应该是边的数量 int uni = 0; // union 的次数，如果等于 n-1 说明联通了 int n, m, k; struct DSU { int par[maxn], sz[maxn], tail = 0; inline void init() { for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1; tail = 0; } int finds(int u) { if (par[u] == u) return u; return finds(par[u]); // 无路径压缩 } void unions(int u, int v) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); // sz[u] \u0026gt;= sz[v] st[++tail] = {u, v, sz[u], sz[v]}; // 无论是否 union 成功都要push到 stack 里 if (u == v) return; par[v] = u; sz[u] += sz[v]; uni++; // 成功union } void cancel() { if (tail \u0026gt; 0) { int u = st[tail].u, v = st[tail].v; par[v] = v; if (sz[u] != st[tail].szu) uni--; // 成功回退一次union sz[u] = st[tail].szu; sz[v] = st[tail].szv; tail--; } } } dsu; struct Edge { int u, v, w; }; struct TreeNode { vector\u0026lt;Edge\u0026gt; vec; }; int ans = 1e5; struct SegmentTree { TreeNode tr[(100005)\u0026lt;\u0026lt;2]; void insert(int cur, int l, int r, int L, int R, Edge e) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].vec.push_back(e); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) insert(cur\u0026lt;\u0026lt;1, l, mid, L, R, e); if (R \u0026gt; mid) insert(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, e); } void dfs(int cur, int l, int r) { for (Edge\u0026amp; e : tr[cur].vec) { dsu.unions(e.u, e.v); } if (l == r) { if (uni == n-1) ans = min(ans, l); } else { int mid = (l+r) \u0026gt;\u0026gt; 1; dfs(cur\u0026lt;\u0026lt;1, l, mid); dfs(cur\u0026lt;\u0026lt;1|1, mid+1, r); } for (Edge\u0026amp; e : tr[cur].vec) { dsu.cancel(); } } } tr; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dsu.init(); int N = 1e5; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (w \u0026gt; 0) tr.insert(1, 0, N, 0, w-1, {u, v, w}); if (w \u0026lt; N) tr.insert(1, 0, N, w+1, N, {u, v, w}); } tr.dfs(1, 0, N); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2023-05-17T17:42:06-05:00","permalink":"https://tom0727.github.io/post/107-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/","tags":["",""],"title":"线段树分治"},{"categories":["算法"],"contents":"介绍 在一个 无向图 中，DFS树是一个生成树（包含 $n-1$ 条边）。DFS树是在DFS过程中，如果从 dfs(u) 走到 dfs(v)，那么 $(u,v)$ 这条边将会加入DFS树。\nBFS树同理。\n上图是一个 DFS 树的形状。\n 性质 DFS树  在 DFS 树中，所有的 非树边 $(u,v)$ 都一定是 back edge，即 $u$ 是 $v$ 的祖先（或者反过来），不可能出现 cross edge。 只有 DFS 的树边可能是桥，DFS的非树边不可能是桥。 如果一条树边 $(u,v)$ 是桥，那么 $v$ 的子树内不存在非树边指向 $u$ 的任意祖先。 对于任意的非树边 $(u,v)$，LCA一定是 $u$ （假设 $d_u \u0026lt; d_v$）。  证明：\n 如果一条非树边是 cross edge，那么 DFS 的过程中应该会沿着这条边访问，这条边应该是树边。 因为 DFS树 本身是一棵生成树，所以去掉所有非树边都仍然联通。 这其实就是 tarjan 的原理。 根据性质1易证。  BFS树  在 BFS 树中，所有的 非树边 $(u,v)$ 一定 不是 back edge，即 $u$ 一定与 $v$ 没有祖孙关系，并且 $u,v$ 的深度相差至多 $1$。  证明：\n 如果一条非树边 $(u,v)$ 中，$u,v$ 的深度相差 $\\geq 2$，那么 BFS 的过程一定会通过 $u$ 走到 $v$，所以 $(u,v)$ 是树边。  例题 例1 ABC251F. Two Spanning Trees 题意\n给定一个无向图，求两个生成树 $T_1,T_2$ 分别满足：\n$T_1$：若以 $1$ 为根，对于所有的非树边 $(u,v)$，$u,v$ 互为子孙。\n$T_2$：若以 $1$ 为根，对于所有的非树边 $(u,v)$，$u,v$ 互不为子孙。\n其中，$n,m \\leq 2 \\times 10^5$，保证图是联通的。\n 题解 $T_1$ 就是 DFS 树，而 $T_2$ 就是 BFS 树。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n, m; vector\u0026lt;int\u0026gt; adj[maxn]; bool vis[maxn]; vector\u0026lt;pii\u0026gt; dft, bft; void dfs(int u) { vis[u] = 1; for (int v : adj[u]) { if (vis[v]) continue; dft.push_back({u,v}); dfs(v); } } void bfs() { queue\u0026lt;int\u0026gt; q; q.push(1); memset(vis, 0, sizeof(vis)); vis[1] = 1; while (q.size()) { int u = q.front(); q.pop(); for (int v : adj[u]) { if (vis[v]) continue; vis[v] = 1; q.push(v); bft.push_back({u,v}); } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } dfs(1); bfs(); for (auto [u, v] : dft) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (auto [u, v] : bft) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 CF118E. Bertown roads 题意\n给定一个无向图，求是否存在一种方案让它变成有向图，并且任意两点之间仍然可以到达？如果有，输出这个方案。\n其中，$n \\leq 10^5, m \\leq 3 \\times 10^5$，原图是一个联通图。\n 题解 首先，如果原图存在桥，那么无解。\n因为如果 $u,v$ 是一个桥，那么如果让它变成有向的 $u \\rightarrow v$，那么 $v$ 就无法到达 $u$ 了。\n判桥用 tarjan 即可。\n 没有桥说明有解，接下来考虑怎么变成有向图。\n跑一个 DFS 树，然后结论是：\n 所有树边都从 parent 连向 child，所有非树边都从 child 连向 ancestor。\n 证明：首先可知根节点可以到达所有的点，只要证明所有的点均可以到达根节点即可。\n考虑到这个图没有桥，意味着对于任意的树边 $u \\rightarrow v$，$v$ 的子树内一定存在一个点，指向了 $u$ 的某个祖先。所以我们可以从 $u$ 出发，来到 $v$ 的子树中的某一个点，然后通过这条非树边来到 $u$ 的某个祖先。\n由于没有桥，这个过程可以一直重复，也就是从任意点出发，都可以一直往它的祖先走，直到走到根。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n, m, dfn[maxn], low[maxn], id = 0; vector\u0026lt;int\u0026gt; adj[maxn]; bool bridge = 0; set\u0026lt;pii\u0026gt; se; void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int to : adj[u]) { if (to == p) continue; // 注意不能用parent if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); se.insert({u, to}); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { // 注意这里的条件 bridge = 1; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } tarjan(1, 0); if (bridge) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } for (int u = 1; u \u0026lt;= n; u++) { for (int v : adj[u]) { if (dfn[u] \u0026lt; dfn[v]) { if (se.count({u,v})) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } } }   例3 Universal Cup 16 H. Classical Maximization Problem 题意\n给定 $2n$ 个二维平面上的互不相同的点。\n求出最大数量的 pair，使得每一个pair都是两个点 $i,j$ 使得 $x_i = x_j$ 或者 $y_i = y_j$。\n每个点只能存在于至多一个 pair 中。\n输出最大pair的数量，以及pair的方案。\n其中，$n \\leq 10^5, x_i,y_i \\in [-10^9, 10^9]$。\n 题解 将所有的 $x$ 坐标，$y$ 坐标作为一个点，每个点 $(x_i,y_i)$ 就是 $x_i \\rightarrow y_i$ 的一条边。\n这样可以多个联通分量，每个联通分量都是一个二分图。很明显联通分量之间是分开的。\n然后问题转变成，找出最多的pair使得每两条边之间都有一个共同的点。先给一个结论：\n 对于大小为 $n$ 的联通分量，一定可以找到一种方案使得有 $\\frac{n}{2}$ 个pair。\n 证明：\n我们在这个图上跑一个 DFS 树，对于每棵子树 $v$，如果里面有偶数条边，那么它们一定可以在 $v$ 的子树内匹配完成。如果这个子树有奇数条边，那么它可以匹配到只剩下一条边，这条边就是连向 parent 的边。\n如何证明？用归纳法：\n考虑当前的节点 $u$，这个节点会有很多个儿子的子树，如果子树 $v$ 里面多了一条边，那么就是 $(u,v)$ 这条树边。\n并且节点 $u$ 自己也会连一些非树边出来，由于这是 DFS 树，这个树边一定是连到 $u$ 的子树内的某个节点。\n也就是说，这些多余的边全部都有 $u$ 这个共同点，那么它们之间就可以俩俩匹配了，所以 $u$ 也满足了偶数条边就可以全部匹配，奇数条边就只贡献一条边的特点。\n这样递归的解决问题即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 6e5+55; int n; struct Node { int x, y, idx; } a[maxn]; struct Edge { int to, idx; }; vector\u0026lt;Edge\u0026gt; adj[maxn\u0026lt;\u0026lt;1]; bool vis[maxn\u0026lt;\u0026lt;1]; vector\u0026lt;pii\u0026gt; ans; int dep[maxn\u0026lt;\u0026lt;1]; // dfs 返回 \u0026gt;0 代表里面剩了一个边，这个边与 v 直接相连，编号就是返回值 int dfs(int u, int p) { dep[u] = dep[p] + 1; vis[u] = 1; vector\u0026lt;int\u0026gt; vec; for (auto [v, idx] : adj[u]) { if (v == p) continue; if (vis[v] \u0026amp;\u0026amp; dep[v] \u0026lt; dep[u]) continue; // 如果这是一个backward edge int r = 1; if (!vis[v]) { r = dfs(v, u); if (r) { ans.push_back({r, idx}); } else { vec.push_back(idx); } } else vec.push_back(idx); } // vec 里面所有都是与 u 直接相连的 while (vec.size() \u0026gt;= 2) { int i = vec.back(); vec.pop_back(); int j = vec.back(); vec.pop_back(); assert(i \u0026gt; 0); assert(j \u0026gt; 0); ans.push_back({i,j}); } if (vec.size()) return vec[0]; return 0; } void solve() { int N = 0; cin \u0026gt;\u0026gt; n; n*=2; map\u0026lt;int, int\u0026gt; xs, ys; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i].x \u0026gt;\u0026gt; a[i].y; if (!xs.count(a[i].x)) xs[a[i].x] = ++N; if (!ys.count(a[i].y)) ys[a[i].y] = ++N; a[i].idx = i; int u = xs[a[i].x], v = ys[a[i].y]; adj[u].push_back({v, i}); adj[v].push_back({u, i}); } for (int i = 1; i \u0026lt;= N; i++) { if (!vis[i]) dfs(i, 0); } vector\u0026lt;bool\u0026gt; used(n+5, 0); cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (auto [u,v] : ans) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; used[u] = used[v] = 1; } vector\u0026lt;int\u0026gt; tmp; for (int i = 1; i \u0026lt;= n; i++) { if (!used[i]) tmp.push_back(i); } for (int i = 0; i \u0026lt; tmp.size(); i+=2) cout \u0026lt;\u0026lt; tmp[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; tmp[i+1] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; ans.clear(); for (int i = 1; i \u0026lt;= N; i++) adj[i].clear(); fill(vis, vis+N+2, 0); fill(dep, dep+N+2, 0); } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { solve(); } }   例4 CF19E. Fairy 题意\n给定一张无向图，现在需要恰好删掉一条边，问有多少种方案，使得恰好删除一条边后，得到的图是二分图。\n输出所有的方案。\n其中，$n,m \\leq 10^4$。\n 题解 注意到一个图是二分图 $\\iff$ 可以被二分染色 $\\iff$ 没有奇环。\n我们先跑一个 DFS 树出来，由于一棵树一定可以被二分染色，我们不妨先只考虑所有的树边，然后进行一个二分染色。\n然后分别讨论树边和非树边。\n首先，由于我们是根据树的结构来染色的，所以树边肯定不会有问题。但是非树边有可能会两端颜色相同，我们把两端颜色相同的非树边叫做 坏边，否则叫做 好边。\n 非树边：  在染色后，一个非树边可以成为答案，当且仅当 只有一条非树边是坏边。显然，如果有至少 $2$ 个坏边，那么怎么remove都不可能得到一个二分图的。\n树边：  一个树边 $e$ 可以成为答案，当且仅当 所有的坏边 $(u,v)$ 在树上的路径均穿过 $e$，并且 没有好边 在树上的路径穿过 $e$。\n所有的坏边必须穿过 $e$ 这一点好理解，由于坏边一定是构成了奇环，所以要断掉这个奇环，肯定得断掉环上的某一条边，如果存在一个坏边所在的奇环没有经过 $e$，那么断掉 $e$ 以后仍然存在奇环。\n为什么还要保证没有好边在树上的路径穿过 $e$ 呢？\n考虑这个例子，我们断开一条树边以后，如果我们暂时忽略掉非树边，那么我们可以得到两个联通块。由于坏边没有被删掉，所以坏边两端颜色还是相同。那么我们希望调整其中一个联通块的颜色，使得坏边两端的颜色不同。\n而一个联通块内部为了保证染色的正确性，只能将整个联通块的颜色反转。此时如果有一个原先的好边，连接了这两个联通块，那么反转后它反而会变成坏边。\n所以我们要保证没有好边在树上的路径穿过 $e$。\n 于是我们对于每个树边，都统计有多少条好边的路径，多少条坏边的路径穿过了它即可。\n这是一个路径加，然后询问的问题。用树上差分即可实现，由于 DFS树 的特殊性质，一条非树边 $(u,v)$ 的 LCA 一定是 $u$，所以我们在 $O(1)$ 的时间就可以完成树上差分了。\n• 最后注意一下原图并非联通图。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 6e5+55; int n, m, color[maxn]; struct Edge { int u, v, idx; }; vector\u0026lt;Edge\u0026gt; adj[maxn]; bool vis[maxn], istree[maxn]; // istree[i]: 第i条边是树边 bool bad[maxn]; // bad[i]: 第i条边不是树边，并且是坏边 (u,v颜色相同) int badcnt = 0; // 有多少个联通块不是二分的 int badcomp = 0; // 这个联通块里有几个边是坏的 vector\u0026lt;int\u0026gt; tmp; int good_dp[maxn], bad_dp[maxn], dep[maxn]; void dfs(int u, int p) { dep[u] = dep[p] + 1; vis[u] = 1; for (auto [_, v, idx] : adj[u]) { if (v == p) continue; if (vis[v] \u0026amp;\u0026amp; dep[u] \u0026gt; dep[v]) continue; // 必须是 ancestor -\u0026gt; child if (!vis[v]) { istree[idx] = 1; color[v] = color[u] ^ 1; dfs(v, u); } else { istree[idx] = 0; // 坏边 if (color[u] == color[v]) { badcomp++; bad[idx] = 1; tmp.push_back(idx); bad_dp[v]++, bad_dp[u]--; } else { good_dp[v]++, good_dp[u]--; } } } } vector\u0026lt;int\u0026gt; ans; void dfs2(int u, int p) { int pidx = -1; for (auto [_, v, idx] : adj[u]) { if (!istree[idx]) continue; // 树边 if (v == p) { pidx = idx; LOG(pidx); continue; } dfs2(v, u); good_dp[u] += good_dp[v]; bad_dp[u] += bad_dp[v]; } if (good_dp[u] == 0 \u0026amp;\u0026amp; bad_dp[u] == badcomp \u0026amp;\u0026amp; badcomp \u0026gt; 0) ans.push_back(pidx); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back({u, v, i}); adj[v].push_back({v, u, i}); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { tmp.clear(); badcomp = 0; dfs(i, 0); badcnt += (badcomp \u0026gt; 0); if (badcomp == 1) ans.push_back(tmp[0]); dfs2(i, 0); } } if (badcnt == 0) { cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; return 0; } if (badcnt \u0026gt;= 2) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } sort(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://codeforces.com/blog/entry/68138 https://www.cnblogs.com/miraclepbc/p/16280781.html  ","date":"2023-05-15T23:50:50-05:00","permalink":"https://tom0727.github.io/post/106-dfs-bfs-tree/","tags":["",""],"title":"DFS/BFS树"},{"categories":["解题报告"],"contents":"G. ICPC Camp 题意\n给定一个整数 $n$，和两个长度分别为 $p,q$ 的数组，$a_1,a_2,\u0026hellip;,a_p$ 和 $b_1,b_2,\u0026hellip;,b_q$，以及一个整数 $s$。\n我们现在要配对出 $n$ 个互不相同（每个 $a_j, b_k$ 只能出现在一个pair中）的pair $(a_j,b_k)$ 使得 $a_j+b_k \\leq s$。\n定义第 $i$ 个pair的差值为 $d_i = |a_j-b_k|$，那么我们要让 $D = \\max d_i$ 的值最小。\n其中，$n,p,q \\leq 2 \\times 10^5, 0 \\leq s,a_i,b_i \\leq 10^9$。\n 题解 一眼二分。先 sort一下 $a,b$。\n二分之后呢？\n假设当前二分的最大差值为 $x$。\n那么对于每一个 $a_i$ 我们都可以找到所有满足条件的 $b_j$ 使得 $|a_i-b_j| \\leq x$ 且 $a_i+b_j \\leq s$。\n这样满足条件的 $b_j$ 一定是sort后的一个连续区间。\n 那么问题转化为，我们有 $p$ 个这样的区间，如何在每个区间上取一个点，使得这些点互不相同，并使得取的点数尽可能多？\n比如 $a_1$ 对应的是 $[b_1,b_1]$，$a_2$ 对应 $[b_1,b_2]$, $a_3$ 对应 $[b_2,b_4]$，则我们获得三个区间 $[1,1],[1,2],[2,4]$。\n可以在 $[1,1]$ 内选 1 这个点，$[1,2]$ 内选 2 这个点，$[2,4]$ 内选 3 这个点，所以可以选3个点，答案为3。\n 我们利用贪心尽可能多选点。\n我们先将所有区间按照右端点sort一下，然后每个区间 $[L,R]$ 看从 $L$ 开始，第一个没用过的点是哪个，如果它 $\\leq R$，就选它。\n怎么快速寻找这个没用过的点？\n注意到区间上的点数最多为 $q\\leq 2 \\times 10^5$ 个，我们先将所有的点 (从 $1$ 到 $q$）加入一个 set，然后在set上 lower_bound() 即可。\n最后，如果可选的点数 $\\geq n$ 就说明 $x$ 是可行的。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n, p, q, s; int a[maxn], b[maxn]; bool solve(int x) { vector\u0026lt;pii\u0026gt; vec; for (int i = 1; i \u0026lt;= p; i++) { int L = lower_bound(b+1, b+q+1, a[i]-x) - b; int R = upper_bound(b+1, b+q+1, min(a[i]+x, s-a[i])) - b-1; if (L \u0026lt;= R) vec.push_back({L,R}); } int m = vec.size(), ans = 0; sort(vec.begin(), vec.end(), [](auto a, auto b) { return a.second \u0026lt; b.second; }); set\u0026lt;int\u0026gt; se; for (int i = 1; i \u0026lt;= q; i++) se.insert(i); for (auto [L, R] : vec) { if (se.lower_bound(L) != se.end()) { int t = *se.lower_bound(L); if (t \u0026lt;= R) { se.erase(t); ans++; } } } return ans \u0026gt;= n; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt;= p; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= q; i++) cin \u0026gt;\u0026gt; b[i]; sort(a+1, a+p+1); sort(b+1, b+q+1); int low = 0, high = 1e9, ans = 1e9+1; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; if (solve(mid)) { ans = mid, high = mid-1; } else low = mid+1; } cout \u0026lt;\u0026lt; (ans == 1e9+1 ? -1 : ans) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   J. Lunchtime Name Recall 题意\n给定一个集合，一开始它为 $\\{n\\}$，现在我们有 $m$ 天，第 $i$ 天我们拥有 $a_i$ 个汉堡。\n在这一天，我们需要将 $a_i$ 个汉堡全部分出去，对于一个集合中的一个元素，假设它为 $v$，那么我们如果分了 $b (0 \\leq b \\leq v)$ 个汉堡给这个元素，那么它会分裂成 $b, v-b$ 这两个数。\n如何分配汉堡，使得 $m$ 天后，集合中元素 $1$ 的出现次数最大？\n其中，$2 \\leq n \\leq 30, 1 \\leq m \\leq 10$，$a_i \\in [1,n-1]$。\n 整数拆分\n一个正整数 $n$ 的整数拆分是将它拆成一些整数的和，即求：\n$$n=r_1+r_2+\u0026hellip;+r_k,~~ r_1 \\geq r_2 \\geq \u0026hellip; \\geq r_k \\geq 1$$\n的方案数。\n我们设 $f_{i,j}$ 表示将整数 $i$ 恰好拆成 $j$ 个数的方案，则有：\n$$f_{i,j} = f_{i-1,j-1} + f_{i-j,j}$$\n这里表示考虑最小的数是否为 $1$，如果是，就转移到 $f_{i-1,j-1}$，否则让所有数字减 $1$，得到 $f_{i-j,j}$。\n由这个可以计算出 $n=30$ 的时候有 $5604$ 种拆法。\n 题解 暴搜！复杂度大概可以感性理解是和分拆数有关的。具体复杂度至少为 $5604^2$。\n在暴搜时需要一些优化：\n 每天如果我们拥有 $a_i$ 个汉堡，那么等价于我们拥有 $n-a_i$ 个汉堡，所以我们取较小的那一个。 如果集合中有多个相同的数 $N_1, N_2 \u0026hellip; N_k$ 可以分，那么我们分给 $N_i$ 的汉堡数量一定要 $\\geq N_{i+1}$ 的汉堡数量（避免重复计算），当然不同的数字之间并没有任何关联。 在每一天分的时候，我们维护两个 vector\u0026lt;int\u0026gt;，一个叫 cur，一个叫 add，分别代表当前还没有分的数，和已经分好了的数，这样可以避免在同一天分了一个数两次。 使用哈希，将当前集合的状态 map 到一个hash value，并且离散化之后由整数拆分知道状态数 $\\leq 5604$。 如果分汉堡的时候会分出 $0$ 的话，就不分这个值。 记得在能加引用的地方，加上引用，否则T飞。  复杂度是 $O($玄学$)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 35; const int maxm = 1e5+55; const int P = 31; int n, m, a[maxn], cid = 0; int dp[12][5700]; // dp[i][S]: 还剩 i 次分的机会，当前状态为 S，最多能区分出几个人 map\u0026lt;ull, int\u0026gt; hash_to_idx; // 哈希值 map 到 index // map\u0026lt;ull, vector\u0026lt;int\u0026gt;\u0026gt; hash_to_vec; // 大小为 5604 // vis = 1: 更新 hash_to_vec inline ull vec_to_hash(vector\u0026lt;int\u0026gt;\u0026amp; vec, bool vis) { sort(vec.begin(), vec.end(), greater\u0026lt;int\u0026gt;()); ull res = 0; for (int i = 0; i \u0026lt; vec.size(); i++) { res = res * P + vec[i]; } if (vis \u0026amp;\u0026amp; hash_to_idx.count(res) == 0) { hash_to_idx[res] = ++cid; } return res; } // 整数拆分 // 还剩下 cur，上一个拆出来的数是 last (所以这次拆的数 \u0026lt;= last), 现在拆出来的是 vec (vec里面的数字不会再被拆) // void init(int cur, int last, vector\u0026lt;int\u0026gt;\u0026amp; vec) { // if (cur == 0) return; // vec.push_back(cur); // ull res = vec_to_hash(vec, 1); // vec.pop_back(); // for (int i = min(cur, last); i \u0026gt;= 1; i--) { // vec.push_back(i); // init(cur - i, i, vec); // vec.pop_back(); // } // } int dfs(int i, vector\u0026lt;int\u0026gt; cur); // i: 第 i 天 // b: 还剩下 b 个汉堡可以用 // cur: 还没有分的组 // add: 已经分好的组 (此时它应该是空的？) // lim: 如果上一个处理的组和当前 cur.back() 的组大小一致，lim 为上一个处理的组拆分的大小，这个不能比它大；如果大小不一致，lim = n (无限制) int helper(int i, int b, vector\u0026lt;int\u0026gt;\u0026amp; cur, vector\u0026lt;int\u0026gt;\u0026amp; add, int lim) { if (b \u0026lt; 0) return 0; if (cur.size() == 0) { if (b == 0) return dfs(i+1, add); return 0; // b \u0026gt; 0, 状态不合法 } // 还剩下没分的组，开始分 int v = cur.back(); cur.pop_back(); bool has_lim = (cur.size() \u0026amp;\u0026amp; cur.back() == v); // 下一个是否有限制 int res = 0; // 记录最大值 for (int j = 0; j \u0026lt;= min({b, lim, v}); j++) { // 用掉 j 个汉堡 if (j \u0026gt; 0) add.push_back(j); if (j != v) add.push_back(v-j); res = max(res, helper(i, b-j, cur, add, has_lim ? j : n)); add.pop_back(); if (j \u0026gt; 0 \u0026amp;\u0026amp; j != v) add.pop_back(); if (res == n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; exit(0); } } cur.push_back(v); return res; } // i: 第 i 天 (这一天还没开始分) // cur: 还没有分的组 // dfs 函数默认是这一天的开始，所以拥有 a[i] 个汉堡可以分 int ans = 0; int dfs(int i, vector\u0026lt;int\u0026gt; cur) { ull S = vec_to_hash(cur, 1); int s = hash_to_idx[S]; if (dp[i][s] != -1) return dp[i][s]; if (i \u0026gt; m) { int cnt = 0; for (int j : cur) cnt += (j == 1); ans = max(ans, cnt); return dp[i][s] = cnt; } vector\u0026lt;int\u0026gt; add; return dp[i][s] = helper(i, a[i], cur, add, n); // 记忆化 } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i], a[i] = min(a[i], n-a[i]); sort(a+1, a+m+1, greater\u0026lt;int\u0026gt;()); vector\u0026lt;int\u0026gt; vec; memset(dp, -1, sizeof(dp)); vector\u0026lt;int\u0026gt; cur; cur.push_back(n); dfs(1, cur); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2023-04-03T19:24:17-05:00","permalink":"https://tom0727.github.io/post/105-nac2020/","tags":["",""],"title":"NAC2020"},{"categories":["题解"],"contents":"CF1805F1. Survival of the Weakest (easy version) 题意\n给定一个数组 $a_1,a_2\u0026hellip;,a_n$，定义 $F(a_1,a_2,\u0026hellip;,a_n)$ 为如下的函数：\n$F(a_1,a_2,\u0026hellip;,a_n)$ 将会在 $\\forall 1\\leq i \u0026lt; j \\leq n$ 中，选取最小的 $n-1$ 个 $a_i+a_j$，然后组成一个新的sort好的数组。\n例如 $F(1,2,5,7) = [1+2,1+5,2+5] = [3,6,7]$。\n给定 $a_1,a_2,\u0026hellip;,a_n$，求 $F^{n-1}(a_1,a_2,\u0026hellip;,a_n)$ 的值（即对这个数组进行 $n-1$ 次操作）。\n其中，$2 \\leq n \\leq 3000, a_i \\in [0,10^9]$，答案对 $10^9+7$ 取模。\n 题解 我们在下文假设 $a_1,a_2,\u0026hellip;,a_n$ 始终为 sort 好的。\n由于 $n \\leq 3000$，考虑直接暴力求 $F$。\n我们注意到，如果 $i\u0026lt;j$ 且 $a_i+a_{j+1}$ 被 $F$ 选中了，那么 $a_i+a_j$ 也一定会被更早选中（因为sorted）。\n所以对于所有的pair的左端点 $i$，我们只需要考虑当前尚未选中的右端点 $j$，如果 $j$ 被选中了那么才考虑 $j+1$ 作为右端点。\n于是我们开一个 pq，先存进 $(a_1,a_2), (a_2,a_3), \u0026hellip;, (a_{n-1},a_n)$。\n当 $(a_i,a_j)$ 被 pop 出来加入下一轮后，push进 $(a_i,a_{j+1})$。\n这样就可以在 $O(n\\log n)$ 内进行一轮 $F$ 了。\n 但是，答案对 $10^9+7$ 取模，我们显然不能在求解 $F$ 的过程中取模，因为这会破坏数字之间的大小关系，怎么办？\n我们发现 $F(a_1-x,a_2-x,\u0026hellip;,a_n-x) = F(a_1,a_2,\u0026hellip;,a_n) - 2^{n-1}x$，所以每一轮我们先减掉当前数组中的最小值，给答案加上即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3005; Z p2[maxn], ans = 0; struct Node { ll val; int i, j; bool operator\u0026lt;(const Node\u0026amp; other) const { return val \u0026gt; other.val; } }; vector\u0026lt;ll\u0026gt; f(vector\u0026lt;ll\u0026gt;\u0026amp; vec) { priority_queue\u0026lt;Node\u0026gt; pq; int n = vec.size(); ll mn = 1e18; for (int i = 0; i \u0026lt; n; i++) { mn = min(mn, vec[i]); } for (int i = 0; i \u0026lt; n; i++) vec[i] -= mn; ans += p2[n-1] * mn; vector\u0026lt;ll\u0026gt; res; for (int i = 0; i \u0026lt; n-1; i++) { pq.push({vec[i] + vec[i+1], i, i+1}); } for (int i = 1; i \u0026lt; n; i++) { auto [val, l, r] = pq.top(); pq.pop(); res.push_back(val); if (r + 1 \u0026lt; n) { pq.push({vec[l] + vec[r+1], l, r+1}); } } return res; } int n; int main() { cin \u0026gt;\u0026gt; n; p2[0] = 1; for (int i = 1; i \u0026lt;= n; i++) p2[i] = p2[i-1] * 2; vector\u0026lt;ll\u0026gt; vec; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; vec.push_back(x); } sort(vec.begin(), vec.end()); for (int t = 1; t \u0026lt; n; t++) { vec = f(vec); } cout \u0026lt;\u0026lt; ans + vec[0] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2023-04-02T23:43:29-05:00","permalink":"https://tom0727.github.io/post/104-cf1862f/","tags":["",""],"title":"CF1862F题解"},{"categories":["算法"],"contents":"bitset作为C++自带的数据结构，利用bit储存信息，由于 1 byte = 8 bits，并且一个int就有 4 bytes，所以通常情况下用 bitset 可以达到 32 倍的常数优化。\n优化01背包 例1 洛谷P1537 弹珠 题意\n给定价值为 $1,2,3,4,5,6$ 的弹珠，数量分别为 $N_1,N_2,\u0026hellip;,N_6$，问是否能将这些弹珠分为两份使得两份的价值和相等。\n其中，弹珠数量和 $\\leq 2 \\times 10^4$。\n 题解 多重背包，正解应该是二进制优化成01背包。\n但bitset可以直接暴力碾过去。\ndp[0] = 1; for (int i = 1; i \u0026lt;= 6; i++) { while (a[i]--) { dp |= (dp \u0026lt;\u0026lt; i); } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[maxn]; bitset\u0026lt;120005\u0026gt; dp; int main() { int t = 0; while (cin \u0026gt;\u0026gt; a[1] \u0026gt;\u0026gt; a[2] \u0026gt;\u0026gt; a[3] \u0026gt;\u0026gt; a[4] \u0026gt;\u0026gt; a[5] \u0026gt;\u0026gt; a[6]) { if (a[1] == 0 \u0026amp;\u0026amp; a[2] == 0 \u0026amp;\u0026amp; a[3] == 0 \u0026amp;\u0026amp; a[4] == 0 \u0026amp;\u0026amp; a[5] == 0 \u0026amp;\u0026amp; a[6] == 0) break; cout \u0026lt;\u0026lt; \u0026quot;Collection #\u0026quot; \u0026lt;\u0026lt; ++t \u0026lt;\u0026lt; \u0026quot;:\\n\u0026quot;; dp.reset(); bool ok = 1; int sum = 0; for (int i = 1; i \u0026lt;= 6; i++) { sum += i * a[i]; } if (sum % 2) ok = 0; dp[0] = 1; for (int i = 1; i \u0026lt;= 6; i++) { while (a[i]--) { dp |= (dp \u0026lt;\u0026lt; i); } } ok = (ok \u0026amp;\u0026amp; dp[sum/2]); if (ok) cout \u0026lt;\u0026lt; \u0026quot;Can be divided.\\n\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;Can't be divided.\\n\\n\u0026quot;; } }   优化floyd传递闭包 在 floyd 中我们有 f[i][j] |= (f[i][k] \u0026amp;\u0026amp; f[k][j]) 的方式来传递闭包。\n如果用bitset实现呢？\nbitset\u0026lt;maxn\u0026gt; f[maxn]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (f[j][i]) f[j] |= f[i]; } }  如果 $j$ 能够到达 $i$，那么 $i$ 所能到达的点，$j$ 也能够到达。\n• 如果是一个闭包在一个图上传递，那么就有：\nstruct Mat { bitset\u0026lt;maxn\u0026gt; f[maxn]; Mat operator*(const Mat\u0026amp; other) { Mat res; // 无需初始化！ for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (f[j][i]) res.f[j] |= other.f[i]; } } return res; } };  例1 CF576D. Flights for Regular Customers 题意\n给定一个 $n$ 个点，$m$ 条边的有向无权图。一开始在节点 $1$，需要走到节点 $n$。\n当且仅当走过了至少 $d_i$ 条边时，才能使用第 $i$ 条边。\n问最少需要走多少条边到达 $n$，或判断无法到达。\n其中，$n,m \\leq 150, 0 \\leq d_i \\leq 10^9$。\n 题解 首先我们根据 $d_i$ sort所有的边，然后对于每一个 $d_i$，我们要求出 恰好走了 $d_i$ 步时，能够停在哪些点，然后从这些点开始多源BFS（就是一开始全丢到queue里），求出 dis[n]，然后加上 $d_i$ 即可得到这个状态的答案。\n那么如何求出 恰好走了 $d_i$ 步时，能够停在哪些点？\n 假设我们求出了恰好走了 $d_{i-1}$ 步时，从 $1$ 出发能够停在哪些点。那么我们只要求出在只包含 $1,2,\u0026hellip;,i-1$ 这些边的图中，从这些点出发，走 $d_{i} - d_{i-1}$ 步能够停留在哪些点。\n那么这就是一个闭包传递的过程了！\n但由于 $d_{i} - d_{i-1}$ 可能会很大，所以我们需要快速幂来优化，为什么可以用快速幂？\n因为我们知道 floyd 传递闭包是利用了 矩阵乘法 的原理。\n因为矩阵乘法是 $C_{i,j} = \\sum\\limits_{k=1}^n A_{i,k}B_{k,j}$，这其实和传递闭包的公式是一样的。\n• 矩阵乘法快速幂的原理也可以用于解决 “走过 $k$ 条边的最短路” 的问题。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 155; const int maxm = 1e5+55; struct Edge { int from, to, d; }; int n, m; map\u0026lt;int, vector\u0026lt;Edge\u0026gt;\u0026gt; mp; int dis[maxn]; vector\u0026lt;int\u0026gt; adj[maxn]; ll ans = 2e9; struct Mat { bitset\u0026lt;maxn\u0026gt; f[maxn]; Mat operator*(const Mat\u0026amp; other) { Mat res; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (f[j][i]) res.f[j] |= other.f[i]; } } return res; } void setone() { for (int i = 1; i \u0026lt;= n; i++) f[i][i] = 1; } }; Mat qpow(Mat a, int b) { Mat res; res.setone(); while (b) { if (b\u0026amp;1) res = res * a; a = a*a; b \u0026gt;\u0026gt;= 1; } return res; } Mat cur, g; // cur代表当前走x步能够恰好从 u 出发停在 v，g代表当前图中恰好走一步能够从u到达v ll D = 0; void bfs() { queue\u0026lt;int\u0026gt; q; fill(dis, dis+maxn, 2e9); for (int i = 1; i \u0026lt;= n; i++) { if (cur.f[1][i]) q.push(i), dis[i] = 0; // 多源bfs } while (q.size()) { int u = q.front(); q.pop(); for (int v : adj[u]) { if (dis[v] \u0026gt; dis[u] + 1) { dis[v] = dis[u] + 1; q.push(v); } } } ans = min(ans, dis[n] + D); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,d; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; d; mp[d].push_back({u,v,d}); } cur.f[1][1] = 1; // 初始状态是走0步，所以可以从1出发恰好停在1，但其他的还没到 // 注意 g 不要设定 g.f[u][u] = 1，因为这里的矩阵代表**恰好**走 $1$ 步。 for (auto itr : mp) { int d = itr.first; int step = d - D; D = d; cur = cur * qpow(g, step); // 将 d_i-1 传递给 d_i bfs(); for (Edge e : itr.second) { int u = e.from, v = e.to; g.f[u][v] = 1; adj[u].push_back(v); } } bfs(); if (ans \u0026gt;= 2e9) cout \u0026lt;\u0026lt; \u0026quot;Impossible\\n\u0026quot;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   暴力字符串匹配 利用 bitset 可以 $O(\\frac{n^2}{w})$ 求出一个模式串 $t$ 在一个母串 $s$ 中出现的所有位置，在 $n=10^5$ 的时候可以跑过去，尤其在多模式串+带修时很好用。\n原理：我们对于每个字符（一般来说是 a 到 z）都开一个bitset，就有 bitset\u0026lt;maxn\u0026gt; bs[26]，其中 bs[i][j] 代表字母 $i$ 在母串 $s$ 的位置 $j$ 是否出现了。\n比如字符串 s = \u0026quot;abab\u0026quot;，那么a,b 两个字母对应的两个bitset就是：\na：1010\nb：0101\n现在要求一个模式串 $t$ 在 $s$ 中出现的所有位置，比如 t = \u0026quot;ab\u0026quot;。\n那么对于每一个模式串 $t$，我们先初始化一个 全为 $1$ 的bitset叫 ans，ans[i] = 1 就代表模式串 $t$ 出现在了 $s$ 的位置 $i$ 处，也就是 $s[i\u0026hellip;i+|t|-1]=t$。\n然后，枚举 $t$ 的每一个字符，对于第 $i$ 个字符 $t_i$，将 $t_i$ 对应的bitset右移 $(i-1)$ 格后，与 ans AND 起来。\nbitset\u0026lt;maxn\u0026gt; bs[26]; // bs[i][j]: 字母i在位置j是否出现过 bitset\u0026lt;maxn\u0026gt; ans; int main() { cin \u0026gt;\u0026gt; s; n = s.size(); for (int i = 1; i \u0026lt;= n; i++) { bs[s[i-1]-'a'][i] = 1; } string t; cin \u0026gt;\u0026gt; t; int m = t.size(); ans.set(); // 全部设为1 for (int i = 1; i \u0026lt;= m; i++) { ans \u0026amp;= ((bs[t[i-1]-'a'] \u0026gt;\u0026gt; (i-1))); } }  然后 ans 就是我们所求的了。\n为什么是正确的？这本质上是暴力匹配的过程，考虑所有的前缀：\n对于 $t_1$ 这个前缀而言，显然只有 $s_i = t_1$ 的位置 $i$ 满足条件，所以 ans \u0026amp;= bs[t[0] - 'a']。\n对于 $t_1t_2$ 这个前缀而言，只有 $s_i = t_1$ 且 $s_{i+1} = t_2$ 满足条件，所以需要将 $t_2$ 对应的bitset右移一格，然后再AND起来。\n后面的同理，直到枚举完整个 $t$。\n我们拿 s = \u0026quot;abab\u0026quot;, t = \u0026quot;ab\u0026quot; 举例：由于有\na：1010\nb：0101\n那么 b 对应的bitset右移一位后可以得到 1010（注意bitset的写法是左右颠倒过来的，所以看起来像左移，但实际上是右移），那么就有：\nans = (\u0026quot;1111\u0026quot; \u0026amp; \u0026quot;1010\u0026quot; \u0026amp; \u0026quot;1010\u0026quot;) = \u0026quot;1010\u0026quot;，代表 $t$ 在 $s$ 的 $1,3$ 位置都出现了。\n 最后注意，不要 在 ans 上跑 for-loop，这会导致它的优化直接失效！\n一些常见的函数：\nbitset\u0026lt;maxn\u0026gt; ans; // 求 ans[l...r] 的和 int getsum(int l, int r) { if (l \u0026gt; r) return 0; return (ans \u0026gt;\u0026gt; l).count() - (ans \u0026gt;\u0026gt; (r+1)).count(); // (ans\u0026gt;\u0026gt;i).count() = ans[i...n] } // 枚举 ans 中所有的 1 (_Find_next(i) 会找 i 后面的下一个 1 的位置，如果没有的话返回 ans.size()) for (int i = ans._Find_first(); i \u0026lt; ans.size(); i = ans._Find_next(i)) { pos.push_back(i); }  例1 CF914F. Substrings in a String 题意\n给定一个字符串（仅包含小写字母） $s$，以及 $q$ 次操作，每次操作有两种：\n1 i c：将 $s_i$ 改为字符 $c$\n2 l r t：求字符串 $t$ 在 $s[l\u0026hellip;r]$ 中，作为子串出现的次数。\n其中，$|s| \\leq 10^5, q \\leq 10^5, \\sum |t| \\leq 10^5$。\n 题解 按照上面说的构造 26 个bitset和一个 ans bitset。\n对于第一种操作，直接 $O(1)$ 修改。\n对于第二种操作，我们求出 $t$ 在 $s$ 中出现的所有位置，然后只要回答 ans[l...r-|t|+1] 的和即可。\n使用 (ans\u0026gt;\u0026gt;i).count() 函数可以求出 ans[i...n] 的和。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bitset\u0026lt;maxn\u0026gt; bs[26]; // bs[i][j]: 字母i在位置j是否出现过 bitset\u0026lt;maxn\u0026gt; ans; // 求 ans[l...r] 的和 int getsum(int l, int r) { if (l \u0026gt; r) return 0; return (ans \u0026gt;\u0026gt; l).count() - (ans \u0026gt;\u0026gt; (r+1)).count(); // (ans\u0026gt;\u0026gt;i).count() = ans[i...n] } string s; int n; int main() { fastio; cin \u0026gt;\u0026gt; s; n = s.size(); for (int i = 1; i \u0026lt;= n; i++) { bs[s[i-1]-'a'][i] = 1; } int q; cin \u0026gt;\u0026gt; q; while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int p; char c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; bs[s[p-1]-'a'][p] = 0; s[p-1] = c; bs[s[p-1]-'a'][p] = 1; } else { int l,r; string t; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; t; int m = t.size(); ans.set(); // 全部设为1 for (int i = 1; i \u0026lt;= m; i++) { ans \u0026amp;= ((bs[t[i-1]-'a'] \u0026gt;\u0026gt; (i-1))); } cout \u0026lt;\u0026lt; getsum(l, r-m+1) \u0026lt;\u0026lt; endl; } } }   例2 CF963D. Frequency of String 题意\n给定一个字符串 $s$，有 $q$ 个询问，每次询问给定一个整数 $k_i$ 和一个字符串 $t_i$，回答 $s$ 中最短的子串使得 $t_i$ 在这个子串中出现了至少 $k_i$ 次。\n其中，$|s| \\leq 10^5, q \\leq 10^5, \\sum|t_i| \\leq 10^5$，$t_i$ 互不相同。\n 性质\n对于互不相同的，长度之和为 $M$ 的一些模式串，在长度为 $n$ 的母串中出现的次数之和不超过 $n\\sqrt M$。\n证明：考虑长度均为 $L$ 的所有模式串，由于它们互不相同，所以这些模式串出现在 $s$ 内的总次数 $\\leq n-L+1$。并且由于 $\\sum L \\leq M$，意味着互不相同的 $L$ 只有 $\\sqrt M$ 种。所以总出现次数不超过 $n \\sqrt M$。\n 题解 有了以上证明，我们知道这些模式串 $t_i$ 的出现次数之和不超过 $n \\sqrt{\\sum|t_i|}$，也就是说处理出的 ans 数组里最多有 $n \\sqrt{\\sum|t_i|}$ 个 $1$。\n于是对于每一个 $t_i$ 处理出 ans，然后利用 _Find_first() 函数和 _Find_next() 函数暴力枚举所有的 $1$ 的位置即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; bitset\u0026lt;maxn\u0026gt; bs[26]; // bs[i][j]: 字母i在位置j是否出现过 bitset\u0026lt;maxn\u0026gt; ans; string s; int n; int main() { fastio; cin \u0026gt;\u0026gt; s; n = s.size(); for (int i = 1; i \u0026lt;= n; i++) { bs[s[i-1]-'a'][i] = 1; } int q; cin \u0026gt;\u0026gt; q; while (q--) { int k; string t; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; t; int m = t.size(); int res = 1e9; ans.set(); for (int i = 1; i \u0026lt;= m; i++) { ans \u0026amp;= ((bs[t[i-1]-'a'] \u0026gt;\u0026gt; (i-1))); } vector\u0026lt;int\u0026gt; pos; for (int i = ans._Find_first(); i \u0026lt; ans.size(); i = ans._Find_next(i)) { pos.push_back(i); } for (int i = k-1; i \u0026lt; pos.size(); i++) { res = min(res, pos[i] - pos[i-k+1] + m); } cout \u0026lt;\u0026lt; (res == 1e9 ? -1 : res) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   高维偏序 bitset可以用来解决高维偏序问题，高维问题一般如下：\n题意\n给定 $n$ 个元素，第 $i$ 个元素有 $D$ 个属性 $p_{i,1}, p_{i,2} \u0026hellip; p_{i,D}$。\n给定 $Q$ 个询问，每次询问给定一个元素，有 $D$ 个属性 $q_1,q_2,\u0026hellip;,q_D$，回答有多少个元素使得每个属性都 $\\leq q_i$。\n询问强制在线。\n 一般这种问题可以用 bitset 在 $O(\\frac{n^2}{w})$ 的时间内解决。\n首先我们把这些元素复制 $D$ 份，分别储存每种元素。然后分别根据这个元素进行 sort，得到 $D$ 个sort后的数组，数组内储存了这个属性的值，和它原来的index。\n然后，对于sort后的数组的每个位置 $i$，我们都可以知道它前面有哪些 index，就代表对于这个属性，$\\leq$ 这个属性的值的index的集合。\n所以我们在询问的时候，对于每一个询问，可以将 $q_i$ 在第 $i$ 个属性的数组中进行二分，找到它的位置，然后求出它前面的集合 index，然后将它们 AND 起来，就可以得到有哪些 index 的所有属性都 $\\leq$ 它了。\n但由于 $n=10^5$，所以我们不能预处理出每个位置前面的 index 的集合，于是我们使用分块。\n对于每一个块，预处理这个块中所有index的集合，然后维护一个数组 bitset\u0026lt;maxn\u0026gt; f[3][320]，其中 f[i][j] 代表第 $i$ 维度，前 $j$ 个block形成的index的集合bitset。\n这样每次查询的时候，只需要 $O(1)$ 找到对应的块，然后再 $O(\\sqrt n)$ 的时间把零散的部分加上即可。\n总的复杂度就是 $O(Dq(\\log n + \\sqrt n + \\frac{n}{w})) = O(D\\frac{qn}{w})$\n例1 洛谷P3810【模板】三维偏序（陌上花开） 题意\n给定 $n$ 个元素，每个元素有 $a_i,b_i,c_i$ 三个属性，设 $f(i)$ 表示 $a_j \\leq a_i, b_j \\leq b_i, c_j \\leq c_i, i \\neq j$ 的数量。\n对于 $d \\in [0, n-1]$，求 $f(i)=d$ 的数量。\n其中，$n \\leq 10^5, a_i,b_i,c_i \\in [1, 2 \\times 10^5]$。\n 题解 同上。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Node { int val, idx; bool operator\u0026lt;(const Node\u0026amp; other) const { if (val == other.val) return idx \u0026lt; other.idx; return val \u0026lt; other.val; } } a[3][maxn]; bitset\u0026lt;maxn\u0026gt; f[3][320]; // f[i][j]: 第i维度，前j个block形成的bitset struct Info { int val[3]; } ori[maxn]; int res[maxn]; int n, m, B, qval[3]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; B = max(50, (int)sqrt(n)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; 3; j++) { cin \u0026gt;\u0026gt; a[j][i].val; ori[i].val[j] = a[j][i].val; a[j][i].idx = i; } } for (int j = 0; j \u0026lt; 3; j++) { sort(a[j]+1, a[j]+n+1); int l = 1, r = min(n, l+B-1); // [1,B] -\u0026gt; 1, [B+1, 2B] -\u0026gt; 2 ... for (l = 1; l \u0026lt;= n; l = r+1) { r = min(n, l+B-1); int b = (l-1) / B + 1; f[j][b] = f[j][b-1]; // 记录前缀bitset for (int i = l; i \u0026lt;= r; i++) { int idx = a[j][i].idx; f[j][b][idx] = 1; } } } for (int k = 1; k \u0026lt;= n; k++) { for (int j = 0; j \u0026lt; 3; j++) qval[j] = ori[k].val[j]; bitset\u0026lt;maxn\u0026gt; ans; ans.set(); for (int j = 0; j \u0026lt; 3; j++) { int p = upper_bound(a[j]+1, a[j]+n+1, Node{qval[j], 10000000}) - a[j] - 1; int b = (p-1) / B + 1; // 所属的block，所以加上 b-1对应的前缀 bitset\u0026lt;maxn\u0026gt; S = f[j][b-1]; // 第 b 个block对应的是 l = (b-1) * B + 1, r = p for (int i = (b-1) * B + 1; i \u0026lt;= p; i++) { S[a[j][i].idx] = 1; } ans \u0026amp;= S; } res[ans.count() - 1]++; } for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } int main() { solve(); }   bitset结合莫队 在一些题目中，我们需要在一个区间内回答询问，这种询问需要使用bitset，就可以用莫队结合bitset。\n例1 洛谷P5355 [Ynoi2017] 由乃的玉米田 题意\n给定一个长度为 $n$ 的数组，和 $m$ 个询问。\n每次询问为 $op,l,r,x$：\n op = 1：回答区间 $[l,r]$ 之间是否存在两个数 $a,b$，使得 $a-b=x$。 op = 2：回答区间 $[l,r]$ 之间是否存在两个数 $a,b$，使得 $a+b=x$。 op = 3：回答区间 $[l,r]$ 之间是否存在两个数 $a,b$，使得 $a*b=x$。 op = 4：回答区间 $[l,r]$ 之间是否存在两个数 $a,b$，使得 $a/b=x$（整除，不能有余数）。  在 $[l,r]$ 里选的两个数可以重复。\n其中，$n,m \\leq 10^5, 1 \\leq a_i \\leq 10^5$。\n 题解 因为数字可以重复选，所以一个区间内我们只关心某个数是否出现过，出现几次不用管。\n首先利用莫队离线所有的询问，然后对于每一个区间 $[l,r]$ 我们都可以知道有哪些数字出现在了这个区间内。\n对于第一种询问，如果 $a-b = x$，那么 $b=a-x$，这说明只要存在 $a$，使得 $a, a-x$ 同时出现在这个区间内即可。\n所以只要维护 bitset\u0026lt;maxn\u0026gt; f 表示这个区间出现的数，然后求 f \u0026amp; (f \u0026gt;\u0026gt; x) 是否有 $1$ 即可。\n对于第二种询问，如果 $a+b = x$，我们希望把 $b$ 的符号反过来，所以我们定义 $N=10^5$（值域的最大值），然后令 $b' = N-b$，有 $a+N-b' = x$，所以得到 $b' = a+N-x$。注意到，$b'$ 对应的 bitset 是 $f$ 反过来的版本 $g$，所以我们只要检查 f \u0026amp; (g\u0026gt;\u0026gt;(N-x)) 是否有 $1$ 即可。\n 第三和第四种询问不再需要 bitset 和莫队了。\n对于第三种询问，可以直接暴力枚举 $x$ 的所有因数（只有 $\\sqrt n$ 个）。\n对于第四种询问，不能枚举 $x$ 的倍数了，复杂度太高。\n我们可以值域分块来处理 $x$：\n 当 $x \u0026gt; \\sqrt {10^5}$ 时，可以暴力枚举倍数。 $x \\leq \\sqrt {10^5} \\approx 315$ 时，可以对于每一个 $x$ 都预处理，如下：  我们可以对于每一个 $x$，都 $O(n)$ 预处理出每个 $i$，$a_i$ 对应的右侧距离它最近的 $a_j$ 使得 $a_j = xa_i$ 或者 $a_j = \\frac{a_i}{x}$。我们预处理出来的这个数组叫 nxt[i]。\n所以每次询问 $[l,r]$ 的时候，只要看 $[l,r]$ 内的最小值是否 $\\leq r$ 即可。\n于是，使用 ST 表？（然后愉快的T了）。\n再仔细观察一下，我们并不需要查询 $[l,r]$ 内的最小值，只需要查询 $[l,n]$ 的最小值即可，因为 $[r+1, n]$ 这部分的 nxt[] 肯定不会 $\\leq r$，所以不会有影响，这样维护一个后缀最小值即可，所以是 $O(n)$ 的。\n• 每一个 $x$ 都要预处理，所以是 $O(315n)$ 的。\n 最终的复杂度：\n 分块 + 莫队: $O(n \\sqrt n)$。 预处理因数：$O(n \\sqrt n)$。 回答前两种询问：$O(\\frac{nq}{w})$。 预处理除法操作的 nxt[]：$O(315n)$。  总复杂度为 $O(n\\sqrt n + \\frac{nq}{w} + 315n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int N = 1e5; int n, m, ans[maxn], a[maxn], l = 1, r = 0, B; int bin[maxn], nxt[maxn]; // nxt[x][i]: 对于位置 i，在它右侧，离它最近的 j 使得 a_j = x * a_i 或者 a_j = a_i / x struct Query { int op, l, r, x, id; bool operator\u0026lt;(const Query\u0026amp; other) const { int b1 = (l - 1) / B, b2 = (other.l - 1) / B; if (b1 == b2) { return r \u0026lt; other.r; } return b1 \u0026lt; b2; } } q[maxn]; vector\u0026lt;Query\u0026gt; q4[320]; // 储存第四种询问 bitset\u0026lt;maxn\u0026gt; f, g; // f: 代表当前区间内所有出现的 x，g 代表 N-x int cnt[maxn]; void add(int p) { int x = a[p]; cnt[x]++; f[x] = 1, g[N-x] = 1; } void del(int p) { int x = a[p]; cnt[x]--; if (cnt[x] == 0) { f[x] = 0, g[N-x] = 0; } } vector\u0026lt;int\u0026gt; fac[maxn]; int pos[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; B = max(10, (int)sqrt(n)); for (int i = 1; i \u0026lt;= N; i++) { for (int j = i; j \u0026lt;= N; j += i) { fac[j].push_back(i); } } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].op \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r \u0026gt;\u0026gt; q[i].x; q[i].id = i; } sort(q+1, q+m+1); for (int i = 1; i \u0026lt;= m; i++) { if (q[i].op == 4 \u0026amp;\u0026amp; q[i].x \u0026lt;= B) { q4[q[i].x].push_back(q[i]); continue; // 不处理 } int ql = q[i].l, qr = q[i].r; while (r \u0026lt; qr) add(++r); while (r \u0026gt; qr) del(r--); while (l \u0026lt; ql) del(l++); while (l \u0026gt; ql) add(--l); int op = q[i].op, x = q[i].x; bool ok = 0; if (op == 1) { // a-b = x // 查询是否有 a, a-x 同时存在 ok = (f \u0026amp; (f\u0026gt;\u0026gt;x)).any(); } else if (op == 2) { // a+b = x ok = (f \u0026amp; (g\u0026gt;\u0026gt;(N-x))).any(); } else if (op == 3) { // a*b = x for (int j : fac[x]) { if (f[j] \u0026amp;\u0026amp; f[x/j]) { ok = 1; break; } } } else { // a/b = x assert(x \u0026gt; B); for (int j = 1; j * x \u0026lt;= 1e5; j++) { if (f[j] \u0026amp;\u0026amp; f[j*x]) { ok = 1; break; } } } ans[q[i].id] = ok; } for (int x = 1; x \u0026lt;= B; x++) { if (!q4[x].size()) continue; // 没有询问，不用build了 fill(pos, pos+maxn, n+1); fill(nxt, nxt+maxn, n+1); for (int i = n; i \u0026gt;= 1; i--) { int v = a[i]; pos[v] = i; if (v * x \u0026lt;= 1e5) nxt[i] = min(nxt[i], pos[v * x]); if (v % x == 0) nxt[i] = min(nxt[i], pos[v / x]); nxt[i] = min(nxt[i], nxt[i+1]); } for (auto [op, l, r, x, id] : q4[x]) { bool ok = (nxt[l] \u0026lt;= r); ans[id] = ok; } } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;yuno\u0026quot; : \u0026quot;yumi\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   bitset 优化二分图匹配 bitset 在加上一些诡异的优化后，可以在 $n=7000$ 的情况下 $O(n^3)$ 跑出二分图最大匹配。\n例1 Universal Cup 12 M.Colorful Graph 题意\n给定一个 $n$ 个点，$m$ 条边的有向图。\n现在需要将所有的点染色 $c_i$，在染色后，保证对于任意两个节点 $i,j$，如果 $c_i=c_j$，那么有\n$i$ 能够到达 $j$ 或者 $j$ 能够到达 $i$。\n求一个染色方案，使得总颜色数量最小，并且输出这个方案。\n其中，$n,m \\leq 7000$，时间限制 $8$ 秒，空间限制 $64$ MB。\n 题解 首先 SCC 缩点，缩点后得到一个DAG，我们知道在同一个 SCC 内的颜色肯定相同。\n然后变成 DAG 中可以相交的最小路径覆盖，我们记得可相交的最小路径覆盖需要对于每一个 $i,j$，如果 $i$ 能够到达 $j$ 那么连 $i \\rightarrow j$ 这条边。\n但这样的话总共有 $O(n^2)$ 条边，这题卡空间，很明显过不了。\n于是考虑用 bitset 优化空间，然后可达性就用闭包来 $O(\\frac{n^3}{w})$ 传递即可。\n这样可以得到一个 bitset\u0026lt;maxn\u0026gt; f[maxn] 来表达一个邻接矩阵。\n 然后解决最小路径覆盖问题，用最大匹配，但最大匹配是 $O(n^3)$ 的明显会T。\n我们有三个优化：\n  注意到在最大匹配里，有 vis[] 数组来表示这个右侧点在这一轮是否被访问过，\n我们可以用一个 bitset\u0026lt;maxn\u0026gt; can 也来表达这个意思。can[j] = 1 代表这个右侧点可以在这一轮被使用。\n  在最大匹配中，我们枚举了所有的边 $(i,j)$，并且check是否有 $j$ 被 visit 过。\n在 bitset 中，我们可以直接用 can 筛选掉所有用不上的边（bitset\u0026lt;maxn\u0026gt; F = (f[i] \u0026amp; can);），然后利用 for (int j = F._Find_first(); j \u0026lt; F.size(); j = F._Find_next(j)) 枚举边。\n  如果这一轮匹配未成功，代表没有边发生变化，也就意味着如果右侧点 $j$ 在上一轮匹配失败了，那么这一轮一定也会匹配失败。\n所以，若当前这一轮匹配并未成功，我们无需重置 can。\n  • 以上三个优化缺一不可，少了一个就会 T。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 7002; int n, m; vector\u0026lt;int\u0026gt; adj[maxn]; struct Tarjan { int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int to : adj[u]) { if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 要记得在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; // 记得这里，将在栈中的标记去掉 } tail--; in[u] = 0; // 记得这里，将在栈中的标记去掉 } } // 跑tarjan void solve() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } } tj; bitset\u0026lt;maxn\u0026gt; f[maxn], can; pii ed[maxn]; int match[maxn], id = 0; bool dfs(int i) { bitset\u0026lt;maxn\u0026gt; F = (f[i] \u0026amp; can); // 优化1: 筛选出有用的边 for (int j = F._Find_first(); j \u0026lt; F.size(); j = F._Find_next(j)) { // 优化2: 不考虑不存在的边 can[j] = 0; if (!match[j] || dfs(match[j])) { match[j] = i; return 1; } } return 0; } int color[maxn], pre[maxn], nxt[maxn], ans[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); ed[i] = {u, v}; } tj.solve(); for (int i = 1; i \u0026lt;= m; i++) { int u = ed[i].first, v = ed[i].second; int fu = tj.from[u], fv = tj.from[v]; if (fu == fv) continue; f[fu][fv] = 1; } int N = tj.scc; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= N; j++) { if (f[j][i]) f[j] |= f[i]; } } can.set(); for (int i = 1; i \u0026lt;= N; i++) { if (dfs(i)) can.set(); // 优化3: 只有在匹配成功时，才重置 can } int c = 0; for (int i = 1; i \u0026lt;= N; i++) { if (match[i]) { nxt[match[i]] = i; pre[i] = match[i]; } } for (int i = 1; i \u0026lt;= N; i++) { if (!pre[i]) { int j = i; ++c; while (j) { color[j] = c; j = nxt[j]; } } } for (int i = 1; i \u0026lt;= n; i++) { ans[i] = color[tj.from[i]]; cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2023-03-30T22:13:18-05:00","permalink":"https://tom0727.github.io/post/103-bitset/","tags":["bitset",""],"title":"Bitset优化"},{"categories":["算法"],"contents":"模版 代码 // sa[i]：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 sa[i] 这个后缀）。 // rk[i]：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 rk[i]）。 // height[i]: LCP(sa[i-1], sa[i])，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度 struct SA { int n, sa[maxn], rk[maxn\u0026lt;\u0026lt;1], oldrk[maxn\u0026lt;\u0026lt;1], cnt[maxn], id[maxn], key1[maxn], height[maxn]; // 注意 rk[maxn\u0026lt;\u0026lt;1] oldrk[maxn\u0026lt;\u0026lt;1] char s[maxn]; int m = 127; bool cmp(int i, int j, int w) { return oldrk[i] == oldrk[j] \u0026amp;\u0026amp; oldrk[i+w] == oldrk[j+w]; } void init(string\u0026amp; ss) { n = ss.size(); // LOG(n); for (int i = 1; i \u0026lt;= n; i++) s[i] = ss[i-1]; for (int i = 1; i \u0026lt;= n; i++) rk[i] = s[i], cnt[rk[i]]++; for (int i = 1; i \u0026lt;= m; i++) cnt[i] += cnt[i-1]; for (int i = n; i \u0026gt;= 1; i--) sa[cnt[rk[i]]--] = i; int p = 0; // 当前值域 for (int w = 1; w \u0026lt;= n; w \u0026lt;\u0026lt;= 1) { // 注意中间没有break的条件 p = 0; for (int i = n; i \u0026gt; n-w; i--) id[++p] = i; for (int i = 1; i \u0026lt;= n; i++) { if (sa[i] \u0026gt; w) id[++p] = sa[i] - w; } memset(cnt, 0, sizeof(cnt)); for (int i = 1; i \u0026lt;= n; i++) key1[i] = rk[id[i]], cnt[key1[i]]++; for (int i = 1; i \u0026lt;= m; i++) cnt[i] += cnt[i-1]; for (int i = n; i \u0026gt;= 1; i--) sa[cnt[key1[i]]--] = id[i]; memcpy(oldrk+1, rk+1, n*sizeof(int)); p = 0; for (int i = 1; i \u0026lt;= n; i++) { rk[sa[i]] = cmp(sa[i], sa[i-1], w) ? p : (++p); } if (p == n) { for (int i = 1; i \u0026lt;= n; i++) sa[rk[i]] = i; break; } m = p; } // 求 height int k = 0; for (int i = 1; i \u0026lt;= n; i++) { if (rk[i] == 0) continue; if (k \u0026gt; 0) k--; while (s[i+k] == s[sa[rk[i]-1]+k]) k++; height[rk[i]] = k; } } } sa; int n; int main() { cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; sa.init(s); ll ans = (ll)(n) * (n+1) / 2; for (int i = 1; i \u0026lt;= n; i++) ans -= sa.height[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   介绍 后缀数组可以对一个字符串的所有后缀进行排序，然后得到一些有用的信息。\n在处理出后缀数组后，我们会得到以下数组：\n sa[i]：所有的后缀排序后，第 $i$ 小的后缀的编号。（排第 $i$ 名的是 sa[i] 这个后缀）。 rk[i]：后缀 $i$ 的排名。（第 $i$ 个后缀的排名是 rk[i]）。 height[i]: LCP(sa[i-1], sa[i])，即第 $i-1$ 名的后缀和 第 $i$ 名的后缀的最长公共前缀长度。  算法 暴力的思路是求出所有后缀，然后排序，复杂度是 $O(n^2 \\log n)$。\n利用倍增可以在 $O(n \\log n)$ 求出后缀数组。\n如上图，我们先比较每个后缀的第一个字符。\n这样我们可以得到第一个字符的排序（注意这个例子和上面那个不同了）。\n接下来比较第二个字符，这样和第一个字符的排序结合起来，可以得到一个双关键字的排序。\n双关键字排序后，又可以得到一个排名，然后注意到此时每个排名都代表 $2$ 个字符长度的排名。\n所以两个排名结合起来就对应了 $4$ 个字符长度的排名，于是就可以利用倍增继续双关键字排序，如下：\n例题 例1 洛谷P2408 不同子串个数 题意\n给定一个长度为 $n$ 的字符串 $s$，求 $s$ 内不同的子串个数。\n其中，$n \\leq 10^5$。\n 题解 答案就是 全部子串数量 $- \\sum\\limits_{i=2}^n height[i]$。\n考虑排序后排名第 $i$ 的后缀（长度为 $m$）贡献了哪些新的子串，有且仅有 $m - height[i]$。\n因为跟排名 $i-1$ 的后缀比较，新贡献的肯定是这么多。\n如果贡献的数量 $\u0026lt; m - height[i]$，说明这个后缀的前缀在之前的某一个位置出现过了，这说明 $LCP(j, i) \u0026gt; height[i]$，其中 $j \u0026lt; i-1$，这与 $LCP(j,i) = \\min\\limits_{k=j+1}^i height[k]$ 冲突了。\n 代码 同模版。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int main() { cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; sa.init(s); ll ans = (ll)(n) * (n+1) / 2; for (int i = 1; i \u0026lt;= n; i++) ans -= sa.height[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 洛谷P2870 [USACO07DEC]Best Cow Line G 题意\n给定一个长度为 $n$ 的字符串 $s$，每次可以从 $s$ 的首部和尾部字符中选一个出来，直到 $s$ 为空，求能够获得的字典序最小的字符串。\n其中，$n \\leq 5 \\times 10^5$。\n 题解 当首尾字符不一样时，肯定选较小的那个。\n当首尾字符一样时，我们就继续看第 $2$ 个和第 $n-1$ 个字符，如果还是一样就继续对比，直到第一个不一样的为止。\n但这样是 $O(n^2)$ 的。\n我们观察一下可以发现，首尾字符一样时，本质是比较 $s$ 的一个后缀，和 $s'$ (反过来的 $s$) 的一个后缀的大小。\n那么比较两个字符串的后缀的大小，我们在后缀数组里可以 $O(1)$ 做到。\n将两个字符串拼在一起的方法是 s + '@' + s'，其中 @ 是一个比所有字符都小的字符，这样保证它在后缀数组中不会影响到 $s,s'$ 后缀的计算。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; string s, ans; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { char c; cin \u0026gt;\u0026gt; c; s += c; } string t = s; s += (char)('A' - 1); reverse(t.begin(), t.end()); s += t; sa.init(s); int i = 1, j = n; while (i \u0026lt;= j) { if (s[i-1] \u0026lt; s[j-1]) ans += s[i-1], i++; else if (s[i-1] \u0026gt; s[j-1]) ans += s[j-1], j--; else { // 比较 s[i] 开始的后缀和 t[2n+2-j] 开始的后缀的大小 if (sa.rk[i] \u0026lt; sa.rk[2*n+2-j]) ans += s[i-1], i++; else ans += s[j-1], j--; } } int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; ans[i]; if (++cnt == 80) cnt = 0, cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2023-03-22T11:30:39-05:00","permalink":"https://tom0727.github.io/post/102-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","tags":["",""],"title":"后缀数组"},{"categories":["算法"],"contents":"介绍 二维ST表就是在一维的ST表上加一个维度，这样可以 $O(nm\\log n \\log m)$ 内预处理以后，$O(1)$ 询问一个矩阵的最大/最小值。\n例题 例1 洛谷P2216[HAOI2007]理想的正方形 题意\n给定一个 $n \\times m$ 的矩阵，每个位置有一个非负整数，给定 $k$，找出一个 $k \\times k$ 的正方形使得正方形内最大值和最小值的差值最小。\n其中，$n,m \\leq 1000$。\n 题解 二维 ST 表，由于是找正方形，所以只用维护额外一个维度，即：\nst[i][j][k] 代表以 $(i,j)$ 为左上角，以 $(i+2^k-1, j+2^k-1)$ 为右下角的矩阵的最大/最小值。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e3+5; int st1[maxn][maxn][12], st2[maxn][maxn][12]; int bin[maxn]; int a[maxn][maxn]; int n, m, k; // 查询以 (i,j) 为左上角的 k*k 的矩阵中的最大值 - 最小值 int ask_st(int i, int j) { int l = bin[k]; int res1 = max({st1[i][j][l], st1[i+k-(1\u0026lt;\u0026lt;l)][j][l], st1[i][j+k-(1\u0026lt;\u0026lt;l)][l], st1[i+k-(1\u0026lt;\u0026lt;l)][j+k-(1\u0026lt;\u0026lt;l)][l]}); int res2 = min({st2[i][j][l], st2[i+k-(1\u0026lt;\u0026lt;l)][j][l], st2[i][j+k-(1\u0026lt;\u0026lt;l)][l], st2[i+k-(1\u0026lt;\u0026lt;l)][j+k-(1\u0026lt;\u0026lt;l)][l]}); return res1 - res2; } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) st1[i][j][0] = st2[i][j][0] = a[i][j]; } for (int k = 1; k \u0026lt; 12; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) { for (int j = 1; j + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= m; j++) { st1[i][j][k] = max({st1[i][j][k-1], st1[i+(1\u0026lt;\u0026lt;(k-1))][j][k-1], st1[i][j+(1\u0026lt;\u0026lt;(k-1))][k-1], st1[i+(1\u0026lt;\u0026lt;(k-1))][j+(1\u0026lt;\u0026lt;(k-1))][k-1]}); st2[i][j][k] = min({st2[i][j][k-1], st2[i+(1\u0026lt;\u0026lt;(k-1))][j][k-1], st2[i][j+(1\u0026lt;\u0026lt;(k-1))][k-1], st2[i+(1\u0026lt;\u0026lt;(k-1))][j+(1\u0026lt;\u0026lt;(k-1))][k-1]}); } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; a[i][j]; } build_st(); int ans = 1e9; for (int i = 1; i + k - 1 \u0026lt;= n; i++) { for (int j = 1; j + k - 1 \u0026lt;= m; j++) { ans = min(ans, ask_st(i, j)); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF713D. Animals and Puzzle 题意\n给定一个 $n \\times m$ 的01矩阵。\n给定 $t$ 个询问，每次询问一个矩阵 $x_1,y_1,x_2,y_2$，回答以 $(x_1,y_1)$ 为左上角，$(x_2,y_2)$ 为右下角的矩阵中，最大的全 $1$ 正方形的边长。\n其中，$n,m \\leq 1000, t \\leq 10^6$。\n 题解 首先我们可以利用二分处理出一个数组 dp[i][j]，代表以 $(i,j)$ 作为左上角，最大的全 $1$ 正方形的边长。\n然后对于每次询问 $x_1,y_1,x_2,y_2$，二分一下答案，对于二分到的答案 $k$，我们只需要check一下 $(x_1,y_1,x_2-k+1,y_2-k+1)$ 这个矩阵中，dp 的最大值即可，用二维ST表即可实现 $O(1)$ 查询。\n所以最后总复杂度是 $O(nm \\log(n) \\log(m))$。\n• 记得将 ST 表开成 short，否则炸内存。\n• 记得开快读，否则头都给T飞。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e3+3; int n, m, a[maxn][maxn], sum[maxn][maxn], dp[maxn][maxn]; int getsum(int i1, int j1, int i2, int j2) { return sum[i2][j2] - sum[i2][j1-1] - sum[i1-1][j2] + sum[i1-1][j1-1]; } short st[maxn][maxn][12][12], bin[maxn]; int ask_st(int i1, int j1, int i2, int j2) { int k1 = bin[i2-i1+1], k2 = bin[j2-j1+1]; return max({st[i1][j1][k1][k2], st[i2-(1\u0026lt;\u0026lt;k1)+1][j1][k1][k2], st[i1][j2-(1\u0026lt;\u0026lt;k2)+1][k1][k2], st[i2-(1\u0026lt;\u0026lt;k1)+1][j2-(1\u0026lt;\u0026lt;k2)+1][k1][k2]}); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) st[i][j][0][0] = dp[i][j]; } for (int k1 = 1; k1 \u0026lt; 12; k1++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k1) - 1 \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { st[i][j][k1][0] = max(st[i][j][k1-1][0], st[i+(1\u0026lt;\u0026lt;(k1-1))][j][k1-1][0]); } } } for (int k2 = 1; k2 \u0026lt; 12; k2++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j + (1\u0026lt;\u0026lt;k2) - 1 \u0026lt;= m; j++) { st[i][j][0][k2] = max(st[i][j][0][k2-1], st[i][j+(1\u0026lt;\u0026lt;(k2-1))][0][k2-1]); } } } for (int k1 = 1; k1 \u0026lt; 12; k1++) { for (int k2 = 1; k2 \u0026lt; 12; k2++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k1) - 1 \u0026lt;= n; i++) { for (int j = 1; j + (1\u0026lt;\u0026lt;k2) - 1 \u0026lt;= m; j++) { st[i][j][k1][k2] = max({st[i][j][k1-1][k2-1], st[i+(1\u0026lt;\u0026lt;(k1-1))][j][k1-1][k2], st[i][j+(1\u0026lt;\u0026lt;(k2-1))][k1][k2-1], st[i+(1\u0026lt;\u0026lt;(k1-1))][j+(1\u0026lt;\u0026lt;(k2-1))][k1-1][k2-1]}); } } } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; a[i][j]; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (!a[i][j]) dp[i][j] = 0; else { int low = 1, high = min(n-i+1, m-j+1), res = 1; while (low \u0026lt;= high) { int mid = (low+high) \u0026gt;\u0026gt; 1; if (getsum(i, j, i+mid-1, j+mid-1) == mid*mid) { res = mid; low = mid+1; } else high = mid - 1; } dp[i][j] = res; } } } build_st(); int t; cin \u0026gt;\u0026gt; t; while (t--) { int i1, j1, i2, j2; cin \u0026gt;\u0026gt; i1 \u0026gt;\u0026gt; j1 \u0026gt;\u0026gt; i2 \u0026gt;\u0026gt; j2; if (!getsum(i1,j1,i2,j2)) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } int low = 1, high = min(i2-i1+1, j2-j1+1), res = 1; while (low \u0026lt;= high) { int k = (low + high) \u0026gt;\u0026gt; 1; if (ask_st(i1,j1,i2-k+1,j2-k+1) \u0026gt;= k) { res = k; low = k+1; } else high = k-1; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2023-03-21T23:33:04-05:00","permalink":"https://tom0727.github.io/post/101-%E4%BA%8C%E7%BB%B4st%E8%A1%A8/","tags":["",""],"title":"二维ST表"},{"categories":["解题报告"],"contents":"C. Constellations 题意\n二维平面中有 $n$ 个点，一开始每个点都属于自己的一组。\n有 $n-1$ 轮合并过程，每次合并选择距离最近的两组点进行合并，两组点 $A,B$ 之间的距离定义为：\n$$d(A,B) = \\frac{1}{|A||B|} \\sum\\limits_{a \\in A} \\sum\\limits_{b \\in B} ||a-b||^2$$\n其中距离为普通的欧式距离定义，$a,b$ 为 $A,B$ 中的点。\n如果距离最近的有多组点，那么选择最老的组优先合并。\n每次合并后，输出合并后得到的组的大小。\n其中，$2 \\leq n \\leq 2000, x_i,y_i \\in [-1000,1000]$。\n 题解 一眼并查集，但怎么做呢？\n每一步我们需要得到现在最近的两组点，我们首先可以发现，如果我们定义\n$$D(A,B) = \\sum\\limits_{a \\in A} \\sum\\limits_{b \\in B} ||a-b||^2$$\n那么有 $D(A+B, C) = D(A,C) + D(B,C)$，所以我们在合并两个组 $A,B$ 后，可以暴力枚举剩下的所有组 $C$，然后计算 $D(A+B, C)$。\n剩下的就是快速选择距离最小的组进行合并了，我们不妨用 pq 来维护所有组之间的距离 $D(A,B)$。\n• 但直接用并查集并不能做，因为我们在合并了两个组 $A,B$ 后，所有和 $A,B$ 相关的pair都需要得到更新，但这是无法做到的。\n所以我们考虑 创造新点。\n每当我们合并 $A,B$ 两个组，就创建一个新点叫 $E$，然后我们将 $A,B$ 标记为不存在，每次从 pq 里 pop 出新的pair时，check一下这个pair中是否有不存在的点，如果有就直接忽略。\n这样甚至都不需要并查集，因为每次合并后一定是parent存在，剩下的不存在，所以存在的点有且仅有可能是parent。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4e3+5; int sz[maxn]; int id; ll dis[maxn][maxn]; ll getdis(int a, int b) { return dis[min(a,b)][max(a,b)]; } struct Node { ll d; int a, b; bool operator\u0026lt;(const Node\u0026amp; other) const { int na = other.a, nb = other.b; ll d1 = d * sz[na] * sz[nb], d2 = other.d * sz[a] * sz[b]; if (d1 == d2) { return (pii){min(a,b), max(a,b)} \u0026gt; (pii){min(na,nb), max(na,nb)}; } return d1 \u0026gt; d2; } }; int n, x[maxn], y[maxn]; priority_queue\u0026lt;Node\u0026gt; pq; inline ll sq(int x) {return x*x;} ll cal(int i, int j) { return sq(x[i] - x[j]) + sq(y[i] - y[j]); } bool alive[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) sz[i] = 1, cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i+1; j \u0026lt;= n; j++) { dis[i][j] = cal(i,j); pq.push({cal(i,j), i, j}); } } fill(alive+1, alive+n+1, 1); int cnt = 0; int cur = n; while (cnt \u0026lt; n-1) { Node nd = pq.top(); pq.pop(); if (getdis(nd.a,nd.b) != nd.d) continue; int a = nd.a, b = nd.b; if (!alive[a] || !alive[b]) continue; sz[++cur] = sz[a] + sz[b]; alive[a] = alive[b] = 0; alive[cur] = 1; for (int c = 1; c \u0026lt; cur; c++) { if (!alive[c]) continue; dis[c][cur] = getdis(a, c) + getdis(b, c); pq.push({dis[c][cur], c, cur}); } cout \u0026lt;\u0026lt; sz[cur] \u0026lt;\u0026lt; endl; cnt++; } }   F. Differences 题意\n给定 $n$ 个长度为 $m$ 的string，每个string只由 $ABCD$ 组成。\n给定一个正整数 $k$，它们之中有且仅有一个 string $s_i$，使得\n$$\\forall j \\neq i, \\text{diff}(s_i,s_j) = k$$\n找出这个 string $s_i$。\n其中，$n,m \\leq 10^5, n*m \\leq 2\\times 10^7$。\n 题解 哈希的神奇用法。\n 看这张图，我们可以预处理出每一列选了 $A,B,C,D$ 的index。\n比如在图上，第 $0,2$ 个string分别为 $AB,AB$，所以 $j=0$ 的时候 $f(0,A) = \\{0,2\\}$，同理 $f(0,C) = \\{3,4,5\\}$\n我们可以知道 $F = f(j,A) + f(j,B) + f(j,C) + f(j,D) = \\{0,1,2,\u0026hellip;,n-1\\}$\n所以我们枚举每一位 $j$ 选择的字母 $m$ 时，就可以得到一个mask $F - f(j,m)$，我们将每一位的mask加起来可以得到一个总的mask。\n我们只要这个mask $= [k,k,k,\u0026hellip;0,k,k,k]$ （第 $i$ 位为 $0$ 即可）。\n 怎么表示一个mask呢？用哈希！\n比如 $\\{0,2\\}$ 就表示为 $p^0 + p^2$\n所以只要最后得到的mask等于 $k * (p^0+p^1+\u0026hellip;+p^{n-1}) - k * p^i$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m,k; string s[maxn]; Z f[maxn][4]; // f[i][j]: 第i列选字母j的mask int p = 31; Z p2[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s[i]; } p2[0] = 1; for (int i = 1; i \u0026lt;= 1e5; i++) p2[i] = p2[i-1] * p; Z all = 0; for (int i = 1; i \u0026lt;= n; i++) all += p2[i]; for (int j = 0; j \u0026lt; m; j++) { for (int i = 1; i \u0026lt;= n; i++) { int o = s[i][j] - 'A'; f[j][o] += p2[i]; } for (int o = 0; o \u0026lt; 4; o++) f[j][o] = all - f[j][o]; } for (int i = 1; i \u0026lt;= n; i++) { // tar: k * p^1 + k * p^2 + ... + k * p^n - k * p^i Z tar = (all - p2[i]) * k; for (int j = 0; j \u0026lt; m; j++) { int o = s[i][j] - 'A'; tar -= f[j][o]; } if (tar.val() == 0) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } } }   ","date":"2023-03-19T22:24:00-05:00","permalink":"https://tom0727.github.io/post/100-universal8/","tags":["",""],"title":"Universal Cup 8 (Slovenia)"},{"categories":["算法"],"contents":"介绍 二项式反演是一种特殊的容斥，用来解决 \u0026ldquo;恰好选 $k$ 个的方案有多少种\u0026rdquo; 的问题。\n一般，我们可以求出 \u0026ldquo;至多/至少选 $k$ 个的方案有多少种\u0026rdquo; 的问题，由此可以得出恰好选 $k$ 个有多少种。\n公式 设 $g_k$ 表示 至多 选 $k$ 个的方案数，$f_k$ 表示恰好选 $k$ 个的方案数。\n$$f_k = \\sum\\limits_{i=0}^k (-1)^{k-i}C_k^i g_i$$\n设 $g_k$ 表示 至少 选 $k$ 个的方案数，$f_k$ 表示恰好选 $k$ 个的方案数。\n$$f_k = \\sum\\limits_{i=k}^n (-1)^{i-k}C_i^k g_i$$\n其中，$n$ 是物品的总数量。\n证明见这里。\n例题 例1 错排问题 题意\n求长度为 $n$ 的错排 permutation 的数量。\n一个permutation 是错排permutation，当且仅当它不存在 $i$ 使得 $p_i=i$。\n 题解 求出 $g_i$ 代表最多有 $i$ 个 fixed point的数量，就有 $g_i = C_n^i (n-i)!$。\n然后让 $f_i$ 为恰好有 $i$ 个 fixed point的数量。\n求 $f_0$ 即可，复杂度为 $O(n)$。\n 例2 CF1342E 题意\n给定一个 $n \\times n$ 的国际象棋棋盘，要放 $n$ 个车在棋盘上，使得：\n 每个点都被覆盖到。 恰好有 $k$ 对车互相攻击（两个车互相攻击当且仅当两个车能直接攻击，比如中间隔了一个车就不算）。  求方案数，对 998244353 取模。\n其中，$1 \\leq n \\leq 200000, 0 \\leq k \\leq \\frac{n(n-1)}{2}$。\n 题解 首先，每个点都要被覆盖到说明要么每一行都有车，要么每一列都有车，并且这两种不能同时存在，除非 $k=0$。\n所以我们假设每一行都有车，答案 $*2$ 即可（因为棋盘翻转一下就是每一列都有车了）。\n现在每一行都有车了，可以发现要恰好 $k$ 对车互相攻击，我们需要恰好把这些车放进 $n-k$ 列。\n但这样还是不好算，所以考虑二项式反演。\n设 $g(i)$ 为：至少有 $i$ 个冲突（也就是至多放进 $n-i$ 列）中的方案数。\n则 $g(i) = C_{n}^{n-i} * (n-i)^n$。\n解释：先从 $n$ 列里面选择 $n-i$ 列，得到 C_{n}^{n-i}，然后每一行对应一个车，这个车可以放进选择的 $n-i$ 列里的任何一个，所以是 $(n-i)^n$。\n然后根据\n$$f_k = \\sum\\limits_{i=k}^n (-1)^{i-k}C_i^k g_i$$\n容斥即可，答案为 $f_k*2$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; Z fac[maxn], ifac[maxn]; Z C(int a, int b) { if (a \u0026lt; b) return 0; return fac[a] * ifac[b] * ifac[a-b]; } int n; ll k; Z g(int i) { return C(n, n-i) * qpow(Z(n-i), n); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; k %= mod; fac[0] = ifac[0] = 1; for (int i = 1; i \u0026lt;= 2e5; i++) fac[i] = fac[i-1] * i; ifac[maxn-5] = 1/fac[maxn-5]; for (int i = 2e5-1; i \u0026gt;= 1; i--) ifac[i] = ifac[i+1] * (i+1); if (k == 0) { cout \u0026lt;\u0026lt; fac[n] \u0026lt;\u0026lt; endl; return 0; } Z ans = 0; for (int i = k; i \u0026lt;= n; i++) { ans = ans + (((i-k)\u0026amp;1) ? -1 : 1) * C(i, k) * g(i); } cout \u0026lt;\u0026lt; ans*2 \u0026lt;\u0026lt; endl; }   ","date":"2023-03-12T22:40:28-05:00","permalink":"https://tom0727.github.io/post/099-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","tags":["数学","容斥"],"title":"二项式反演"},{"categories":["解题报告"],"contents":"G. Rafting Trip 题意\n给定一个 $n \\times m$ 的网格，每个网格要么是河流，要么是陆地。\n如果是河流，那么它一定是上下左右四个方向之一，代表走到这个位置，下一个位置就会被冲到对应方向一格的位置。\n如果是陆地，要么是空地，要么是一个观光点。\n我们可以选定从一个点出发，顺着河流的流向前进，当我们走到陆地/场地外/一个走过的点时，将会结束旅程。\n旅程中，如果我们在河流上，并且邻居有观光点，那么我们可以记录这个观光点。\n对于所有的出发点，求最优的出发点，使得旅程中记录到的观光点最多（每个观光点不能被重复记录）。\n其中，$n,m \\leq 500$。\n 题解 注意到如果是河流，只会有上下左右四个方向。所以每个点只有至多1个出边。这说明什么？基环树！（更准确的说是基环森林）。\n虽然这题是有向边，但处理基环树我们直接当无向边做就可以了。\n所以我们先建无向图，只考虑河流，陆地就直接忽略。\n然后我们先找到基环树中的环，然后缩点，这样就得到一个树了。以环作为根，跑 dfs 即可。\n如果没有环，就取一个没有出边的点作为根。\n• 这样看起来 dfs 的过程是跑了反向的边，但实际上为了统计这个观光点，必须按照反向的顺序来。\n• 缩点后不用重新建图，建一个新点即可，注意新点向被缩的点的邻居们连边，要check一下不能连到环上的点。\n 基环树找环-注意事项\n然后是需要特别注意的基环树找环问题。\n注意到这个题目，基环树可能会有大小为 $2$ 的环，这样就会有重边了。\n所以我们在第一次dfs找环时，不能直接记录 parent 的 vertex。\n而是应该记录 parent 的边，并且用前向星建图。\n举个例子，1-\u0026gt;2, 2-\u0026gt;1。\n如果我们用 if (par[v] == u) continue; 的话，到了 2 时就会直接忽略掉 1。然后回到 1 的时候，由于有重边，1会发现 vis[2] = 1;，这样看起来 1 是cycle的终点，2是cycle的起点，实际上是反过来的！\n所以正确的写法是：\nvector\u0026lt;int\u0026gt; cycle, comp; // component: 储存这个联通分量的所有点 void dfs1(int u, int in_edge) { // 这里的参数是 e的编号！ vis[u] = 1; comp.push_back(u); for (int e = head[u]; e; e = edges[e].nxt) { if (e == (in_edge ^ 1)) continue; // 特意处理了大小为2的环，注意这里 (in_edge^1) 需要加括号！ int v = edges[e].to; if (vis[v]) { if (!cycle.size()) { // 只跑一个cycle！因为有重边！ int c = u; while (c != v) { cycle.push_back(c); c = pre[c]; } cycle.push_back(c); for (int j : cycle) iscycle[j] = 1; } } else { pre[v] = u; dfs1(v, e); // 注意这里参数是 e } } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 500+5; const int maxm = (500*500+105) * 2; int n,m; char grid[maxn][maxn]; int id[maxn][maxn]; bool river[maxn][maxn], site[maxn][maxn]; bool ok(int i, int j) { return i \u0026gt;= 1 \u0026amp;\u0026amp; i \u0026lt;= n \u0026amp;\u0026amp; j \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026lt;= m \u0026amp;\u0026amp; river[i][j]; } vector\u0026lt;int\u0026gt; adj[maxm]; vector\u0026lt;int\u0026gt; adj_site[maxm]; int d[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxm], ecnt = 2; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } bool vis[maxm], iscycle[maxm]; int pre[maxm], outdeg[maxm]; vector\u0026lt;int\u0026gt; cycle, comp; // component: 储存这个联通分量的所有点 void dfs1(int u, int in_edge) { vis[u] = 1; comp.push_back(u); for (int e = head[u]; e; e = edges[e].nxt) { if (e == (in_edge ^ 1)) continue; // 特意处理了大小为2的环，注意这里 (in_edge^1) 需要加括号！ int v = edges[e].to; if (vis[v]) { if (!cycle.size()) { int c = u; while (c != v) { cycle.push_back(c); c = pre[c]; assert(c != 0); } assert(c == v); cycle.push_back(c); for (int j : cycle) iscycle[j] = 1; } } else { pre[v] = u; dfs1(v, e); // 注意这里参数是 e } } } int cid = 0; int cnt[maxm], res = 0, ans = 0; void dfs2(int u, int p) { for (int v : adj_site[u]) { if (!cnt[v]) res++; cnt[v]++; } ans = max(ans, res); for (int v : adj[u]) { if (v == p || iscycle[v]) continue; // 已经是cycle的说明被缩点缩掉了，删去 dfs2(v, u); } // 回溯 for (int v : adj_site[u]) { cnt[v]--; if (!cnt[v]) res--; } } void solve(int u) { cycle.clear(); comp.clear(); dfs1(u, 0); int rt = -1; if (cycle.size()) { // 有环 rt = ++cid; for (int v : cycle) { for (int j : adj_site[v]) { adj_site[rt].push_back(j); } for (int nv : adj[v]) { if (!iscycle[nv]) { // 只考虑不是cycle上的点 adj[rt].push_back(nv); } } } iscycle[rt] = 1; sort(adj[rt].begin(), adj[rt].end()); adj[rt].resize(unique(adj[rt].begin(), adj[rt].end()) - adj[rt].begin()); sort(adj_site[rt].begin(), adj_site[rt].end()); adj_site[rt].resize(unique(adj_site[rt].begin(), adj_site[rt].end()) - adj_site[rt].begin()); } else { for (int v : comp) { if (!outdeg[v]) { rt = v; break; } } assert(rt != -1); } dfs2(rt, 0); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; for (int j = 1; j \u0026lt;= m; j++) { grid[i][j] = s[j-1], id[i][j] = ++cid; if (grid[i][j] != '.' \u0026amp;\u0026amp; grid[i][j] != '#') river[i][j] = 1; if (grid[i][j] == '#') site[i][j] = 1; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { int u = id[i][j]; int op; if (grid[i][j] == 'v') op = 0; if (grid[i][j] == '^') op = 1; if (grid[i][j] == '\u0026gt;') op = 2; if (grid[i][j] == '\u0026lt;') op = 3; int ni = i + d[op][0], nj = j + d[op][1]; if (ok(ni, nj)) { int v = id[ni][nj]; addEdge(u,v); addEdge(v,u); adj[u].push_back(v); adj[v].push_back(u); outdeg[u]++; // outdeg = 0的就是树的根 } // adj_site (only consider river's neighbor) if (river[i][j]) { for (int o = 0; o \u0026lt; 4; o++) { int ni = i + d[o][0], nj = j + d[o][1]; if (site[ni][nj]) { adj_site[u].push_back(id[ni][nj]); } } } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (river[i][j]) { int u = id[i][j]; if (!vis[u]) solve(u); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   L. Triangular Logs 题意\n二维空间中有 $n$ 个点，每个点 $(x_i,y_i)$ 有一个权值 $w_i$。\n现在有 $q$ 个询问，每次询问 $x_l,x_r,y_l,y_r$，回答：\n在 $[x_l,x_r] \\times [y_l,y_r]$ 这个矩阵中，是否存在三个点，使得这三个点的权值能够形成一个三角形？\n其中，$n,q \\leq 10^5, x_i,y_i,w_i \\in [1,10^9]$。\n 题解 首先给一个结论：\n 每次询问，只需要从矩阵中，取 $\\log(10^9)$ 个点，就足够了。\n 证明：如果矩阵中，取了 $m\u0026gt;\\log(10^9)$ 个点，仍然没找到三角形，那么，将这些点的权值进行排序：\n$$w_1,w_2,w_3,w_4,w_5,\u0026hellip;,w_m$$\n我们可以得到 $w_1+w_2 \u0026lt; w_3$，那么 $2w_1 \u0026lt; w_3$，同理 $w_2+w_3\u0026lt;w_4$，那么 $2w_2\u0026lt;w_4$。\n所以 $\\forall i, 2w_i \u0026lt; w_{i+2}$，说明这个数组的元素是几何增长的，所以长度不可能超过 $\\log(10^9)$。\n 于是每次询问，我们只要从中找到 $\\log(10^9)$ 个点，怎么维护呢？\n我们 $x$ 坐标用动态开点线段树维护，而每棵线段树里层维护一个 set，按照 $y$ 坐标的大小排序，这样可以通过 lower_bound() 来找到 $[y_l,y_r]$ 的。\n线段树的层数为 $\\log(10^9)$，而每个点最坏情况下都会在每一层出现，所以总时空复杂度就是 $O(n\\log n * \\log(10^9))$。\n • 最后注意！这个题不能用二维线段树！\n考虑一个例子：$[1,2] \\times [1,2]$ 这个矩阵里刚好有 $4$ 个点 $(1,1),(1,2),(2,1),(2,2)$。\n我们如果考虑 $x \\in [1,2]$，那么这刚好对应一棵线段树，里面储存的是 $y \\in [1,2]$ 的，但这棵线段树只能储存 $2$ 个值，所以会丢失一些信息！\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int N = 1e9; struct Point { int x, y, val; bool operator\u0026lt;(const Point\u0026amp; others) const { return y \u0026lt; others.y; } } a[maxn]; // 区间查询 // 单点修改 struct SegNode { multiset\u0026lt;Point\u0026gt; s; int lc, rc; }; int cid = 0; const int M = 80; vector\u0026lt;Point\u0026gt; vec; struct SegX { SegNode tr[maxn*40]; void update(int\u0026amp; cur, int l, int r, int x, int y, int val) { if (!cur) cur = ++cid; tr[cur].s.insert(Point {x, y, val}); if (l == r) { return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) update(tr[cur].lc, l, mid, x, y, val); if (x \u0026gt; mid) update(tr[cur].rc, mid+1, r, x, y, val); } void query(int cur, int l, int r, int xl, int xr, int yl, int yr) { if (!cur) return; if (vec.size() \u0026gt; M) return; if (xl \u0026lt;= l \u0026amp;\u0026amp; xr \u0026gt;= r) { // 寻找 [yl, yr] 之间的 auto pl = tr[cur].s.lower_bound(Point {0, yl, 0}); auto pr = tr[cur].s.lower_bound(Point {0, yr+1, 0}); while (pl != pr) { if (pl-\u0026gt;y \u0026gt; yr) break; vec.push_back(*pl); if (vec.size() \u0026gt; M) return; pl = next(pl); } return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (xl \u0026lt;= mid) query(tr[cur].lc, l, mid, xl, xr, yl, yr); if (xr \u0026gt; mid) query(tr[cur].rc, mid+1, r, xl, xr, yl, yr); } } tr; int RT = 0; void query(int xl, int xr, int yl, int yr) { vec.clear(); tr.query(RT, 1, N, xl, xr, yl, yr); } void update(int x, int y, int val) { tr.update(RT, 1, N, x, y, val); } int n,q; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i].x \u0026gt;\u0026gt; a[i].y \u0026gt;\u0026gt; a[i].val; update(a[i].x, a[i].y, a[i].val); } while (q--) { int xl, yl, xr, yr; cin \u0026gt;\u0026gt; xl \u0026gt;\u0026gt; yl \u0026gt;\u0026gt; xr \u0026gt;\u0026gt; yr; query(xl, xr, yl, yr); int good = 0; sort(vec.begin(), vec.end(), [](auto a, auto b) { return a.val \u0026lt; b.val; }); for (int i = 0; i \u0026lt; vec.size(); i++) { if (i \u0026gt;= 2 \u0026amp;\u0026amp; vec[i-2].val + vec[i-1].val \u0026gt; vec[i].val) { good = 1; break; } } cout \u0026lt;\u0026lt; good \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2023-03-05T18:59:57-06:00","permalink":"https://tom0727.github.io/post/098-nac2022/","tags":["",""],"title":"NAC2022"},{"categories":["算法"],"contents":"介绍 吉司机线段树可以做到：\n 区间最大/最小操作（对一个区间内的所有数取 max 或者 min） 维护区间历史最值  我们直接看一道例题：\n题意\n给定一个数组 $a_1, a_2, \u0026hellip; a_n$，同时给定一个数组 $b_1, b_2\u0026hellip;, b_n$（初始状态下 $a,b$ 相同）。\n进行 $m$ 次操作，操作有 $5$ 种：\n$1 ~ l ~ r ~ x$：$\\forall i \\in [l,r]$，将 $a_i$ 加上 $x$。\n$2 ~ l ~ r ~ x$：$\\forall i \\in [l,r]$，将 $a_i$ 变成 $\\min(a_i, x)$。\n$3 ~ l ~ r$：求 $[l,r]$ 之间 $a_i$ 的区间和。\n$4 ~ l ~ r$：求 $[l,r]$ 之间 $a_i$ 的区间最大值。\n$5 ~ l ~ r$：求 $[l,r]$ 之间 $b_i$ 的区间最大值。\n在每一次操作后，我们进行一次更新，使得 $\\forall i \\in [1,n], b_i \\leftarrow \\max(b_i, a_i)$。\n 吉司机线段树可以在 $O((n+m) \\log^2n)$ 的时间内解决这个问题。\n具体的，我们先看一下线段树的节点需要维护什么。\n区间历史最值 先考虑第 $5$ 个操作。首先 $b_i$ 其实是一个历史最大值数组（即 $a_i$ 在任意时刻，所存放过的最大的值）。我们要求的是 $b_i$ 的区间最大值。\n在区间加的时候，我们会维护一个最大值的懒标记 add1。不过这个懒标记可能会被多次更新，所以我们只要维护在任意时刻，这个懒标记的最大值 add3（也就是懒标记本身的 历史最大值）即可。\n• 简而言之 add3 就是 add1 在任意时刻所达到的最大值。\n区间取最小操作 区间怎么取最小？考虑一下，如果我们要对一个区间取 $\\min$，要取的值是 $x$。\n那么假设这个区间只有 一种值 是 $\u0026gt;x$ 的，那么就可以取最小了。\n所以我们需要维护区间的最大值 maxa，和次大值 se。一个区间可以取 min 当且仅当 $se \u0026lt; x \u0026lt; maxa$。\n如果不满足这个条件，则要么直接退出（$x \\geq maxa$），或者继续递归（$x \u0026lt; maxa$）。\n由于我们需要维护次大值，而区间加也有可能会更新次大值，所以我们还需要 非最大值的懒标记 add2，同上理由还需要一个 非最大值懒标记 的历史最大值 add4。\n• 简而言之 add4 就是 add2 在任意时刻所达到的最大值。\n模版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct SegTreeBeats { const int INF = 1e9; int a[maxn]; // 原数组 struct Node { ll sum; int maxa, maxb, cnt, se; // maxa: 区间最大值, maxb: 区间历史最大值, cnt: 区间最大值的数量, se: 区间严格次大值 int add1, add2, add3, add4; // add1: 区间最大值懒标记, add2: 区间非最大值懒标记, add3: 区间历史最大值懒标记, add4: 区间历史非最大值懒标记 } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { int lc = cur\u0026lt;\u0026lt;1, rc = cur\u0026lt;\u0026lt;1|1; tr[cur].sum = tr[lc].sum + tr[rc].sum; tr[cur].maxa = max(tr[lc].maxa, tr[rc].maxa); tr[cur].maxb = max(tr[lc].maxb, tr[rc].maxb); if (tr[lc].maxa == tr[rc].maxa) { tr[cur].se = max(tr[lc].se, tr[rc].se); tr[cur].cnt = tr[lc].cnt + tr[rc].cnt; } else if (tr[lc].maxa \u0026gt; tr[rc].maxa) { tr[cur].se = max(tr[lc].se, tr[rc].maxa); tr[cur].cnt = tr[lc].cnt; } else { // rc.maxa \u0026gt; lc.maxa tr[cur].se = max(tr[lc].maxa, tr[rc].se); tr[cur].cnt = tr[rc].cnt; } } void helper(int cur, int l, int r, ll k1, ll k2, ll k3, ll k4) { tr[cur].sum += k1 * tr[cur].cnt + k2 * (r-l+1-tr[cur].cnt); tr[cur].maxb = max((ll)tr[cur].maxb, tr[cur].maxa + k3); tr[cur].maxa += k1; if (tr[cur].se != -INF) tr[cur].se += k2; tr[cur].add3 = max((ll)tr[cur].add3, tr[cur].add1 + k3); tr[cur].add4 = max((ll)tr[cur].add4, tr[cur].add2 + k4); tr[cur].add1 += k1, tr[cur].add2 += k2; } void push_down(int cur, int l, int r) { int lc = cur\u0026lt;\u0026lt;1, rc = cur\u0026lt;\u0026lt;1|1; int mx = max(tr[lc].maxa, tr[rc].maxa); int mid = (l+r) \u0026gt;\u0026gt; 1; if (tr[lc].maxa == mx) helper(lc, l, mid, tr[cur].add1, tr[cur].add2, tr[cur].add3, tr[cur].add4); // 注意这里是 1,2,3,4 else helper(lc, l, mid, tr[cur].add2, tr[cur].add2, tr[cur].add4, tr[cur].add4); // 注意这里是 2,2,4,4 if (tr[rc].maxa == mx) helper(rc, mid+1, r, tr[cur].add1, tr[cur].add2, tr[cur].add3, tr[cur].add4); // 注意这里是 1,2,3,4 else helper(rc, mid+1, r, tr[cur].add2, tr[cur].add2, tr[cur].add4, tr[cur].add4); // 注意这里是 2,2,4,4 tr[cur].add1 = tr[cur].add2 = tr[cur].add3 = tr[cur].add4 = 0; } void build(int cur, int l, int r) { if (l == r) { tr[cur].sum = tr[cur].maxa = tr[cur].maxb = a[l]; tr[cur].cnt = 1; tr[cur].se = -INF; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } ll query_sum(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].sum; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query_sum(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query_sum(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int query_maxa(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].maxa; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = -INF; if (L \u0026lt;= mid) res = max(res, query_maxa(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = max(res, query_maxa(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return res; } int query_maxb(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].maxb; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = -INF; if (L \u0026lt;= mid) res = max(res, query_maxb(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = max(res, query_maxb(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return res; } void update_add(int cur, int l, int r, int L, int R, ll x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].sum += x * (r-l+1); tr[cur].maxa += x; tr[cur].maxb = max(tr[cur].maxb, tr[cur].maxa); if (tr[cur].se != -INF) tr[cur].se += x; tr[cur].add1 += x, tr[cur].add2 += x; tr[cur].add3 = max(tr[cur].add3, tr[cur].add1); tr[cur].add4 = max(tr[cur].add4, tr[cur].add2); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update_add(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update_add(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } void update_min(int cur, int l, int r, int L, int R, int x) { if (x \u0026gt;= tr[cur].maxa) return; if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r \u0026amp;\u0026amp; x \u0026gt; tr[cur].se) { // 保证 se \u0026gt; x ll k = tr[cur].maxa - x; // 最大值减少的幅度 tr[cur].sum -= tr[cur].cnt * k; tr[cur].maxa = x; tr[cur].add1 -= k; return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update_min(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update_min(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } } seg; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; seg.a[i]; seg.build(1, 1, n); while (m--) { int op, l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 1) { ll x; cin \u0026gt;\u0026gt; x; seg.update_add(1, 1, n, l, r, x); } else if (op == 2) { ll x; cin \u0026gt;\u0026gt; x; seg.update_min(1, 1, n, l, r, x); } else if (op == 3) { cout \u0026lt;\u0026lt; seg.query_sum(1, 1, n, l, r) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 4) { cout \u0026lt;\u0026lt; seg.query_maxa(1, 1, n, l, r) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; seg.query_maxb(1, 1, n, l, r) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例题 例1 洛谷P4314 CPU 监控 题意\n给定一个数组 $a_1,a_2\u0026hellip;,a_n$，有 $m$ 个询问。\n进行 $m$ 次操作，操作有 $4$ 种：\n$Q ~ l ~ r$：求 $[l,r]$ 之间 $a_i$ 的区间最大值。\n$A ~ l ~ r$：求 $[l,r]$ 之间 $a_i$ 的区间历史最大值。\n$P ~ l ~ r ~ x$：将 $[l,r]$ 之间的 $a_i$ 增加 $x$。\n$C ~ l ~ r ~ x$：将 $[l,r]$ 之间的 $a_i$ 变为 $x$。\n 题解 题解链接：https://www.luogu.com.cn/blog/He-Ren/solution-p4314\n带有区间赋值，维护历史最大值。\n我们对于一个区间，在 push_down() 之后，所有之前的操作都可以看作不存在。\n那么我们按照每次 push_down() 作为分隔符来考虑这些操作序列，以下的讨论都仅限于 一次 push_down() 以内的。\n一个区间的操作只有区间加和区间赋值，并且相邻的相同类型操作可以合并为一个。\n所以最终操作序列肯定可以被简化为 区间加 + 区间赋值 + 区间加 + 区间赋值 + 区间加 \u0026hellip;\n我们可以发现，区间赋值后，所有的区间加操作都可以被重新看作为赋值，所以我们维护一个 set_tag 表示在此次 push_down() 内是否有赋值操作即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct SegTreeBeats { const int INF = 2e9; int a[maxn]; // 原数组 struct Node { ll sum; int maxa, maxb; // maxa: 区间最大值, maxb: 区间历史最大值, cnt: 区间最大值的数量, se: 区间严格次大值 int add1, add2; int set1, set2; bool set_tag; // add1: 区间最大值懒标记, add2: 区间非最大值懒标记, add2: 区间历史最大值懒标记, add4: 区间历史非最大值懒标记 } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { int lc = cur\u0026lt;\u0026lt;1, rc = cur\u0026lt;\u0026lt;1|1; tr[cur].maxa = max(tr[lc].maxa, tr[rc].maxa); tr[cur].maxb = max(tr[lc].maxb, tr[rc].maxb); } void add_helper(int cur, ll x, ll max_add) { if (tr[cur].set_tag) { tr[cur].set2 = max((ll)tr[cur].set2, tr[cur].set1 + max_add); tr[cur].maxb = max((ll)tr[cur].maxb, tr[cur].maxa + max_add); tr[cur].maxa += x; tr[cur].set1 += x; } else { tr[cur].add2 = max((ll)tr[cur].add2, tr[cur].add1 + max_add); tr[cur].maxb = max((ll)tr[cur].maxb, tr[cur].maxa + max_add); tr[cur].maxa += x; tr[cur].add1 += x; } } void set_helper(int cur, ll x, ll max_set) { tr[cur].set2 = max((ll)(tr[cur].set2), max_set); tr[cur].maxb = max((ll)tr[cur].maxb, max_set); tr[cur].set_tag = 1; tr[cur].maxa = tr[cur].set1 = x; } void push_down(int cur, int l, int r) { int lc = cur\u0026lt;\u0026lt;1, rc = cur\u0026lt;\u0026lt;1|1; add_helper(lc, tr[cur].add1, tr[cur].add2); add_helper(rc, tr[cur].add1, tr[cur].add2); tr[cur].add1 = tr[cur].add2 = 0; if (tr[cur].set_tag) { set_helper(lc, tr[cur].set1, tr[cur].set2); set_helper(rc, tr[cur].set1, tr[cur].set2); tr[cur].set_tag = 0; tr[cur].set1 = tr[cur].set2 = 0; return; } } void build(int cur, int l, int r) { if (l == r) { tr[cur].sum = tr[cur].maxa = tr[cur].maxb = a[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } ll query_sum(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].sum; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query_sum(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query_sum(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int query_maxa(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].maxa; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = -INF; if (L \u0026lt;= mid) res = max(res, query_maxa(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = max(res, query_maxa(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return res; } int query_maxb(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].maxb; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = -INF; if (L \u0026lt;= mid) res = max(res, query_maxb(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = max(res, query_maxb(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return res; } void update_set(int cur, int l, int r, int L, int R, ll x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { set_helper(cur, x, x); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update_set(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update_set(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } void update_add(int cur, int l, int r, int L, int R, ll x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { add_helper(cur, x, x); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update_add(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update_add(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } } seg; int n, m; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; seg.a[i]; seg.build(1, 1, n); cin \u0026gt;\u0026gt; m; while (m--) { char op; int l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 'Q') { cout \u0026lt;\u0026lt; seg.query_maxa(1, 1, n, l, r) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 'A') { cout \u0026lt;\u0026lt; seg.query_maxb(1, 1, n, l, r) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 'P') { ll x; cin \u0026gt;\u0026gt; x; seg.update_add(1, 1, n, l, r, x); } else if (op == 'C') { ll x; cin \u0026gt;\u0026gt; x; seg.update_set(1, 1, n, l, r, x); } } }   参考链接  https://www.luogu.com.cn/problem/P6242  ","date":"2023-02-22T15:48:08-06:00","permalink":"https://tom0727.github.io/post/097-segment-tree-beats/","tags":["线段树",""],"title":"吉司机线段树（Segment Tree Beats）"},{"categories":["算法"],"contents":"老是忘，简单记录一下吧。\n介绍 一个边权仅为 $0,1$ 的图中跑最短路可以直接用 bfs。\n维护一个 deque，每次更新 dis[v] 时就将 v push进去，如果 w(u,v) == 0 就push到前面，否则push到后面。\nvector\u0026lt;pii\u0026gt; adj[maxn]; // (v, w) int dis[maxn]; bool vis[maxn]; void bfs01(int x) { deque\u0026lt;int\u0026gt; q; q.push_back(x); memset(dis, 63, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[x] = 0; while (!q.empty()) { int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (pii p : adj[u]) { int v = p.first, w = p.second; if (dis[u] + w \u0026lt; dis[v]) { dis[v] = dis[u] + w; if (w == 1) q.push_back(v); else q.push_front(v); } } } }  ","date":"2023-02-20T23:51:42-06:00","permalink":"https://tom0727.github.io/post/096-bfs01/","tags":["",""],"title":"01BFS 最短路"},{"categories":["算法"],"contents":"介绍 给定一个无向图，找出图中所有的三元环，每个环只能被计一次。(比如 $a,b,c$ 和 $b,a,c$ 都是同一个环)。\n我们先处理出每个点的 degree，然后建一个新的图，这个图是有向图：\n$u \\rightarrow v$ 连一条边当且仅当以下条件之一成立：\n $d_u \u0026lt; d_v$ $d_u = d_v$ 且 $u\u0026lt;v$。  其中，$d_u$ 是 $u$ 的degree。\n然后利用如下代码片段进行计数：\nvector\u0026lt;int\u0026gt; adj[maxn]; int deg[maxn]; int n,m; int vis[maxn]; // check (u,v) 这条边是否满足以下条件之一: // (1) deg(u) \u0026lt; deg(v) // (2) deg(u) == deg(v) \u0026amp;\u0026amp; u \u0026lt; v bool valid(int u, int v) { return deg[u] \u0026lt; deg[v] || (deg[u] == deg[v] \u0026amp;\u0026amp; u \u0026lt; v); } vector\u0026lt;int\u0026gt; adj2[maxn]; void count_cycle() { for (int a = 1; a \u0026lt;= n; a++) { for (int b : adj[a]) { if (valid(a,b)) adj2[a].push_back(b); } } for (int a = 1; a \u0026lt;= n; a++) { for (int b : adj2[a]) vis[b] = a; // 打上时间戳 for (int b : adj2[a]) { for (int c : adj2[b]) { if (vis[c] == a) { // (a,b,c) 是一个环 ... } } } } }  这段代码本质上是枚举了一条边 $(a,b)$，然后找和 $a,b$ 均相连的点 $c$。\n首先正确性不难证明，由于我们按照如上定义得出了一个新的有向图，所以每个环只会被记录一次。\n时间复杂度是 $O(m \\sqrt m)$，以下是证明：\n第一步是枚举边 $a,b$，这是 $O(m)$ 的，然后我们讨论 $b$ 是一个大点（$d_b \u0026gt; \\sqrt m$）还是一个小点（$d_b \\leq \\sqrt m$）。\n 如果 $b$ 是大点，意味着这样的 $b$ 最多就 $\\sqrt m$ 个，而 $d_c \\geq d_b$，所以 $c$ 也是大点，这意味着这样的 $c$ 最多也就 $\\sqrt m$ 个。所以里层循环枚举 $c$ 的复杂度是 $O(\\sqrt m)$，总共 $O(m \\sqrt m)$。 如果 $b$ 是小点，那么很明显 $d_b \\leq \\sqrt m$，由于 $c$ 是 $b$ 的邻居，这意味着这样的 $c$ 不超过 $d_b = \\sqrt m$ 个，所以里层循环枚举 $c$ 的复杂度是 $O(\\sqrt m)$，总共 $O(m \\sqrt m)$。  例题 例1 NAQ2021 L. Sword Counting 题意\n给定一个无向图，求形状为如下图的 subgraph 数量：\n其中，$n,m \\leq 10^5$，两个subgraph被看作不同当且仅当存在至少一条边不同。\n 题解 先找 $D$，特征是 $d_D \\geq 4$，再找 $B$，特征是 $d_B \\geq 2$。\n确认完这两个点以后，我们要判断剩下 $A,C,E,F$ 有多少种选法。\n首先注意到，如果 $A$ 同时是 $B,D$ 的一个邻居，那么选了 $A$ 以后会让 $D$ 剩下的选择少一个，否则没有影响。\n所以我们只要找出 $B,D$ 共同的邻居数量，假设 $B,D$ 共同邻居共有 $x$ 个，那么答案为：\n$$(d_B-1-x)C_{d_D-1}^3 + xC_{d_D-2}^3$$\n这个 $x$ 怎么找？就找到所有的三元环即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll C3(ll a) { if (a \u0026lt; 3) return 0; return a * (a-1) * (a-2) / 6; } vector\u0026lt;int\u0026gt; adj[maxn]; int deg[maxn]; map\u0026lt;int, int\u0026gt; cnt[maxn]; // cnt[a][b]: a,b的共同邻居数量, a\u0026lt;b int n,m; int vis[maxn]; // check (u,v) 这条边是否满足以下条件之一: // (1) deg(u) \u0026lt; deg(v) // (2) deg(u) == deg(v) \u0026amp;\u0026amp; u \u0026lt; v bool valid(int u, int v) { return deg[u] \u0026lt; deg[v] || (deg[u] == deg[v] \u0026amp;\u0026amp; u \u0026lt; v); } vector\u0026lt;int\u0026gt; adj2[maxn]; void count_cycle() { for (int a = 1; a \u0026lt;= n; a++) { for (int b : adj[a]) { if (valid(a,b)) adj2[a].push_back(b); } } for (int a = 1; a \u0026lt;= n; a++) { for (int b : adj2[a]) vis[b] = a; for (int b : adj2[a]) { for (int c : adj2[b]) { if (vis[c] == a) { // (a,b,c) 是一个环 cnt[min(a,b)][max(a,b)]++; cnt[min(a,c)][max(a,c)]++; cnt[min(b,c)][max(b,c)]++; } } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); deg[u]++, deg[v]++; } count_cycle(); ll ans = 0; for (int d = 1; d \u0026lt;= n; d++) { if (deg[d] \u0026lt; 4) continue; for (int b : adj[d]) { if (deg[b] \u0026lt; 2) continue; int x = cnt[min(d,b)][max(d,b)]; ans = ans + C3(deg[d]-2) * x + max(0, deg[b] - 1 - x) * C3(deg[d]-1); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2023-02-06T22:06:05-06:00","permalink":"https://tom0727.github.io/post/095-%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/","tags":["",""],"title":"三元环计数"},{"categories":["算法"],"contents":"公平组合游戏 公平组合游戏 Impartial Combinatorial Game (ICG) 满足以下性质：\n 有 $2$ 名玩家。 $2$ 名玩家轮流操作，在一个游戏集合中选其中一个进行操作。 对于任意一个合法的局面，当前的决策与之前的操作无关。 无法操作者（操作集合为空）会输掉游戏。  Nim游戏 Nim游戏是一个经典的 ICG。\n游戏规则如下：\n 地上有 $n$ 堆石子，每堆石子数量可能不同，两人轮流操作，每人每次可从任意一堆石子里取走任意多枚石子，可以取完，不能不取，无石子可取者输掉游戏，问是否存在先手必胜的策略。\n 结论：如果石子的数量为 $a_1,a_2,\u0026hellip;a_n$，那么 先手获胜 $\\iff a_1 \\oplus a_2 \\oplus \u0026hellip; \\oplus a_n = 0$，否则后手获胜。\n证明：对于等于 $0$ 的情况，进行任意一个操作都一定会让 XOR 的值变成非 $0$。对于非 $0$ 的情况，一定存在某一个操作使得 XOR 的值变成 $0$。\n前者易证，对于后者：假设 $a_1 \\oplus a_2 \\oplus \u0026hellip; \\oplus a_n = k \u0026gt; 0$，考虑 $k$ 的最高位为 $1$，所以一定存在一个 $a_i$ 使得 $a_i$ 的这一位也是 $1$，并且一定有 $a_i \\oplus k \u0026lt; a_i$。\n博弈图和状态 如果令节点 $(i,j,k)$ 表示局面为 $i,j,k$ 时的状态，就可以画出如上的博弈图。注意到这个博弈图是 DAG。\n定义 必胜状态 为先手必胜的状态，必败状态 为先手必败的状态，有 $3$ 条定理：\n 没有后继状态（没有出边）的状态是必败状态。 一个状态是必胜状态 $\\iff$ 它的后继状态 存在至少 $1$ 个必败状态。 一个状态是必败状态 $\\iff$ 它的所有后继状态均为 必胜状态。  SG函数 我们定义 SG函数：$SG(x)$，其中 $x$ 是一个游戏状态，SG函数的值是一个非负整数。\n 如果没有后继状态 / 后继状态全部是必胜状态，那么 $SG(x) = 0$，表示必败状态。 如果后继状态中存在至少一个必败状态，那么 $SG(x) \u0026gt; 0$，表示必胜状态。  而 $SG$ 函数本身的定义如下：\n对于状态 $x$ 和它的 $k$ 个后继状态 $y_1, y_2 \u0026hellip; y_k$，定义\n$$SG(x) = \\text{mex}\\{SG(y_1), SG(y_2), \u0026hellip; , SG(y_k)\\}$$\n回忆一下 mex函数的定义：一个整数集合中，最小的没有出现的非负整数。\n$$\\text{mex}(S) = \\min\\{x | x \\notin S, x \\in N\\}$$\n根据这个定义，我们可以发现，对于当前状态 $x$，如果令 $a = SG(x)$，那么对于任意的 $b \\in [0, a-1]$，一定存在某个后继状态 $y$ 使得 $b = SG(y)$。\n这也解释了为什么 $SG(x) \u0026gt; 0$ 时代表必胜状态，而 $SG(x) = 0$ 代表必败状态。\n• 因为 $SG(x)\u0026gt;0$ 就说明有一种后继状态 $y$ 使得 $SG(y) = 0$，而 $SG(x) = 0$ 说明不存在这样的 $SG(y) = 0$。\n 如果一个 ICG 包含了多个互相的独立状态 $x_1,x_2\u0026hellip;,x_n$，那么这个 ICG 的 $SG$ 函数表示为：\n$$SG(x_1) \\oplus SG(x_2) \\oplus \u0026hellip; \\oplus SG(x_n)$$\n而类比一个状态的情况，可以得出：\n$SG(x_1) \\oplus SG(x_2) \\oplus \u0026hellip; \\oplus SG(x_n) = 0$，表示必败状态。\n$SG(x_1) \\oplus SG(x_2) \\oplus \u0026hellip; \\oplus SG(x_n) \u0026gt; 0$，表示必胜状态。\n• 在 nim 游戏中，有 $SG(x) = x$，即当前状态有几个石子，SG函数就是几。\n例题 例1 CF1823E. Removing Graph 题意\n给定一个图，有 $n$ 个节点和 $n$ 条边，这个图是若干个联通分量组成的，每个联通分量一定是一个环。\n现在 Alice 和 Bob 轮流对这个图进行一些操作，每次操作选择一个联通分量，然后删掉这个分量上的一些点和对应的边，这些点必须本身组成一个subgraph。\n每次可以删 $[l,r]$ 个点。\n求谁能赢？\n其中，$n \\leq 2 \\times 10^5, 1 \\leq l \u0026lt; r \\leq n$。\n 题解 第一眼看起来像是 nim 游戏的变种（每次只能remove $[l,r]$ 个石头），如果是这样的话那么 sg(i) = (i % (l+r)) / l，但这个不太一样。\n注意到将一个环的 subgraph remove掉以后，会断成两条链，这就不太一样了，所以我们只能打表找找规律。\n我们设环和链的 SG 函数分别为 $A,B$，那么就有：\n$$B_i = \\text{mex} \\{ B_j \\text{ xor } B_k ~|~ j+k \\in [i-r, i-l]\\}$$\n$$A_i = \\text{mex} \\{ B_j ~|~ j \\in [i-r, i-l]\\}$$\n经过一些打表观察后，可以发现：\n  $A_i=0$ 当且仅当 $i \\geq l+r$。\n  $A_i = \\frac{i}{l}$ 当且仅当 $i \u0026lt; l+r$。\n  然后就做完了。\n具体证明可以看 这里。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std;   ","date":"2023-01-20T13:51:32-06:00","permalink":"https://tom0727.github.io/post/094-%E5%8D%9A%E5%BC%88%E8%AE%BA/","tags":["",""],"title":"博弈论与SG函数"},{"categories":["算法"],"contents":"模版 struct Edge { int from, to, nxt; }; int n; // 变量个数 struct SAT2 { // from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小 int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn], head[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1, ecnt = 1; Edge edges[maxm]; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 要记得在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; // 记得这里，将在栈中的标记去掉 } tail--; in[u] = 0; // 记得这里，将在栈中的标记去掉 } } void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void solve() { for (int i = 1; i \u0026lt;= 2*n; i++) { if (!dfn[i]) dfs(i); } for (int i = 1; i \u0026lt;= n; i++) { if (from[i] == from[i+n]) { cout \u0026lt;\u0026lt; \u0026quot;-1\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 无解 return; } } // 否则输出答案 for (int i = 1; i \u0026lt;= n; i++) { if (from[i] \u0026lt; from[i+n]) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 这个变量选择 True } else { cout \u0026lt;\u0026lt; i+n \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 这个变量选择 False } } } }; int f(int u) { if (u \u0026gt; n) return u - n; return u + n; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { SAT2 sat {}; // 注意这里的 {} 才能正确清空！ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // u,v 冲突 sat.addEdge(u, f(v)); // u -\u0026gt; not v sat.addEdge(v, f(u)); // v -\u0026gt; not u } } }   介绍 2-SAT 用于解决：寻找满足一个 二元 boolean 方程集合的解。\n例如，我们有 $n$ 个 boolean 变量 $a_1,a_2,\u0026hellip;a_n$。\n而我们给出一个boolean方程集合，共有 $m$ 个方程：\n$$a_1 \\wedge a_3 = 1$$\n$$a_1 \\vee a_4 = 1$$\n$$a_2 \\wedge a_4 = 0$$\n$$\u0026hellip;$$\n注意到每一个方程都只有两个变量 $a_i, a_j$，所以叫做 2-SAT。如果有超过 $2$ 个变量，那么是 NP 问题，只能暴力。\n原理 2-SAT 本质上是利用了 boolean 表达式之间的推导关系。\n比如 $a_1 \\vee a_4 = 1$ 可以等效转化为 $(\\neg a_1 \\rightarrow a_4) \\wedge (\\neg a_4 \\rightarrow a_1)$。\n这意味着，如果 $a_1 = 0$，那么 $a_4 = 1$，且，如果 $a_4 = 0$，那么 $a_1 = 1$。\n那么我们就可以这么连边：\n因为是推导关系所以是有向边。\n那么 2-SAT 问题有解 $\\iff$ 对于所有的 $i$，$a_i$ 和 $\\neg a_i$ 并不在同一个强连通分量（SCC）中。\n所以跑 tarjan 找SCC即可。\n一些例子 考虑如下的情况：\n在这个图中，如果我们从 $\\neq a$ 出发，最终会走到 $a$。这说明 $\\neq a$ 是不可能成立的。\n由此可知，$a=1$。\n所以我们在找 SCC 过后，还需要判断 $a$ 和 $\\neq a$ 的拓扑序。哪个拓扑序更靠后，就说明这个变量必须取这个值。\n这样就可以输出解的具体值了。\n• 注意到在 tarjan 算法中，SCC的序号反过来就是拓扑序，所以板子中我们直接比较了 from[] 的值，哪个小就取哪个。\n常用连边模型    表达式 连边方式     $a \\vee b = 1$ $\\neg a \\rightarrow b, \\neg b \\rightarrow a$   $a \\wedge b = 0$ $a \\rightarrow \\neg b, b \\rightarrow \\neg a$   $a = 1$ $\\neg a \\rightarrow a$   $a = 0$ $a \\rightarrow \\neg a$   $a,b$ 冲突(不能同时出现) $a \\rightarrow \\neg b, b \\rightarrow \\neg a$     例题 例1 洛谷P5782 [POI2001] 和平委员会 题意\n有 $n$ 个党派，每个党派有两个人（第 $i$ 个党派的人是 $2i-1, 2i$）。\n给定 $m$ 个关系，表示 $a,b$ 互相厌恶。\n现在每个党派需要派出恰好一个人，并且互相厌恶的人不能同时出现。\n其中，$n \\leq 8000, m \\leq 20000$。\n 题解 本题可以用二分图染色做。\n2-SAT 也是可以的。每个党派看作一个 boolean 变量。\n参考表达式中的 $a,b$ 冲突就可以做了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4e5+5; const int maxm = 5e5+505; struct Edge { int from, to, nxt; }; int n; struct SAT2 { // from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小 int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn], head[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1, ecnt = 1; Edge edges[maxm]; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 要记得在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; // 记得这里，将在栈中的标记去掉 } tail--; in[u] = 0; // 记得这里，将在栈中的标记去掉 } } void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void solve() { for (int i = 1; i \u0026lt;= 2*n; i++) { if (!dfn[i]) dfs(i); } for (int i = 1; i \u0026lt;= 2*n; i += 2) { if (from[i] == from[i+1]) { cout \u0026lt;\u0026lt; \u0026quot;NIE\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 无解 return; } } // 否则输出答案 for (int i = 1; i \u0026lt;= 2*n; i += 2) { if (from[i] \u0026lt; from[i+1]) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } // cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } sat; int m; int f(int u) { if (u % 2 == 0) return u - 1; return u + 1; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; sat.addEdge(u, f(v)); sat.addEdge(v, f(u)); } sat.solve(); }   例2 CF1250E. The Coronation 题意\n给定 $n$ 个 $01$ 串（长度均为 $m$）。\n给定一个正整数 $k$， 定义两个 $01$ 串为相似当且仅当它们同位置上相同的字符至少有 $k$ 个。\n现在我们可以将一些 $01$ 串反转（从后往前）。\n求最少翻转多少个，使得所有串之间两两相似？无解输出 $-1$。\n其中，$n \\in [2, 50], m \\in [1, 50], k \\in [1,m]$。\n 题解 这个题 不能用 2SAT！\n我们考虑所有两两不相似的串（这个可以直接预处理出来）。\n现在其实就相当于，每个串要么翻转，要么不翻转，使得最后得到的 $n$ 个串不能有冲突。\n看起来很像 2-SAT，并且也可以这么做？\n但有个问题，2-SAT并 没有办法处理最少翻转几个 的问题！\n 正解是用权值并查集或者二分图染色。\n因为这个题是串之间的 冲突 问题，所以可以这么做，更复杂的情况才需要2-SAT。\n 考虑二分图染色。\n我们将翻转前的所有串作为左边的点，翻转后的作为右边的。\n两两冲突的点之间连一条边（$i$ 和翻转后的版本 $i'$ 也要连边）。\n虽然这样不算严格的二分图？但跑染色还是没问题的。\n连完以后跑染色，可以得到若干个联通块。对于每个联通块，看染色是否成功，如果成功，黑白两个颜色中，翻转后的版本 $i'$ 哪个最少，选最少的那个即可。\n如果染色失败，输出无解即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 1e5+505; struct Edge { int from, to, nxt; } edges[maxm]; int n, head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int m, k; int f(int u) { if (u \u0026gt; n) return u - n; return u + n; } string s[maxn]; int similar(int u, int v) { int res = 0; for (int i = 0; i \u0026lt; m; i++) { if (s[u][i] == s[v][i]) res++; } return res; } vector\u0026lt;int\u0026gt; tmp0, tmp1; int color[maxn], cnt0, cnt1; bool ok = 1; void dfs(int u) { if (color[u] == 1 \u0026amp;\u0026amp; u \u0026gt; n) tmp1.push_back(u - n); if (color[u] == 0 \u0026amp;\u0026amp; u \u0026gt; n) tmp0.push_back(u - n); for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (color[v] == -1) { color[v] = color[u] ^ 1; dfs(v); } else if (color[v] == color[u]) { ok = 0; return; } } } int main() { fastio; int T; cin \u0026gt;\u0026gt; T; while (T--) { ok = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s[i]; s[i+n] = s[i]; reverse(s[i+n].begin(), s[i+n].end()); } for (int i = 1; i \u0026lt;= 2*n; i++) { for (int j = i+1; j \u0026lt;= 2*n; j++) { if (j == i+n) continue; if (similar(i, j) \u0026lt; k) { // 冲突 addEdge(i, j); addEdge(j, i); } } } for (int i = 1; i \u0026lt;= n; i++) addEdge(i, i+n), addEdge(i+n, i); vector\u0026lt;int\u0026gt; ans; memset(color, -1, sizeof(color)); for (int i = 1; i \u0026lt;= 2*n; i++) { if (color[i] == -1) { tmp1.clear(); tmp0.clear(); color[i] = 0; dfs(i); if (tmp1.size() \u0026lt; tmp0.size()) { for (int j : tmp1) ans.push_back(j); } else { for (int j : tmp0) ans.push_back(j); } } } if (!ok) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int j : ans) cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } ecnt = 1; memset(head, 0, sizeof(head)); ok = 1; } }   ","date":"2023-01-09T18:27:02-06:00","permalink":"https://tom0727.github.io/post/093-2sat/","tags":["",""],"title":"2-SAT"},{"categories":["算法"],"contents":"介绍 我们希望在二进制下枚举所有的 mask，并且枚举每个mask的所有子集。\nfor (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); mask++) { // i 枚举所有物体的选择情况 for (int sub = mask; sub; sub = (sub - 1) \u0026amp; mask) { // j 枚举了 i 的子集 ... } }  原理 每次 sub 都相当于移除了最后一个 $1$，然后再和 mask AND 一下。\n复杂度 考虑 mask 中 $bit$ 的数量，如果有 $i$ 个 $1$，那么就有 $C_n^i$ 种。而 submask 中，每个 $1$ 可选可不选，所以有 $2^i$ 种。\n总复杂度为（由二项式定理可得）：\n$$\\sum\\limits_{i=0}^n C_n^i 2^i = (1+2)^n = 3^n$$\n例题 例1 Atcoder ABC187F. Close Group 题意\n给定一个 $n$ 个节点，$m$ 条边的无向图，我们可以删除任意数量的边，使得删除后，每个联通块都是完全联通的（两两之间一定有边）。\n求，在这样操作后，图中最少有多少个联通块？\n其中，$1 \\leq n \\leq 18, 0 \\leq m \\leq \\frac{n(n-1)}{2}$。\n 题解 很明显的二进制枚举。\n令 int dp[mask] 为这个 mask 对应的最少联通块数量。\n先处理 bool ok[mask] 判断一个mask是否已经完全联通。\n然后枚举子集就可以了。\n• 如果 mask 和 submask 都知道，计算 mask - submask 只要使用 XOR 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxm = 5e5+505; int n, m; int adj[20][20]; int dp[maxm]; bool ok[maxm]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u][v] = adj[v][u] = 1; } for (int mask = 1; mask \u0026lt; (1\u0026lt;\u0026lt;n); mask++) { ok[mask] = 1; vector\u0026lt;int\u0026gt; vec; for (int j = 0; j \u0026lt; n; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;j)) vec.push_back(j+1); } for (int i : vec) { for (int j : vec) { if (i != j \u0026amp;\u0026amp; !adj[i][j]) { ok[mask] = 0; break; } } } } for (int mask = 1; mask \u0026lt; (1\u0026lt;\u0026lt;n); mask++) { dp[mask] = 1e9; } dp[0] = 0; for (int mask = 1; mask \u0026lt; (1\u0026lt;\u0026lt;n); mask++) { for (int sub = mask; sub; sub = (sub - 1) \u0026amp; mask) { if (ok[sub]) { dp[mask] = min(dp[mask], 1 + dp[mask ^ sub]); } } } cout \u0026lt;\u0026lt; dp[(1\u0026lt;\u0026lt;n)-1] \u0026lt;\u0026lt; endl; }   ","date":"2023-01-07T11:57:31-06:00","permalink":"https://tom0727.github.io/post/092-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/","tags":["",""],"title":"二进制枚举子集"},{"categories":["算法"],"contents":"介绍 容斥原理用于计算集合的 union 和 intersection 的大小。\n集合的 Union:\n$$|\\bigcup_{i=1}^{n} S_i| = \\sum_{i} |S_i| - \\sum_{i \u0026lt; j} |S_i \\cap S_j| + \\sum_{i \u0026lt; j \u0026lt; k} |S_i \\cap S_j \\cap S_k| - \u0026hellip; + (-1)^{n-1} |S_1 \\cap \u0026hellip; \\cap S_n|$$\n集合的 Intersection = 全集 - 补集的并集\n$$|\\bigcap_{i=1}^n S_i| = |U| - |\\bigcup_{i=1}^n \\bar S_i|$$\n例题 例1 CF1425D. Danger of Mad Snakes 题意\n一个 $1000 \\times 1000$ 的矩阵里放了 $n$ 条蛇，第 $i$ 个蛇位于 $(x_i, y_i)$，价值 $b_i$。\n现在，我们要放 $m$ 个炸弹，每个炸弹必须放在某条蛇身上（不能重叠）。炸弹会爆炸，爆炸半径为 $r$。\n• 比如，炸弹放在 $(x,y)$ 处，那么所有 $\\max(|x - x'|, |y - y'|) \\leq r$ 的点 $(x', y')$ 都会受到影响。\n每一个炸弹放置方案所带来的价值定义为：$(\\sum\\limits_{i} b_{i})^2$，其中 $i$ 是所有被炸弹炸到的蛇。\n求所有炸弹放置方案的价值之和，答案对 $10^9+7$ 取模。\n其中，$n \\in [1, 2000], m \\in [1, n], r \\in [0, 1000), x_i, y_i \\in [1, 1000], b_i \\in [1, 10^6]$，蛇的位置互不相同。\n 题解 看见这种 所有方案 的和，就想到每一个元素所带来的贡献。\n很明显总共有 $C_n^m$ 种方案，每种方案如果炸到的蛇是 $(a_1, a_2, \u0026hellip;, a_k)$，那么价值就是\n$$(\\sum\\limits_{i=1} b_{a_i})^2 = (b_{a_1} + b_{a_2} + \u0026hellip; + b_{a_k})^2 = \\sum\\limits_{i=1}^k b_{a_i}^2 + \\sum\\limits_{i\u0026lt;j} 2b_{a_i}b_{a_j}$$\n 先看第一项 $\\sum\\limits_{i=1}^k b_{a_i}^2$，只要考虑：\n 对于每一条蛇，有多少种方案能炸到它？\n 这个不好算，不如考虑有多少种炸不到它。\n我们可以预处理出炸弹放在每一条蛇，都能影响到哪些蛇。这样就可以得到有哪些蛇的位置放置炸弹，是炸不到这一条的。\n假设有 $k$ 个位置放炸弹，炸不到它，那么能炸到它的方案数就是 $C_n^m - C_k^m$。\n 再看第二项 $\\sum\\limits_{i\u0026lt;j} 2b_{a_i}b_{a_j}$，我们要考虑：\n 对于每两条蛇 $(i,j)$，有多少种方案都能炸到它们？\n 我们设 $A$ 为第一条蛇被炸，$B$ 为第二条蛇被炸。\n所以由容斥原理有：\n$$|A \\cap B| = |U| - |\\bar A \\cup \\bar B| = |U| - |\\bar A| - |\\bar B| + |\\bar A \\cap \\bar B|$$\n易知 $|U| = C_n^m, 而 |\\bar A|, |\\bar B|$ 上面已经算出来了，就剩下 $|\\bar A \\cap \\bar B|$。\n这代表着两条蛇都没被炸，所以只要找出有哪些点，使得这两条蛇都不会被炸就行。\n没法直接找，所以找有哪些点能分别炸到这两条蛇，然后取一个并集，用 $m$ 减掉这个并集的大小即可。\n注意到，能炸到一条蛇的范围是一个正方形，所以我们就取这两个正方形的并集，也就是将两个正方形相加然后减去正方形的交集。\n我们做一个 $01$ 矩阵，$1$ 代表这个位置可以放炸弹（有蛇），然后正方形的值就是这个正方形内的和，所以用二维前缀和。\n 正方形的交集怎么求？\n 让两个正方形的：\n 左端点 $x$ 坐标取 $\\max$，右端点 $x$ 坐标取 $\\min$。 下端点 $y$ 坐标取 $\\max$，上端点 $y$ 坐标取 $\\min$。  然后就可以得出正方形的范围是 $[x_{lmax}, x_{rmin}] \\times [y_{dmax}, y_{umin}]$。\n• 当然这个题坐标系原点在左上方，所以稍微修改一下即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e4+5; Z fac[maxn], inv_fac[maxn]; Z C(int a, int b) { if (b \u0026gt; a) return 0; return fac[a] * inv_fac[b] * inv_fac[a-b]; } int n, m, r; int x[maxn], y[maxn]; ll b[maxn]; vector\u0026lt;int\u0026gt; adj[maxn]; int sum[maxn/2][maxn/2]; Z ans = 0; struct Point { int x, y; }; struct Matrix { Point ul, ur, dl, dr; // upper left, upper right, down left, down right } mat[maxn]; // 两个矩阵相交里面的元素数量 int intersect(Matrix a, Matrix b) { int xmin = min(a.dr.x, b.dr.x); int xmax = max(a.dl.x, b.dl.x); int ymin = max(a.ul.y, b.ul.y); int ymax = min(a.dl.y, b.dl.y); if (xmin \u0026lt; xmax || ymin \u0026gt; ymax) return 0; // [xmax, xmin] * [ymin, ymax] return sum[xmin][ymax] - sum[xmin][ymin-1] - sum[xmax-1][ymax] + sum[xmax-1][ymin-1]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; r; fac[0] = 1; for (int i = 1; i \u0026lt;= 2000; i++) fac[i] = fac[i-1] * i; inv_fac[2000] = fac[2000].inv(); for (int i = 1999; i \u0026gt;= 1; i--) inv_fac[i] = inv_fac[i+1] * (i+1); inv_fac[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; b[i]; sum[x[i]][y[i]] = 1; mat[i].ul.x = max(1, x[i] - r); mat[i].ul.y = max(1, y[i] - r); mat[i].ur.x = min(1000, x[i] + r); mat[i].ur.y = max(1, y[i] - r); mat[i].dl.x = max(1, x[i] - r); mat[i].dl.y = min(1000, y[i] + r); mat[i].dr.x = min(1000, x[i] + r); mat[i].dr.y = min(1000, y[i] + r); } for (int i = 1; i \u0026lt;= 1e3; i++) { for (int j = 1; j \u0026lt;= 1e3; j++) { sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (max(abs(x[i] - x[j]), abs(y[i] - y[j])) \u0026lt;= r) { adj[i].push_back(j); } } } for (int i = 1; i \u0026lt;= n; i++) { Z r = b[i] * b[i] % mod; // 贡献 Z s = C(n, m) - C(n - adj[i].size(), m); // 方案 ans += r * s; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i+1; j \u0026lt;= n; j++) { // 计算方案数 Z s = C(n, m); int x = adj[i].size() + adj[j].size() - intersect(mat[i], mat[j]); s += C(n - x, m); s -= C(n - adj[i].size(), m); s -= C(n - adj[j].size(), m); Z r = 2LL * b[i] * b[j] % mod; ans += r * s; } } cout \u0026lt;\u0026lt; ans.val() \u0026lt;\u0026lt; endl; }   例2 CF1267K. Key Storage 题意\n对于一个整数 $n$，我们定义它的一个multiset $f(n)$ 为：\n初始序列为空，将 n % 2 放入multiset中，然后让 n /= 2，如果此时 $n \u0026gt; 0$，那么继续将 n % 3 放入multiset中，然后 n /= 3，以此类推。\n持续执行这个操作直到 $n=0$。\n给定一个正整数 $n$，求有多少个其他的正整数 $m$ 使得 $f(n)=f(m)$？\n其中，$n \\leq 10^{18}$。\n 题解 首先我们可以计算出 $n$ 对应的 $f(n)$。\n那么对于 $f(n)$，我们从小到大来看这个 multiset，第一个位置是 % 2 的结果，所以值必须 $\u0026lt;2$，第二个位置是 % 3 的结果，所以必须 $\u0026lt;3$，以此类推。\n• 最后一个位置不能为 $0$，因为除以最后一个数以后，$n$ 变成了 $0$，所以余数是不可能为 $0$ 的。\n所以实际上，计算 $f(m)$ 的数量，也就是计算给每个位置填上 multiset 中的元素的方案数，这个方案数要满足以下条件：\n 第 $i$ 个位置的数 $\u0026lt;i+1$。 最后一个位置的数不能为 $0$。  先考虑第二种，我们不妨固定最后一位为 $0$，然后用无限制的方案数减去它即可。\n现在只剩下第一个条件了，这其实是乘法原理，我们从小到大枚举位置，枚举到第 $i$ 位的时候，就将 $\\leq i$ 的数加入选项中。\n• 最后需要注意，我们计算的是 multiset 的数量，所以相同元素之间的顺序是无所谓的，所以还要把每个元素的数量的阶乘从答案里除掉。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll cnt[30], fac[18]; int T; int main() { cin \u0026gt;\u0026gt; T; fac[0] = 1; for (int i = 1; i \u0026lt; 18; i++) fac[i] = fac[i-1] * i; while (T--) { ll n; cin \u0026gt;\u0026gt; n; int m = 0; for (int i = 2; ; i++) { cnt[n % i]++; n /= i; m++; if (!n) break; } ll sum = cnt[0], ans = 1; for (int i = 1; i \u0026lt;= m; i++) { // 第 i 个：\u0026lt;= i 的 sum += cnt[i]; ans = ans * (sum - i + 1); } ll tmp = 0; if (cnt[0]) { tmp = cnt[0]; // 最后一位固定为0，可以有 cnt[0] 种选法 sum = cnt[0] - 1; // 预设最后一个为 0 for (int i = 1; i \u0026lt; m; i++) { sum += cnt[i]; tmp = tmp * (sum - i + 1); } } ans -= tmp; for (int i = 0; i \u0026lt; 18; i++) { ans /= fac[cnt[i]]; } ans--; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; memset(cnt, 0, sizeof(cnt)); } }   例3 Atcoder ABC152F. Tree and Constraints 题意\n给定 $n$ 个节点的树，每个边可以被涂成黑色或者白色。\n给定 $m$ 个constraint $(u_i,v_i)$，代表 $(u_i,v_i)$ 的路径上至少有一个黑色边？\n求有多少钟涂色方案，使得所有constraint都被满足？\n其中，$2 \\leq n \\leq 50, 1 \\leq m \\leq 20$。\n 题解 $m\\leq 20$，一眼暴力。\n这个至少有一条黑色边很不好处理，但它的补集是路径上所有都是白色边。这个就好办了。\n所以令 $S_i$ 为：第 $i$ 个constraint没有被满足。\n要求的是 $|S_1 \\cup S_2 \u0026hellip; \\cup S_m|$，即至少有一个constraint没有被满足的方案数量。\n根据容斥原理，就是 +1个不满足 - 2个不满足 + 3个不满足 \u0026hellip;\n所以我们直接bitmask枚举所有的情况，对于不满足的constraint，它们路径上的所有边只能涂白，剩下的所有边随便涂。然后根据奇偶性判断符号即可。\n• 处理constraint的时候用树上差分。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 500+5; const int maxm = 2e6+5; int n, m; vector\u0026lt;int\u0026gt; adj[maxn]; ll ans = 1; pii p[maxn]; int count_bits(ll x) { int res = 0; while (x) { if (x\u0026amp;1) res++; x \u0026gt;\u0026gt;= 1; } return res; } int lca[maxn][maxn], par[maxn], dep[maxn], val[maxn]; void dfs(int u, int p) { dep[u] = dep[p] + 1; for (int v : adj[u]) { if (v == p) continue; par[v] = u; dfs(v, u); } } void init_lca(int u, int v) { int tu = u, tv = v; if (u == v) { lca[u][v] = lca[v][u] = u; return; } if (dep[u] \u0026lt; dep[v]) swap(u,v); while (dep[u] \u0026gt; dep[v]) u = par[u]; assert(dep[u] == dep[v]); while (u != v) { u = par[u], v = par[v]; } lca[tu][tv] = lca[tv][tu] = u; } ll cnt = 0; void dfs2(int u, int p) { for (int v : adj[u]) { if (v == p) continue; dfs2(v, u); val[u] += val[v]; if (val[v] \u0026gt; 0) cnt++; // (u,v) must be white } } ll p2[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } dfs(1, 0); p2[0] = 1; for (int i = 1; i \u0026lt;= n; i++) p2[i] = p2[i-1] * 2; ans = p2[n-1]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; p[i].first \u0026gt;\u0026gt; p[i].second; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026lt;= n; j++) { init_lca(i,j); } } for (int mask = 1; mask \u0026lt; (1\u0026lt;\u0026lt;m); mask++) { int f = ((count_bits(mask) \u0026amp; 1) ? -1 : 1); memset(val, 0, sizeof(val)); cnt = 0; for (int j = 0; j \u0026lt; m; j++) { if (mask\u0026amp;(1\u0026lt;\u0026lt;j)) { // j+1 int u = p[j+1].first, v = p[j+1].second; val[u]++; val[v]++; val[lca[u][v]] -= 2; } } dfs2(1, 0); ans += f * p2[n-1-cnt]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2022-12-31T21:16:36-06:00","permalink":"https://tom0727.github.io/post/091-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","tags":["",""],"title":"容斥原理"},{"categories":[""],"contents":"介绍 点分治用于处理 树上的路径问题。\n点分治的主要思想是，对于一棵子树，子树内的所有路径只有两种情况：\n 不经过根节点 经过根节点  对于第一种，我们可以在处理其他子树的时候再讨论。\n对于第二种，注意到一个经过根节点的路径，可以被拆分成从根节点出发的一条路径，合并上另外一条从根节点出发的路径。\n所以点分治的核心思想就是对于每一个子树，都只考虑从根节点出发的路径，这些路径有 $O(n)$ 条。\n但极端情况下，比如一条链，这样的复杂度可能来到 $O(n^2)$，所以在寻找一个子树的根时，应该将这个子树的重心作为根，这样递归的时候深度最多就是 $O(\\log n)$。\n总体上来说复杂度就是 $O(n \\log n)$。\n模版 int n, m; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, queries[maxn]; bool ans[maxn], has_dis[maxm]; // has_dis[i]: 当前子树中存在到根距离为i的节点 void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn], dis[maxn], q[maxn], hd = 1, tail = 0; bool vis[maxn]; vector\u0026lt;int\u0026gt; tmp; int cursz, rt; void find_centroid(int u, int p) { sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; find_centroid(v, u); sz[u] += sz[v]; mx = max(mx, sz[v]); } mx = max(mx, cursz - sz[u]); if (mx \u0026lt;= cursz / 2) rt = u; } void get_cursz(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v] || v == p) continue; get_cursz(v, u); sz[u] += sz[v]; } } void getdis(int u, int p) { q[++tail] = dis[u]; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; dis[v] = dis[u] + edges[e].w; getdis(v, u); } } // 计算 u 为根，所有以 u 出发的路径带来的贡献 void calc(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; hd = 1, tail = 0; // 清空 v 的子树信息 dis[v] = dis[u] + edges[e].w; getdis(v, u); // 将子树 v 的贡献加进 ans for (int p = hd; p \u0026lt;= tail; p++) { // 遍历子树 v 的节点 for (int k = 1; k \u0026lt;= m; k++) { // 遍历每一个询问 int q_dis = queries[k]; if (q_dis \u0026gt;= q[p]) { ans[k] |= has_dis[q_dis - q[p]]; } } } // 考虑完子树 v 以后，将子树 v 的信息储存进去 for (int p = hd; p \u0026lt;= tail; p++) { has_dis[q[p]] = 1; tmp.push_back(q[p]); } } for (int d : tmp) has_dis[d] = 0; // 清空 u 的子树信息 tmp.clear(); } // 分治 u void solve(int u) { vis[u] = 1; dis[u] = 0; has_dis[0] = 1; // 初始情况 calc(u); // 处理答案 for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; get_cursz(v, 0); cursz = sz[v]; find_centroid(v, u); solve(rt); // 子树 } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt; n; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u, v, w); addEdge(v, u, w); } for (int i = 1; i \u0026lt;= m; i++) { int k; cin \u0026gt;\u0026gt; k; queries[i] = k; } find_centroid(1, 0); solve(rt); for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;AYE\u0026quot; : \u0026quot;NAY\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   在模版中，主要修改的部分就是 calc(u) 函数，这个函数代表着题目要求计算什么样的路径。\n例题 例1 洛谷P3806 点分治1 题意\n给定一棵有 $n$ 个点的树，边有权值。\n有 $m$ 次询问，每次询问树上距离为 $k$ 的点对是否存在。\n其中，$n \\leq 10^4, m \\leq 100, 1 \\leq k \\leq 10^7, 1 \\leq w \\leq 10^4$。\n 题解 注意到 $k \\leq 10^7$，所以可以开一个数组来储存长度为 $x$ 的路径（从根出发）是否存在。\n然后就是点分治的模版了，有几个点可能需要注意：\n 点分治的 calc(u) 过程里，枚举了每个子树 $v$，枚举一个 $v$ 得到子树信息以后，先将信息贡献给 ans[]，然后才储存进当前子树内。这是为了防止出现非法的情况，比如一个路径，两个端点都在同一个子树 $v$ 内，这也类似于树形 DP 的思想。 使用了一个队列 q 来储存子树 $v$ 的信息。 使用了一个 vector\u0026lt;\u0026gt; tmp 来储存整个 $u$ 子树的节点，calc() 结束以后用来清空信息，避免 memset 导致复杂度变成 $O(n^2)$。 记得根节点 $u$ 的信息在一开始要先储存进去（或者后续贡献 ans[] 时单独考虑）。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 1e8+5; int n, m; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, queries[maxn]; bool ans[maxn], has_dis[maxm]; // has_dis[i]: 当前子树中存在到根距离为i的节点 void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn], dis[maxn], q[maxn], hd = 1, tail = 0; bool vis[maxn]; vector\u0026lt;int\u0026gt; tmp; int cursz, rt; void find_centroid(int u, int p) { sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; find_centroid(v, u); sz[u] += sz[v]; mx = max(mx, sz[v]); } mx = max(mx, cursz - sz[u]); if (mx \u0026lt;= cursz / 2) rt = u; } void get_cursz(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v] || v == p) continue; get_cursz(v, u); sz[u] += sz[v]; } } void getdis(int u, int p) { q[++tail] = dis[u]; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; dis[v] = dis[u] + edges[e].w; getdis(v, u); } } void calc(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; hd = 1, tail = 0; // 清空 v 的子树信息 dis[v] = dis[u] + edges[e].w; getdis(v, u); for (int p = hd; p \u0026lt;= tail; p++) { for (int k = 1; k \u0026lt;= m; k++) { // 遍历询问 int q_dis = queries[k]; if (q_dis \u0026gt;= q[p]) { ans[k] |= has_dis[q_dis - q[p]]; } } } for (int p = hd; p \u0026lt;= tail; p++) { has_dis[q[p]] = 1; tmp.push_back(q[p]); } } for (int d : tmp) has_dis[d] = 0; // 清空 u 的子树信息 tmp.clear(); } void solve(int u) { vis[u] = 1; dis[u] = 0; has_dis[0] = 1; // 初始情况 calc(u); // 处理答案 for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; get_cursz(v, 0); cursz = sz[v]; find_centroid(v, u); solve(rt); // 子树 } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt; n; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u, v, w); addEdge(v, u, w); } for (int i = 1; i \u0026lt;= m; i++) { int k; cin \u0026gt;\u0026gt; k; queries[i] = k; } find_centroid(1, 0); solve(rt); for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;AYE\u0026quot; : \u0026quot;NAY\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 洛谷P4178 Tree 题意\n给定一棵有 $n$ 个点的树，边有权值。\n求出树上两点距离小于等于 $k$ 的点对数量。\n其中，$n \\leq 4 \\times 10^4, w \\in [0, 10^3], k \\in [0, 2 \\times 10^4]$。\n 题解 小于等于 $k$ 的话，用树状数组维护一下就可以了，剩下的和上一题几乎没区别。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct BIT { int n, tr[maxn]; inline int lowbit(int x) { return x \u0026amp; -x; } void update(int p, int val) { while (p \u0026lt;= n) { tr[p] += val; p += lowbit(p); } } // return sum[1...p] int query(int p) { int ans = 0; while (p \u0026gt; 0) { ans += tr[p]; p -= lowbit(p); } return ans; } } tr; int n, k; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, queries[maxn]; ll ans = 0; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn], dis[maxn], q[maxn], hd = 1, tail = 0; bool vis[maxn]; vector\u0026lt;int\u0026gt; tmp; int cursz, rt; void find_centroid(int u, int p) { sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; find_centroid(v, u); sz[u] += sz[v]; mx = max(mx, sz[v]); } mx = max(mx, cursz - sz[u]); if (mx \u0026lt;= cursz / 2) rt = u; } void get_cursz(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v] || v == p) continue; get_cursz(v, u); sz[u] += sz[v]; } } void getdis(int u, int p) { q[++tail] = dis[u]; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || vis[v]) continue; dis[v] = dis[u] + edges[e].w; getdis(v, u); } } void calc(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; hd = 1, tail = 0; // 清空 v 的子树信息 dis[v] = dis[u] + edges[e].w; getdis(v, u); for (int p = hd; p \u0026lt;= tail; p++) { int d = q[p]; // d + x \u0026lt;= k 说明 x \u0026lt;= k - d if (d \u0026lt;= k) { ans += tr.query(k - d); ans++; // 到根节点 } } for (int p = hd; p \u0026lt;= tail; p++) { if (q[p] \u0026lt;= k) { tr.update(q[p], 1); tmp.push_back(q[p]); } } } // printf(\u0026quot;u = %d, ans = %lld\\n\u0026quot;,u,ans); for (int d : tmp) tr.update(d, -1); tmp.clear(); } void solve(int u) { vis[u] = 1; dis[u] = 0; calc(u); // 处理答案 for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (vis[v]) continue; get_cursz(v, 0); cursz = sz[v]; find_centroid(v, u); solve(rt); // 子树 } } int main() { tr.n = 2e4; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u, v, w); addEdge(v, u, w); } cin \u0026gt;\u0026gt; k; find_centroid(1, 0); solve(rt); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2022-12-29T16:07:08-06:00","permalink":"https://tom0727.github.io/post/090-%E7%82%B9%E5%88%86%E6%B2%BB/","tags":["",""],"title":"点分治"},{"categories":["算法"],"contents":"这篇 blog 记录一个树状数组上二分的小技巧。\n介绍 对于树状数组，我们知道它支持 $O(\\log n)$ 内进行如下操作：\n 单点修改 前缀和查询  现在我们希望它用 $O(\\log n)$ 支持第三种操作：\n二分找到一个前缀和的值  形式化的，例如在上面 lower_bound(v)，就希望找到一个最小的 $i$，使得 $sum[1\u0026hellip;i] \\geq v$。\n思想 我们利用倍增的思想，类似于树上倍增找 LCA，我们知道，因为树状数组是以 $2^i$ 来记录前缀和的，我们也可以从高位开始枚举，如果当前的和加上这一段的和 $\u0026lt; v$ 那么就加上，并且更新 pos，否则看下一位。\n// 找到最小的 p 使得 sum[1...p] \u0026gt;= v int LOGN = 19; int bit_lowerbound(int v) { int sum = 0; int pos = 0; for(int i = LOGN; i \u0026gt;= 0; i--) { if (pos + (1 \u0026lt;\u0026lt; i) \u0026lt;= n \u0026amp;\u0026amp; sum + tr[pos + (1 \u0026lt;\u0026lt; i)] \u0026lt; v) { sum += tr[pos + (1 \u0026lt;\u0026lt; i)]; pos += (1 \u0026lt;\u0026lt; i); } } return pos + 1; // +1 because 'pos' will have position of largest value \u0026lt; 'v' } // 找到最小的 p 使得 sum[1...p] \u0026gt; v int bit_upperbound(int v) { int sum = 0; int pos = 0; for(int i = LOGN; i \u0026gt;= 0; i--) { if (pos + (1 \u0026lt;\u0026lt; i) \u0026lt;= n \u0026amp;\u0026amp; sum + tr[pos + (1 \u0026lt;\u0026lt; i)] \u0026lt;= v) { sum += tr[pos + (1 \u0026lt;\u0026lt; i)]; pos += (1 \u0026lt;\u0026lt; i); } } return pos + 1; // +1 because 'pos' will have position of largest value \u0026lt;= 'v' }  由于树状数组的特性，pos 需要从 $0$ 开始。\n线段树版本 其实线段树也可以 $O(\\log n)$ 进行二分前缀和。\n不过前缀和的方式不太一样，线段树的方式是从根开始 dfs，判断左边的和加上当前和是否 $\u0026lt; v$，如果是的话，加上左边的和，然后走到右边，否则就走左边。\n这个思想有点类似于主席树的区间第 $k$ 大，只不过是线段树版本，更简单一些。\n例题 例1 CF787E. Till I Collapse 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n对于每一个 $k \\in [1,n]$，问数组最少需要分成连续的几段，使得每一段里面 distinct 元素的数量 $\\leq k$。\n其中，$n \\in [1, 10^5], a_i \\in [1, n]$。\n 题解 先思考简化版的问题：\n 给定一个数组，$q$ 个询问，每次询问 $[L,R]$ 之间有多少个 distinct 的元素？\n 这个问题已经记录过了：HH的项链，大体思路就是离线，然后遍历询问的过程中只保留最靠左/右的那个，建立线段树/树状数组维护一个 $01$ 序列代表这个元素是否在当前范围内即可。\n 回到这个问题，对于每一个 $k$，可以知道我们从 $1$ 出发，每次向右走尽可能多的步数使得范围内 distinct 元素的数量 $\\leq k$。能走到哪？可以考虑使用二分。\n因为询问 $[L,R]$ 之间的 distinct 元素个数本质上就是 $sum[L\u0026hellip;R] \\leq k$，其实就是 $s_R - s_{L-1} \\leq k$，也就是 $s_R \\leq k + s_{L-1}$。\n由于我们询问时固定了 $L$，所以 $k + s_{L-1}$ 是定值，那么 $R$ 的位置可以利用树状数组上 upper_bound 来 $O(\\log n)$ 找到。\n 最后，需要考虑怎么离线询问？\n注意到如果我们一边处理询问，一边获得下一个区间的左端点，那么区间的左端点是自然排序好的，不用手动去排序了。\n实现的过程中，对于每一个左端点都开一个 vector 记录询问即可。\n复杂度：$O(n \\log n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n, a[maxn], nxt[maxn], pos[maxn]; inline int lowbit(int x) { return x \u0026amp; -x; } int tr[maxn]; void update(int p, int val) { while (p \u0026lt;= n) { tr[p] += val; p += lowbit(p); } } // return sum[1...p] int query(int p) { int ans = 0; while (p \u0026gt; 0) { ans += tr[p]; p -= lowbit(p); } return ans; } int LOGN = 19; // 找到最小的 p 使得 sum[1...p] \u0026gt;= v int bit_lowerbound(int v) { int sum = 0; int pos = 0; for(int i = LOGN; i \u0026gt;= 0; i--) { if (pos + (1 \u0026lt;\u0026lt; i) \u0026lt;= n \u0026amp;\u0026amp; sum + tr[pos + (1 \u0026lt;\u0026lt; i)] \u0026lt; v) { sum += tr[pos + (1 \u0026lt;\u0026lt; i)]; pos += (1 \u0026lt;\u0026lt; i); } } return pos + 1; // +1 because 'pos' will have position of largest value \u0026lt; 'v' } // 找到最小的 p 使得 sum[1...p] \u0026gt; v int bit_upperbound(int v) { int sum = 0; int pos = 0; for(int i = LOGN; i \u0026gt;= 0; i--) { if (pos + (1 \u0026lt;\u0026lt; i) \u0026lt;= n \u0026amp;\u0026amp; sum + tr[pos + (1 \u0026lt;\u0026lt; i)] \u0026lt;= v) { sum += tr[pos + (1 \u0026lt;\u0026lt; i)]; pos += (1 \u0026lt;\u0026lt; i); } } return pos + 1; // +1 because 'pos' will have position of largest value \u0026lt;= 'v' } vector\u0026lt;int\u0026gt; queries[maxn]; // query[i]: 以 i 为端点的所有 query 对应的 k值 int ans[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = n; i \u0026gt;= 1; i--) { if (!pos[a[i]]) nxt[i] = n+1; else nxt[i] = pos[a[i]]; pos[a[i]] = i; } // 先保留 [1,n] 中最靠左的 for (int i = n; i \u0026gt;= 1; i--) { if (nxt[i] \u0026lt;= n) { update(nxt[i], -1); } update(i, 1); } for (int k = 1; k \u0026lt;= n; k++) queries[1].push_back(k); for (int L = 1; L \u0026lt;= n; L++) { for (int k : queries[L]) { ans[k]++; int R = bit_upperbound(k + query(L-1)) - 1; queries[R+1].push_back(k); } update(L, -1); if (nxt[L] \u0026lt;= n) update(nxt[L], 1); } for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://codeforces.com/blog/entry/61364  ","date":"2022-12-27T23:39:23-06:00","permalink":"https://tom0727.github.io/post/089-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86/","tags":["",""],"title":"树状数组二分"},{"categories":["解题报告"],"contents":"L. Lost Permutation 题意\n交互题。\n有一个隐藏的 permutation $\\pi$，长度为 $n$。\n现在只有一种询问：\n$? ~f_1 ~f_2 \u0026hellip; ~f_n$：给定一个 permutation $f$，系统会回答你一个 permutation $g$，其中 $g = \\pi^{-1} \\circ f \\circ \\pi$。\n你只能询问 $2$ 次，回答这个隐藏的 permutation $\\pi$。\n其中，$3 \\leq n \\leq 10^4$。\n Permutation 的定义\nPermutation 的定义：\n若有一个permutation $a=(4,1,3,2)$，我们需要看第 $i$ 位上的数字 $a_i$，意味着把旧 permutation 第 $i$ 位上的数字映射到新 permutation 中的第 $a_i$ 位。\n• 这里 $a$ 是一个运算符，单独存在时，旧的permutation都是 $1,2,3,\u0026hellip;,n$。\n $i = 1, a_1 = 4$，说明把第 $1$ 位的数字（是 $1$）放到 第 $4$ 位，所以新 permutation 就是 $(?, ?, ?, 1)$。 $i = 2, a_2 = 1$，说明把第 $2$ 位的数字（是 $2$）放到 第 $1$ 位，所以新 permutation 就是 $(2, ?, ?, 1)$。 $i = 3, a_3 = 3$，说明把第 $3$ 位的数字（是 $3$）放到 第 $3$ 位，所以新 permutation 就是 $(2, ?, 3, 1)$。 $i = 4, a_4 = 2$，说明把第 $4$ 位的数字（是 $4$）放到 第 $2$ 位，所以新 permutation 就是 $(2, 4, 3, 1)$。  由此也可以得出 $a^{-1} = (2,4,3,1)$。\n $a \\circ b$ 则代表对于 $I=(1,2,3\u0026hellip;,n)$ 先施加 $a$，再施加 $b$。\n所以可得：\n若 $a = (4,1,3,2), b = (3,2,1,4)$，那么 $a \\circ b = (4,3,1,2)$。\n 题解 置换群。\n首先明确 $\\forall \\pi, f, \\pi^{-1} \\circ f \\circ \\pi$ 与 $f$ 是共轭的（conjugate）。\n这意味着，如果我们把一个 permutation 看作一个图：\n例如 $b = (3,2,1,4)$，那么有 $1 \\rightarrow 3, 2 \\rightarrow 2, 3 \\rightarrow 1, 4 \\rightarrow 4$。\n$a=(4,1,3,2),a^{-1} = (2,4,3,1)$\n$a^{-1} \\circ b \\circ a = (1,2,4,3)$，所以有 $1 \\rightarrow 1, 2 \\rightarrow 2, 3 \\rightarrow 4, 4 \\rightarrow 3$。\n看到图上的结构是不是完全一致？由此，得出一个结论：\n 两个 permutation 是共轭的 $\\iff$ 存在一种 bijection，使得图上节点重新编号，能得到另外一个图。\n 这也等价为下图：\n所以我们的方案就有了：\n第一次询问 $f = (2,3,4,\u0026hellip;,n,1)$，这样可以得到一个大的环，而返回的 $g$ 也一定是一个大环。\n并且我们只要找到 $\\pi_1$，剩下的都可以找到了。\n 第二次询问：\n我们需要找到 $\\pi_1$，利用共轭的特点，我们不妨询问一个 fixed point $1$ 和一个环。\n所以第二次询问 $f = (1, 3, 4, \u0026hellip;, n, 2)$，这样回答我们的也是一个 fixed point $\\pi_1$ 和一个环，所以只要找到这个 fixed point 即可得到 $\\pi_1$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; int T; int a[maxn], b[maxn], ans[maxn]; int main() { cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; \u0026quot;? \u0026quot;; for (int i = 2; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; fflush(stdout); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cout \u0026lt;\u0026lt; \u0026quot;? \u0026quot;; cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; for (int i = 3; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; fflush(stdout); int p; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; b[i]; if (b[i] == i) p = i; } ans[1] = p; for (int i = 2; i \u0026lt;= n; i++) ans[i] = a[ans[i-1]]; cout \u0026lt;\u0026lt; \u0026quot;! \u0026quot;; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; fflush(stdout); } }   N. Nunchucks Shop 题意\n现在有若干个棒子，每个棒子里包含 $n$ 个珠子（要么是白，要么是黑）。\n每一种组合由两根棒子连接而成，并且总共包含 $k$ 个黑色珠子。\n现在问需要多少个棒子，使得所有可能的组合都能出现？\n例如：\n$n=3, k=2$ 时就需要 $7$ 个。\n• 注意到棒子是可以左右翻转的，所以需要考虑对称的情况。\n其中，$n \\leq 50, k \\in [0, 2n]$。\n 题解 如果 $k \\geq n+1$，那么就让黑白颠倒，即 $k = 2n - k$。\n所以只用考虑 $k \\leq n$ 的情况。\n那么两根棒子，黑色珠子的数量组合为 $(0,k), (1,k-1) \u0026hellip; (k,0)$，其中对称的情况是一样的，即 $(0,k) = (k,0)$。\n那么只要求出，一个棒子中，有 $j$ 个黑色珠子的话，有多少种情况即可（需要考虑对称）。\n我们令这个值为 $S(n,j)$。\n如果不考虑对称，很明显是 $C(n,j)$。\n如果要考虑对称，我们设黑色为 $1$，白色为 $0$，那么 $1000$ 和 $0001$ 就是对称的，每当有两个不同的字符串对称时，数量就会减一。\n 但是也有些字符串的对称是自己（回文串）：比如 $1111$ 对称的是 $1111$，$0110$ 对称的是 $0110$。\n那么有多少种字符串是回文串？\n如果 $n$ 是偶数，$k$ 是奇数，可以发现不存在回文串。\n否则，有 $C(\\frac{n}{2}, \\frac{j}{2})$ 个回文串。\n因为一个回文串如果左边部分定了，右边部分也定了，所以就相当于只能从 $\\frac{n}{2}$ 个格子里选 $\\frac{j}{2}$ 个黑色的。\n 于是有\n$$S(n,j) = \\frac{C(n,j) + C(\\frac{n}{2}, \\frac{j}{2})}{2}$$\n而最终答案就是\n$$ans = \\sum\\limits_{j=0}^k S(n,j)$$\n当然还要加上 $S(n,\\frac{k}{2})$，如果 $k$ 是偶数。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll C[55][55]; ll cnt(int n, int k) { if (n % 2 == 0 \u0026amp;\u0026amp; k % 2 == 1) return C[n][k] / 2; return (C[n][k] + C[n/2][k/2]) / 2; } int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; C[0][0] = 1; for (int i = 1; i \u0026lt;= 50; i++) { C[i][0] = 1; for (int j = 1; j \u0026lt;= i; j++) { C[i][j] = C[i-1][j-1] + C[i-1][j]; } } if (k \u0026gt;= n+1) k = 2*n - k; ll ans = 0; for (int i = 0; i \u0026lt;= k; i++) { int j = k - i; if (i \u0026gt; j) break; ans += cnt(n, i) + cnt(n, j); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2022-12-26T23:07:50-06:00","permalink":"https://tom0727.github.io/post/088-icpc-2020-neerc-regional/","tags":["",""],"title":"2020-2021 ICPC NERC (NEERC), North-Western Russia Regional Contest"},{"categories":["算法"],"contents":"介绍 两个树同构 $\\iff$ 有且仅有一种重新编号方式，使得一棵树的节点重新编号后得到另外一棵树。\n• 如果是有根树同构，那么还要额外加一个限制条件：树的节点重新编号，必须让 $r_1$ 映射到 $r_2$，其中 $r_1,r_2$ 为这两棵树的根。\n哈希方法 树哈希的方法有很多种，这里提供一位黑红老哥的方法：\n对于一棵以 $u$ 为根的子树，假设儿子是 $v_1,v_2,\u0026hellip;,v_k$，定义子树的哈希\n$$h(u) = 1 + \\sum\\limits_{i \\in [1,k]} f(h(v_i))$$\n其中 $h(v_i)$ 是 $v_i$ 对应子树的哈希，$f$ 为一个待定函数。\n代码 mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); ull h[maxn], base = rng(); ull H(ull x){ return x*x*x*19890535+19260817; } ull F(ull x){ return H(x\u0026amp;((1ll\u0026lt;\u0026lt;32)-1))+H(x\u0026gt;\u0026gt;32); } void dfs2(int u, int p, int f) { h[u] = base; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || v == f) continue; dfs2(v, u, f); h[u] += F(h[v]); } }   树同构的判断方式 判断两棵树是否同构，一般都是无根树的情况。而对于同一棵树来说，选定不同的节点作为根，得到的哈希值并不相同。\n但如果两棵树同构，意味着它们的重心是相同的，所以只要分别找到两棵树的重心，然后让重心作为根，再求哈希值，比较是否相同即可。\n• 需要注意的是重心可能有 $2$ 个，所以需要比较 $2$ 次，只要有一次对上了就说明同构。(如果同构，则说明第一棵树的任意一个重心 $a_1$ 的哈希值一定等于第二棵树的其中一个重心的哈希值)。\n例题 例1 洛谷P5043 【模板】树同构 题意\n给定 $M$ 棵树，根据同构关系将它们分为等价类。\n其中，$n, M \\leq 50$。\n 题解 求出每棵树的重心，然后暴力两两对比即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 55; const int maxm = 1e5+5; struct Edge { int from, to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxm], ecnt = 1; void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxm], cur_tr; int M; int rt[maxn], tr_sz[maxn]; vector\u0026lt;int\u0026gt; cent[maxn]; ull h[maxm], base = rng(); ull H(ull x){ return x*x*x*19890535+19260817; } ull F(ull x){ return H(x\u0026amp;((1ll\u0026lt;\u0026lt;32)-1))+H(x\u0026gt;\u0026gt;32); } void dfs1(int u, int p) { sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs1(v, u); sz[u] += sz[v]; mx = max(mx, sz[v]); } int cur_sz = tr_sz[cur_tr]; mx = max(mx, cur_sz - sz[u]); if (mx \u0026lt;= cur_sz / 2) cent[cur_tr].push_back(u); } vector\u0026lt;ull\u0026gt; ha[maxn]; void dfs2(int u, int p) { h[u] = base; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs2(v, u); h[u] += F(h[v]); } } int main() { cin \u0026gt;\u0026gt; M; int id = 0; for (int j = 1; j \u0026lt;= M; j++) { int n; cin \u0026gt;\u0026gt; n; tr_sz[j] = n; for (int i = 1; i \u0026lt;= n; i++) { int p; cin \u0026gt;\u0026gt; p; if (p \u0026gt; 0) { p += id; addEdge(p, i+id); addEdge(i+id, p); } else { rt[j] = i + id; } } id += n; } for (int j = 1; j \u0026lt;= M; j++) { cur_tr = j; dfs1(rt[j], 0); for (int c : cent[j]) { dfs2(c, 0); ha[j].push_back(h[c]); } } for (int tj = 1; tj \u0026lt;= M; tj++) { for (int ti = 1; ti \u0026lt;= tj; ti++) { bool ok = 0; for (ull h1 : ha[tj]) { for (ull h2 : ha[ti]) { if (h1 == h2) ok = 1; } } if (ok) { cout \u0026lt;\u0026lt; ti \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; break; } } } }   例2 CF1252F Regular Forestation 题意\n给定一棵无根树，问是否存在一个点 $u$，使得将点 $u$ 移除后，得到的所有子树两两同构？\n如果存在，输出 degree 最大的这样的 $u$。\n• 要求 $u$ 的degree至少为 $2$。\n其中，$n \\leq 4000$。\n 题解 由于 $n \\leq 4000$，所以先定 $1$ 为根，然后：\n 找出所有子树的重心。 找出对于所有 $u$，除了 $u$ 子树以外的部分的重心。 然后对于每个 $u$，check它的所有子树和它以外的部分是否同构。  第一步可以用树的重心提到的 $O(n)$ 方法来找，第二步好像没有什么好方法，只能暴力了。\n第三步注意一下重心可能有两个，然后拿个 map 记录一下哈希值的 count，注意到一棵子树最多贡献一次哈希值count即可。\n复杂度是 $O(n^2)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 8005; struct Edge { int from, to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn], deg[maxn], son[maxn], par[maxn]; vector\u0026lt;int\u0026gt; cent[maxn\u0026lt;\u0026lt;1]; // cent[i]: centroids of subtree i, cent[i+n]: centroids of up[i] ull h[maxn], base = rng(); ull H(ull x){ return x*x*x*19890535+19260817; } ull F(ull x){ return H(x\u0026amp;((1ll\u0026lt;\u0026lt;32)-1))+H(x\u0026gt;\u0026gt;32); } void dfs1(int u, int p) { par[u] = p; sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs1(v, u); if (sz[v] \u0026gt; sz[son[u]]) { son[u] = v; } sz[u] += sz[v]; mx = max(mx, sz[v]); } if (mx \u0026lt;= sz[u] / 2) cent[u].push_back(u); if (cent[son[u]].size()) { int k = cent[son[u]][0]; while (k != u) { if (sz[son[k]] \u0026lt;= sz[u] / 2 \u0026amp;\u0026amp; sz[u] - sz[k] \u0026lt;= sz[u] / 2) { cent[u].push_back(k); } if (cent[u].size() \u0026gt;= 2 || sz[son[k]] \u0026gt; sz[u] / 2) break; // 再往上不会更优了 k = par[k]; } } } vector\u0026lt;ull\u0026gt; ha[maxn]; void dfs2(int u, int p, int f) { h[u] = base; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || v == f) continue; dfs2(v, u, f); h[u] += F(h[v]); } } int cursz, currt; // 当前考虑部分的sz, root (如果是 i 外面的，currt 就是 i + n) void dfs3(int u, int p, int f) { sz[u] = 1; int mx = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || v == f) continue; dfs3(v, u, f); sz[u] += sz[v]; mx = max(mx, sz[v]); } if (mx \u0026lt;= cursz / 2 \u0026amp;\u0026amp; cursz - sz[u] \u0026lt;= cursz / 2) { cent[currt].push_back(u); } } void dfs4(int u, int p, int f) { h[u] = base; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p || v == f) continue; dfs4(v, u, f); h[u] += F(h[v]); } } int n; int ans = 0; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); deg[u]++; deg[v]++; } dfs1(1, 0); for (int i = 1; i \u0026lt;= n; i++) { for (int c : cent[i]) { dfs2(c, 0, par[i]); ha[i].push_back(h[c]); } } // 现在处理所有子树外的部分 for (int i = 1; i \u0026lt;= n; i++) { if (deg[i] \u0026lt; 2) continue; bool ok = 1; map\u0026lt;ull, int\u0026gt; mp; // hash: count int s = sz[son[i]]; if (n - sz[i] != s) ok = 0; for (int e = head[i]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == par[i]) continue; if (sz[v] != s) ok = 0; if (ha[v].size() == 2 \u0026amp;\u0026amp; ha[v][0] == ha[v][1]) { mp[ha[v][0]]++; } else { for (ull hv : ha[v]) { mp[hv]++; } } } if (!ok) continue; // 现在说明 i 可能为最佳切割点 // 寻找 i 外面子树的信息 (如果有) if (par[i]) { cursz = n - sz[i]; currt = i + n; dfs3(par[i], 0, i); } for (int c : cent[i+n]) { dfs4(c, 0, i); ha[i+n].push_back(h[c]); } if (ha[i+n].size() == 2 \u0026amp;\u0026amp; ha[i+n][0] == ha[i+n][1]) { mp[ha[i+n][0]]++; } else { for (ull hv : ha[i+n]) mp[hv]++; } for (auto ptr : mp) { if (ptr.second == deg[i]) { ans = max(ans, deg[i]); } } } cout \u0026lt;\u0026lt; (ans ? ans : -1) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://zh.wikipedia.org/zh-hk/%E6%A0%91%E5%90%8C%E6%9E%84 https://peehs-moorhsum.blog.uoj.ac/blog/7891 https://uoj.ac/submission/580510  ","date":"2022-12-25T18:14:24-06:00","permalink":"https://tom0727.github.io/post/087-%E6%A0%91%E5%90%8C%E6%9E%84/","tags":["",""],"title":"树同构"},{"categories":["算法"],"contents":"定义 树的重心是指：\n在一棵无权无根树中，对于每一个点 $u$，计算它所有子树中最大的子树的节点数，这个最大值最小的点 $u$ 就是树的重心。\n性质   点 $u$ 为重心 $\\iff$ 以 $u$ 为根时，所有子树大小 $\\leq \\frac{n}{2}$\n  重心至少有一个，最多有两个。\n2.1. 如果有两个重心，那么它们之间一定有一条边相连，且此时树一定是有偶数个节点，且存在一种方式分割成两棵树，使得这两个重心分别为两棵树的重心。\n  点 $u$ 为重心 $\\iff$ 树中所有点到某个点的距离和中，到 $u$ 的距离和是最小的。\n3.1. 如果有两个重心，那么到它们的距离和一样。\n  把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上，并且新重心会落在较大的树那边。\n  在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。\n  证明   $\\Rightarrow$：如果存在一个重心使得某个子树大小 $\u0026gt; \\frac{n}{2}$，那么向着这个子树的方向移动一条边，一定能找到一个更优的重心。$\\Leftarrow$：当以 $u$ 为根时，如果所有子树大小 $\\leq \\frac{n}{2}$，那么它的任意邻居 $v$ 不可能比 $u$ 更优，因为以 $v$ 为根时，$u$ 所在子树的大小会 $\\geq \\frac{n}{2}$。\n  易证一个和两个的情况，如果有 $3$ 个重心，易证每两个重心之间一定有一条边相连，而这样的话会形成一个大小为 $3$ 的环，不可能是树。\n2.1. 有两个重心意味着有两个大小为 $\\frac{n}{2}$ 的子树。\n  设点 $u$ 到所有其他点的距离为 $d_u$，那么如果存在一个邻居 $v$ 使得 $v$ 所在子树的大小 $\u0026gt; \\frac{n}{2}$，那么移动到 $v$ 一定有 $d_v \u0026lt; d_u$（因为贡献的点数量 $\u0026gt; \\frac{n}{2}$）。由此可以推出，除了重心以外的点都至少存在一个邻居使得 $d_v$ 更小，可以得出重心的 $d_u$ 最小。\n  WLOG 假设两棵树一大一小，可以看作将小子树一个个作为叶子的加入到大子树上，此时重心会沿着连接的点方向移动。\n  易证。\n   例题 例1 CF1406C. Link Cut Centroids 题意\n给定一棵树，我们需要切掉一个edge，再加上一个edge，使得新生成的仍然是一棵树，并且仅有一个重心。\n求出这样的方案，答案一定存在。\n其中，$n \\leq 10^5$。\n 题解 首先判断重心是不是有 $2$ 个，如果不是，什么也不用干。\n如果是，那么设两个重心分别为 $c_1, c_2$，那么只要在 $c_2$ 子树中寻找一个叶子，然后切下来，安给 $c_1$ 即可。\n证明：易证 $c_1$ 的其他邻居不可能为新的重心，而 $c_2$ 也不可能为重心，因为 $c_2$ 所在的部分少了一个，所以只有 $c_1$ 变成新的重心了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int T, n; struct Edge { int from, to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn]; bool center[maxn]; int c1, c2; void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs1(v, u); sz[u] += sz[v]; if (sz[v] \u0026gt; n/2) center[u] = 0; } if (n - sz[u] \u0026gt; n/2) center[u] = 0; } int c, cp; // f: forbidden void dfs2(int u, int p, int f) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == f || v == p) continue; dfs2(v, u, f); sz[u] += sz[v]; } if (sz[u] == 1) { c = u; cp = p; } } int main() { fastio; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; addEdge(x, y); addEdge(y, x); } for (int i = 1; i \u0026lt;= n; i++) center[i] = 1; dfs1(1, 0); c1 = c2 = 0; for (int i = 1; i \u0026lt;= n; i++) { if (center[i]) { if (!c1) c1 = i; else c2 = i; } } if (!c2) { cout \u0026lt;\u0026lt; edges[1].from \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; edges[1].to \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; \u0026lt;\u0026lt; edges[1].from \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; edges[1].to \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { c = cp = 0; dfs2(c2, 0, c1); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; cp \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } for (int i = 1; i \u0026lt;= n; i++) head[i] = 0, sz[i] = 0; ecnt = 1; } }   例2 CF685B. Kay and Snowflake 题意\n给定一棵有根树（$1$ 为根），和 $q$ 次询问，每次询问回答 $u$ 的子树中，重心是哪个点。\n其中，$n,q \\leq 3 \\times 10^5$。\n 题解 结论：考虑 $u$ 的子树，它的重心要么是它自己，要么在它重儿子所在子树里。\n如果在它重儿子（设为 $v$）里，那么可以看作以 $v$ 为子树，然后加上了一个较小的子树（$u$ 剩下的部分），所以原本重心是 $v$ 的重心，加上了以后，重心会往连接点处移动，所以新的重心一定是 $v$ 的重心的 ancestor。\n所以我们可以从下往上处理每个子树的重心，处理到 $u$ 时只要从它的重儿子 $v$ 的重心 $c_v$ 开始，暴力往上跳即可。\n可证每个点最多会被跳 $1$ 次，复杂度为 $O(n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n, q; struct Edge { int from, to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {u, v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int sz[maxn], par[maxn], son[maxn], maxsz[maxn], ans[maxn]; void dfs(int u, int p) { sz[u] = 1; par[u] = p; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs(v, u); sz[u] += sz[v]; if (maxsz[u] \u0026lt; sz[v]) { son[u] = v; maxsz[u] = sz[v]; } } } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs2(v, u); } if (maxsz[u] \u0026lt;= sz[u] / 2) { ans[u] = u; return; } else { int c = ans[son[u]]; while (c != u) { if (maxsz[c] \u0026lt;= sz[u] / 2 \u0026amp;\u0026amp; sz[u] - sz[c] \u0026lt;= sz[u] / 2) { ans[u] = c; break; } else c = par[c]; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 2; i \u0026lt;= n; i++) { int p; cin \u0026gt;\u0026gt; p; addEdge(p, i); addEdge(i, p); } dfs(1, 0); dfs2(1, 0); while (q--) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; ans[x] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   参考链接  https://zhuanlan.zhihu.com/p/357938161  ","date":"2022-12-23T22:49:22-06:00","permalink":"https://tom0727.github.io/post/086-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/","tags":["树",""],"title":"树的重心"},{"categories":["解题报告"],"contents":"K. Addition Robot 题意\n给定 $n$ 个字母 $s_1, s_2 \u0026hellip;, s_n$，每个字母要么为 $A$ 要么为 $B$。\n现在有 $Q$ 个询问，每个询问有两种类型：\n$1 ~ L ~ R$：将 $i \\in [L,R]$ 的所有 $A$ 改成 $B$，$B$ 改成 $A$。\n$2 ~ L ~ R ~ a ~ b$：$a,b$ 是两个非负整数，从左往右遍历 $L$ 到 $R$，遇到一个 A 就让 $a=a+b$，遇到一个 B 就让 $b=a+b$，返回 $a,b$ 在经历这些操作后的值。\n其中，$n \\leq 10^5, Q \\leq 10^5$，答案对 $10^9+7$ 取模。\n 题解 线段树。\n注意到这个 $a=a+b$，$b=a+b$，有没有想到 矩阵操作？\n设 $v = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}$，那么设 $A = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \\\\ \\end{bmatrix}, B = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 1 \u0026amp; 1 \\\\ \\end{bmatrix}$，就有\n$$Av = \\begin{bmatrix} a+b \\\\ b \\\\ \\end{bmatrix}, Bv = \\begin{bmatrix} a \\\\ a+b \\\\ \\end{bmatrix}$$\n所以线段树里面维护矩阵即可。\n 现在考虑一下第一种询问怎么处理？\n第一种询问其实相当于保持矩阵不变，先把 $v = \\begin{bmatrix} a \\\\ b \\\\ \\end{bmatrix}$ 变成 $v‘ = \\begin{bmatrix} b \\\\ a \\\\ \\end{bmatrix}$，然后乘完矩阵以后，再上下对调变回来。\n这个操作本质上也是矩阵乘法，即令 $C = \\begin{bmatrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\\\ \\end{bmatrix}$，假设原矩阵操作序列是 $M = (AABA)$，原操作序列得到的结果是 $Mv$，现在的结果是 $C(M(cv)) = CMCv = (CMC)v$。\n由此可知第一种询问就是将 $[L,R]$ 维护的矩阵 $M$ 变成了 $CMC$。\n进行一些手动计算以后可以发现这等效于将 $M$ 的两个对角线元素互换。\n 最后需要注意一点，矩阵乘法和序列的遍历顺序是反过来的，比如序列是 $AB$，那么矩阵乘法应该是 $(BA)v$，处理这种情况只要在维护线段树的时候先处理 right child即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxn = 1e5+5; const int maxm = 2e5+5; struct Mat { ll a[2][2]; friend Mat operator*(const Mat\u0026amp; lhs, const Mat\u0026amp; rhs) { Mat res; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { // 第i行 乘 第j列 res.a[i][j] = 0; for (int k = 0; k \u0026lt; 2; k++) { res.a[i][j] += lhs.a[i][k] * rhs.a[k][j]; res.a[i][j] %= mod; } } } return res; } void rev() { swap(a[0][0], a[1][1]); swap(a[0][1], a[1][0]); } }; int n, Q; Mat A, B, arr[maxn]; struct Tree_Node { Mat a; int flag = 0; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].a = tr[cur\u0026lt;\u0026lt;1|1].a * tr[cur\u0026lt;\u0026lt;1].a; } void push_down(int cur) { if (!tr[cur].flag) return; tr[cur].flag = 0; int lc = cur\u0026lt;\u0026lt;1, rc = lc|1; tr[lc].flag ^= 1; tr[rc].flag ^= 1; tr[lc].a.rev(); tr[rc].a.rev(); } void build(int cur, int l, int r) { if (l == r) { tr[cur].a = arr[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1|1, mid+1, r); build(cur\u0026lt;\u0026lt;1, l, mid); push_up(cur); } void update(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].flag ^= 1; tr[cur].a.rev(); return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R); push_up(cur); } Mat query(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].a; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; Mat res {}; res.a[0][0] = res.a[1][1] = 1; res.a[0][1] = res.a[1][0] = 0; if (R \u0026gt; mid) res = res * query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (L \u0026lt;= mid) res = res * query(cur\u0026lt;\u0026lt;1, l, mid, L, R); push_up(cur); return res; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; Q; A.a[0][0] = A.a[0][1] = A.a[1][1] = 1; B.a[0][0] = B.a[1][0] = B.a[1][1] = 1; for (int i = 1; i \u0026lt;= n; i++) { char c; cin \u0026gt;\u0026gt; c; if (c == 'A') arr[i] = A; else arr[i] = B; } build(1, 1, n); while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int L, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; update(1, 1, n, L, R); } else { int L, R; ll a, b; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; Mat res = query(1, 1, n, L, R); cout \u0026lt;\u0026lt; (a * res.a[0][0] + b * res.a[0][1]) % mod \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; (a * res.a[1][0] + b * res.a[1][1]) % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   G. Performance Review 题意\n一家公司有 $N$ 个员工，总共有 $M$ 年，每个员工都有一个表现分 $A_i$。\n第 $i$ 年，公司会淘汰 $R_i$ 个表现最差的员工，并且换上 $R_i$ 个新员工，他们的表现分为 $B_{i,1}, B_{i,2} \u0026hellip; B_{i,R_i}$（这些新员工表现不一定比老员工好）。\n现在考虑第一个员工 $A_1$，他有 $Q$ 个询问，每次询问他会更改一个未来替换的员工的表现分，回答在替换之后，他在 $M$ 年之后是否还能留在公司。\n• 每次询问的更改结果会保留到后续询问。\n其中，$N,M,Q \\leq 10^5, \\sum\\limits_{i=1}^M R_i \\leq 10^6$，所有员工（包括未来的）表现分各不相同。\n 题解 注意到员工 $A_1$ 能留到 $M$ 年后当且仅当对于所有的 $i$，在第 $i$ 年结束时，比他菜的人数 $\\geq$ 要淘汰的人数。\n形式化的：\n$$cnt_{i-1} \\geq \\sum\\limits_{j=1}^i R_i, \\forall i \\in [1, M]$$\n其中，$cnt_{i-1}$ 代表第 $i-1$ 年结束后，（完成招聘以后）比他菜的人数。\n 现在，只要考虑每次询问过后有什么影响即可。\n注意到要淘汰的人数是个定值，影响的只有比他菜的人数。\n所以用线段树，储存每一年 $cnt_{i-1} - \\sum\\limits_{j=1}^i R_i$ 的值。\n每次更改第 $j$ 年中，一个人的表现分以后，跟 $A[1]$ 对比，如果原本比他菜，现在比他强，意味着从 $(j+1)$ 年起，一直到 $M$，比他菜的人少了一个，反之则是多了一个。\n所以就是线段树的区间修改，区间查询最小值是否 $\\geq 0$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n, m, Q, a[maxn]; vector\u0026lt;int\u0026gt; per[maxn]; int cnt[maxn], sum_r[maxn]; // cnt[i]: 第i年之前比他小的 (0...i-1) 年，sum_r[i]: 第i年过后总共要裁的人数 int c[maxn]; // c[i] = cnt[i] - sum(R[1..i]) struct Tree_Node { int mn = 1e9, flag = 0; // min_val, flag } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].mn = min(tr[cur\u0026lt;\u0026lt;1].mn, tr[cur\u0026lt;\u0026lt;1|1].mn); } void push_down(int cur) { if (!tr[cur].flag) return; int f = tr[cur].flag; tr[cur\u0026lt;\u0026lt;1].flag += f; tr[cur\u0026lt;\u0026lt;1|1].flag += f; tr[cur\u0026lt;\u0026lt;1].mn += f; tr[cur\u0026lt;\u0026lt;1|1].mn += f; tr[cur].flag = 0; } // += x void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].flag += x; tr[cur].mn += x; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // query 最小值 int query(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].mn; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 1e9; if (L \u0026lt;= mid) res = min(res, query(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = min(res, query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); push_up(cur); return res; } void build(int cur, int l, int r) { if (l == r) { tr[cur].mn = c[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (i \u0026gt; 1 \u0026amp;\u0026amp; a[i] \u0026lt; a[1]) cnt[1]++; } for (int i = 1; i \u0026lt;= m; i++) { int r; cin \u0026gt;\u0026gt; r; sum_r[i] = sum_r[i-1] + r; cnt[i+1] = cnt[i]; while (r--) { int x; cin \u0026gt;\u0026gt; x; per[i].push_back(x); if (x \u0026lt; a[1]) cnt[i+1]++; } } for (int i = 1; i \u0026lt;= m; i++) c[i] = cnt[i] - sum_r[i]; build(1, 1, m); while (Q--) { int x,y,z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; if (x \u0026lt; m) { // 注意这里特判 if (per[x][y-1] \u0026lt; a[1] \u0026amp;\u0026amp; z \u0026gt; a[1]) { // update(1, 1, m, x+1, m, -1); } else if (per[x][y-1] \u0026gt; a[1] \u0026amp;\u0026amp; z \u0026lt; a[1]) { update(1, 1, m, x+1, m, 1); } } per[x][y-1] = z; if (query(1, 1, m, 1, m) \u0026lt; 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2022-12-23T18:57:28-06:00","permalink":"https://tom0727.github.io/post/085-icpc-2019-jakarta-regional/","tags":["",""],"title":"2019 Jakarta Regional"},{"categories":["解题报告"],"contents":"CF1666J Job Lookup 题意\n给定一个 $n \\times n$ 的矩阵 $c_{ij}$。\n求一个BST，使得 $\\sum\\limits_{i,j} c_{ij} \\cdot d_{ij}$ 最小。\n其中，$d_{ij}$ 代表节点 $i,j$ 在BST中的距离。\n输出这个 BST 的结构。\n其中，$n \\leq 200$，$c_{ij} \\in [0, 10^9], c_{ii} = 0$。\n 题解 注意 BST 一个非常重要的结论：\n 子树内的节点编号是一个连续的区间。\n 所以可以考虑用区间DP来做。\n设 $dp(i,j)$ 为 $[i,j]$ 之间形成的子树对应的最小值。\n显然转移方程是枚举 parent节点 $k$。\n而 $d_{ij}$ 可以考虑每条边带来的贡献，在这个转移过程中我们只需要考虑这两条边带来的贡献。\n所以 $[i, k-1]$ 给除了它本身以外的所有部分带来了贡献，贡献部分为：\n$$\\sum\\limits_{a \\in [i,k-1]}\\sum\\limits_{b \\in [1, n]} c_{ab} - \\sum\\limits_{a \\in [i,k-1]}\\sum\\limits_{b \\in [i,k-1]} c_{ab}$$\n$[k+1, j]$ 同理。\n转移方程有：\n$$dp(i,j) = \\min_{k \\in [i,j]} \\{dp(i,k-1)+dp(k+1,j)+\\sum\\limits_{a \\in [i,k-1]}\\sum\\limits_{b \\in [1, n]} c_{ab} - \\sum\\limits_{a \\in [i,k-1]}\\sum\\limits_{b \\in [i,k-1]}c_{ab} + \\sum\\limits_{a \\in [k+1,j]}\\sum\\limits_{b \\in [1, n]} c_{ab} - \\sum\\limits_{a \\in [k+1,j]}\\sum\\limits_{b \\in [i,k-1]}c_{ab}\\}$$\n用二维前缀和预处理一下即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 205; int n; ll c[maxn][maxn]; ll sumc[maxn][maxn], dp[maxn][maxn]; int use[maxn][maxn]; int par[maxn]; ll sum_matrix(int xl, int xr, int yl, int yr) { if (xl \u0026gt; xr || yl \u0026gt; yr) return 0; return sumc[xr][yr] - sumc[xl-1][yr] - sumc[xr][yl-1] + sumc[xl-1][yl-1]; } void dfs(int i, int j, int p) { if (i \u0026gt; j) return; if (i == j) { par[i] = p; return; } int k = use[i][j]; par[k] = p; dfs(i, k-1, k); dfs(k+1, j, k); } ll DP(int i, int j) { if (i \u0026gt; j) return 0; if (dp[i][j] \u0026gt;= 0) return dp[i][j]; dp[i][j] = 1e18; for (int k = i; k \u0026lt;= j; k++) { ll res = DP(i, k-1) + DP(k+1, j); res += sum_matrix(i, k-1, 1, n) - sum_matrix(i, k-1, i, k-1); res += sum_matrix(k+1, j, 1, n) - sum_matrix(k+1, j, k+1, j); if (res \u0026lt; dp[i][j]) { dp[i][j] = res; use[i][j] = k; } } return dp[i][j]; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) cin \u0026gt;\u0026gt; c[i][j]; } memset(dp, -1, sizeof(dp)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { sumc[i][j] = sumc[i-1][j] + sumc[i][j-1] - sumc[i-1][j-1] + c[i][j]; } } DP(1, n); dfs(1, n, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; par[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   CF1666E Even Split 题意\n给定一个长度为 $L$ 的直线，现在直线上有 $n$ 个位置互不相同的点。\n求一种方案，将这个直线分成 $n$ 段，并且保证第 $i$ 个点属于第 $i$ 条线段（包括边界），线段之间没有空隙，并且第 $1$ 个线段的左端一定是 $0$，第 $n$ 个线段的右端一定是 $L$。\n• 相当于划定 $n-1$ 个分割点，将直线分成 $n$ 段。\n求一种分割方案，使得这些线段中，最长的与最短的差距最小？\n其中，$n \\leq 10^5, L \\leq 10^9$。\n 题解 首先易知可以二分最终的长度差。\n然后我们需要确定一个线段的长度范围 [ml, mr]，注意到这个范围也是可以二分的（为什么？）。\n所以我们二分 $ml$ 的值。\n那么给定 [ml, mr] 这个范围区间，怎么check是否合法？\n我们从左向右，考虑第 $i$ 个区间的右端点可能的范围。\nint check(int mn, int mx) { l[0] = 0, r[0] = 0; int c = 0; for (int i = 1; i \u0026lt;= n; i++) { if (l[i-1] + mn \u0026gt; p[i+1]) return -1; // mn 太大了 if (r[i-1] + mx \u0026lt; p[i]) return 1; // mn 太小了 // [l,r] 表示右端点可能在的区间 l[i] = max(l[i-1] + mn, p[i]); r[i] = min(r[i-1] + mx, p[i+1]); } if (l[n] \u0026gt; L) return -1; if (r[n] \u0026lt; L) return 1; return 0; // ok }  我们让 $l$ 表示这个右端点尽可能的小，$r$ 表示尽可能大。\n然后判断这个范围是否一直合法即可。\n如果不合法，也可以通过不合法的是哪个条件推测出 $ml$ 的值是大了还是小了，从而返回不同的值。\n 现在我们求出了最优的范围区间 [ml, mr]，怎么得到最终的区间分配结果？\n我们 不能 简单的取 $[l_i, r_i]$ 中的值，因为这个范围只是代表：\n一定存在一种分配方案，使得第 $i$ 个区间的右端点落在了 $[l_i, r_i]$ 中，反之则不一定成立。\n不过注意到，第 $n$ 个区间的右端点是已经确定为 $L$ 了的，所以我们从右向左构造答案，设 res[i] 为第 $i$ 个区间的右端点，那么只要保证 res[i-1] 与 res[i] 的距离在 [ml, mr] 之间，并且 res[i-1] $\\in [l_i, r_i]$ 即可。由于前面的答案，这样的方案一定是存在的。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll L; int n; int p[maxn]; int l[maxn], r[maxn]; int check(int mn, int mx) { l[0] = 0, r[0] = 0; int c = 0; for (int i = 1; i \u0026lt;= n; i++) { if (l[i-1] + mn \u0026gt; p[i+1]) return -1; // mn 太大了 if (r[i-1] + mx \u0026lt; p[i]) return 1; // mn 太小了 // [l,r] 表示右端点可能在的区间 l[i] = max(l[i-1] + mn, p[i]); r[i] = min(r[i-1] + mx, p[i+1]); } if (l[n] \u0026gt; L) return -1; if (r[n] \u0026lt; L) return 1; return 0; // ok } int ml, mr; bool check_diff(int d) { int low = 1, high = 1e9; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; int res = check(mid, mid+d); if (!res) { ml = mid, mr = mid+d; return 1; } else if (res == 1) { low = mid+1; } else high = mid-1; } return 0; } int res[maxn]; // res[i]: 第i个区间的右端点 int main() { cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; p[n+1] = L; int low = 0, high = 1e9, ans = 1e9; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; if (check_diff(mid)) { ans = mid; high = mid-1; } else low = mid+1; } check(ml, mr); // 这里需要再check一下保证 l[] 和 r[] 里面的值正确 res[n] = L; for (int i = n-1; i \u0026gt;= 1; i--) { int lmax = max(l[i], res[i+1] - mr), rmin = min(r[i], res[i+1] - ml); assert(lmax \u0026lt;= rmin); res[i] = lmax; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; res[i-1] \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2022-12-20T16:57:11-06:00","permalink":"https://tom0727.github.io/post/084-icpc-2021-nerc/","tags":["",""],"title":"2021 NERC"},{"categories":["解题报告"],"contents":"A. Access Levels 题意\n有 $n$ 个程序员，$m$ 个文档。\n给定一个 $n \\times m$ 的矩阵 $a$，其中 $a_{ij} = 1$ 表示程序员 $i$ 可以访问文档 $j$，否则不行。\n现在我们需要选择一个数字 $k$，使得总共有 $k$ 个access group。\n然后将每个文档放入这 $k$ 个access group中的一个，并且给这个文档设定一个权限值 $c_i$。\n然后给每个程序员设定 $k$ 个数字 $v_i$，代表这个程序员在使用第 $i$ 个group时拥有 $v_i$ 的权限值。\n当一个程序员在访问一个文档 $i$ 时，如果这个文档所在的group为 $j$，那么需要保证这个程序员的 $v_j \\geq c_i$ 才能访问，否则不能。\n求一个最小的 $k$，使得访问矩阵可以被满足，并且给出具体方案。\n其中，$n,m \\leq 500$。\n 题解 注意到 group 与 group 之间是独立的，因为每个文档仅能属于一个group，所以我们分 group 来考虑。\n注意到，如果一个group内有 $d$ 个文档 $i_1, i_2, \u0026hellip;, i_d$，那么这些文档对于程序员们来说一定遵循：访问关系为单调为超集。\n举个例子，在第二个样例中\n2 3 101 100  那么假设这三个文档都在同一个group内，那么按照列来看，就可以得到 11, 00, 10 这三个数字，可以发现 11 \u0026gt; 10 \u0026gt; 00（这里的 11 \u0026gt; 10 是指 11 为 10 的超集）。\n这说明这三个文档可以在同一个group内。\n这让我们想到了什么？如果我们将每一列看作一个 bitmask，那么如果 $b_1 \u0026gt; b_2$ 则可以由 $b_1$ 向 $b_2$ 连一条边，这就是一个DAG中的最小路径覆盖问题，每个路径就是一个 group。\n剩下的就是很麻烦的实现了，注意去重之类的问题。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e2+5; int n, m; char a[maxn][maxn]; map\u0026lt;string, int\u0026gt; mask_to_idx; string masks[maxn]; // return 1 if b \u0026lt; a (b is subset of a) bool is_sub(string\u0026amp; a, string\u0026amp; b) { for (int i = 1; i \u0026lt;= n; i++) { if (a[i-1] \u0026lt; b[i-1]) return 0; } return 1; } int par[maxn]; int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return; par[v] = u; } vector\u0026lt;int\u0026gt; adj[maxn\u0026lt;\u0026lt;1]; int vis[maxn\u0026lt;\u0026lt;1], visid = 0, match[maxn\u0026lt;\u0026lt;1], from[maxn\u0026lt;\u0026lt;1]; bool dfs(int u) { for (int v : adj[u]) { if (vis[v] == visid) continue; vis[v] = visid; if (!match[v] || dfs(match[v])) { match[v] = u; return 1; } } return 0; } int groupid = 0; vector\u0026lt;int\u0026gt; groups[maxn]; int belongs[maxn]; int pri[maxn][maxn]; // privilege for the users int privilege[maxn]; // privilege for each software int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; for (int j = 1; j \u0026lt;= m; j++) { a[i][j] = s[j-1]; } } int id = 0; for (int j = 1; j \u0026lt;= m; j++) { string mask = \u0026quot;\u0026quot;; for (int i = 1; i \u0026lt;= n; i++) { mask += a[i][j]; } mask_to_idx[mask] = ++id; masks[id] = mask; } for (int i = 1; i \u0026lt;= m; i++) par[i] = i; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (i == j) continue; if (masks[i] == masks[j]) { unions(i, j); } } } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (i == j) continue; if (par[i] == i \u0026amp;\u0026amp; par[j] == j \u0026amp;\u0026amp; is_sub(masks[i], masks[j])) { adj[i].push_back(j+m); } } } // 最小路径覆盖 int ans = 0; // 记录有多少个独立的parent for (int i = 1; i \u0026lt;= m; i++) { if (par[i] == i) ans++; } for (int i = 1; i \u0026lt;= m; i++) { if (par[i] == i) { visid++; ans -= dfs(i); } } for (int i = m+1; i \u0026lt;= 2*m; i++) { if (par[i-m] == i-m) { if (match[i]) { from[match[i]] = i-m; } } } for (int i = m+1; i \u0026lt;= 2*m; i++) { if (par[i-m] == i-m) { if (!match[i]) { int j = i-m; groupid++; while (j) { groups[groupid].push_back(j); belongs[j] = groupid; j = from[j]; } } } } cout \u0026lt;\u0026lt; groupid \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i = 1; i \u0026lt;= m; i++) { belongs[i] = belongs[finds(i)]; cout \u0026lt;\u0026lt; belongs[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 已经找到了每个column所在的group for (int g = 1; g \u0026lt;= groupid; g++) { // 现在处理第 g 个group vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; vec; // vector of masks for each user (with selected column in this group) for (int i = 1; i \u0026lt;= n; i++) { string mask = \u0026quot;\u0026quot;; for (int j : groups[g]) { mask += a[i][j]; } vec.push_back({mask, i}); } sort(vec.begin(), vec.end()); reverse(vec.begin(), vec.end()); int pre_pri = 505; // 先处理 vec[0] string s = vec[0].first; // 长度为 groups[g] 的长度 pri[vec[0].second][g] = pre_pri - 1; for (int k = 0; k \u0026lt; groups[g].size(); k++) { int j = groups[g][k]; if (s[k] == '0') { privilege[j] = pre_pri; } } for (int i = 1; i \u0026lt; n; i++) { s = vec[i].first; if (s == vec[i-1].first) { // 如果和前面一个一样，直接复制 pri[vec[i].second][g] = pri[vec[i-1].second][g]; } else { pre_pri--; for (int k = 0; k \u0026lt; groups[g].size(); k++) { int j = groups[g][k]; if (!privilege[j] \u0026amp;\u0026amp; s[k] == '0') { privilege[j] = pre_pri; } } pri[vec[i].second][g] = pre_pri - 1; } } for (int j : groups[g]) { if (!privilege[j]) privilege[j] = 1; } } // output answer for (int i = 1; i \u0026lt;= m; i++) { if (privilege[i] == 0) { privilege[i] = privilege[finds(i)]; } cout \u0026lt;\u0026lt; (privilege[i]) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i = 1; i \u0026lt;= n; i++) { for (int g = 1; g \u0026lt;= groupid; g++) { cout \u0026lt;\u0026lt; pri[i][g] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2022-12-04T23:48:35-06:00","permalink":"https://tom0727.github.io/post/083-icpc-2022-nerc-regional/","tags":["",""],"title":"2022 NERC Regional"},{"categories":["算法"],"contents":"介绍 线性规划问题一般表示为如下：\n给定 $c_j, a_{ij}, b_i$，求 $x$ 的值使得\n$$\\max_x \\sum_{j=1}^d c_jx_j$$\n其中\n$$\\sum_{j=1}^d a_{ij} x_j \\leq b_i, \\forall i = 1\u0026hellip;n$$ $$x_j \\geq 0, \\forall j = 1\u0026hellip;d$$\n等价的，可以把上式写作：\n$$\\max_x ~ c \\cdot x$$\n其中\n$$Ax \\leq b$$ $$x \\geq 0$$\n有 $c \\in 1 \\times d, A \\in n \\times d, x \\in d \\times 1, b \\in n \\times 1$。\n对偶问题 我们称原问题为 Primary Problem, 对偶问题为 Dual Problem, 解决 Primary Problem 和解决 Dual Problem 是等价的。\n按照上面定义的问题作为 Primary Problem，那么 Dual Problem 的形式可以写作：\n$$\\min_y y \\cdot b$$\n其中，\n$$yA \\geq c$$ $$y \\geq 0$$\n有 $y \\in 1 \\times n, b \\in n \\times 1, A \\in n \\times d, c \\in 1 \\times d$。\n例子 二分图最大权匹配 原问题：\n给定一个二分图，边上有边权 $w_j$，找到一组匹配，使得匹配中的边权和最大。\n我们定义 $n$ 为二分图中点的数量之和，$m$ 为边的数量。\n定义一个系数矩阵 $A$\n其中 $A_{i,j} = 1$ 当且仅当第 $i$ 个点是第 $j$ 条边的其中一个端点。\n 如图（注意边的数字代表着这是第几条边，边权在这张图里没写），系数矩阵为\n$$A=\\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} $$\n而 $x$ 就代表了 $m$ 条边，$x_j = 1$ 代表第 $j$ 条边在匹配内，$x_j = 0$ 代表不在。 $$b = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ \\end{bmatrix}$$\n代表了这是一个匹配的限制，即每个点所连的边中，至多有一个被选进匹配中。\n这满足了 $Ax \\leq b, x \\geq 0$ 的限制。\n接下来我们考虑对偶问题：\n$$\\min_y y \\cdot b$$\n其中，\n$$yA \\geq c$$ $$y \\geq 0$$\n由于 $x$ 代表了 $m$ 条边，所以 $y$ 就代表了 $n$ 个点。\n$A$ 的意义不变，还是代表了二分图本身，而 $c \\in 1 \\times m$ 代表了对于 $m$ 条边的限制，限制每条边的值最多为 $c_j$，也就是原问题中的边权。\n那这个值是什么呢？我们考虑 $y$ 的意义。\n$y$ 可以看出是给每个点赋值（我们在这里称这个值为顶标），然后和 $A$ 乘起来代表一个节点 $i$ 的顶标会被贡献到所有的与 $i$ 相连的边 $j$ 上。\n所以对偶问题就是 最小顶标和：\n给每个节点赋一个值（顶标），使得每条边两个端点的顶标和 $\\geq$ 边权，且所有节点的顶标和最小。\n","date":"2022-11-29T22:05:01-06:00","permalink":"https://tom0727.github.io/post/082-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/","tags":["",""],"title":"线性规划"},{"categories":["算法"],"contents":"介绍 KMP算法能在 $O(n)$ 的时间内，求出一个字符串的每个前缀的最长 border 长度。\n利用 border 的性质，也可以在 $O(n)$ 的时间内，求出一个字符串 $t$ 在文本串 $s$ 中出现的所有位置。\n一个字符串 $s$ 的 border 是指 $s$ 的一个长度为 $j$ 的前缀，使得长度为 $j$ 的后缀与这个前缀相等，其中 $j\u0026lt;n$。\n形式化的说，若 $s$ 任何border的长度为 $j$，那么满足：\ns[1 ... j] = s[n-j+1 ... n]\n 如图，这个字符串的最长 border 长度为 $3$。\nkmp 算法做的事情就是，对于每个 $i$，求出 kmp[i]，其中 kmp[i] 的值代表 $s[1\u0026hellip;i]$ 的最长的border长度。\n那么怎么求 kmp[] 数组呢？\nchar s[maxn]; int kmp[maxn]; int main() { int n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); scanf(\u0026quot;%s\u0026quot;, s+1); int j = 0; for (int i = 2; i \u0026lt;= n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j+1]) j = kmp[j]; if (s[i] == s[j+1]) j++; kmp[i] = j; } }  基本思路是维护两个指针 $i,j$，$i$ 表示后缀，$j$ 表示前缀，在 $s_i,s_j$ 匹配时 $i,j$ 向前走一格，如果不匹配，那么 $j$ 跳回前一个更小的 border 处，这样保证了在任何时刻都有 s[1 ... j] = s[n-j+1 ... n]，然后继续判断 $s_i,s_j$ 是否匹配。\n性质   一个字符串有很多个 border，但是所有 较小 的border一定是 最大border的border。\n例如 ABABA 有两个border，一个是 ABA，一个是 A，可以发现 A 是 ABA 的一个border。\n  应用 查找子串 查找 $t$ 在 $s$ 内出现的所有位置，只要先对 $t$ 跑一次kmp，处理出 $t$ 上的 kmp 数组，然后在匹配的过程中，把 $i$ 指针放在 $s$ 上，$j$ 指针放在 $t$ 上，当 $j = n_2$ 时说明找到一个匹配，那么就让 $j = kmp[j]$ 继续匹配。\n代码 char s[maxn], t[maxn]; int kmp[maxn]; int main() { scanf(\u0026quot;%s\u0026quot;, s+1); scanf(\u0026quot;%s\u0026quot;, t+1); int n = strlen(s+1), m = strlen(t+1); int j = 0; for (int i = 2; i \u0026lt;= m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; t[i] != t[j+1]) j = kmp[j]; if (t[i] == t[j+1]) j++; kmp[i] = j; } j = 0; for (int i = 1; i \u0026lt;= n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != t[j+1]) j = kmp[j]; if (s[i] == t[j+1]) j++; if (j == m) { printf(\u0026quot;%d\\n\u0026quot;,i-j+1); j = kmp[j]; } } }   周期/循环节 对于长度为 $n$ 的字符串 $s$，若 $p \\in [1, n]$ 满足\n$$s[i] = s[i+p], \\forall i \\in [1, n-p]$$\n说明 $p$ 是 $s$ 的周期。\n满足条件的 $p$ 可能有很多，但所有的 $p$ 一定满足：\n$$p_i = n - f^i(n)$$\n这里 $f^1(n) = kmp[n], f^{i}(n) = kmp[f^{i-1}(n)]$，$f^{i}(n)$ 代表了 $s$ 的所有border的长度。\n如上图，可以看出 s[1 ... p] == s[p+1 ... 2p]，后面的也可以由此推出，所以 $p$ 是一个周期。\n 循环节的定义：如果一个字符串 $s$ 可以表达为 $s = (X)(X)\u0026hellip;(X)$ 这种形式说明 $(X)$ 是一个循环节。\n例如 s = \u0026quot;abababab\u0026quot;，那么 ab 是循环节，abab 也是循环节。\n一个字符串拥有循环节，并且循环节长度为 $p$ 当且仅当：\n $p$ 是一个周期。 n % p == 0。  换而言之，只要判断 p = n - kmp[n], n % p == 0 是否成立即可。\n同周期，循环节可能有很多个，寻找的方式跟周期一样，额外判断一下 n % p == 0 是否成立即可。\n• 最小循环节的长度就是 $n - kmp[n]$。\n最小表示法 虽然和 KMP 并没有必然联系，但思想上可能有些相同。\n定义一个字符串 $s$ 和另外一个字符串 $t$ 循环同构 (cyclic shift)，当且仅当\n$$\\exists i \\in [1,n], s[i\u0026hellip;n] + s[1\u0026hellip;i-1] = t$$\nEquivalently，有：\n $t$ 与 $s$ 循环同构。 $t$ 可以用 $s$ 的位置为 $i$ 的后缀，加上位置为 $i$ 的前缀组成。 $t$ 是 $s+s$ 中的一个 substring（注意前提是 $|s| = |t|$）。  • 注意到由于性质 $3$，也可以用 KMP 在 $O(n)$ 判断两个字符串是否为循环同构。\n最小表示法可以在 $O(n)$ 时间内求出一个字符串 字典序最小 的循环同构。\n方法是维护两个指针 $i,j$，讨论三种情况：\nCase1: $s_i \u0026lt; s_j$：说明 $j$ 不可能为最小表示的起点，所以 j++;。\nCase2: $s_i \u0026gt; s_j$：说明 $i$ 不可能为最小表示的起点，所以 i++;。\nCase3: $s_i = s_j$：说明需要接着往后看，所以用另外一个值 $k$，让 $k$ 从 $0$ 开始加，直到 $s_{i+k} \\neq s_{j+k}$。\nCase3.1: 如果 $s_{i+k} \u0026lt; s_{j+k}$：说明任何 $j' \\in [j, j+k]$ 不可能满足条件，因为如果满足了，必然有对应相同位置的 $i'$ 更好。所以令 j = j+k+1;。\nCase3.2: 如果 $s_{i+k} \u0026gt; s_{j+k}$：说明任何 $i' \\in [i, i+k]$ 不可能满足条件，因为如果满足了，必然有对应相同位置的 $j'$ 更好。所以令 i = i+k+1;。\n代码 // 输出 s 的最小表示法 string min_cyc(string s) { int n = s.size(); int i = 0, j = 1, k = 0; while (i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; k \u0026lt; n) { char a = s[(i+k) % n], b = s[(j+k) % n]; if (a == b) k++; else { if (a \u0026lt; b) j = j+k+1; if (a \u0026gt; b) i = i+k+1; if (i == j) i++; // 如果重合就后移 k = 0; } } i = min(i, j); // 保证是一个合法位置 (结束时i,j很有可能有一个非法) return s.substr(i, n-i) + s.substr(0, i); }   失配树 例题 例1 HDU3746 Cyclic Nacklace 题意\n给定一个字符串 $s$，求需要在它的尾部加最少几个字符，使得它拥有循环节？\n其中，$n \\leq 10^5$。\n 题解 根据循环节的定义，先判断循环节是否存在，如果已经存在返回 0。\n如果不存在，那么只需要求出最小周期 $p$，然后判断还差多少个字符能够形成循环节即可，这个循环节的长度就是最小周期 $p$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; char s[maxn]; int kmp[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { scanf(\u0026quot;%s\u0026quot;, s+1); int n = strlen(s+1); int j = 0; for (int i = 2; i \u0026lt;= n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j+1]) j = kmp[j]; if (s[i] == s[j+1]) j++; kmp[i] = j; } int len = n - kmp[n]; if (len == n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } else { if (n % len == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; len - n % len \u0026lt;\u0026lt; endl; } } } }   例2 POI2006 OKR-Periods of Words 题意\n给定一个字符串 $s$，对于这个字符串的每一个前缀 $s_i = s[1\u0026hellip;i]$，找出一个最大的 $Q$ 使得：\n $Q$ 是 $s_i$ 的前缀，且 $Q \\neq s_i$。 $s_i$ 是 $Q+Q$ 的前缀（可以相等）。  求出对于每个 $i$，这样 $Q$ 的最大长度之和。（如果不存在的话就是 $0$）\n其中，$n \\leq 10^6$。\n 题解 我们会发现，如果 $Q$ 不存在的话，说明是类似于 \u0026quot;ABCD\u0026quot; 这种的字符串，这种字符串代表 $kmp[n] = 0$。否则类似于 \u0026quot;ABCA\u0026quot; 这种，Q = \u0026quot;ABC\u0026quot; 就满足要求。\n简单推导可以发现，只要找到 $s_i$ 的最小 border 长度 $j$，然后 $Q = i-j$。\n问题在于 kmp[] 维护的是最大border长度，最小border怎么办？\n注意到最小border可以通过最大border一直往前跳获得，所以我们在初始处理 kmp 数组时仍然保留最大border。\n然后枚举第二次，从 $1$ 枚举到 $n$，每次枚举完都让 kmp[i] 维护的是最小 border 的长度，这样后面的在往前跳的时候只用跳一次了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; char s[maxn]; int kmp[maxn]; int main() { int n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); scanf(\u0026quot;%s\u0026quot;, s+1); int j = 0; for (int i = 2; i \u0026lt;= n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j+1]) j = kmp[j]; if (s[i] == s[j+1]) j++; kmp[i] = j; } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { while (kmp[kmp[i]] \u0026gt; 0) kmp[i] = kmp[kmp[i]]; // 这里处理了最小border if (kmp[i]) { ans += (i-kmp[i]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 HDU3336 Count the string 题意\n给定一个字符串 $s$，对于它的每一个前缀 $s_i$，找到 $s_i$ 在 $s$ 内出现的次数，输出所有前缀的出现次数之和。\n其中，$n \\leq 2 \\times 10^5$，答案对 $10007$ 取模。\n Follow Up: 如果给定另外一个字符串 $t$，对于 $s$ 的每一个前缀 $s_i$，求 $s_i$ 在 $t$ 内出现的次数？\n 题解 KMP + DP。\n我们设 $dp[i]$ 为：长度为 $i$ 的前缀的出现次数。\n我们可以发现，一个前缀 $s_k$ 如果出现在了 $s$ 内，那么它出现的一个位置的右端点为 $j$ 的话，必然有: $s_k$ 是前缀 $s_j$ 的一个border。\n于是我们发现，如果 $i$ 的kmp值 $kmp[i] = j$，那么一个最大的前缀 $s_j$ 出现了并且以 $i$ 作为右端点，也就是说 s[1 ... j] = s[i-j+1 ... i]。\n那么更小的前缀呢？我们可以先把 $dp[i]$ 加到 $dp[j]$ 上，更小的前缀留到之后处理 $s_j$ 的时候再一起考虑它们。\n所以我们从后往前处理。\nint ans = 0; for (int i = n; i \u0026gt;= 1; i--) { dp[i]++; dp[kmp[i]] += dp[i]; ans += dp[i]; }   Follow Up:\n创造一个新的string s + \u0026quot;#\u0026quot; + t。\n\u0026quot;#\u0026quot; 的目的是让整个串的 border 不会穿过 \u0026quot;#\u0026quot;。\n仍然设 $dp[i]$ 为：长度为 $i$ 的前缀的出现次数。然后对整个串跑一次 kmp。\n不同的是，我们这次分开处理。\n先处理 $t$ 的部分，对于 $t$ 内的所有index $i$，给所有的 dp[kmp[i]]++;。\n接着处理 $s$ 即可，处理方法和之前完全一样。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; char s[maxn]; int kmp[maxn]; int dp[maxn]; int main() { int T; scanf(\u0026quot;%d\u0026quot;,\u0026amp;T); while (T--) { int n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); scanf(\u0026quot;%s\u0026quot;, s+1); int j = 0; for (int i = 2; i \u0026lt;= n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j+1]) j = kmp[j]; if (s[i] == s[j+1]) j++; kmp[i] = j; } int ans = 0; for (int i = n; i \u0026gt;= 1; i--) { dp[i]++; (dp[kmp[i]] += dp[i]) %= 10007; (ans += dp[i]) %= 10007; } printf(\u0026quot;%d\\n\u0026quot;, ans); fill(kmp, kmp+n+1, 0); fill(dp, dp+n+1, 0); } }   Follow Up 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; char s[maxn]; int kmp[maxn]; int dp[maxn]; int main() { int T; scanf(\u0026quot;%d\u0026quot;,\u0026amp;T); while (T--) { int n, m; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); scanf(\u0026quot;%s\u0026quot;, s+1); // 输入 s s[n+1] = '#'; scanf(\u0026quot;%s\u0026quot;, s+n+2); // 输入 t int j = 0; for (int i = 2; i \u0026lt;= n+m+1; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j+1]) j = kmp[j]; if (s[i] == s[j+1]) j++; kmp[i] = j; } int ans = 0; for (int i = n+m+1; i \u0026gt;= n+2; i--) { if (kmp[i] \u0026gt; 0) dp[kmp[i]]++; } for (int i = n; i \u0026gt;= 1; i--) { if (kmp[i] \u0026gt; 0) dp[kmp[i]] += dp[i]; ans += dp[i]; } printf(\u0026quot;%d\\n\u0026quot;, ans); fill(kmp, kmp+n+1, 0); fill(dp, dp+n+1, 0); } }   例4 HDU2609 How many 题意\n给定 $n$ 个长度相同的字符串，问有多少个本质不同的字符串？\n$s,t$ 本质不同当且仅当 $s,t$ 不互为循环同构。\n其中，$n \\leq 10000$，每个字符串长度 $\\leq 100$。\n 题解 求出每个字符串的最小表示法，去一下重即可。（代码都不用放了）。\n 例5 CF808G Anthem of Berland 题意\n给定一个包含小写字母和 '?' 的字符串 $s$，和一个仅包含小写字母的字符串 $t$，求如何替换 $s$ 中的 '?' 为小写字母，使得 $t$ 在 $s$ 中出现的次数最多？\n其中，$|s|, |t| \\leq 10^5, |s| * |t| \\leq 10^7$。\n 题解 KMP + DP。\n注意到 $|s| * |t| \\leq 10^7$。\n思考一个 dp 的做法：$dp[i][j]$ 代表匹配到了 $s$ 的第 $i$ 位，此时尝试匹配 $s_i$ 和 $t_{j+1}$（之所以是 $j+1$ 是因为 KMP 的写法），dp数组的值代表此时 $t$ 出现的次数。\n如果匹配成功，那么有：\n$$dp[i+1][j+1] = dp[i][j]$$\n特别的，当 $j+1 = m$ 时，出现次数加 $1$。那么按照 kmp 的做法，在匹配完成后，需要跳回 kmp[m] 的位置继续匹配。\n所以在 $j+1 = m$ 时有：\n$$dp[i+1][kmp[m]] = dp[i][j] + 1$$\n如果匹配失败，那么就按照 KMP 的失配规则，$j$ 一直往前跳，直到 $s_i = t_{j+1}$。\n 以上讨论都基于没有 ? 的情况，有 ? 怎么办呢？\n我们不能简单的说 '?' 就默认为匹配成功，可能存在一种情况使得 '?' 换成其他的字符更好，比如 s = \u0026quot;a?bc\u0026quot;, t = \u0026quot;abc\u0026quot;。\n既然总共就只有小写字母，不妨枚举 ? 的所有可能性，然后分别进行转移。\n 最后注意到复杂度有点爆炸，每次枚举 '?' 的值时 kmp 都要暴力往前跳。\n不妨预处理一个 nxt[][] 数组，其中 nxt[c][j] 代表在 $s$ 的一个 '?' 替换成字符 $c$ 时，若此时正在匹配 $t_{j+1}$，那么 KMP 应该让它跳回什么地方？\n其实这就是一个最小 border 问题，利用例 $2$ 的做法即可，这里只是加了一个枚举 $c$ 而已。\n最终复杂度 $O(26 nm)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; char s[maxn], t[maxn]; int kmp[maxn]; int nxt[26][maxn]; int main() { scanf(\u0026quot;%s\u0026quot;, s+1); scanf(\u0026quot;%s\u0026quot;, t+1); int n = strlen(s+1), m = strlen(t+1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n+2, vector\u0026lt;int\u0026gt;(m+2, -1e9)); int j = 0; for (int i = 2; i \u0026lt;= m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; t[i] != t[j+1]) j = kmp[j]; if (t[i] == t[j+1]) j++; kmp[i] = j; } for (int i = 1; i \u0026lt;= n; i++) dp[i][0] = 0; for (int cc = 0; cc \u0026lt; 26; cc++) { // 枚举 ? 替换成的字符 char c = (char)(cc + 'a'); for (int j = 0; j \u0026lt;= m; j++) { if (c == t[j+1]) nxt[cc][j] = j+1; // 匹配成功则不需要跳 else { nxt[cc][j] = nxt[cc][kmp[j]]; // 最小 border } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++){ if (dp[i][j] == -1e9) continue; for (char c = 'a'; c \u0026lt;= 'z'; c++) { int nj = j, val = 0; if (s[i] != '?' \u0026amp;\u0026amp; s[i] != c) continue; nj = nxt[c-'a'][j]; // if (c == t[nj+1]) nj++; // else { // while (nj \u0026gt; 0 \u0026amp;\u0026amp; c != t[nj+1]) { // nj = kmp[nj]; // } // if(c == t[nj+1]) nj++; // } if (nj == m) { // 匹配成功！往回跳一次 nj = kmp[nj]; val = 1; } dp[i+1][nj] = max(dp[i+1][nj], dp[i][j] + val); } } } int ans = 0; for (int i = 1; i \u0026lt;= n+1; i++) { // 注意是 i 往 i+1 转移所以要在 n+1 取答案 for (int j = 0; j \u0026lt;= m; j++) ans = max(ans, dp[i][j]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2022-10-29T11:43:01-05:00","permalink":"https://tom0727.github.io/post/081-kmp/","tags":["KMP",""],"title":"KMP"},{"categories":["算法"],"contents":"介绍 Treap是一个自平衡的 BST (Binary Search Tree)。与普通BST不同的在于，每个节点会有一个随机的优先级 (priority/rank)，在不破坏 BST 的性质的情况下，保证了每一个子树根据 优先级 形成一个最小堆。\n这样，Treap的所有操作均为 $O(\\log n)$。\nTreap支持的操作有：\n 插入 删除 根据值查询排名 根据排名查询值 查询第一个值比 val 小的节点 查询第一个值比 val 大的节点  结构/操作 需要同时维护 BST 和 最小堆的性质，我们利用旋转来维护这个性质。\n所以为了维护最小堆性质，只要对于一个节点 $u$，在插入节点后，判断插入左/右的 priority 是否比它小，如果是，将最小priority的那个旋转上来。\n性质   Treap 相当于将所有值赋上随机的 priority 后，按照priority从小到大的顺序插入进一个普通的 BST 中。\n  $\\forall i \\neq k, i ↑ k \\iff p_i = \\min(\\{p_i, p_{i+1}, \u0026hellip; p_k\\})$\n这里 $i ↑ k$ 的意思是 $i$ 是 $k$ 的祖先。我们这里假设 $\\forall i$，第 $i$ 个节点有整个 treap 中第 $i$ 大的val，$p_i$ 代表了 $i$ 的 priority（这里 WLOG 假设了 $i\u0026lt;k$）。\n证明：\n考虑当前子树中：\nCase1: $i$ 为 $k$ 的祖先，这很明显说明 $i$ 在这个子树内的priority是最小的，反之亦然。\nCase2: $j$ 为 $k$ 的祖先，$j \\neq i, j \\neq k$，并且 $i,k$ 在不同的子树中，那么条件不成立。\nCase3: $j$ 为 $k$ 的祖先，$j \\neq i, j \\neq k$，并且 $i,k$ 在相同的子树中，那么则可以递归解决。\n  $\\Pr(i ↑ k) = \\frac{1}{|i-k|+1}, i \\neq k$\n证明：由性质 $2$，可以得知因为所有的priority均为随机，所以 $p_i$ 成为最小值的概率为 $\\frac{1}{|i-k|+1}$\n  $E[depth(k)] = \\sum\\limits_{i=1}^n \\Pr(i ↑ k) = O(\\log n)$。\n这也解释了为什么 Treap 的复杂度是 $O(\\log n)$。\n  ","date":"2022-10-28T17:44:57-05:00","permalink":"https://tom0727.github.io/post/080-treap/","tags":["",""],"title":"Treap"},{"categories":["算法"],"contents":"介绍 给定一个正整数 $n$，Meissel-Lehmer算法用于求 $\\leq n$ 的质数数量。\n时间复杂度：$O(\\frac{n^{\\frac{2}{3}}}{\\log^2{n}})$\n空间复杂度：$O(n^{\\frac{1}{3}}\\log^3{n})$\n模版 int isqrt(ll n) {return sqrtl(n);} // 时间复杂度 O(n^{2/3})，空间复杂度 O(n^{1/3} * log^3(n)) // 调用 prime_pi(n) 返回 \u0026lt;= n 的质数数量（不包含1） ll prime_pi(const ll N) { if (N \u0026lt;= 1) return 0; if (N == 2) return 1; const int v = isqrt(N); int s = (v + 1) / 2; vector\u0026lt;int\u0026gt; smalls(s); for (int i = 1; i \u0026lt; s; ++i) smalls[i] = i; vector\u0026lt;int\u0026gt; roughs(s); for (int i = 0; i \u0026lt; s; ++i) roughs[i] = 2 * i + 1; vector\u0026lt;ll\u0026gt; larges(s); for (int i = 0; i \u0026lt; s; ++i) larges[i] = (N / (2 * i + 1) - 1) / 2; vector\u0026lt;bool\u0026gt; skip(v + 1); const auto divide = [] (ll n, ll d) -\u0026gt; int { return double(n) / d; }; const auto half = [] (int n) -\u0026gt; int { return (n - 1) \u0026gt;\u0026gt; 1; }; int pc = 0; for (int p = 3; p \u0026lt;= v; p += 2) if (!skip[p]) { int q = p * p; if ((ll)(q) * q \u0026gt; N) break; skip[p] = true; for (int i = q; i \u0026lt;= v; i += 2 * p) skip[i] = true; int ns = 0; for (int k = 0; k \u0026lt; s; ++k) { int i = roughs[k]; if (skip[i]) continue; ll d = (ll)(i) * p; larges[ns] = larges[k] - (d \u0026lt;= v ? larges[smalls[d \u0026gt;\u0026gt; 1] - pc] : smalls[half(divide(N, d))]) + pc; roughs[ns++] = i; } s = ns; for (int i = half(v), j = ((v / p) - 1) | 1; j \u0026gt;= p; j -= 2) { int c = smalls[j \u0026gt;\u0026gt; 1] - pc; for (int e = (j * p) \u0026gt;\u0026gt; 1; i \u0026gt;= e; --i) smalls[i] -= c; } ++pc; } larges[0] += (ll)(s + 2 * (pc - 1)) * (s - 1) / 2; for (int k = 1; k \u0026lt; s; ++k) larges[0] -= larges[k]; for (int l = 1; l \u0026lt; s; ++l) { int q = roughs[l]; ll M = N / q; int e = smalls[half(M / q)] - pc; if (e \u0026lt; l + 1) break; ll t = 0; for (int k = l + 1; k \u0026lt;= e; ++k) t += smalls[half(divide(M, roughs[k]))]; larges[0] += t - (ll)(e - l) * (pc + l - 1); } return larges[0] + 1; }  例1 CF665F Four Divisors 题意\n给定一个正整数 $n$，求有多少个正整数 $a$ 满足以下条件：\n $1 \\leq a \\leq n$。 $a$ 拥有恰好4个disivor。  其中，$1 \\leq n \\leq 10^{11}$。\n 题解 $a$ 拥有恰好 $4$ 个divisor意味着 $a$ 只有可能为两种情况：\n $a = p^3$ $a = p_1 * p_2$  其中，$p, p_1, p_2$ 均为质数。\n对于第一种情况暴力枚举即可。\n对于第二种情况，我们保证 $p_1 \u0026lt; p_2$，那么 $p_1 \u0026lt; 10^6$，所以只要枚举 $10^6$ 以内的所有 $p_1$，然后判断有多少个 $p_2$ 满足 $p_1 * p_2 \\leq n$ 即可，可以直接求在 $[p_1+1, \\frac{n}{p_1}]$ 之间的质数数量得到答案。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int isqrt(ll n) {return sqrtl(n);} // 时间复杂度 O(n^{2/3})，空间复杂度 O(n^{1/3} * log^3(n)) ll prime_pi(const ll N) { if (N \u0026lt;= 1) return 0; if (N == 2) return 1; const int v = isqrt(N); int s = (v + 1) / 2; vector\u0026lt;int\u0026gt; smalls(s); for (int i = 1; i \u0026lt; s; ++i) smalls[i] = i; vector\u0026lt;int\u0026gt; roughs(s); for (int i = 0; i \u0026lt; s; ++i) roughs[i] = 2 * i + 1; vector\u0026lt;ll\u0026gt; larges(s); for (int i = 0; i \u0026lt; s; ++i) larges[i] = (N / (2 * i + 1) - 1) / 2; vector\u0026lt;bool\u0026gt; skip(v + 1); const auto divide = [] (ll n, ll d) -\u0026gt; int { return double(n) / d; }; const auto half = [] (int n) -\u0026gt; int { return (n - 1) \u0026gt;\u0026gt; 1; }; int pc = 0; for (int p = 3; p \u0026lt;= v; p += 2) if (!skip[p]) { int q = p * p; if ((ll)(q) * q \u0026gt; N) break; skip[p] = true; for (int i = q; i \u0026lt;= v; i += 2 * p) skip[i] = true; int ns = 0; for (int k = 0; k \u0026lt; s; ++k) { int i = roughs[k]; if (skip[i]) continue; ll d = (ll)(i) * p; larges[ns] = larges[k] - (d \u0026lt;= v ? larges[smalls[d \u0026gt;\u0026gt; 1] - pc] : smalls[half(divide(N, d))]) + pc; roughs[ns++] = i; } s = ns; for (int i = half(v), j = ((v / p) - 1) | 1; j \u0026gt;= p; j -= 2) { int c = smalls[j \u0026gt;\u0026gt; 1] - pc; for (int e = (j * p) \u0026gt;\u0026gt; 1; i \u0026gt;= e; --i) smalls[i] -= c; } ++pc; } larges[0] += (ll)(s + 2 * (pc - 1)) * (s - 1) / 2; for (int k = 1; k \u0026lt; s; ++k) larges[0] -= larges[k]; for (int l = 1; l \u0026lt; s; ++l) { int q = roughs[l]; ll M = N / q; int e = smalls[half(M / q)] - pc; if (e \u0026lt; l + 1) break; ll t = 0; for (int k = l + 1; k \u0026lt;= e; ++k) t += smalls[half(divide(M, roughs[k]))]; larges[0] += t - (ll)(e - l) * (pc + l - 1); } return larges[0] + 1; } ll ans = 0; bool isPrime[maxn]; vector\u0026lt;int\u0026gt; primes; void euler() { memset(isPrime, 1, sizeof(isPrime)); for (ll i = 2; i \u0026lt;= 1e6; i++) { if (isPrime[i]) { primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size(); j++) { if (i * (ll)primes[j] \u0026gt; 1e6) break; isPrime[i * primes[j]] = 0; if (i % primes[j] == 0) break; } } } int main() { euler(); ll n; cin \u0026gt;\u0026gt; n; for (ll p : primes) { if (p * p * p \u0026lt;= n) ans++; else break; } for (ll p : primes) { if (p * p \u0026gt;= n) break; ans += prime_pi(n/p) - prime_pi(p); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   参考链接\n https://oi-wiki.org/math/number-theory/meissel-lehmer/#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6   ","date":"2022-10-24T00:02:14-05:00","permalink":"https://tom0727.github.io/post/079-meissel-lehmer/","tags":["质数",""],"title":"Meissel-Lehmer算法"},{"categories":["解题报告"],"contents":"B. Building an Amusement Park 题意\n二维平面上给定 $n$ 个点，求一个最小的圆，使得：\n $(0,0)$ 在圆上。 圆内（包括圆上）包含至少 $k$ 个点。  输出最小圆半径。\n其中，$1 \\leq n \\leq 10^5, 1 \\leq k \\leq n, |x_i|, |y_i| \\in [0, 10^5]$。\n相对误差 $\\leq 10^{-4}$。\n 题解 首先二分半径 $r$，\n我们已知一个半径 $r$，已知圆需要过原点 $(0,0)$，那么我们只需要再确定圆上的一个点即可得到一个圆。\n显然，想让半径最小，那么我们应该在此时 恰好 包括了一个点 $p_i$，这意味着只要枚举圆上的点 $p_i$ 即可确认 $n$ 个圆，只要判断这 $n$ 个圆中是否存在一个使得它包含了至少 $k$ 个点即可。\n然而直接判断复杂度太高了，我们换种思考方式：\n因为对于每个点 $p_i$，能够恰好让 $p_i$ 在圆上的圆有 $2$ 个，如果我们是逆时针旋转这个圆，那么恰好有 $2$ 个角度，使得这个圆恰好让这个点 $p_i$ 进来/出来。\n所以如果圆心恰好在这两个角度 $a_1, a_2$ 之间，即圆心的极角在 $[a_1,a_2]$ 之间，说明这个点被包含进去了。\n 这个圆心的极角怎么计算呢？\n可以先计算出每个点 $p_i$ 的极角 ang[i] 和距离圆心的距离 $d$，然后计算点 $p_i$ 与圆心的极角差 rot，可以得到 $\\cos(rot) = \\frac{d}{2r}$，这样就可以得到两个圆心的极角了。\n 剩下的就相当于一个区间覆盖问题了，可以直接 sort() 一下然后从左往右枚举，过程中维护当前覆盖点数（有优雅的写法连差分数组都不需要）。\n更优雅的是，可以直接给所有的点加上 $2\\pi$ 这样可以断环成链，剩下的完全一致，具体操作看代码吧。\n• 最后注意特判一下某些点可能位于 $(0,0)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int sgn(double x){ if(fabs(x) \u0026lt; eps)return 0; if(x \u0026lt; 0)return -1; else return 1; } //square of a double inline double sqr(double x){return x*x;} struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } void input(){ scanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;x,\u0026amp;y); } void output(){ printf(\u0026quot;%.2f %.2f\\n\u0026quot;,x,y); } bool operator == (Point b)const{ return sgn(x-b.x) == 0 \u0026amp;\u0026amp; sgn(y-b.y) == 0; } bool operator \u0026lt; (Point b)const{ return sgn(x-b.x)== 0?sgn(y-b.y)\u0026lt;0:x\u0026lt;b.x; } Point operator -(const Point \u0026amp;b)const{ return Point(x-b.x,y-b.y); } //叉积 double operator ^(const Point \u0026amp;b)const{ return x*b.y - y*b.x; } //点积 double operator *(const Point \u0026amp;b)const{ return x*b.x + y*b.y; } //返回长度 double len(){ return hypot(x,y);//库函数 } //返回长度的平方 double len2(){ return x*x + y*y; } //返回两点的距离 double distance(Point p){ return hypot(x-p.x,y-p.y); } Point operator +(const Point \u0026amp;b)const{ return Point(x+b.x,y+b.y); } Point operator *(const double \u0026amp;k)const{ return Point(x*k,y*k); } Point operator /(const double \u0026amp;k)const{ return Point(x/k,y/k); } //`计算pa 和 pb 的夹角` //`就是求这个点看a,b 所成的夹角` //`测试 LightOJ1203` double rad(Point a,Point b){ Point p = *this; return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) )); } //`化为长度为r的向量` Point trunc(double r){ double l = len(); if(!sgn(l))return *this; r /= l; return Point(x*r,y*r); } }; int n, k; vector\u0026lt;pair\u0026lt;double, int\u0026gt;\u0026gt; vec; long double dis[maxn], ang[maxn]; Point p[maxn]; bool check(long double x) { int cur = 0; vec.clear(); for (int i = 1; i \u0026lt;= n; i++) { if (dis[i] \u0026gt; 0 \u0026amp;\u0026amp; dis[i] \u0026lt;= 2.0*x) { double rot = acos(dis[i] / 2.0 / x); vec.push_back({ang[i] - rot, 1}); // 直接利用 +1, -1 来完成区间覆盖操作 vec.push_back({ang[i] + rot, -1}); vec.push_back({ang[i] - rot + 2 * pi, 1}); // 直接加上 2pi vec.push_back({ang[i] + rot + 2 * pi, -1}); } } sort(vec.begin(), vec.end()); // -1 在前所以没问题 for (auto di : vec) { cur += di.second; if (cur \u0026gt;= k) return 1; } return 0; } long double ans = 0.0; int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;k); for (int i = 1; i \u0026lt;= n; i++) { p[i].input(); if (abs(p[i].x) \u0026lt; eps \u0026amp;\u0026amp; abs(p[i].y) \u0026lt; eps) k--; else { dis[i] = p[i].len(); ang[i] = atan2(p[i].y, p[i].x); } } if (k \u0026lt;= 0) { ans = 0; printf(\u0026quot;%.15Lf\\n\u0026quot;, ans); return 0; } long double low = 0.0, high = 2e5; int T = 100; while (high - low \u0026gt; 1e-6 \u0026amp;\u0026amp; T--) { long double mid = (high + low) * 0.5; if (check(mid)) { ans = mid; high = mid; } else low = mid; } printf(\u0026quot;%.15Lf\\n\u0026quot;, ans); }   L. Longest Array Deconstruction 题意\n给定 $n$ 个正整数 $a_i$，我们可以从中remove掉若干个元素，求remove后，最多有多少个 $i$ 满足 $a_i = i$？\n其中，$n \\leq 2 \\times 10^5, a_i \\in [1, 2 \\times 10^5]$。\n 题解 先处理 $b_i = i - a_i$，如果 $b_i \u0026lt; 0$ 这意味着这个数字不可能对答案有贡献。\n如果 $i \u0026gt; j$ 并且 $i - a_i \\geq j - a_j$，那么就有办法通过 remove $(j, i)$ 中的一些元素来让 $i$ 满足条件。\n• 一个特例是 $1, 1, 1$，这里 i[] = [1, 2, 3], a[] = [1, 1, 1], b[] = [0, 1, 2]，但是答案只能是 $1$，所以还得加个限制条件代表每个数只能被用一次。\n所以我们需要找一个最长的 subsequence 使得序列中均为 index，并且转移时保证：\n $j - a_j \\leq i - a_i$。 $a_j \u0026lt; a_i$。 $j \u0026lt; i$。  看样子是个三维偏序，但实际上知道 $1,2$ 就可以推出 $3$，所以是二维偏序。\n做二维偏序的方法：先根据一个维度 sort 一下，然后按照这个顺序加入元素，用线段树维护另外一个维度（另外一个维度的值作为 index），线段树里的值是转移的 dp值。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n; struct Node { int a, b, i; // a : a[i], b : i - a[i], i : idx } arr[maxn]; int tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur] = max(tr[cur\u0026lt;\u0026lt;1], tr[cur\u0026lt;\u0026lt;1|1]); } // 给位置 p 赋值为 x void update(int cur, int l, int r, int p, int x) { tr[cur] = max(tr[cur], x); if (l == r) return; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); } int query(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) return tr[cur]; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res = max(res, query(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) res = max(res, query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return res; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].a; arr[i].b = i - arr[i].a; arr[i].i = i; } sort(arr+1, arr+n+1, [](auto a, auto b) { if (a.b == b.b) return a.a \u0026lt; b.a; return a.b \u0026lt; b.b; }); int N = 2e5; for (int i = 1; i \u0026lt;= n; i++) { int res = 0; if (arr[i].a - 1 \u0026gt; 0) res = query(1, 1, N, 1, arr[i].a - 1); if (arr[i].b \u0026gt;= 0) update(1, 1, N, arr[i].a, res + 1); } int ans = query(1, 1, N, 1, N); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2022-10-23T23:48:58-05:00","permalink":"https://tom0727.github.io/post/078-icpc-compfest13/","tags":["",""],"title":"COMPFEST13"},{"categories":["解题报告"],"contents":"G. Hobbits 题意\n二维平面上有 $n$ 个点，第 $i$ 个点的坐标是 $(x_i,y_i)$，其中 $x_i \u0026lt; x_{i+1}, \\forall i \\in [1, n-1]$，点 $i$ 与点 $(i+1)$ 之间由一条线段链接。\n在 $(x_n, y_n + H)$ 位置有一个眼睛，现在从点 $1$ 沿着线段走到点 $n$，求这个眼睛的视野能覆盖这个路程中的多长距离？\n其中，$2 \\leq n \\leq 2 \\cdot 10^5, H \\in [1, 10^4], x_i \\in [0, 4 \\cdot 10^5], y_i \\in [0 \\leq 10^4]$。\n 题解 几何题。这里用的是 kuangbin的板子，并且有 板子相对应的讲解\n我们设这个眼睛为 $s$，那么可以知道 $(x_n,y_n)$ 在 $s$ 的正下方，接着视线顺时针旋转，每次碰到一个点就判断这个点是否能被看到。\n可以知道，这个点能被看见，当且仅当它前面没有点（或相应的线段）能挡住它，判断是否能挡住只要看顺时针扫描的时候的夹角即可，如果右边有个点对应的角更大的话就看不见了。\n如果能看见点 $i$，记录这个点为 $pre$，在看见下一个点 $i$ 时，链接 $(s,pre)$ 并且做延长线，与线段 $(i,i+1)$ 相交即可得到对应路程长度。\n 最后注意特判一下平行的情况，如图：\n如果 $(i,pre)$ 之间刚好是一条线段（这意味着 $pre=i+1$），并且 $s,pre,i$ 在同一条线上，那么是 $(i,pre)$ 整条可以计入答案的。\n这里要注意使用 long long 或者板子里的 parallel() 函数来判断，如果用夹角判断会出现精度问题！\n• 最后，注意用 scanf() 读入数据，否则超时。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sgn(double x){ if(fabs(x) \u0026lt; eps)return 0; if(x \u0026lt; 0)return -1; else return 1; } //square of a double inline double sqr(double x){return x*x;} struct Point{ double x,y; Point(){} Point(double _x,double _y){ x = _x; y = _y; } void input(){ scanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;x,\u0026amp;y); } void output(){ printf(\u0026quot;%.2f %.2f\\n\u0026quot;,x,y); } bool operator == (Point b)const{ return sgn(x-b.x) == 0 \u0026amp;\u0026amp; sgn(y-b.y) == 0; } bool operator \u0026lt; (Point b)const{ return sgn(x-b.x)== 0?sgn(y-b.y)\u0026lt;0:x\u0026lt;b.x; } Point operator -(const Point \u0026amp;b)const{ return Point(x-b.x,y-b.y); } //叉积 double operator ^(const Point \u0026amp;b)const{ return x*b.y - y*b.x; } //点积 double operator *(const Point \u0026amp;b)const{ return x*b.x + y*b.y; } //返回长度 double len(){ return hypot(x,y);//库函数 } //返回长度的平方 double len2(){ return x*x + y*y; } //返回两点的距离 double distance(Point p){ return hypot(x-p.x,y-p.y); } Point operator +(const Point \u0026amp;b)const{ return Point(x+b.x,y+b.y); } Point operator *(const double \u0026amp;k)const{ return Point(x*k,y*k); } Point operator /(const double \u0026amp;k)const{ return Point(x/k,y/k); } //`计算pa 和 pb 的夹角` //`就是求这个点看a,b 所成的夹角` //`测试 LightOJ1203` double rad(Point a,Point b){ Point p = *this; return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) )); } //`化为长度为r的向量` Point trunc(double r){ double l = len(); if(!sgn(l))return *this; r /= l; return Point(x*r,y*r); } //`逆时针旋转90度` Point rotleft(){ return Point(-y,x); } //`顺时针旋转90度` Point rotright(){ return Point(y,-x); } //`绕着p点逆时针旋转angle` Point rotate(Point p,double angle){ Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c); } }; struct Line{ Point s,e; Line(){} Line(Point _s,Point _e){ s = _s; e = _e; } bool operator ==(Line v){ return (s == v.s)\u0026amp;\u0026amp;(e == v.e); } //`根据一个点和倾斜角angle确定直线,0\u0026lt;=angle\u0026lt;pi` Line(Point p,double angle){ s = p; if(sgn(angle-pi/2) == 0){ e = (s + Point(0,1)); } else{ e = (s + Point(1,tan(angle))); } } //ax+by+c=0 Line(double a,double b,double c){ if(sgn(a) == 0){ s = Point(0,-c/b); e = Point(1,-c/b); } else if(sgn(b) == 0){ s = Point(-c/a,0); e = Point(-c/a,1); } else{ s = Point(0,-c/b); e = Point(1,(-c-a)/b); } } void input(){ s.input(); e.input(); } void adjust(){ if(e \u0026lt; s)swap(s,e); } //求线段长度 double length(){ return s.distance(e); } //`返回直线倾斜角 0\u0026lt;=angle\u0026lt;pi` double angle(){ double k = atan2(e.y-s.y,e.x-s.x); if(sgn(k) \u0026lt; 0)k += pi; if(sgn(k-pi) == 0)k -= pi; return k; } //`点和直线关系` //`1 在左侧` //`2 在右侧` //`3 在直线上` int relation(Point p){ int c = sgn((p-s)^(e-s)); if(c \u0026lt; 0)return 1; else if(c \u0026gt; 0)return 2; else return 3; } // 点在线段上的判断 bool pointonseg(Point p){ return sgn((p-s)^(e-s)) == 0 \u0026amp;\u0026amp; sgn((p-s)*(p-e)) \u0026lt;= 0; } //`两向量平行(对应直线平行或重合)` bool parallel(Line v){ return sgn((e-s)^(v.e-v.s)) == 0; } //`两线段相交判断` //`2 规范相交` //`1 非规范相交` //`0 不相交` int segcrossseg(Line v){ int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); int d3 = sgn((v.e-v.s)^(s-v.s)); int d4 = sgn((v.e-v.s)^(e-v.s)); if( (d1^d2)==-2 \u0026amp;\u0026amp; (d3^d4)==-2 )return 2; return (d1==0 \u0026amp;\u0026amp; sgn((v.s-s)*(v.s-e))\u0026lt;=0) || (d2==0 \u0026amp;\u0026amp; sgn((v.e-s)*(v.e-e))\u0026lt;=0) || (d3==0 \u0026amp;\u0026amp; sgn((s-v.s)*(s-v.e))\u0026lt;=0) || (d4==0 \u0026amp;\u0026amp; sgn((e-v.s)*(e-v.e))\u0026lt;=0); } //`直线和线段相交判断` //`-*this line -v seg` //`2 规范相交` //`1 非规范相交` //`0 不相交` int linecrossseg(Line v){ int d1 = sgn((e-s)^(v.s-s)); int d2 = sgn((e-s)^(v.e-s)); if((d1^d2)==-2) return 2; return (d1==0||d2==0); } //`两直线关系` //`0 平行` //`1 重合` //`2 相交` int linecrossline(Line v){ if((*this).parallel(v)) return v.relation(s)==3; return 2; } //`求两直线的交点` //`要保证两直线不平行或重合` Point crosspoint(Line v){ double a1 = (v.e-v.s)^(s-v.s); double a2 = (v.e-v.s)^(e-v.s); return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1)); } //点到直线的距离 double dispointtoline(Point p){ return fabs((p-s)^(e-s))/length(); } //点到线段的距离 double dispointtoseg(Point p){ if(sgn((p-s)*(e-s))\u0026lt;0 || sgn((p-e)*(s-e))\u0026lt;0) return min(p.distance(s),p.distance(e)); return dispointtoline(p); } //`返回线段到线段的距离` //`前提是两线段不相交，相交距离就是0了` double dissegtoseg(Line v){ return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e))); } //`返回点p在直线上的投影` Point lineprog(Point p){ return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) ); } //`返回点p关于直线的对称点` Point symmetrypoint(Point p){ Point q = lineprog(p); return Point(2*q.x-p.x,2*q.y-p.y); } }; int n; int H; Point a[maxn]; double ang[maxn]; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;H); for (int i = 1; i \u0026lt;= n; i++) { a[i].input(); } Point p(a[n].x, a[n].y + H); for (int i = 1; i \u0026lt;= n; i++) { ang[i] = p.rad(a[n], a[i]); } int pre = n; double ans = 0.0; for (int i = n-1; i \u0026gt;= 1; i--) { Line s(p, a[pre]); // (s, pre) Line t(p, a[i]); if (s.parallel(t)) { if (pre-i == 1) { ans += a[i].distance(a[pre]); } pre = i; } else if (ang[i] \u0026gt; ang[pre]) { Line l(a[i], a[i+1]); // (i, i+1) Point c = l.crosspoint(s); ans += c.distance(a[i]); pre = i; } } printf(\u0026quot;%.15lf\\n\u0026quot;, ans); }   H. K and Medians 题意\n给定一个数组，包含 $n$ 个数字 $1, 2, \u0026hellip;, n$。\n给定一个奇数 $k$，每次操作中，可以选择array中一个大小为 $k$ 的subsequence（不一定连续），保留median，remove掉其他的数字。\n问是否可以通过这样的操作，使得最后留下 $m$ 个数，分别为 $b_1, b_2, \u0026hellip; b_m$？\n其中，$n \\in [3, 2 \\times 10^5], 3 \\leq k \\leq n, 1 \\leq m \u0026lt; n, 1 \\leq b_1 \u0026lt; b_2 \u0026hellip; \u0026lt; b_m \\leq n$。\n 题解 脑洞题。\n我们首先给出结论：\n设 $k = 2a + 1$，\n如果我们只考虑所有要最终被remove掉的数，那么如果存在 $i$，使得 $b_i$ 的左边有 $\\geq a$ 个要被remove的数，右边也有 $\\geq a$ 个要被remove的数，并且 $(n-m)$ 可以被 $(2a)$ 整除，那么答案为 YES，否则为 NO。\n这是充要条件，接下来证明：\n• $(n-m)$ 可以被 $(2a)$ 整除 是一个显然的条件，在接下来的证明中直接忽略。\n  存在 $i$，使得 $b_i$ 的左边有 $\\geq a$ 个要被remove的数，右边也有 $\\geq a$ 个要被remove的数 $\\rightarrow$ 有解。\n WLOG 我们设左边的数的数量 $\\leq$ 右边。\n我们一直移除右边，使得右边剩余数字数量 $\u0026lt; 2a$。\n此时，左边 $\\geq a$，右边 $\u0026lt; 2a$。\n并且我们注意到，之前已经有 $(n-m)$ 可以被 $(2a)$ 整除这个条件了，说明我们需要移除偶数个数字，这说明左边需要移除的数字 + 右边需要移除的数字 总量是一个偶数。\n这说明，左右奇偶性 相同，又因为我们每次移除 $2a$ 个数字，并且左右两边相差不超过 $a-1$，这说明一定可以有一种移除方法使得左右平衡。\n这意味着一定存在这样的remove方案。\n• 注意到，在以上证明中，我们没有讨论每次 remove 选择的中位数是什么，因为这并不重要，只要保证在remove的过程中，不会动到那些需要保留的数字即可。\n  有解 $\\rightarrow$ 存在 $i$，使得 $b_i$ 的左边有 $\\geq a$ 个要被remove的数，右边也有 $\\geq a$ 个要被remove的数。\n 假设不存在这样的 $i$，说明每次 remove 时，任何需要保留的数字都不能作为中位数。这意味着每次 remove 操作会选择一个最终需要扔掉的数字作为中位数，所以不可能remove干净。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n, k, m, a[maxn]; int pre[maxn], suf[maxn]; bool solve() { if ((n - m) % (k-1)) return 0; for (int i = 1; i \u0026lt;= n; i++) { pre[i] = pre[i-1] + a[i]; } for (int i = n; i \u0026gt;= 1; i--) { suf[i] = suf[i+1] + a[i]; } for (int i = 1; i \u0026lt;= n; i++) { if (!a[i] \u0026amp;\u0026amp; pre[i] \u0026gt;= k/2 \u0026amp;\u0026amp; suf[i] \u0026gt;= k/2) return 1; } return 0; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) a[i] = 1, pre[i] = suf[i] = 0; for (int i = 1; i \u0026lt;= m; i++) { int x; cin \u0026gt;\u0026gt; x; a[x] = 0; } bool res = solve(); if (res) cout \u0026lt;\u0026lt; \u0026quot;YES\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; } }   M. Similar Sets 题意\n给定 $n$ 个set，一个set内部所有的正整数互不相同。\n求是否存在 $2$ 个 set，使得这两个set中拥有至少 $2$ 个相同元素？如果有，输出这两个 set 的index，否则输出 $-1$。\n其中，$n \\leq 10^5$，并且所有set内的元素总数量 $\\leq 2 \\times 10^5$，所有元素 $\\in [1, 10^9]$。\n 题解 分块讨论。将 size 大于 $\\sqrt n$ 的看作大set，其余看作小 set。\n那么有 $3$ 种情况：\n 大大 大小 小小  对于前两种情况：考虑到大set最多只有 $\\sqrt n$ 个，那么只要对于每一个大的set，都维护一个 vis[] 代表这个set里有哪些元素，vis[x] = 1 代表 x 在这个大set内，然后对比其他所有set，判断其他所有set里是否有两个元素使得 vis[x] = 1 成立两次即可。\n复杂度：设总共有 $m$ 个元素，那么复杂度为 $O(m\\sqrt n)$。\n 对于第三种情况：\n因为每个set都很小，小于 $\\sqrt n$，所以对于每个 set 可以考虑处理出所有 pair $(u,v)$，其中 $u \u0026lt; v$，然后判断这个pair是否在其他的小set里。\n但这样复杂度太高了，我们有个更优雅的写法：\n从小到大枚举所有可能的 $v$，然后枚举这个 $v$ 所在的所有小set（可以预处理得出），在这些小set中枚举所有可能的比 $v$ 小的 $u$，然后判断这个 $u$ 之前是否也出现在另外一个小set中，并且这个小set还包含了 $v$。在代码中，用 last[u] = v, pos[u] = i 很优雅的实现了。\n• 本质上来说，对于所有的 $v$，维护了一个list of 所有的 $u$，然后判断在这个list中是否存在两个相同的元素。\n复杂度：$O(m\\sqrt n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int T, n; vector\u0026lt;int\u0026gt; a[maxn]; int sz[maxn]; vector\u0026lt;int\u0026gt; big, small; bool done = 0; bool vis[maxn]; void solve_big() { for (int i : big) { for (int x : a[i]) vis[x] = 1; for (int j = 1; j \u0026lt;= n; j++) { if (j == i) continue; int cnt = 0; for (int x : a[j]) { if (vis[x]) cnt++; } if (cnt \u0026gt;= 2) { done = 1; printf(\u0026quot;%d %d\\n\u0026quot;, i, j); return; } } for (int x : a[i]) vis[x] = 0; } } int last[maxn], pos[maxn]; set\u0026lt;int\u0026gt; small_num; // 储存所有 small 里面的数字 vector\u0026lt;int\u0026gt; p[maxn]; // p[v]: 这个值所在的所有 small set 的index void solve_small() { for (int v : small_num) { for (int i : p[v]) { for (int j = 0; j \u0026lt; a[i].size() \u0026amp;\u0026amp; a[i][j] \u0026lt; v; j++) { int u = a[i][j]; if (last[u] == v) { done = 1; printf(\u0026quot;%d %d\\n\u0026quot;, i, pos[u]); return; } else { last[u] = v; pos[u] = i; } } } } } map\u0026lt;int, int\u0026gt; id; int cnt = 0; void clearall() { for (int i = 1; i \u0026lt;= n; i++) { for (int j : a[i]) vis[j] = 0, p[j].clear(), last[j] = pos[j] = 0; } for (int i = 1; i \u0026lt;= n; i++) { sz[i] = 0; a[i].clear(); } big.clear(); small.clear(); small_num.clear(); done = 0; id.clear(); cnt = 0; } const int M = 400; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); while (T--) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;sz[i]); for (int j = 1; j \u0026lt;= sz[i]; j++) { int x; scanf(\u0026quot;%d\u0026quot;, \u0026amp;x); if (!id.count(x)) { id[x] = ++cnt; } a[i].push_back(id[x]); } sort(a[i].begin(), a[i].end()); if (sz[i] \u0026gt; M) big.push_back(i); else small.push_back(i); } for (int i : small) { for (int j : a[i]) { small_num.insert(j), p[j].push_back(i); } } // 先处理 big solve_big(); if (!done) { solve_small(); } if (!done) printf(\u0026quot;-1\\n\u0026quot;); clearall(); } }   ","date":"2022-10-17T13:51:05-05:00","permalink":"https://tom0727.github.io/post/077-icpc-2020-nerc-regional/","tags":["",""],"title":"2020-2021 ICPC, NERC, Southern and Volga Russian Regional Contest"},{"categories":["解题报告"],"contents":"D. Evolution of Weasels 题意\n给定两个字符串 $s,t$，字符串中仅包含 $ABC$ 这三个字母。\n我们对于 $s$ 可以在任意位置增加/删除子串 $AA,BB,CC,ABAB,BCBC$。\n求是否存在一种方式让 $s$ 变成 $t$？\n其中，$|s|, |t| \\in [1, 200]$。\n 题解 一开始想的是 editing distance，但有个反例：\n$s =$\u0026quot;CBCBCC\u0026quot;，$t =$ \u0026quot;ABAB\u0026quot;，这里 $s$ 应该从中间删掉 BCBC，然后删掉 CC，最后添加 ABAB，答案应该是 YES。\n 以下是正解：\n观察这些子串，发现它们每个字母都包含了 偶数 个，并且我们还能发现 $B$ 出现的频率很高。\n我们会发现，$B$ 其实是可以在整个串中随意移动的！\n以下先给出一些引理：\n BABA 与 CBCB 可以直接删掉。  证：BABA -\u0026gt; AA[BABA]BB -\u0026gt; A[ABAB]ABB -\u0026gt; AABB -\u0026gt;  ，对于 CBCB 同理。\n对于 AB，我们有办法将它变成 BA：  证：AB -\u0026gt; BB[AB]AA -\u0026gt; B[BABA]A -\u0026gt; BA\n同理可得 AB \u0026lt;-\u0026gt; BA, BC \u0026lt;-\u0026gt; CB。\n这说明 B 我们可以全部移动到最右边然后消掉，并且 B 的奇偶性无法变化，所以如果 $s,t$ 中 B 数量的奇偶性不同，则答案为 NO。\n最后我们可以发现 A,C 的相对顺序不能变化，所以把 B 全部消掉以后只要拿栈维护一下 A,C 看最终情况是否相同即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int T; int main() { cin \u0026gt;\u0026gt; T; while (T--) { string s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int bs = 0, bt = 0; for (char c : s) { if (c == 'B') bs++; } for (char c : t) { if (c == 'B') bt++; } if ((bs\u0026amp;1) != (bt\u0026amp;1)) { cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; continue; } stack\u0026lt;char\u0026gt; st1, st2; for (char c : s) { if (c == 'B') continue; if (st1.size() \u0026amp;\u0026amp; st1.top() == c) { st1.pop(); } else { st1.push(c); } } for (char c : t) { if (c == 'B') continue; if (st2.size() \u0026amp;\u0026amp; st2.top() == c) { st2.pop(); } else { st2.push(c); } } if (st1.size() != st2.size()) { cout \u0026lt;\u0026lt; \u0026quot;NO\\n\u0026quot;; continue; } bool ok = 1; while (st1.size()) { if (st1.top() != st2.top()) { ok = 0; } st1.pop(); st2.pop(); } cout \u0026lt;\u0026lt; (ok ? \u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;) \u0026lt;\u0026lt; endl; } }   F. Antennas 题意\n有 $n$ 个天线塔排列在一条直线上，第 $i$ 个天线塔位于位置 $i$，拥有一个信号水平 $p_i$。\n两个天线塔 $i,j$ 之间可以双向交流，当且仅当 $|i-j| \\leq \\min(p_i,p_j)$。\n给定 $a,b$，求信号塔 $a$ 到 $b$ 的最短路径长度？\n其中，$n \\leq 2 \\times 10^5, a,b,p_i \\in [1, n]$。\n 题解 这题就是一个图上跑 bfs 找最短路（因为权值均为 $1$），但图的点和边太多了，该怎么办？\n对于点 $i$，它可以覆盖到的范围为 $[i-p_i, i+p_i]$，但覆盖到的这些点 $j$ 不一定能与 $i$ 相连。\n所以我们只要找到一个范围内，有哪些满足条件的点 $j$ 即可。\n考虑两个部分：\n  $j \u0026gt; i$，只要 $p_j \\geq j-i$，即 $p_j - j \\geq -i$ 即可。\n  $j \u0026lt; i$，只要 $p_j \\geq i-j$，即 $p_j + j \\geq i$ 即可。\n  所以对于 $i$，只要分成两个区间：\n  $[i+1, i+p_i]$ 内，寻找 $j$ 使得 $p_j - j \u0026gt; -i$。\n  $[i-p_i, i-1]$ 内，寻找 $j$ 使得 $p_j + j \\geq i$ 即可。\n  用线段树就可以解决了，并且我们其实每次只需要找到一个满足条件的 $j$ 即可，找到一个以后就把 $p_j$ 设为 $-\\infty$，然后继续找 $j$，直到找不到为止。\n具体来说，维护两个线段树，分别维护区间内 $p_j - j$ 和 $p_j + j$ 的最大值和对应的index $j$。\n这样就可以跑 bfs 了，每个 $j$ 只会被用一次，复杂度为 $O(n\\log n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct State { int val, idx; bool operator\u0026lt;(const State\u0026amp; other) const { if (val == other.val) return idx \u0026lt; other.idx; return val \u0026gt; other.val; } }; struct Tree_Node { int maxval, maxidx; } tr1[maxn\u0026lt;\u0026lt;2], tr2[maxn\u0026lt;\u0026lt;2]; int p[maxn]; int n, st, ed; void merge_set(set\u0026lt;State\u0026gt;\u0026amp; s1, set\u0026lt;State\u0026gt;\u0026amp; s2, set\u0026lt;State\u0026gt;\u0026amp; s3) { for (State s : s1) s3.insert(s); for (State s : s2) s3.insert(s); } void push_up(Tree_Node* tr, int cur) { tr[cur].maxval = -1e9; if (tr[cur\u0026lt;\u0026lt;1].maxval \u0026gt; tr[cur].maxval) { tr[cur].maxval = tr[cur\u0026lt;\u0026lt;1].maxval; tr[cur].maxidx = tr[cur\u0026lt;\u0026lt;1].maxidx; } if (tr[cur\u0026lt;\u0026lt;1|1].maxval \u0026gt; tr[cur].maxval) { tr[cur].maxval = tr[cur\u0026lt;\u0026lt;1|1].maxval; tr[cur].maxidx = tr[cur\u0026lt;\u0026lt;1|1].maxidx; } } void build(Tree_Node* tr, int cur, int l, int r, int f) { if (l == r) { tr[cur] = {p[l] + f*l, l}; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(tr, cur\u0026lt;\u0026lt;1, l, mid, f); build(tr, cur\u0026lt;\u0026lt;1|1, mid+1, r, f); push_up(tr, cur); } void del(Tree_Node* tr, int cur, int l, int r, int x, int f) { if (l == r) { tr[cur].maxidx = -1; tr[cur].maxval = -1e9; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) del(tr, cur\u0026lt;\u0026lt;1, l, mid, x, f); else del(tr, cur\u0026lt;\u0026lt;1|1, mid+1, r, x, f); push_up(tr, cur); } void Del(int x) { del(tr1, 1, 1, n, x, 1); del(tr2, 1, 1, n, x, -1); } vector\u0026lt;int\u0026gt; tmp; // 用于储存满足条件的index void query(Tree_Node* tr, int cur, int l, int r, int L, int R, int val) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { if (tr[cur].maxval \u0026gt;= val) { tmp.push_back(tr[cur].maxidx); } return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(tr, cur\u0026lt;\u0026lt;1, l, mid, L, R, val); if (R \u0026gt; mid) query(tr, cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val); } // 寻找满足 p[j] + f*j \u0026gt;= val 的 void Query(Tree_Node* tr, int L, int R, int val) { tmp.clear(); L = max(L, 1); R = min(R, n); if (L \u0026lt;= R) query(tr, 1, 1, n, L, R, val); } int dis[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; st \u0026gt;\u0026gt; ed; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i], dis[i] = 1e9; build(tr1, 1, 1, n, 1); build(tr2, 1, 1, n, -1); queue\u0026lt;int\u0026gt; q; q.push(st); dis[st] = 0; Del(st); while (q.size()) { int i = q.front(); q.pop(); bool done = 0; while (!done) { done = 1; Query(tr1, i-p[i], i-1, i); if (tmp.size()) done = 0; for (int j : tmp) { dis[j] = dis[i] + 1; Del(j); q.push(j); } Query(tr2, i+1, i+p[i], -i); if (tmp.size()) done = 0; for (int j : tmp) { dis[j] = dis[i] + 1; Del(j); q.push(j); } } } cout \u0026lt;\u0026lt; dis[ed] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   N. Drone Photo 题意\n在一个 $n \\times n$ 的网格中，每个格子有一个 $\\in [1, n^2]$ 的数字，格子内数字各不相同。\n求有多少个矩形，使得这个矩形的四个角中，最小的两个值所在的位置 不是 对角。（即，最小的两个值如果连一条线在中间，一定是矩形的一条边，而不是对角线）。\n其中，$n \\leq 1500$。\n 题解 我们发现，如果对于一个点 $(i,j)$，只要与它同一行/同一列的值，一个比它大，一个比它小即可，不需要管对角的第四个值。\n这里，考虑的点为 $2$，很容易发现，无论 $x$ 的值为多少，这个矩形一定满足条件。\n我们只需要证明：\n一个矩形满足条件，当且仅当矩形的四个角中存在一个角 $(i,j)$，使得 与它同一行/同一列的角，一个比它大，一个比它小。\n上面我们已经证明了 $\\leftarrow$ 这个方向，接下来证明 $\\rightarrow$。\n假设一个矩形满足条件，但是不存在这样的角 $(i,j)$，那么我们选取最小的那个角，可以画出如下情况：\n可以发现，无论 $x$ 取什么值，要么最小的两个值是对角，要么存在一个角使得同一行列中一个比它大，另外一个比它小。\n所以得证。\n 所以对于每个点 $(i,j)$，设第 $i$ 行有 $A$ 个比它小的数字，第 $j$ 列有 $B$ 个比它小的数字，那么这个点的贡献就是\n$$A * (n-1-B) + B * (n-1-A)$$\n最后答案就是所有贡献之和除以 $2$。\n 我们可以通过 $O(n^2)$ 的复杂度对于所有点 $(i,j)$ 找出对应的 $A,B$（更高的复杂度会T，本题卡常）：\n注意到所有的值位于 $[1, n^2]$ 之间且互不相同，所以不妨直接从 $1$ 枚举到 $n^2$，枚举到值 $x$ 时我们可以知道 $x$ 所在的坐标 $(i,j)$，此时我们知道之前枚举的所有值都小于 $x$，所以可以直接利用两个数组 R[], C[] 来记录第 $i$ 行已经有几个数了，第 $j$ 列有几个数，统计完以后将 R[i]++; C[j]++; 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1505; int n; pii pos[maxn*maxn]; int row[maxn][maxn], col[maxn][maxn]; // 记录row/col 内有多少个比 (i,j) 小。 int R[maxn], C[maxn]; // 记录枚举到x时，row[i] 中有多少个小于 x 的数，col[j] 中有多少个小于 x 的数 int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int a; cin \u0026gt;\u0026gt; a; pos[a] = {i,j}; } } for (int x = 1; x \u0026lt;= n*n; x++) { int i = pos[x].first, j = pos[x].second; row[i][j] = R[i]; col[i][j] = C[j]; R[i]++, C[j]++; } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { ll r = row[i][j], c = col[i][j]; ans += r * (n-1-c) + c * (n-1-r); } } cout \u0026lt;\u0026lt; ans/2 \u0026lt;\u0026lt; endl; }   ","date":"2022-10-10T13:32:05-05:00","permalink":"https://tom0727.github.io/post/076-icpc-2021-swerc/","tags":["",""],"title":"SWERC 2021-2022"},{"categories":["解题报告"],"contents":"M. Yet Another Divisor Problem 题意\n设 $f(n)$ 为正整数 $n$ 的 divisor 个数。\n给定 $a, b$，求有多少个满足以下条件的数 $n$？\n $n$ 是奇数。 $n \\in [a,b]$。 $f(f(n^n))$ 是 $n$ 的 divisor。  其中，$1 \\leq a \\leq b \\leq 10^8$。\n 题解 这题可以用打表解决，直觉上来说满足这个条件的 $n$ 比较少。\n那么先考虑对于一个正整数 $n$，如何求 $f(n)$？\n我们将 $n$ 进行质因数分解得到：\n$$n = p_1^{m_1} p_2^{m_2} p_3^{m_3} \u0026hellip; p_k^{m_k}$$\n那么\n$$f(n) = (m_1+1)(m_2+1)\u0026hellip;(m_k+1)$$\n那么对于较小的 $n$（如 $n \\leq 5 \\times 10^7$）我们可以利用线性筛预处理，然后 $O(\\log n)$ 时间内进行质因数分解，具体怎么做参考 这里。\n对于较大的 $n$ 我们可以利用 Pollard-Rho 在 $O(n^{\\frac{1}{4}})$ 的复杂度内进行质因数分解。\n所以我们的算法就有了：\n 先分解 $n = p_1^{m_1} p_2^{m_2} p_3^{m_3} \u0026hellip; p_k^{m_k}$，然后得到 $f(n) = (m_1+1)(m_2+1)\u0026hellip;(m_k+1)$ 接下来，设 $n' = n(m_1+1) * n(m_2+1) \u0026hellip; * n(m_k+1)$，我们需要知道 $f(n')$，所以对于每项 $n(m_i+1)$ 都质因数分解到同一个 map 里统计质因数。 最后可求得 $f(n') = f(f(n))$。  • 本题，对于 $n \\leq 5 \\times 10^7$ 的情况下的线性筛优化非常重要，速度差距至少在10倍以上。\n最后打表出来的结果只有 $10^4$ 个数左右。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 5e7; struct PollardRho { bool isPrime[M+5]; int small[M+5]; vector\u0026lt;int\u0026gt; primes; void preprocess() { // 线性筛优化 memset(isPrime, 1, sizeof(isPrime)); small[1] = 1; for (int i = 2; i \u0026lt;= M; i++) { if (isPrime[i]) primes.push_back(i), small[i] = i; for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = i * primes[j]; isPrime[cur] = 0; small[cur] = primes[j]; if (i % primes[j] == 0) break; } } } vector\u0026lt;ll\u0026gt; factor; ll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b); } ll quick_pow(ll x, ll p, ll mod) { // 快速幂 ll ans = 1; while (p) { if (p \u0026amp; 1) ans = (__int128_t)ans * x % mod; x = (__int128_t)x * x % mod; p \u0026gt;\u0026gt;= 1; } return ans; } bool Miller_Rabin(ll p) { // 判断素数 if (p \u0026lt; 2) return 0; if (p == 2) return 1; if (p == 3) return 1; ll d = p - 1, r = 0; while (!(d \u0026amp; 1)) ++r, d \u0026gt;\u0026gt;= 1; // 将d处理为奇数 for (ll k = 0; k \u0026lt; 10; ++k) { ll a = rand() % (p - 2) + 2; ll x = quick_pow(a, d, p); if (x == 1 || x == p - 1) continue; for (int i = 0; i \u0026lt; r - 1; ++i) { x = (__int128_t)x * x % p; if (x == p - 1) break; } if (x != p - 1) return 0; } return 1; } ll Pollard_Rho(ll x) { ll s = 0, t = 0; ll c = (ll)rand() % (x - 1) + 1; int step = 0, goal = 1; ll val = 1; for (goal = 1;; goal *= 2, s = t, val = 1) { // 倍增优化 for (step = 1; step \u0026lt;= goal; ++step) { t = ((__int128_t)t * t + c) % x; val = (__int128_t)val * abs(t - s) % x; if ((step % 127) == 0) { ll d = gcd(val, x); if (d \u0026gt; 1) return d; } } ll d = gcd(val, x); if (d \u0026gt; 1) return d; } } void findFac(ll x) { if (x \u0026lt;= M) { while (x \u0026gt; 1) { int sp = small[x]; while (x % sp == 0) x /= sp, factor.push_back(sp); // factor里会有重复质因数，如果不要重复的话把 push_back 放下面即可 } return; } if (Miller_Rabin(x)) { // 如果x为质数 factor.push_back(x); return; } ll p = x; while (p \u0026gt;= x) p = Pollard_Rho(x); // 使用该算法 findFac(x/p), findFac(p); // 继续向下分解x和p } void clear() { factor.clear(); } } PR; map\u0026lt;ll, ll\u0026gt; cnt; map\u0026lt;ll, ll\u0026gt; cnt2; bool check(ll n) { PR.clear(); cnt.clear(); cnt2.clear(); PR.findFac(n); for (ll a : PR.factor) { cnt[a]++; } for (auto\u0026amp; itr : cnt) { PR.clear(); ll c = itr.second * n + 1LL; PR.findFac(c); for (ll a : PR.factor) { cnt2[a]++; } } ll sum = 1; for (auto\u0026amp; itr : cnt2) { sum = sum * (itr.second + 1LL); if (n % sum) return 0; } return n % sum == 0; } int main() { PR.preprocess(); for (ll i = 1; i \u0026lt;= 1e8; i+=2) { if (check(i)) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;, fflush(stdout); } cout \u0026lt;\u0026lt; endl; }   ","date":"2022-10-10T13:30:58-05:00","permalink":"https://tom0727.github.io/post/075-icpc2022maps/","tags":["",""],"title":"MAPS 2022"},{"categories":["解题报告"],"contents":"I. Slow Leak 题意\n$n$ 个节点的带权无向图中有 $m$ 条边，有一个汽车从 $1$ 出发要到 $n$，汽车有油箱，油箱一开始是满的，最多可以装 $d$ 升油。\n每走 $1$ 单位距离就要消耗 $1$ 升油，图中有 $t$ 个节点是加油站，分别为 $a_1,a_2,\u0026hellip;,a_t$。\n求 $1$ 到 $n$ 的最短路径？如果不可能，输出 \u0026ldquo;stuck\u0026rdquo;。\n其中，$n \\in [2, 500], m \\in (0, \\frac{n(n-1)}{2}], t \\in (0, n), d \\in (0, 2^{31})$\n 题解 经典套路题：两次最短路。\n加油站是关键，如果把 $1,n$ 也视作加油站，那么最后求出的路径一定是以加油站作为关键节点，从 $1$ 到 $n$ 的。\n不妨考虑建立一个只有加油站的图，怎么建立呢？\n首先，跑一个 floyd 最短路求出每两点之间的最短距离。\n然后，只保留加油站进行建图，如果两个加油站之间的距离 $\\leq d$，就连一条边。\n再跑一次最短路即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 505; int n, m, t, d; bool gas[maxn]; ll dp[maxn][maxn]; ll dp2[maxn][maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t \u0026gt;\u0026gt; d; for (int i = 1; i \u0026lt;= t; i++) { int x; cin \u0026gt;\u0026gt; x; gas[x] = 1; } gas[1] = 1; gas[n] = 1; memset(dp, -1, sizeof(dp)); for (int i = 1; i \u0026lt;= n; i++) dp[i][i] = 0; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (w \u0026lt;= d) { dp[u][v] = dp[v][u] = w; } } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if ((dp[i][k] \u0026gt;= 0 \u0026amp;\u0026amp; dp[k][j] \u0026gt;= 0)) { if (dp[i][j] \u0026lt; 0) dp[i][j] = dp[i][k] + dp[k][j]; else if (dp[i][k] + dp[k][j] \u0026lt; dp[i][j]) dp[i][j] = dp[i][k] + dp[k][j]; } } } } memset(dp2, -1, sizeof(dp2)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (gas[i] \u0026amp;\u0026amp; gas[j] \u0026amp;\u0026amp; dp[i][j] \u0026lt;= d) { dp2[i][j] = dp[i][j]; } } } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (gas[i] \u0026amp;\u0026amp; gas[j] \u0026amp;\u0026amp; gas[k]) { if ((dp2[i][k] \u0026gt;= 0 \u0026amp;\u0026amp; dp2[k][j] \u0026gt;= 0)) { if (dp2[i][j] \u0026lt; 0) dp2[i][j] = dp2[i][k] + dp2[k][j]; else if (dp2[i][k] + dp2[k][j] \u0026lt; dp2[i][j]) dp2[i][j] = dp2[i][k] + dp2[k][j]; } } } } } if (dp2[1][n] \u0026gt;= 0) cout \u0026lt;\u0026lt; dp2[1][n] \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026quot;stuck\\n\u0026quot;; }   J. Stop Counting! 题意\n给定一个 $n$ 个元素的整数数组 $a_1,\u0026hellip;,a_n$，求：\n$$\\max\\limits_{L \\in [0,n], R \\in [L+1, n]} \\frac{(a_1+a_2+\u0026hellip;a_L) + (a_R + a_{R+1} + a_n)}{L + (n-R+1)}$$\n即：求左边一段加右边一段，使得平均值最大。\n其中，$n \\in [1, 10^6], a_i \\in [-10^9, 10^9]$，要求答案的绝对误差在 $10^{-6}$ 以内或者相对误差在 $10^{-9}$ 以内。\n 题解 经典套路题，看见 最大/最小平均值 就想到 二分答案。\n即二分答案，然后给所有元素减去这个值，判断是否存在左边一段加上右边一段的和 $\\geq 0$ 即可，也就转变成求最小和的 subarray。\n这题主要的坑在于不能用绝对误差，得用相对误差！因为绝对误差在数字较大的时候精度不够！\nlong double low = 0.0, high = 1e9; // 应该用 long double！ while (high - low \u0026gt; 1e-7) { // 这样写是错误的！ double mid = (low + high) * 0.5; if (check(mid)) { low = mid; ans = mid; } else { high = mid; } }  如上是不行的，注意到相对误差的定义是：如果答案为 $x$，相对误差为 $10^{-9}$，意味着答案在 $(x (1-10^{-9}), x (1+10^{-9}))$ 之间。\n所以在答案可能较大时，应该限制二分次数 $T$，如下：\nlong double low = 0.0, high = 1e9; // long double 是正确的 int T = 100; while (high - low \u0026gt; 1e-7 \u0026amp;\u0026amp; T--) { // 当相对误差 \u0026lt;= 1e-7 或者 次数超过 100次就停下来 long double mid = (low + high) * 0.5; if (check(mid)) { low = mid; ans = mid; } else { high = mid; } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n; int a[maxn]; // 是否存在大于0的subarray (左右两边) double sm[maxn]; bool check(double x) { double mn = 0; double res = 1e18; for (int i = 1; i \u0026lt;= n-1; i++) { sm[i] = sm[i-1] - x + (double)a[i]; mn = max(mn, sm[i]); res = min(res, sm[i] - mn); } sm[n] = sm[n-1] - x + (double)a[n]; for (int j = 1; j \u0026lt;= n; j++) { res = min(res, sm[n] - sm[j]); } return sm[n] - res \u0026gt;= 0; } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); long double ans = 0.0; long double low = 0.0, high = 1e9; int T = 100; while (high - low \u0026gt; 1e-7 \u0026amp;\u0026amp; T--) { // 当相对误差 \u0026lt;= 1e-7 或者 次数超过 100次就停下来 long double mid = (low + high) * 0.5; if (check(mid)) { low = mid; ans = mid; } else { high = mid; } } printf(\u0026quot;%.15lf\\n\u0026quot;, ans); }   ","date":"2022-09-26T11:41:02-05:00","permalink":"https://tom0727.github.io/post/074-icpc2019naq/","tags":["",""],"title":"NAQ 2019"},{"categories":["算法"],"contents":"介绍 斜率DP一般用于解决类似于如下的问题：\n$$dp[i] = \\min\\limits_{j\u0026lt;i} \\{ g(j) + f(i, j) + h(i)\\}$$\n• 注意到上述式子中，当我们固定 $i$，仅有的变量为 $j$，需要最小化的是 $g(j) + f(i, j)$。\n我们看一个例子（例1）：\n$$dp[i] - (s_i - L')^2 = \\min\\limits_{j \u0026lt; i} \\{dp[j] + s_j^2 + 2s_j(L' - s_i)\\}$$\n在这个式子中，$L'$ 是一个定值，$s_i$ 代表 $sum[i] + i$，所以对于固定的 $i$，$(s_i - L')^2$ 也是一个定值，所以变量也就只有 $j$，如何快速找到这样的 $j$ 是斜率优化DP要解决的问题。\n 对于这一类问题，我们列出式子 $y=kx+b$，也就是 $b=y-kx$。\n一般来说，变量的意义如下：\n$b$：需要最大化/最小化的项，一般形式为 $dp[i] + h(i)$\n$y$：仅包含 $j$ 的项，一般形式为 $g(j)$\n$kx$：包含 $i,j$ 的项，一般形式为 $f(i,j)$，其中 $x$ 需要单调递增 (如果不是，需要两边同乘 $-1$)，并且一般 $x$ 是 $f(i,j)$ 中代表 $j$ 的部分，$k$ 是 $f(i,j)$ 中代表 $i$ 的部分。\n  假设我们要最小化 $b$ 的值，那么需要直线 $y=kx+b$ 的截距最小。\n那么根据上述式子，我们令\n$$b_i = dp[i] - (s_i - L')^2$$\n$$y_j = dp[j] + s_j^2$$\n$$k_i=-2(L'-s_i)$$\n$$x_j = s_j$$\n转移方程就有\n$$b_i=\\min\\limits_{j\u0026lt;i} \\{ y_j - k_ix_j \\}$$\n如果我们把 $(x_j,y_j)$ 看作二维平面上的点，则 $k_i$ 就是斜率，$b_i$ 代表一条过 $(x_j,y_j)$ 的斜率为 $k_i$ 的直线的截距，那么问题转化为选择合适的点 $j$，最小化截距。\n我们发现，在求 最小值 的情况下，只有那些在这个点集中的 下凸包 上的点，才有可能作为最优的 $j$。\n具体是哪个点呢？\n我们发现，如果将直线 $y=kx+b$ 从下往上移动，第一个碰到的点 $j$ 就是最优决策点。\n 从图中可以发现，这个最优决策点 $j$ 一定满足条件：它是最小的 $j$，使得直线 $(j,j+1)$ 的斜率 $\u0026gt;k$。\n由于下凸包中，$\\forall i \u0026lt; j$，直线 $(i, i+1)$ 的斜率一定小于直线 $(j,j+1)$ 的斜率，所以这样的 $j$ 可以用二分找到。\n 不过这道题更简单，因为 $k_i$ 随着 $i$ 的增加而单调递减，所以用单调队列维护凸包即可。\n最后看下如何用单调队列维护一个点集的下凸包：\n只要在插入一个新的点 $i$ 时，判断是否满足以下条件：\n 插入前，队列里至少有两个元素 $k(q_{r-1}, q_r) \u0026gt; k(q_r, i)$  那么就一直pop队尾，直到上述两个条件之一不满足即可。\n所以在这个单调队列的 头部 所储存的 $j$ 就是对于这个 $i$ 的最佳转移点。\n例题 例1 [HNOI2008]玩具装箱 题意\n给定一个正整数数组 $C_1, C_2, \u0026hellip;, C_n$，我们将其分为若干个连续的段，如果 $C_i, \u0026hellip; C_j$ 被放进了同一段中，那么这一段的长度被定义为 $x=j-i+\\sum\\limits_{k=i}^j C_k$。\n给定一个常数 $L$，每一段的费用为 $(x-L)^2$，求一个最优分段方式，使得费用最小。\n其中，$n \\leq 5 \\times 10^4, 1 \\leq L \\leq 10^7, 1 \\leq C_i \\leq 10^7$。\n 题解 设 $dp[i]$ 为前 $i$ 个元素的最小费用，那么\n$$dp[i] = \\min\\limits_{j \\leq i} \\{dp[j] + (i-j+\\sum\\limits_{k=j}^i C_k-L)^2\\}$$\n调整为 $j \u0026lt; i$ 有\n$$dp[i] = \\min\\limits_{j \u0026lt; i} \\{dp[j] + (i-j+1+\\sum\\limits_{k=j}^i C_k-L)^2\\}$$\n那么设 $s_i = p_i + i$，其中 $p_i$ 为前缀和，$p_i = \\sum\\limits_{j=1}^i C_j$，令 $L' = L+1$，\n化简后可得\n$$dp[i] - (s_i - L')^2 = \\min\\limits_{j \u0026lt; i} \\{dp[j] + s_j^2 + 2s_j(L' - s_i)\\}$$\n接下来解法与上面写的相同。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll dp[maxn]; int n; ll L; ll a[maxn]; int q[maxn\u0026lt;\u0026lt;1], head = 0, tail = -1; ll s[maxn]; inline ll X(int i) { return s[i]; } inline ll Y(int i) { return s[i] * s[i] + dp[i]; } inline double slope(int i, int j) { return (long double)(Y(j) - Y(i)) / (X(j) - X(i)); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], s[i] = s[i-1] + a[i]; for (int i = 1; i \u0026lt;= n; i++) s[i] += i; L++; q[++tail] = 0; for (int i = 1; i \u0026lt;= n; i++) { while (head \u0026lt; tail \u0026amp;\u0026amp; slope(q[head], q[head+1]) \u0026lt; 2 * (s[i] - L)) head++; // 寻找最佳决策点 int j = q[head]; // 最优决策点 dp[i] = dp[j] + (s[i] - L - s[j]) * (s[i] - L - s[j]); while (head \u0026lt; tail \u0026amp;\u0026amp; slope(q[tail], i) \u0026lt; slope(q[tail-1], q[tail])) tail--; q[++tail] = i; } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 CF1715E Long Way Home 题意\n一个包含 $n$ 个点，$m$ 条边的无向图中，每条边有权值 $w_i$。同时我们拥有 $k$ 次使用传送门的机会，从点 $u$ 传送到点 $v$ 会花费 $(u-v)^2$ 的时间。\n求对于所有的点 $i$，从 $1$ 出发，到达点 $i$ 所需要的最短时间。\n其中，$n, m \\leq 10^5, 1 \\leq k \\leq 20, 1 \\leq w_i \\leq 10^9$。\n 题解 看到 $k \\leq 20$ 就想到了 DP或者分层图。\n再看到 $(u-v)^2$ 这个奇怪的平方，就确定了是斜率 DP。\n设 $dp(i, k)$ 代表已经传送了 $k$ 次，到了点 $i$ 所花费的时间。\n那么\n$$dp(i, k) = \\min\\limits_{j \\in [1,n]} \\{dp(j, k-1) + (i-j)^2\\} = \\min\\limits_{j \\in [1,n]} \\{dp(j, k-1) + i^2 + 2ij + j^2\\}$$\n设 $b = dp(i,k) - i^2, x = j, k = 2i, y = dp(j, k-1) + j^2$。\n接下来就是斜率DP的套路了。\n 本题需要特别注意几点：\n  在每次 DP 后，要再跑一次 dijkstra，因为使用一次传送门以后，可能会对最短路有影响（比如某个最短路中间穿插了几次传送），处理方式就是在 Dijkstra 一开始的时候就把所有的点的 dis 更新好，然后全部扔进 pq 里。\n  在斜率 DP 过程中，由于没有 $j\u0026lt;i$ 这个限制条件，所以不再是转移的过程中维护凸包，而是一开始就将凸包建好，然后直接转移。\n   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Edge { int to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } ll dp[maxn][21]; ll dis[maxn]; struct Node { int u; ll d; bool operator\u0026lt;(const Node\u0026amp; other) const { if (d == other.d) return u \u0026lt; other.u; return d \u0026gt; other.d; // 大顶堆 } }; priority_queue\u0026lt;Node\u0026gt; pq; bool vis[maxn]; int n, m; void dijkstra(int k) { memset(vis, 0, sizeof(vis)); memset(dis, 63, sizeof(dis)); for (int i = 1; i \u0026lt;= n; i++) { dis[i] = dp[i][k]; } while (pq.size()) pq.pop(); dis[1] = 0; for (int i = 1; i \u0026lt;= n; i++) { pq.push({i, dis[i]}); // 开始先将所有的点扔进去 } // pq.push({1, 0}); while (pq.size()) { Node nd = pq.top(); pq.pop(); int u = nd.u; if (vis[u]) continue; vis[u] = 1; ll d = nd.d; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; ll w = edges[e].w; if (d + w \u0026lt; dis[v]) { dis[v] = d + w; pq.push({v, dis[v]}); } } } for (int i = 1; i \u0026lt;= n; i++) dp[i][k] = min(dp[i][k], dis[i]); } inline ll X(ll i, int k) { return i; } inline ll Y(ll i, int k) { return dp[i][k-1] + i*i; } inline long double slope(int i, int j, int k) { return ((long double)(Y(j,k) - Y(i,k)) / (X(j,k) - X(i,k))); } int q[maxn\u0026lt;\u0026lt;1], hd = 0, tail = -1; void DP(int k) { hd = 0, tail = -1; // 需要先加所有的转移点，因为 j\u0026lt;i 的限制不成立！ for (ll i = 1; i \u0026lt;= n; i++) { while (hd \u0026lt; tail \u0026amp;\u0026amp; slope(q[tail-1], q[tail], k) \u0026gt; slope(q[tail], i, k)) tail--; q[++tail] = i; } for (ll i = 1; i \u0026lt;= n; i++) { while (hd \u0026lt; tail \u0026amp;\u0026amp; slope(q[hd], q[hd+1], k) \u0026lt;= 2*i) hd++; ll j = q[hd]; // 最佳决策点 dp[i][k] = min(dp[i][k], i*i + dp[j][k-1] + j*j - 2*i*j); } } int k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; memset(dp, 63, sizeof(dp)); for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u, v, w); addEdge(v, u, w); } dijkstra(0); for (int K = 1; K \u0026lt;= k; K++) { DP(K); dijkstra(K); } for (int i = 1; i \u0026lt;= n; i++) { ll ans = 1e18; for (int j = 0; j \u0026lt;= k; j++) ans = min(ans, dp[i][j]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   ","date":"2022-09-21T14:47:44-05:00","permalink":"https://tom0727.github.io/post/073-%E6%96%9C%E7%8E%87dp/","tags":["DP","斜率优化DP"],"title":"斜率优化DP"},{"categories":["解题报告"],"contents":"I. Trip Tik 题意\n给定一个坐标轴，坐标轴上有 $n$ 个点，每个点坐标 $x_i$ 互不相同。每个点 $i$ 都有一个重要性 $w_i$，其中第 $i$ 个点的重要性 $w_i = i$。\n现在有一个视野范围和视野中心，初始情况下视野中心为 $0$，视野范围是 $[-1,1]$。\n在视野中，只能看见前 $k$ 个最重要的点。\n每一步可以进行如下操作之一：\n Zoom Out: 将视野范围扩大 $2$ 倍。 Zoom In: 将视野范围缩小 $2$ 倍。 Change Center: 改变视野中心到一个点 $i$，这个操作要求点 $i$ 必须在之前的视野中可见。  现在对于每一个点，求出从初始情况 $\\rightarrow$ 视野中心在这个点，并且能看见这个点所需要的最少操作次数，如果不可能输出 $-1$。\n其中，$n \\leq 10^5, |x_i| \\leq 10^8, k \\in [1,4]$。\n 题解 BFS，定义一个状态为：$(x,d)$，其中 $x$ 代表当前的视野中心，$d$ 代表视野范围。\n注意这种状态最多只有 $n * log(10^8) \\leq 30n$ 种。\n并且每个状态之间的转移也可以求出来，只要解决 判断一个点是否在当前状态的视野中 问题即可。\n 预处理时，所有的点 sort 一下 二分找到当前状态能看见的点的 index 范围 $[L,R]$。 求 $a[L,R]$ 之间前 $k$ 重要的点。  注意 $k \\leq 4$，这个问题可以直接用线段树来维护（每个 node 维护前 $4$ 重要的点，合并时也很简单）。\n但这样太麻烦了，而且复杂度过高。\n• 注意到 ST表 也可以解决这个问题，合并时同理（注意去重即可）。\n• 最后注意一下视野范围可以最小来到 $[x_i-0.5, x_i+0.5]$。\n最后答案就是从初始状态出发到每个状态的最短路（由于权值均为 $1$ 所以 BFS 找最短路即可）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n; struct Point { int x, w; } arr[maxn]; const int M = 27; int st_id[maxn][M+1]; // state to id struct State { int x, d; // center, dimension }; State st[maxn*(M+1)]; const int MM = 21000000+23300; const int N = 21000000+23300; struct Edge { int to, nxt; } edges[MM]; int head[N], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } queue\u0026lt;int\u0026gt; q; bool vis[N]; int dis[N]; void bfs(int start) { memset(dis, -1, sizeof(dis)); q.push(start); vis[start] = 1; dis[start] = 0; while (q.size()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (!vis[v]) { vis[v] = 1; dis[v] = dis[u] + 1; q.push(v); } } } } bool good[maxn][M+1]; // 如果状态能看见自己，说明是ok的 int ans[maxn]; int bin[maxn]; vector\u0026lt;int\u0026gt; st_table[maxn][18]; vector\u0026lt;int\u0026gt; merge(const vector\u0026lt;int\u0026gt;\u0026amp; vec1, const vector\u0026lt;int\u0026gt;\u0026amp; vec2) { vector\u0026lt;int\u0026gt; res; for (int j : vec1) res.push_back(j); for (int j : vec2) res.push_back(j); sort(res.begin(), res.end(), [\u0026amp;](auto a, auto b) { return arr[a].w \u0026gt; arr[b].w; }); vector\u0026lt;int\u0026gt; tmp; tmp.clear(); if (res.size()) tmp.push_back(res[0]); for (int i = 1; i \u0026lt; res.size(); i++) { if (res[i] != res[i-1] \u0026amp;\u0026amp; tmp.size() \u0026lt;= 3) { tmp.push_back(res[i]); } } return tmp; } vector\u0026lt;int\u0026gt; ask_st(int l, int r) { if (l \u0026gt; r) return {}; int len = r-l+1; int k = bin[len]; vector\u0026lt;int\u0026gt; vec1 = st_table[l][k]; vector\u0026lt;int\u0026gt; vec2 = st_table[r-(1\u0026lt;\u0026lt;k)+1][k]; return merge(vec1, vec2); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) st_table[i][0] = {i}; for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) { st_table[i][k] = merge(st_table[i][k-1], st_table[i+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } } int k; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].x; arr[i].w = i; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.x \u0026lt; b.x; }); int cnt = 0; arr[n+1].x = 0; for (int i = 1; i \u0026lt;= n+1; i++) { for (int j = 0; j \u0026lt;= M; j++) { st_id[i][j] = ++cnt; st[cnt] = {arr[i].x, 1\u0026lt;\u0026lt;j}; } } build_st(); // build(1, 1, n); for (int i = 1; i \u0026lt;= n+1; i++) { for (int j = 0; j \u0026lt;= M; j++) { int id = st_id[i][j]; int x = st[id].x, d = st[id].d; int low = 1, high = i, L = i, R = i; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; if (x - arr[mid].x \u0026lt;= d) { // visible high = mid-1; L = mid; } else { low = mid+1; } } low = i, high = n; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; if (arr[mid].x - x \u0026lt;= d) { low = mid + 1; R = mid; } else high = mid - 1; } if (i == n+1) { L = n, R = 1; for (int t = 1; t \u0026lt;= n; t++) { if (abs(arr[t].x) \u0026lt;= d) { L = min(L, t); R = max(R, t); } } } // 现在找到了 [L,R]，只要找 [L,R] 中前k大的数字即可 vector\u0026lt;int\u0026gt; res = ask_st(L, R); for (int t = 0; t \u0026lt; min((int)res.size(), k); t++) { int idx = res[t]; if (idx \u0026gt; 0) { // must have an important point! int s_id = st_id[idx][j]; if (id != s_id) { addEdge(id, s_id); // 不同的点，同缩放情况 加边 } if (idx == i) { good[i][j] = 1; // 这个状态下可以看见自己 } } } // 缩放之间加边 if (j \u0026gt; 0) addEdge(id, st_id[i][j-1]); if (j \u0026lt; M) addEdge(id, st_id[i][j+1]); } } bfs(st_id[n+1][0]); for (int i = 1; i \u0026lt;= n; i++) { int d = 1e9; for (int j = 0; j \u0026lt;= M; j++) { if (good[i][j]) { int id = st_id[i][j]; if (dis[id] \u0026gt;= 0) { d = min(d, dis[id]); } } } for (int j = 0; j \u0026lt;= M; j++) { int id = st_id[i][j]; if (dis[id] \u0026gt;= 0) { d = min(d, dis[id] + j+1); } } if (d == 1e9) { ans[arr[i].w] = -1; } else ans[arr[i].w] = d; } for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   G. Exciting Tournament 题意\n有 $n$ 个参赛者，每个参赛者 $i$ 有一个skill level $s_i$ 和一个参赛次数限制 $g_i$。\n当两个选手 $i,j$ 比赛时，拥有较大 skill level 的选手会获胜，另外一位会被淘汰，并且总得分会增加 $s_i \\text{ XOR } s_j$。\n每个选手最多只能参赛 $g_i$ 次，并且它最后一次参赛要么被淘汰，要么成为冠军（唯一的留下的选手）。\n求可能的最小总得分和最大总得分。\n其中，$3 \\leq n \\leq 100, s_i \\in [0, 2^{30}), g_i \\in [2, n)$。\n每个选手的 $s_i$ 各不相同。\n 题解 看见 $n \\leq 100$ 并且拥有各种奇怪的限制，就想到网络流/费用流。\n 如何表示一个选手被击败？\n 每个选手视作一个点，并且复制一份，$i+n$ 代表选手 $i$ 被击败的情况。\n 如何表示参赛次数限制？\n 在网络流中，边的最大流量用来表达限制。\n• 最后注意，比赛结束时的冠军一定是拥有最大 $s_i$ 的选手，所以其他选手只能击败 $g_i - 1$ 位选手。\n于是费用流的建图方法如下：\n  对于每个选手 $i$，连边 $(s, i, g_i-1, 0)$，只有最大 $s_i$ 的选手连边 $(s, i, g_i, 0)$。\n  对于每一个pair $(i,j)$，连边 $(i, j+n, 1, s_i \\text{ XOR } s_j)$。\n  对于每个选手 $i$，连边 $(i+n, t, 1, 0)$。\n  跑最大费用流和最小费用流即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 255; const int maxm = 2e5+5; struct Edge { int to, nxt; ll w, c; }; struct MCMF { int n,m,s,t; Edge edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 ll cost = 0; void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll mcmf(bool mincost = true) { ll maxflow = 0; while (spfa(mincost)) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } } flow_min, flow_max; int skill[maxn], g[maxn]; int n, s, t; int main() { cin \u0026gt;\u0026gt; n; s = 201, t = 202; flow_min.s = s; flow_max.s = s; flow_min.t = t, flow_max.t = t; int maxs = 0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; skill[i] \u0026gt;\u0026gt; g[i]; maxs = max(maxs, skill[i]); } for (int i = 1; i \u0026lt;= n; i++) { bool notmax = !(skill[i] == maxs); flow_min.add(s, i, g[i]-notmax, 0); flow_min.add(i+n, t, 1, 0); flow_max.add(s, i, g[i]-notmax, 0); flow_max.add(i+n, t, 1, 0); } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (skill[i] \u0026gt; skill[j]) { flow_min.add(i, j+n, 1, skill[i] ^ skill[j]); flow_max.add(i, j+n, 1, skill[i] ^ skill[j]); } } } flow_min.mcmf(true); flow_max.mcmf(false); cout \u0026lt;\u0026lt; flow_min.cost \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; flow_max.cost \u0026lt;\u0026lt; endl; }   ","date":"2022-09-13T14:05:04-05:00","permalink":"https://tom0727.github.io/post/071-icpc2020mid-central/","tags":["",""],"title":"ICPC2020 Mid Central USA"},{"categories":["算法"],"contents":"介绍 字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。\n一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3\u0026hellip;a_n$ 的哈希值为：\n$$a_1 p^{n-1} + a_2 p^{n-2} + a_3 p^{n-3} + \u0026hellip; + a_n p^0$$\n其中 $a_i$ 为该字符的 ASCII值。\nbuild 方法如下：\nll p[maxn]; int base = 31; const int MOD = 1e9 + 7; void p_init() { p[0] = 1; for (int i = 1; i \u0026lt;= maxn-1; i++) { p[i] = p[i-1] * base % MOD; } }  求一个子串 $s[L,R]$ 的哈希值：只需要维护一个前缀和 $sum$，其中 $sum[R]$ 代表 $s[1\u0026hellip;R]$ 的哈希值。\n$$sum[R] = (a_1 p^{R-1} + a_2 p^{R-2} + \u0026hellip; + a_{L-1} p^{R-L+1}) + (a_{L} p^{R-L} + \u0026hellip; + a_R p^0)$$\n$$sum[L-1] = a_1 p^{L-2} + a_2 p^{L-3} + \u0026hellip; + a_{L-1} p^0$$\n然后就有：\n$$sum[R]-(sum[L] * p^{R-L+1}) = (a_{L} p^{R-L} + \u0026hellip; + a_R p^0) = HASH(s[L\u0026hellip;R])$$\n总结：hash[L...R] = sum[R] - sum[L] * p[R-L+1]\n应用 O(1) 判断回文串 对于原字符串进行一次预处理，反过来再预处理一次，然后判断 $s[L,R]$ 正过来和反过来的哈希值是否相等即可。\n最长回文子串 $O(n)$ 利用 DP：设 $R_i$ 为以 $i$ 结尾的最长回文的长度，那么答案为 $\\max_{i=1}^n R_i$。\n注意到 $R_i \\leq R_{i-1} + 2$，所以每次暴力从 $R_{i-1} + 2$ 开始递减，找到第一个回文串为止。\n复杂度：每次 $i$ 增大时，$R_{i}$ 增加 $2$，每次循环减少 $1$，所以复杂度为 $O(2n)$。\n模版 (取模双哈希) const int maxn = 5e5+5; const int NUM = 2; ll base[2] = {131, 137}; int MOD[2] = {(int)(1e9+7), (int)(1e9+9)}; ll p[maxn][NUM]; void p_init() { for (int j = 0; j \u0026lt; NUM; j++) { p[0][j] = 1; for (int i = 1; i \u0026lt;= maxn-1; i++) { p[i][j] = p[i-1][j] * base[j] % MOD[j]; } } } struct StringHash { ll hs[maxn][NUM]; string s; int n; void init() { n = s.size(); for (int j = 0; j \u0026lt; NUM; j++) { for (int i = 1; i \u0026lt;= n; i++) { hs[i][j] = (hs[i-1][j] * base[j] % MOD[j] + (ll)s[i-1]) % MOD[j]; } } } // get the hash of j-th HASH function int gethash(int l, int r, int j) { return (hs[r][j] - hs[l-1][j] * p[r-l+1][j] % MOD[j] + MOD[j]) % MOD[j]; } array\u0026lt;int, NUM\u0026gt; gethash(int l, int r) { array\u0026lt;int, NUM\u0026gt; res; for (int j = 0; j \u0026lt; NUM; j++) { res[j] = gethash(l, r, j); } return res; } }; int n; string s; StringHash hs, rev_hs; bool isPalindrome(int l, int r) { return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1); } int main() { p_init(); // 先 init 所有p 的次方 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; n = s.size(); hs.s = s; rev_hs.s = s;; reverse(rev_hs.s.begin(), rev_hs.s.end()); hs.init(); rev_hs.init(); isPalindrome(1, n); // 测试 }  模版 (自然溢出哈希) 自然溢出 没有 MOD 操作，依靠 unsigned long long 的 $2^64$ 自然溢出取模，速度快很多。\n不是特别推荐这种方法，无论双哈希或者如何选择 base 都会被卡，卡自然溢出哈希的方法见 这里\n• 注意需要用 ull (unsigned long long)\nconst int maxn = 5e5+5; const int NUM = 1; ull base[2] = {131, 137}; ull p[maxn][NUM]; // 注意这里换成了 ull void p_init() { for (int j = 0; j \u0026lt; NUM; j++) { p[0][j] = 1; for (int i = 1; i \u0026lt;= maxn-1; i++) { p[i][j] = p[i-1][j] * base[j]; } } } struct StringHash { ull hs[maxn][NUM]; string s; int n; void init() { n = s.size(); for (int j = 0; j \u0026lt; NUM; j++) { for (int i = 1; i \u0026lt;= n; i++) { hs[i][j] = hs[i-1][j] * base[j] + s[i-1]; } } } // get the hash of j-th HASH function ull gethash(int l, int r, int j) { return hs[r][j] - hs[l-1][j] * p[r-l+1][j]; } array\u0026lt;ull, NUM\u0026gt; gethash(int l, int r) { array\u0026lt;ull, NUM\u0026gt; res; for (int j = 0; j \u0026lt; NUM; j++) { res[j] = gethash(l, r, j); } return res; } }; int n; string s; StringHash hs, rev_hs; bool isPalindrome(int l, int r) { return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1); } int main() { p_init(); // 先 init 所有p 的次方 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; n = s.size(); hs.s = s; rev_hs.s = s;; reverse(rev_hs.s.begin(), rev_hs.s.end()); hs.init(); rev_hs.init(); isPalindrome(1, n); // 测试 }   例题 例1 CF1721E 题意\n给定一个 string $s$，并且给定 $q$ 次询问，每次询问一个 string $t$，并且进行如下操作：\n 将 $t$ 连在 $s$ 后面。 询问 $|s|+1, |s|+2, \u0026hellip;, |s|+|t|$ 位置的 prefix function 将字符串恢复为 $s$。  定义一个string $a$ 的 prefix function为：$p_1, p_2, \u0026hellip;, p_{|a|}$，其中 $p_i$ 是最大的 $k$ 使得：\n $k \u0026lt; i$ 且 $a[1\u0026hellip;k] = a[i-k+1 \u0026hellip; i]$  即最长的 $k$ 使得前缀等于后缀。\n其中，$|s| \\leq 10^6, q \\leq 10^5, |t| \\leq 10$\n 题解 首先我们可以发现，在 $t$ 连在 $s$ 后面时，我们可以很简单的处理哈希值。\n现在考虑怎么计算 prefix function？\n我们不能用哈希 + 二分，因为它不具有单调性，例如 abab，对于 $k=1$ 不成立，但是 $k=2$ 成立。\n 考虑另外一个方法：\n如果前缀等于后缀，那么它应该是：\n$$s_1 s_2 \u0026hellip; s_k = s_{x} s_{x+1} \u0026hellip; s_n t_1 t_2 \u0026hellip; t_m$$\n注意到我们可以拆成两段：\n$$s_1 s_2 \u0026hellip; s_{k-m} = s_{x} s_{x+1} \u0026hellip; s_n$$\n$$s_{k-m+1} \u0026hellip; s_k = t_1 t_2 \u0026hellip; t_m$$\n前面一段实际上是 $s$ 本身的前缀后缀 matching，可以预处理。\n后面一段是 $t$ 在 $s$ 里面的一个匹配。\n所以问题转变成：\n只要 $t$ 在 $s$ 中有一个匹配 $t = s[i \u0026hellip; i+m-1]$，并且 $s[1\u0026hellip;i-1] = s[n-i \u0026hellip; n]$ 即可。\n就剩下一个问题：如果要将 $t$ 在 $s$ 中匹配很多次，复杂度会爆炸。\n鉴于 $|t| \\leq 10$，我们可以对于每个位置 $i$ 都判断一下是否有前缀等于后缀，如果有，那么提前储存 $s[i\u0026hellip;i], s[i\u0026hellip;i+1] \u0026hellip; s[i\u0026hellip;i+m-1]$ 这些子串的哈希值，然后匹配即可。\n最后注意一些边界情况：在一个位置的prefix function $\u0026gt; |s|$ 时没有考虑到，暴力枚举一下即可。\n• 为了防止 map 爆炸，所以根据子串长度分开几个 map 来储存。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } const int NUM = 2; struct StringHash { int hs[maxn][NUM]; int MOD[NUM] = {(ll)1e9+7, (ll)1e9+9}; int p[NUM] = {131, 137}; int inv[maxn][NUM]; string s; int n; void init() { n = s.size(); for (int j = 0; j \u0026lt; NUM; j++) { int P = 1, invP = qpow(p[j], MOD[j]-2, MOD[j]); inv[0][j] = 1; for (int i = 1; i \u0026lt;= n; i++) { P = (ll)P * p[j] % MOD[j]; inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j]; hs[i][j] = (hs[i-1][j] + (ll)s[i-1] * P % MOD[j]) % MOD[j]; } } } void concat(string t) { int m = t.size(); for (int j = 0; j \u0026lt; NUM; j++) { for (int i = n+1; i \u0026lt;= n+m; i++) inv[i][j] = hs[i][j] = 0; int P = qpow(p[j], n, MOD[j]), invP = qpow(p[j], MOD[j]-2, MOD[j]); for (int i = n+1; i \u0026lt;= n+m; i++) { P = (ll)P * p[j] % MOD[j]; inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j]; hs[i][j] = (hs[i-1][j] + (ll)t[i-n-1] * P % MOD[j]) % MOD[j]; } } } // get the hash of j-th HASH function int gethash(int l, int r, int j) { ll sum = (hs[r][j] - hs[l-1][j] + MOD[j]) % MOD[j]; return sum * inv[l-1][j] % MOD[j]; } array\u0026lt;int, NUM\u0026gt; gethash(int l, int r) { array\u0026lt;int, NUM\u0026gt; res; for (int j = 0; j \u0026lt; NUM; j++) { res[j] = gethash(l, r, j); } return res; } } hs; map\u0026lt;array\u0026lt;int, NUM\u0026gt;, int\u0026gt; mp[11]; int n,m; int main() { cin \u0026gt;\u0026gt; hs.s; hs.init(); n = hs.s.size(); int Q; cin \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= n-1; i++) { if (hs.gethash(1, i) == hs.gethash(n-i+1, n)) { for (int j = 1; j \u0026lt;= 10; j++) { if (i+j \u0026gt; n) break; array\u0026lt;int, NUM\u0026gt; h = hs.gethash(i+1, i+j); mp[j][h] = i; } } } while (Q--) { string t; cin \u0026gt;\u0026gt; t; hs.concat(t); m = t.size(); for (int i = 1; i \u0026lt;= m; i++) { int ans = 0; int r = n+i; for (int j = 1; j \u0026lt;= min(2*m, n+i-1); j++) { if (hs.gethash(1, j) == hs.gethash(r-j+1, r)) ans = j; } auto h = hs.gethash(n+1, n+i); if (mp[i].count(h)) { ans = max(ans, i + mp[i][h]); } for (int j = n+i-1; j \u0026gt;= n; j--) { if (hs.gethash(1, j) == hs.gethash(n+i+1-j, n+i)) { ans = max(ans, j); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 洛谷P4287 [SHOI2011]双倍回文 题意\n如果一个字符串能写成 $ss^{-1}ss^{-1}$ 的形式，那么它是一个双倍回文。\n给定一个字符串，求它的最长双倍回文子串长度。\n其中，$n \\leq 5 \\times 10^5$。\n 回文串性质\n首先明确一个性质：\n 对于一个长度为 $n$ 的字符串 $s$，它的本质不同的回文子串数量最多只有 $n$ 个。\n 证明：利用归纳。\n对于 $n=1$ 显然成立，设对于 $n-1$ 都成立，那么当长度为 $n$ 时：\n设 $s = tc$，其中 $t$ 为长度为 $(n-1)$ 的字符串，$c$ 是新加的字符，根据假设 $t$ 符合上述规则。\n考虑以 $c$ 结尾的回文子串，假设它们的左端点从小到大排序为 $l_1, l_2, \u0026hellip;, l_k$，则我们可以知道仅有 $s[l_1 \u0026hellip; n]$ 可能为新增的回文串，因为对于任何 $l_j, j \u0026gt; 2$，$s[l_j \u0026hellip; n] = s[l_1 \u0026hellip; n + l_1 - l_j]$ 一定出现过了。\n• 也就是说，在每次新增一个字符时，只用考虑以它为结尾的最长回文子串即可。\n 题解 首先我们知道，一个双倍回文子串一定是一个回文子串，所以它也遵循如上性质。\n既然本质不同的回文子串数量只有 $n$ 个，那我们只要每一个都check一下是否符合双倍回文即可。\n那么按照 $O(n)$ 的最长回文子串的做法，就是考虑了所有不同的回文子串。\n 如何在 $O(1)$ 时间内判断一个字符串是否为回文串/双倍回文串？\n把原字符串 $s$ 反过来，复制一份为 $t$，然后在 $t$ 上再预处理一次hashing即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = 5e5+5; const int maxm = 3e5+50; int qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } const int NUM = 2; struct StringHash { int hs[maxn][NUM]; int MOD[NUM] = {(ll)1e9+7, (ll)1e9+9}; int p[NUM] = {131, 137}; int inv[maxn][NUM]; string s; int n; void init() { n = s.size(); for (int j = 0; j \u0026lt; NUM; j++) { int P = 1, invP = qpow(p[j], MOD[j]-2, MOD[j]); inv[0][j] = 1; for (int i = 1; i \u0026lt;= n; i++) { P = (ll)P * p[j] % MOD[j]; inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j]; hs[i][j] = (hs[i-1][j] + (ll)s[i-1] * P % MOD[j]) % MOD[j]; } } } // get the hash of j-th HASH function int gethash(int l, int r, int j) { ll sum = (hs[r][j] - hs[l-1][j] + MOD[j]) % MOD[j]; return sum * inv[l-1][j] % MOD[j]; } array\u0026lt;int, NUM\u0026gt; gethash(int l, int r) { array\u0026lt;int, NUM\u0026gt; res; for (int j = 0; j \u0026lt; NUM; j++) { res[j] = gethash(l, r, j); } return res; } } hs, hs2; int n; int dp[maxn]; // 以 i 结尾的回文串长度 bool isPalindrome(int l, int r) { return hs.gethash(l, r) == hs2.gethash(n-r+1, n-l+1); } bool check(int l, int r) { int len = r-l+1; if (len % 4) return 0; if (!isPalindrome(l,r)) return 0; if (!isPalindrome(r-len/2+1, r)) return 0; return 1; } int main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; hs.s; hs.init(); hs2.s = hs.s; reverse(hs2.s.begin(), hs2.s.end()); hs2.init(); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int len = min(i, dp[i-1]+2); len \u0026gt;= 1; len--) { if (check(i-len+1, i)) ans = max(ans, len); if (isPalindrome(i-len+1, i)) { dp[i] = len; break; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 ICPC2018南京M Mediocre String Problem 题意\n给定两个string $s,t$，求满足以下条件的三元组 $(i,j,k)$ 的数量：\n $1 \\leq i \\leq j \\leq |s|$ $1 \\leq k \\leq |t|$ $j-i+1 \u0026gt; k$ $s[i\u0026hellip;j] + t[1\u0026hellip;k]$ 是一个回文串。  其中 $s \\in [2, 10^6], t \\in [1, |s|)$\n 题解 我们看第四条：如果 $s[i\u0026hellip;j] + t[1\u0026hellip;k]$ 是一个回文串，因为第三条规定了 $s[i\u0026hellip;j]$ 是比 $t[1\u0026hellip;k]$ 长的，所以我们可以把 $s[i\u0026hellip;j]$ 分成两个部分：\n$s[i\u0026hellip;i+k-1]$ 和 $s[i+k\u0026hellip;j]$，其中：\n $s[i\u0026hellip;i+k-1]$ 反过来和 $t[1\u0026hellip;k]$ 完全一样。 $s[i+k\u0026hellip;j]$ 是一个回文串。  并且假如我们固定 $i+k-1$ 这个位置，并且让 $i$ 逐渐增大，$k$ 随之减小，那么 $(i,j,k)$ 仍然是一个回文串。\n我们需要知道：以 $i+k-1$ 开头的回文串有多少个？这个值乘上 $k$ 就是固定了这个 $i+k-1$ 的值对答案的贡献了。\n 考虑如下问题：以 $i$ 开头的回文串有几个？\n一般对于这种问题，我们需要考虑固定一个点来哈希+二分，这里固定开头或者结尾是不行的，那固定对称中心呢？是可行的。\n所以我们枚举对称中心，然后利用哈希+二分求出最长的回文半径，用差分数组进行区间加即可。\n• 注意枚举奇数和偶数两种情况。\n 有了上述信息，我们只要枚举 $i+k-1$ 的值，然后将 $t$ 先反转过来得到 $t_r$，那么每次要找的就是\n$s[1\u0026hellip;i+k-1]$ 与 $t_r[1\u0026hellip;|t|]$ 的最长后缀，同样用哈希+二分即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; ull base = 131; ull p[maxn]; void p_init() { p[0] = 1; for (int i = 1; i \u0026lt;= maxn-1; i++) { p[i] = p[i-1] * base; } } struct StringHash { ull hs[maxn]; string s; int n; void init() { n = s.size(); for (int i = 1; i \u0026lt;= n; i++) { hs[i] = hs[i-1] * base + s[i-1]; } } ull gethash(int l, int r) { return hs[r] - hs[l-1] * p[r-l+1]; } }; int n,m; int st[maxn]; // st[i]: the number of palindromes index starts with i (in s) string s,t; StringHash hs, rev_hs, rev_ht; bool isPalindrome(int l, int r) { return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1); } void init_st() { // 枚举奇数长度的回文串 for (int mid = 1; mid \u0026lt;= n; mid++) { int l = 0, r = min(mid-1, n-mid); int res = 0; while (l \u0026lt;= r) { int c = (l+r) \u0026gt;\u0026gt; 1; int L = mid-c, R = mid+c; if (isPalindrome(L, R)) { res = c; l = c + 1; } else r = c - 1; } st[mid-res]++; st[mid+1]--; } // 偶数长度的回文串 for (int mid = 1; mid \u0026lt; n; mid++) { if (s[mid-1] != s[mid]) continue; // 这里特判一下 int l = 0, r = min(mid-1, n-mid-1); int res = 0; while (l \u0026lt;= r) { int c = (l+r) \u0026gt;\u0026gt; 1; int L = mid-c, R = mid+1+c; if (isPalindrome(L, R)) { res = c; l = c + 1; } else r = c - 1; } st[mid-res]++; st[mid+1]--; } for (int i = 1; i \u0026lt;= n; i++) st[i] = st[i] + st[i-1]; } int main() { p_init(); cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; n = s.size(), m = t.size(); hs.s = s; rev_hs.s = s; rev_ht.s = t; reverse(rev_hs.s.begin(), rev_hs.s.end()); reverse(rev_ht.s.begin(), rev_ht.s.end()); hs.init(); rev_hs.init(); rev_ht.init(); init_st(); // init the start array ll ans = 0; for (int x = 1; x \u0026lt;= n-1; x++) { // 匹配 s[1...x] 与 rev_t[] 的最长后缀 int l = 1, r = min(x, m); int res = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (hs.gethash(x-mid+1, x) == rev_ht.gethash(m-mid+1, m)) { res = mid; l = mid + 1; } else r = mid - 1; } ans += (ll)st[x+1] * (ll)res; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 Atcoder ABC135F. Strings of Eternity 题意\n给定两个string $s,t$，求一个最大的 $i$，使得存在一个 $j \\geq 0$，使得 $t$ 的 $i$ 个copy是 $s$ 的 $j$ 个copy的一个substring。\n如果这个 $i$ 可能是无穷大，输出 $-1$。\n 题解 思路巧妙的图论题。\n我们先考虑 $i=1$ 的情况，这说明 $t$ 从 $s$ 的一个后缀开始，经过 $s$ 的一些copy，然后到 $s$ 的某一个前缀结束。\n所以可以看作是从 $s$ 的一个index $u$ 到了另外一个index $v$。\n于是我们连边 $(u,v+1)$。\n那么 $i \u0026gt; 1$ 的情况就可以递推得到：也就是顺着这些边走 $i$ 次。\n所以如果最后图中有环，就是 $-1$，没有环的话，只要看在图中最深能走多远即可。\n• 我们用字符串哈希来 $O(1)$ 找出每一个 $u$ 出发，能走到哪个 $v$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; StringHash hs, ht; vector\u0026lt;int\u0026gt; adj[maxn]; int dp[maxn], vis[maxn]; bool ok = 1; int ID = 0; void dfs(int u, int p) { dp[u] = 0; vis[u] = ID; for (int v : adj[u]) { if (dp[v] != -1 \u0026amp;\u0026amp; vis[v] == ID) { ok = 0; return; } dfs(v, p); dp[u] = dp[v] + 1; } } int main() { p_init(); string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = s.size(), m = t.size(); while (s.size() \u0026lt; 1e6) s += s; hs.s = s; ht.s = t; hs.init(); ht.init(); for (int i = 1; i \u0026lt;= n; i++) { if (hs.gethash(i, i+m-1) == ht.gethash(1, m)) { int R = i + m; // [1...n], [n+1...2n] R %= n; if (!R) R = n; adj[i].push_back(R); } } memset(dp, -1, sizeof(dp)); memset(vis, -1, sizeof(vis)); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { if (dp[i] == -1) { dfs(i, ++ID); ans = max(ans, dp[i]); } } if (ok) cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; }   ","date":"2022-08-28T23:23:53-05:00","permalink":"https://tom0727.github.io/post/070-%E5%AD%97%E7%AC%A6%E4%B8%B2hash/","tags":["字符串","Hash"],"title":"字符串Hash"},{"categories":null,"contents":"","date":"2022-05-27T12:43:51+08:00","permalink":"https://tom0727.github.io/ys-calculator/","tags":null,"title":"原神圣遗物计算器"},{"categories":["解题报告"],"contents":"A. Accelerator 题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，它们总共有 $n!$ 种 permutation。\n对于每一种 permutation $a_{k_1},a_{k_2},\u0026hellip;,a_{k_n}$，我们有一个初始值 $v=0$。\n从左向右遍历这个 permutation，每遍到一个数 $a_{k_i}$，就令 $v = (v+1) * a_{k_i}$。\n求所有 permutation 中，最终的 $v$ 的期望值？\n其中，$n \\leq 10^5, a_i \\in [1, 10^9]$。\n 题解 期望的分母我们知道是 $n!$，我们只要求分子即可。\n我们先看一种简单的例子：\n$n=3$ 的情况下，假设一种 permutation 是 $a_1,a_3,a_2$，那么最终的答案 $v$ 就等于：\n$$v=(((v+1)*a_1+1)*a_3+1)*a_2=a_1a_2a_3+a_2a_3+a_2$$\n很容易发现规律，$v$ 由 $n$ 个数的和组成，每个数都是 $k = \\{1,2,\u0026hellip;n\\}$ 个 $a_i$ 的乘积。\n我们设 $b_i$ 为 $i$ 个 $a$ 的乘积组成的项的和。\n例如，$n=3$ 时，\n$$b_3=a_1a_2a_3$$ $$b_2=a_1a_2+a_1a_3+a_2a_3$$ $$b_1=a_1+a_2+a_3$$\n又因为全排列总共有 $n!$ 个，而对于每一个全排列，其中的每一项，都恰好会出现 $1$ 次（比如上面例子中，对于全排列 $a_1,a_3,a_2$，出现的项就是 $a_1a_2a_3,a_2a_3,a_2$）。\n所以对于 $b_i$，它总共出现了 $\\frac{n!}{C_n^i}$ 次。\n所以分子的值就是：\n$$\\sum\\limits_{i=1}^n \\frac{n!}{C_n^i}b_i$$\n现在我们只要求出所有的 $b_i$ 即可。\n 我们注意到 $b_i$ 是 乘起来，然后加起来 的形式，于是我们想到 生成函数。\n定义\n$$f(x)=(1+a_1x)(1+a_2x)\u0026hellip;(1+a_nx)$$\n我们会发现 $x^i$ 的系数就是所求的 $b_i$。\n 最后注意到这是 $n$ 个 deg = 1 的多项式相乘。\n然而，两个 deg 分别为 $n,m$ 的多项式相乘，令 $d=\\max(n,m)$，则复杂度是 $O(d\\log d)$ 的。\n所以我们不能直接把这些多项式乘一块，我们应该分治着相乘，即 solve(L, R) = solve(L, mid) * solve(mid+1, R)。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = 1e5+5; Z fac[maxn], inv_fac[maxn]; Z C(int n, int m) { return fac[n] * inv_fac[n-m] * inv_fac[m]; } Z invC(int n, int m) { return inv_fac[n] * fac[n-m] * fac[m]; } int n; Poly solve(int l, int r) { if (l == r) { int x; cin \u0026gt;\u0026gt; x; Poly f(2); f[0] = 1; f[1] = x; return f; } int mid = (l+r) \u0026gt;\u0026gt; 1; Poly f = solve(l, mid); return f * solve(mid+1, r); } int main() { int T; cin \u0026gt;\u0026gt; T; fac[0] = inv_fac[0] = 1; for (int i = 1; i \u0026lt;= 1e5; i++) fac[i] = fac[i-1] * i; inv_fac[100000] = fac[100000].inv(); for (int i = 99999; i \u0026gt;= 1; i--) inv_fac[i] = inv_fac[i+1] * (i+1); while (T--) { cin \u0026gt;\u0026gt; n; Poly f = solve(1, n); Z res = 0; for (int i = 1; i \u0026lt;= n; i++) { res = res + (Z(f[i].v) * invC(n, i)); } cout \u0026lt;\u0026lt; res.val() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2022-01-30T23:43:21+08:00","permalink":"https://tom0727.github.io/post/069-icpc2020%E6%BE%B3%E9%97%A8/","tags":["",""],"title":"ICPC2020澳门"},{"categories":["算法"],"contents":"介绍 一维差分可以用于解决以下问题：\n给定一系列的区间加/减操作，最后询问整个数组的元素。\n那么二维差分就可以解决：\n给定一系列的矩阵加/减操作，最后询问整个矩阵中的元素。\n二维差分原理 我们知道，二维前缀和的计算方式是：\n$$sum[x][y] = sum[x-1][y] + sum[x][y-1] - sum[x-1][y-1]$$\n所以我们思考，对于差分数组 $d[x][y]$，如果我们要给一个矩阵\n$$[x_1,y_1][x_2,y_2]$$\n全部加 $1$，即左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的矩阵全部加 $1$，应该怎么处理？\n注意到如果我们进行二维前缀和的话，修改一个差分数组 $d[x][y]$ 影响到的是 $(x,y)$ 右下方的所有元素的值。\n我们想要的是 紫色部分 全部加 $1$。\n那么如果我们让 $d[x_1][y_1]$ 加 $1$，那么影响到的是所有的 紫色加红色 部分。\n于是，我们可以通过让 $d[x_1][y_2+1]$ 和 $d[x_2+1][y_1]$ 全部减去 $1$ 来消除红色部分。\n然而 绿色部分 被减去了两次，所以我们再给 $d[x_2+1][y_2+1]$ 加上 $1$。\n在所有的操作结束后，使用 二维前缀和 的方式来获得矩阵值即可。\nvoid update(ll arr[][maxn], int xl, int xr, int yl, int yr, ll val) { arr[xl][yl] += val; arr[xr+1][yr+1] += val; arr[xl][yr+1] -= val; arr[xr+1][yl] -= val; }  例题 例1 2018ICPC焦作J题 Carpets Removal 题意\n给定 $m\\times m$ 的一个矩阵，并且给定 $n$ 个地毯（每个地毯是一个矩形）。\n我们需要移除 恰好两个地毯，使得 没有被地毯覆盖到的格子数量 最大。\n输出这个最大值。\n其中，$3 \\leq n \\leq 3 \\times 10^5, 1 \\leq m \\leq 1500$。\n 题解 首先，我们可以利用二维差分，求出每个格子的覆盖次数。\n我们知道，如果一个格子被覆盖的次数 $\\geq 3$，那么可以直接忽略。\n所以我们只考虑覆盖次数为 $1$ 或者 $2$ 的格子。\n我们分开讨论。\n 对于覆盖次数为 $1$ 的格子，我们可以把它们单独拿出来，在一个全部为 $0$ 的矩阵中，然后把这些 $1$ 放进去。\n这样我们可以得出每个地毯所覆盖的 $1$ 的数量。\n我们设第 $i$ 个地毯覆盖的 $1$ 的数量为 $a_i$。\n 对于覆盖次数为 $2$ 的格子，假设覆盖它的地毯分别为 $i,j$，那么我们设 $b_{ij}$ 为地毯 $i,j$ 共同覆盖的，覆盖次数为 $2$ 的格子数量。\n所以最后的最大值就是\n$$\\max\\limits_{(i,j)}\\{a_i+a_j+b_{ij}\\}$$\n $a_i$ 我们可以求出，但是 $b_{ij}$ 呢？\n假设我们知道对于每个覆盖次数为 $2$ 的格子，覆盖它的两个地毯 index 为 $i,j$，那么这个 $b_{ij}$ 就可以求出。\n我们利用 二维差分 来记录这样的信息！\n除了我们维护的 cnt[][] 来代表覆盖次数以外，我们再额外维护两个信息：\n sum[][]：如果 $(i,j)$ 被地毯 $x$ 覆盖，那么它的值会被加上 $x$。 sum2[][]：如果 $(i,j)$ 被地毯 $x$ 覆盖，那么它的值会被加上 $x^2$。  对于 cnt[i][j] == 1 的格子，我们只要看一下 sum[i][j]，就可以知道它是被哪个地毯覆盖的了。\n对于 cnt[i][j] == 2 的格子，我们可以知道它被两个地毯 $x,y$ 所覆盖，并且我们知道 $(x+y)$ 与 $(x^2+y^2)$ 的值。\n那么我们只要利用 $$2(x^2+y^2) - (x+y)^2 = x^2 + y^2 - 2xy = (x-y)^2$$\n就可以求出 $|x-y|$ 的值，那么用 $\\frac{(x+y) \\pm |x-y|}{2}$ 即可求出 $x,y$。\n 最后要注意，有可能有 $b_{ij} = 0$，所以我们还需要让答案再考虑一下\n$$\\max\\limits_{(i,j)}\\{a_i+a_j\\}$$\n这个只要在 $a_i$ 中找到前 $2$ 大的加起来就可以了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1515; const int maxm = 3e5+50; ll n,m; ll cnt[maxn][maxn]; ll sum1[maxn][maxn], sum2[maxn][maxn]; void update(ll arr[][maxn], int xl, int xr, int yl, int yr, ll val) { arr[xl][yl] += val; arr[xr+1][yr+1] += val; arr[xl][yr+1] -= val; arr[xr+1][yl] -= val; } ll one[maxm]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (ll i = 1; i \u0026lt;= n; i++) { int xl,xr,yl,yr; cin \u0026gt;\u0026gt; xl \u0026gt;\u0026gt; xr \u0026gt;\u0026gt; yl \u0026gt;\u0026gt; yr; update(cnt, xl, xr, yl, yr, 1); update(sum1, xl, xr, yl, yr, i); update(sum2, xl, xr, yl, yr, i*i); } map\u0026lt;pii,int\u0026gt; mp; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= m; j++) { cnt[i][j] += cnt[i][j-1] + cnt[i-1][j] - cnt[i-1][j-1]; sum1[i][j] += sum1[i][j-1] + sum1[i-1][j] - sum1[i-1][j-1]; sum2[i][j] += sum2[i][j-1] + sum2[i-1][j] - sum2[i-1][j-1]; if (cnt[i][j] == 1) { ll x = sum1[i][j]; one[x]++; } else if (cnt[i][j] == 2) { ll d = sqrt(2LL * sum2[i][j] - sum1[i][j] * sum1[i][j]); // d = abs(x-y) ll x = (sum1[i][j] + d) / 2, y = (sum1[i][j] - d) / 2; if (x \u0026gt; y) swap(x, y); mp[{x,y}]++; } } } ll ans = 0; for (auto p : mp) { int x = p.first.first, y = p.first.second; ll a = p.second; ans = max(ans, one[x] + one[y] + a); } ll m1 = 0, m2 = 0; for (int i = 1; i \u0026lt;= n; i++) { m1 = max(m1, one[i]); if (m1 \u0026gt; m2) { swap(m1, m2); } } ans = max(ans, m1 + m2); ans = -ans; LOG(ans); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= m; j++) { ans += (cnt[i][j] \u0026gt; 0); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i = 0; i \u0026lt;= m+2; i++) { for (int j = 0; j \u0026lt;= m+2; j++) { cnt[i][j] = sum1[i][j] = sum2[i][j] = 0; } } fill(one, one+n+2, 0); } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { solve(); } }   参考链接  https://www.cnblogs.com/LMCC1108/p/10753451.html  ","date":"2022-01-24T12:14:30+08:00","permalink":"https://tom0727.github.io/post/068-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/","tags":["差分",""],"title":"二维差分"},{"categories":["算法"],"contents":"介绍 树套树常常用于解决一些二维数点问题。\n经典的问题如：矩阵内查询和/最大值，更新矩阵内一个点的值等等。\n在介绍树套树之前，先简单讲一下树状数组。\n树状数组介绍 树状数组 树状数组的本质就是一个数组 tr[]。\n其中 tr[x] 维护的是区间 [x-lowbit(x)+1, x] 的信息（即：以 x 为结尾，长度为 lowbit(x) 的区间）。\n那么如果我们要询问 $[1,x]$ 的信息，那么可以利用 不断减去 lowbit(x) 的形式实现。\n如果我们需要更新点 $x$ 的值，那么需要 不断加上 lowbit(x) 来保证所有包含了 $x$ 的区间都被更新了。\n 我们以 区间查询和，单点加值 为例：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; inline int lowbit(int x) { return x \u0026amp; -x; } int tr[maxn]; int n, m; void update(int p, int val) { while (p \u0026lt;= n) { tr[p] += val; p += lowbit(p); } } // return sum[1...p] int query(int p) { int ans = 0; while (p \u0026gt; 0) { ans += tr[p]; p -= lowbit(p); } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; update(i, x); } while (m--) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) update(x, y); else cout \u0026lt;\u0026lt; query(y) - query(x-1) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  • 注意一点，树状数组本质上维护的是 前缀信息，所以如果要询问区间信息，需要保证这个信息是 可减的。\n比如 区间最大值 就不能用树状数组了（但是 前缀最大值 仍然可以用）。\n 树套树 所谓树套树，实际上就是将一个数据结构看作是两层线段树。\n比如维护二维的矩阵信息，那么这个数据结构的外层线段树维护的是 $x$ 坐标，而内层线段树维护的则是 $y$ 坐标。\n对于内层线段树来说，它和普通的一维线段树没有区别：每个节点维护的是一个区间，区间包含的是一些数字。\n对于外层线段树：每个节点维护的是一个区间，区间包含的是一些内层线段树。\n简单来说，相当于我们在每个 $x$ 坐标上，都开了一棵内层线段树。\n而我们用外层线段树，维护了 $x$ 坐标的区间。\n因此，我们在进行 矩阵查询/修改 时（例如 $[x_L,x_R][y_L,y_R]$），就分成了两步：\n 首先在外层线段树找到 $x$ 坐标所在的区间 $[x_L,x_R]$，它在外层线段树上对应的就是若干个节点。 进入这些节点（进入了以后就可以看到内层线段树了），然后对内层线段树进行 $[y_L,y_R]$ 的操作。  标记永久化 如果是 矩阵查询，单点修改 的话我们可以直接用树套树解决。\n但是如果是 矩阵查询，矩阵修改 呢？\n我们还是按照访问树套树的方式，但看起来我们需要对于 $[x_L,x_{L+1},\u0026hellip;,x_R]$ 中的每一棵线段树都进行修改操作？\n因为我们无法对外层线段树进行 pushup 或者 pushdown 操作，因为它维护的是线段树，而不是数值。\n那么我们就引入了标记永久化的思想，什么意思呢？\n简单来说，标记永久化就是 去除了 pushdown 操作，对于那些被修改操作完全覆盖的区间，直接给它打上一个标记。\n之后，在询问的时候，当我们访问了一个节点时，我们就看一下这个节点上的标记，这时，标记的值就相当于 这个节点 之前被修改了，但是尚未下传 的信息。\n所以询问时：\n  无论这个节点是否完全被我们的询问覆盖，我们都要把这个节点的标记，加入到我们的询问答案。\n  如果这个节点完全被覆盖，则我们直接考虑这个节点所维护的值即可，无需考虑标记了。\n   那么，在树套树的实现中，一般是通过 开两棵树套树：\n一棵树套树，专门用来维护 原来的值。\n另一棵树套树，专门用来维护 标记值。\n 然后在询问的时候，按照上面的两条规则进行操作，对内外两层线段树，写法基本一致。\n例题 例1 洛谷P3287 [SCOI2014]方伯伯的玉米田 题意\n给定 $n$ 个正整数 $a_i$，并且给定一个正整数 $K$。\n每次操作我们可以选定一个区间 $[L,R]$，将 $[a_L \u0026hellip; a_R]$ 内的所有值 + 1，操作最多进行 $K$ 次。\n求操作后，最长不下降子序列（不一定连续）的长度？\n其中，$n \\in [1, 10000], K \\in [1, 500], a_i \\in [1,5000]$。\n 题解 首先，每次操作一个区间的话，右端点一定为 $n$（因为右边数字越大，LIS就有可能越长，所以让右边更大一些一定更好）。\n然后就有了一个比较简单的 dp 思路：\n设 dp[i][j] 代表：当前考虑前 $i$ 个元素，已经用掉了 $j$ 次操作，恰好以 $i$ 为结尾的最长 LIS 的长度。\n然后我们不需要讨论当前用了多少个，我们直接用前面所有可能的状态进行转移：\n$$dp[i][j] = \\max\\sum\\limits_{i' \\in [1,i-1], j' \\in [0,j]} \\{dp[i'][j'] + 1\\}, ~ 其中 a[i] + j \\geq a[i'] + j'。$$\n总共有 $3$ 个条件（维度），这个东西怎么优化？\n首先，如果我们将 $i$ 从小到大枚举，那么 $i$ 这一维可以直接忽略掉。\n所以我们就剩下了 $a[i] + j$ 和 $j$ 这两个维度。\n那么我们可以将 $a[i] + j$ 的值看作 $x$ 坐标，$j$ 的值看作 $y$ 坐标，那么转移方程就是：\n$$dp[a[i]+j][j] = \\max\\sum\\limits_{x \\in [1,a[i] + j], y \\in [0,j]} \\{dp[x][y] + 1\\}$$\n那么这个东西本质上就是一个矩阵查询最大值，支持单点修改的结构。\n$x$ 坐标的取值范围是 $[1,5500]$，$y$ 坐标的取值范围是 $[0,500]$。\n二维线段树？不对，空间复杂度 $5500 * 501 * \\log (5500) * \\log(501)$ 约等于 1e9。\n二维树状数组？空间复杂度刚好是 $5500 * 501$，可以过。\n注意到，虽然我们维护的是最大值，但这实际上是一个 前缀最大值 的形式，所以可以用树状数组。\n最后注意一下把 $y$ 变成 $[1,501]$ 即可。\n 二维树状数组代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int N = 5500, M = 501; int tr[N+5][M+5]; inline int lowbit(int x) { return x\u0026amp;-x; } void update(int x, int y, int val) { int tmp = y; while (x \u0026lt;= N) { y = tmp;\twhile (y \u0026lt;= M) { tr[x][y] = max(tr[x][y], val); y += lowbit(y); } x += lowbit(x); } } // 查询 [1...x][1...y] int query(int x, int y) { int tmp = y; int ans = 0; while (x \u0026gt; 0) { y = tmp; while (y \u0026gt; 0) { ans = max(ans, tr[x][y]); y -= lowbit(y); } x -= lowbit(x); } return ans; } int n, K; int a[maxn]; int ans = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = K; j \u0026gt;= 0; j--) { int v = a[i] + j; int res = query(v, j+1); ans = max(ans, res + 1); update(v, j+1, res + 1); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   二维线段树代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int N = 5500, M = 500; // x:[1, 5500], y: [0, 500] struct Node { int maxval, lc, rc; int rt; // 这个节点所维护的线段树的根 } tr[2e9]; // 开不了这么大的！ int rt = 0, ID = 0; void insert_y(int\u0026amp; cur, int l, int r, int y, int val) { if (!cur) cur = ++ID; tr[cur].maxval = max(tr[cur].maxval, val); if (l == r) return; int mid = (l+r) \u0026gt;\u0026gt; 1; if (y \u0026lt;= mid) insert_y(tr[cur].lc, l, mid, y, val); if (y \u0026gt; mid) insert_y(tr[cur].rc, mid+1, r, y, val); } void insert_x(int\u0026amp; cur, int l, int r, int x, int y, int val) { if (!cur) cur = ++ID; tr[cur].maxval = max(tr[cur].maxval, val); insert_y(tr[cur].rt, 0, M, y, val); // 从根节点开始 if (l == r) return; int mid = (l+r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) insert_x(tr[cur].lc, l, mid, x, y, val); if (x \u0026gt; mid) insert_x(tr[cur].rc, mid+1, r, x, y, val); } // change the value of (x,y) to val void insert(int x, int y, int val) { insert_x(rt, 1, N, x, y, val); } int query_y(int cur, int l, int r, int yl, int yr) { if (!cur) return 0; int res = 0; if (yl \u0026lt;= l \u0026amp;\u0026amp; yr \u0026gt;= r) return tr[cur].maxval; int mid = (l+r) \u0026gt;\u0026gt; 1; if (yl \u0026lt;= mid) res = max(res, query_y(tr[cur].lc, l, mid, yl, yr)); if (yr \u0026gt; mid) res = max(res, query_y(tr[cur].rc, mid+1, r, yl, yr)); return res; } int query_x(int cur, int l, int r, int xl, int xr, int yl, int yr) { if (!cur) return 0; int res = 0; if (xl \u0026lt;= l \u0026amp;\u0026amp; xr \u0026gt;= r) { return query_y(tr[cur].rt, 0, M, yl, yr); } int mid = (l+r) \u0026gt;\u0026gt; 1; if (xl \u0026lt;= mid) res = max(res, query_x(tr[cur].lc, l, mid, xl, xr, yl, yr)); if (xr \u0026gt; mid) res = max(res, query_x(tr[cur].rc, mid+1, r, xl, xr, yl, yr)); return res; } int query(int xl, int xr, int yl, int yr) { return query_x(rt, 1, N, xl, xr, yl, yr); } int n, K; int a[maxn]; int ans = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = K; j \u0026gt;= 0; j--) { int v = a[i] + j; int res = query(1, v, 0, j); ans = max(ans, res + 1); insert(v, j, res + 1); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P3437 [POI2006]TET-Tetris 3D 题意\n给定一个 $N \\times M$ 的矩阵，有 $q$ 个询问，每次询问一个子矩阵内的最大值，并且将这个矩阵加上某个值。\n求所有操作后，整个矩阵内的最大值？\n其中，$q \\leq 20000, N,M \\leq 1000$。\n 题解 直接二维线段树维护即可，都不需要动态开点。这题是一个很好的板子。\n对于最大值，我们注意到一个特性：只要一个矩阵中的任意一个元素被更新了，那么整个矩阵的最大值都要被更新。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; const int maxm = 30; // 矩阵查询最大值 // 矩阵修改（加上值） const int N = 1000; struct Node { int maxval; int lazy; // 永久化标记（只打在内层线段树上） }; struct SegY { Node tr[maxn\u0026lt;\u0026lt;2]; void update(int cur, int l, int r, int L, int R, int val) { tr[cur].maxval = max(tr[cur].maxval, val); // 如果 [l,r] 与 [L,R] 有交集直接更改 if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].lazy = max(tr[cur].lazy, val); // 完全覆盖时，记录懒标记 return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, val); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val); } int query(int cur, int l, int r, int L, int R) { int ans = 0; ans = max(ans, tr[cur].lazy); // 懒标记值记录 if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { ans = max(ans, tr[cur].maxval); // 正常查询 return ans; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) ans = max(ans, query(cur\u0026lt;\u0026lt;1, l, mid, L, R)); if (R \u0026gt; mid) ans = max(ans, query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R)); return ans; } }; struct SegX { SegY mx[maxn\u0026lt;\u0026lt;2], tag[maxn\u0026lt;\u0026lt;2]; void update(int cur, int l, int r, int xl, int xr, int yl, int yr, int val) { mx[cur].update(1, 1, N, yl, yr, val); // 有交集就更新 if (xl \u0026lt;= l \u0026amp;\u0026amp; xr \u0026gt;= r) { tag[cur].update(1, 1, N, yl, yr, val); // 让被完全覆盖的这些线段树都更新一下 tag return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (xl \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, xl, xr, yl, yr, val); if (xr \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, xl, xr, yl, yr, val); } int query(int cur, int l, int r, int xl, int xr, int yl, int yr) { int ans = 0; ans = max(ans, tag[cur].query(1, 1, N, yl, yr)); // 懒标记下传 if (xl \u0026lt;= l \u0026amp;\u0026amp; xr \u0026gt;= r) { ans = max(ans, mx[cur].query(1, 1, N, yl, yr)); return ans; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (xl \u0026lt;= mid) ans = max(ans, query(cur\u0026lt;\u0026lt;1, l, mid, xl, xr, yl, yr)); if (xr \u0026gt; mid) ans = max(ans, query(cur\u0026lt;\u0026lt;1|1, mid+1, r, xl, xr, yl, yr)); return ans; } } tr; int D, S, q; // assign val to [xl,xr][yl,yr] void update(int xl, int xr, int yl, int yr, int val) { tr.update(1, 1, N, xl, xr, yl, yr, val); } // query maximum value between [xl,xr][yl,yr] int query(int xl, int xr, int yl, int yr) { return tr.query(1, 1, N, xl, xr, yl, yr); } int main() { cin \u0026gt;\u0026gt; D \u0026gt;\u0026gt; S \u0026gt;\u0026gt; q; while (q--) { int n, m, h, x, y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; h \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x++, y++; n--, m--; int res = query(x, x+n, y, y+m); update(x, x+n, y, y+m, res + h); } cout \u0026lt;\u0026lt; query(1, N, 1, N) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例3 洛谷P3688 [ZJOI2017] 树状数组 题意\n现在有道题：\n给定长度为 $n$ 的数组 $A$，初始值为 $0$，接下来进行 $m$ 次操作，每次操作有两种：\n$1 ~ x$：将 $A_x$ 变成 $(A_x+1) \\text{ mod } 2$\n$2 ~ l ~ r$：询问 $\\sum\\limits_{i=l}^r A_i \\text{ mod } 2$\n九条可怜用树状数组解决这个问题，然而很可惜，她把树状数组的修改和前缀和询问操作的方向写反了，她写了如下程序：\n 现在，我们需要回答以下问题：\n进行 $m$ 次操作，每次操作有两种：\n$1 ~ l ~ r$：每次在区间 $[l,r]$ 内等概率选取一个 $x$，并且执行 $Add(x)$ （这里是指执行九条可怜写的错误程序）。\n$2 ~ l ~ r$：询问 $Query(l,r)$ 得到正确结果的概率。\n将答案输出为 $\\frac{p}{q}$ 的形式，模 $998244353$。\n其中，$n,m \\leq 10^5$。\n 题解 如果我们熟悉树状数组的原理的话，就知道它正确的情况下，每次修改/询问维护的是前缀和。\n那么现在这个错误的树状数组把两个方向都反过来了，那维护的就是后缀和了。\n于是每次 $Query(l,r)$ 其实返回的是 suf[r] - suf[l-1] 的值。\n当然注意到这个是在 $\\text{mod } 2$ 下的，所以正负号没有区别。\n所以 suf[r] - suf[l-1] = suf[l-1] - suf[r] $= \\sum\\limits_{i=l-1}^{r-1} A_i$\n而正确的答案应该是 $\\sum\\limits_{i=l}^r A_i$，所以两者差的就是一个 $A_{l-1} + A_{r}$。\n于是，原问题可以转化为：\n$1 ~ l ~ r$ 仍然是等概率修改。\n$2 ~ l ~ r$ 询问 $A_{l-1} = A_r$ 的概率。\n 怎么解决呢？一维线段树？每次修改给一个区间乘上一个概率？\n似乎不行，因为这个题的修改操作是 $[l,r]$ 内有且仅有一个元素被修改，而一维线段树维护的概率包含了多个元素同时被修改的可能性。\n 一个神仙想法：二维线段树\n我们将一个二元组 $(x,y)$ 定义为：$A_x, A_y$ 相等的概率。\n所以每次修改 $[l,r]$，我们设 $p = \\frac{1}{r-l+1}$，都会影响到三种这样的二元组：\n $x \\in [l,r], y \\in [l,r]$：那么 $(x,y)$ 有 $2*p$ 的概率被取反。 $x \\in [l,r], y \\not\\in [l,r]$：那么 $(x,y)$ 有 $p$ 的概率被取反。 $x \\not\\in [l,r], y \\in [l,r]$：那么 $(x,y)$ 有 $p$ 的概率被取反。  这实际上就是矩阵修改操作了。\n那么对于每次询问，就只要询问 $(l-1,r)$ 这个点的概率即可。\n 那么这样的概率应该怎么维护？\n我们给每个 node 都打上一个标记 $a$，代表 $x,y$ 相等的概率。\n那么现在，设有 $b$ 的概率让 $x,y$ 继续保持相等。\n那么 $x,y$ 在操作后，保持相等的概率就等于\n$$ab + (1-a)(1-b)$$\n所以我们定义一个特殊的乘法运算方式 $*$，其中\n$$a*b = ab + (1-a)(1-b)$$\n所以每次更新的时候，如果有 $p$ 的概率取反，那么就给所有对应的矩阵都 $*(1-p)$。\n• 这个就用标记永久化进行维护即可。\n• 因为 $n \\leq 10^5$，所以必须动态开点，外层不用动态开，在外层维护一个 rt[maxn\u0026lt;\u0026lt;2] 即可，内层需要动态开点，这样总复杂度是 $O(n\\log^2n)$ 的。\n 最后，我们注意到，当询问操作的 $l=1$ 时，这个错误程序返回的实际上是 $$suf[r] = \\sum\\limits_{i=r}^n A_i$$\n而正确的答案是 $$pre[r] = \\sum\\limits_{i=1}^r A_i$$\n所以询问的就是 $r$ 的前缀和与后缀和相等的概率。\n这个可以直接用一维线段树维护，其中 $p_x$ 就代表 $x$ 的前缀和与后缀和相等的概率。\n我们直接把这个一维线段树，维护在 $[0,0][y_1,y_2]$ 这个矩阵上，这样就不用特殊处理了。\n每次修改 $[l,r]$ 时，前后缀和关系受到影响的位置有三种情况：\n $x \\in [0, l-1]$：前缀和不变，后缀和一定变化，所以有 $1$ 的概率取反。 $x \\in [r+1, n]$：前缀和一定变化，后缀和不变，所以有 $1$ 的概率取反。 $x \\in [l,r]$：只有修改位置恰好在 $x$ 时，前后缀和的关系才不变，否则一定变化，所以有 $(1-\\frac{1}{r-l+1})$ 的概率取反。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int N = 1e5; template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } }; inline Z mul(Z a, Z b) { return (1-a) * (1-b) + a*b; } struct Node { Z p = 1; // 相同的概率 int lc, rc; }; int ID = 0; struct SegY { Node tr[maxn*400]; // 内层是动态开点的 void update(int\u0026amp; cur, int l, int r, int L, int R, Z val) { if (!cur) cur = ++ID; if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].p = mul(tr[cur].p, val); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(tr[cur].lc, l, mid, L, R, val); if (R \u0026gt; mid) update(tr[cur].rc, mid+1, r, L, R, val); } Z query(int cur, int l, int r, int x) { if (!cur) return 1; if (l == r) return tr[cur].p; int mid = (l+r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) return mul(tr[cur].p, query(tr[cur].lc, l, mid, x));; return mul(tr[cur].p, query(tr[cur].rc, mid+1, r, x)); } } tag; struct SegX { int rt[maxn\u0026lt;\u0026lt;2]; // 外层无需动态开点 void update(int cur, int l, int r, int xl, int xr, int yl, int yr, Z val) { if (xl \u0026lt;= l \u0026amp;\u0026amp; xr \u0026gt;= r) { tag.update(rt[cur], 0, N, yl, yr, val); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (xl \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, xl, xr, yl, yr, val); if (xr \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, xl, xr, yl, yr, val); } Z query(int cur, int l, int r, int x, int y) { Z d = tag.query(rt[cur], 0, N, y); if (l == r) { return d; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) return mul(d, query(cur\u0026lt;\u0026lt;1, l, mid, x, y)); return mul(d, query(cur\u0026lt;\u0026lt;1|1, mid+1, r, x, y)); } } tr; int n,m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--) { int op, l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 1) { Z p = Z(1) / Z(r-l+1); // 修改二维情况，因为有规定 l \u0026lt;= r，所以更新矩阵的时候也遵循这个规定。 tr.update(1, 0, N, l, r, l, r, 1-2*p); if (l \u0026gt; 1) tr.update(1, 0, N, 1, l-1, l, r, 1-p); if (r \u0026lt; n) tr.update(1, 0, N, l, r, r+1, N, 1-p); // 修改一维情况的前后缀和 tr.update(1, 0, N, 0, 0, 0, l-1, 0); // [0,l-1] 的前后缀和一定更改 tr.update(1, 0, N, 0, 0, r+1, N, 0); // 一定会修改 [r+1,N] 的前后缀和一定更改 tr.update(1, 0, N, 0, 0, l, r, p); // 只有修改这个位置时，才不会改变前后缀和的区别，否则都会改 } else { Z res = tr.query(1, 0, N, l-1, r); cout \u0026lt;\u0026lt; res.val() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   参考链接  https://www.cnblogs.com/Mychael/p/9049136.html https://www.cnblogs.com/wozaixuexi/p/9462461.html  ","date":"2022-01-20T18:30:51+08:00","permalink":"https://tom0727.github.io/post/067-%E6%A0%91%E5%A5%97%E6%A0%91/","tags":["树套树","线段树","树状数组"],"title":"树套树"},{"categories":["算法"],"contents":"本文主要记录一些组合数学的常用模型。\n组合数 $C(n,m)$  $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \\frac{n!}{k!(n-k)!}$ $\\sum\\limits_{i=l}^r C_i^m = C_{r+1}^{m+1}-C_{l}^{m+1}$  • 注：$0! = 1, (0!)^{-1} = 1$\n证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素：\n 如果它被选中，有 $C_{n-1}^{k-1}$ 种。 如果它没有被选中，有 $C_{n-1}^k$ 种。   证明公式4 这个对应杨辉三角中的一列。\n$C_{l}^{m+1} + \\sum\\limits_{i=l}^r C_i^m = (C_l^{m+1} + C_l^m) + \\sum\\limits_{i=l+1}^r = C_{l+1}^{m+1} + \\sum\\limits_{i=l+1}^r C_i^m = C_{l+2}^{m+1} + \\sum\\limits_{i=l+2}^r C_i^m = \u0026hellip; = C_{r+1}^{m+1}$\n 杨辉三角 --  -- 第 $i$ 行，第 $j$ 列的数就是 $C_{i-1}^{j-1}$。这个杨辉三角也可以用于证明二项式定理和组合数的一些性质。\n二项式定理 $$(a+b)^n = \\sum\\limits_{k=0}^n C_n^ka^kb^{n-k}$$\n卡特兰数 (Catalan) 通项公式：\n  $H_n = 1 ~ (n=0,1)$\n  $H_n = \\frac{C_{2n}^n}{n+1}~(n \\geq 2)$\n  $H_n = C_{2n}^n - C_{2n}^{n-1}$\n  递推式：\n  $H_n = \\sum\\limits_{i=0}^{n-1}H_{i}H_{n-i-1} = H_0H_{n-1} + H_1H_{n-2} + \u0026hellip; + H_{n-1}H_0$\n  $H_n = \\frac{(4n-2)}{n+1} H_{n-1}$\n  第二类斯特林数 $S(n,m)$ 代表将 $n$ 个不同的小球，放进 $m$ 个相同，非空盒子的方案数\n通项公式：\n$$S(n,m) = \\sum\\limits_{i=0}^m (-1)^{m-i}\\frac{i^n}{i!(m-i)!}$$\n递推式：\n$$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$$\n证明 考虑第一个小球，有两种情况：\n 独占一个盒子：相当于，其他 $n-1$ 个小球要放进 $m-1$ 个盒子中，且盒子不为空，所以为 $S(n-1,m-1)$ 不独占一个盒子：相当于，先将其他 $n-1$ 个小球放进 $m$ 个盒子中，且盒子不为空，然后从 $m$ 个盒子中选一个，把当前小球放进去，所以为 $m*S(n-1,m)$   经典例题 例1 男女生排列问题 题意\n三个女生和五个男生站成一排。\n  如果女生必须全排在一起，有多少种排法？\n  如果女生不能相邻，有多少种排法？\n  如果两端都不排女生，有多少种排法？\n  如果两端不都排女生，有多少种排法？\n   第一题答案 将3个女生看作1个，所以就有 $A_6^6$ 种。对于女生内部的排列有 $A_3^3$ 种。所以总共为 $A_6^6A_3^3$ 种。\n 第二题答案 先排男生，有 $A_5^5$ 种，然后将女生插入6个空位中，有 $A_6^3$ 种。所以总共为 $A_5^5A_6^3$ 种。\n 第三题答案 先排好两个男生在两边，有 $A_5^2$ 种，两个男生中间的人就可以随便排了，就有 $A_6^6$ 种。所以总共为 $A_5^2A_6^6$ 种。\n也可以这么想，让女生在中间的6个位置先选好3个，有 $A_6^3$ 种，剩下的男生随便排，有 $A_5^5$ 种。所以总共为 $A_6^3A_5^5$ 种，答案和上面一样。\n 第四题答案 所有排列情况有 $A_8^8$ 种，如果两边都排女生，有 $A_3^2A_6^6$ 种。所以总共为 $A_8^8 - A_3^2A_6^6$ 种。\n 例2 小球放盒子问题 假设有 $n$ 个小球，$m$ 个盒子，要将小球放进这些盒子中，每个小球都必须放入其中一个盒子中。\n小球无区别-盒子无区别-不允许空盒 略（还没遇到）\n 小球无区别-盒子无区别-允许空盒 略（还没遇到）\n 小球无区别-盒子有区别-不允许空盒 使用隔板法，在 $n$ 个小球中间放置 $m-1$ 块挡板，将小球分为不为空的 $m$ 部分。小球之间的空位有 $n-1$ 个。所以答案为\n$$C_{n-1}^{m-1}$$\n 小球无区别-盒子有区别-允许空盒 先多加 $m$ 个小球，转化为 不允许空盒 的问题后，再把多加的 $m$ 个小球拿出来即可。所以答案为\n$$C_{n+m-1}^{m-1}$$\n 小球有区别-盒子无区别-不允许空盒 答案就是第二类斯特林数 $S(n,m)$，递推式如上：\n$$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$$\n 小球有区别-盒子无区别-允许空盒 在 不允许空盒 的基础上，枚举一下 空盒的个数。所以答案为\n$$\\sum\\limits_{i=1}^{\\min(n,m)}S(n,i)$$\n 小球有区别-盒子有区别-不允许空盒 在 盒子无区别 的基础上，乘上盒子的排列 $m!$ 即可，所以答案为：\n$$S(n,m) * m!$$\n 小球有区别-盒子有区别-允许空盒 每个小球可以随便选，互不影响，所以答案为：\n$$n^m$$\n 例3 整数解问题 题意\n$$a_1+a_2+\u0026hellip;+a_m = n$$\n的解的个数，由此可以得出一系列的例题，如下：\n $\\forall i \\in [1,m], a_i \u0026gt; 0$ 这就是小球放盒子问题，盒子不为空的情况，用隔板法即可得到答案为在 $n$ 个小球之间放置 $m-1$ 个隔板，等于：\n$$C_{n-1}^{m-1}$$\n $\\forall i \\in [1,m], a_i \\geq 0$ 我们直接转化成：\n$$a_1'+a_2'+\u0026hellip;+a_m' = n+m, ~~ \\forall i \\in [1,m], a_i' \u0026gt; 0$$\n其中 $a_i' = a_i + 1$。\n所以就可以套上面那种情况了，答案为：\n$$C_{n+m-1}^{m-1}$$\n 求 $a_1\u0026#43;a_2\u0026#43;...\u0026#43;a_m \u0026lt; n$，其中 $\\forall i \\in [1,m], a_i \u0026gt; 0$ 我们直接添加一个额外的正整数元素 $a_{m+1}$，问题转化为：\n求\n$$a_1+a_2+\u0026hellip;+a_m+a_{m+1} = n, ~~\\forall i \\in [1,m+1], a_i \u0026gt; 0$$\n又转化成了第一种情况，答案为：\n$$C_{n-1}^m$$\n $\\forall i \\in [1,m], a_i \\geq 0$，且 $x_1 \u0026gt; 3, x_2 \\in [4,8]$ 我们往最基础的模型（第一种，第二种）情况上面转，也就是尽可能让 $x_i \\geq 0$ 或者 $x_i \u0026gt; 0$ 对于所有 $i$ 都成立。\n首先因为 $x_2 \\in [4,8]$，所以我们如果令 $x_2 \\geq 3$，只要减去 $x_2 \\geq 9$ 的情况即可。\n所以现在，我们先求出 $x_1 \u0026gt; 3, x_2 \\geq 3$ 的情况即可。\n由于 $x_1 \u0026gt; 3$，我们有 $x_1 \\geq 4$，那么我们令 $x_1' = x_1 - 4, x_2' = x_2 - 3$，那么就可以得到 $x_1' \\geq 0, x_2' \\geq 0$。\n所以我们只要求出：\n$$a_1'+a_2'+\u0026hellip;+a_m = n - 4 - 3 = n-7$$\n其中每一项都 $\\geq 0$ 即可。\n所以方案数就是：$C_{n-7+m-1}^{m-1}$。\n 同理我们可以求出 $x_1 \u0026gt; 3, x_2 \\geq 9$ 的情况，即为：\n$$a_1'+a_2'+\u0026hellip;+a_m = n - 4 - 9 = n-13$$\n所以方案数就是：$C_{n-13+m-1}^{m-1}$。\n 两者相减，得到最终答案：\n$$C_{n-7+m-1}^{m-1} - C_{n-13+m-1}^{m-1}$$\n 例4 错排问题 题意\n有 $1,2,3,\u0026hellip;,n$ 这些数字，重新排序使得不存在任何一个数字的位置和原来相同，有多少种方法？\n 答案 $$D_n = (n-1)(D_{n-1} + D_{n-2})$$\n其中 $D_1 = 0, D_2 = 1$。\n证明：初始情况下如图：\n在图中，上下两行对应的元素需要错开。我们设这种情况下，排序的方法有 $f(n)$ 种。\n对于元素 $1$，我们可以选择除 $1$ 以外的任何一个元素，所以有 $n-1$ 种。\n假设我们选了 $1 \\rightarrow 2$，就会变成下图：\n那么，再看元素 $2$：\n  如果 $2 \\rightarrow 1$，那么就会变成下图，即 $f(n-2)$ 种。   如果 $2 \\rightarrow 3 ~ or ~ 4 ~ or ~ \u0026hellip; ~ n$，就相当于 $2$ 和 $1$ 必须错开，那就相当于下图，即 $f(n-1)$ 种。\n  所以最终就可以得到 $f(n) = (n-1)(f(n-1) + f(n-2))$\n 例题 例1 CCPC威海2021 M题 810975 题意\n求 $n$ 场比赛中，胜利 $m$ 场，最长连胜恰好为 $k$ 场的方案数？答案对 $998244353$ 取模。\n其中，$n,m,k \\in [0,10^5]$。\n 题解 首先让我们求最长连胜恰好为 $k$ 连胜的方案数，那么我们就转化成求 最长连胜 $\\leq k$ 连胜的方案数，然后减去 $\\leq (k-1)$ 的部分即可。\n现在问题变成：\n求 $n$ 场比赛中，胜利 $m$ 场，最长连胜 $\\leq k$ 场的方案数？\n 那么我们往小球放盒子模型 / 整数解模型 上面转化，我们把一段连胜看作是一个数字，那么因为有 $(n-m)$ 个败场，每一段连胜就相当于插在这些败场的两侧。\n所以就相当于有 $(n-m+1)$ 个盒子，我们把这些一段一段的胜场往盒子里面放。\n也就是求：\n$$a_1+a_2+\u0026hellip;+a_{n-m+1} = m,~~ a_i \\in [0,k]$$\n的解数量。\n为了方便，我们直接令 $n = n-m+1$，然后问题变成：\n $$a_1+a_2+\u0026hellip;+a_{n} = m,~~ a_i \\in [0,k]$$\n的解数量。\n这个不是 $\\geq 0$ 或者 $\u0026gt; 0$ 的形式，所以我们只能容斥来求。\n首先我们有：\n$$|\\cap_{i=1}^n a_i \\in [0,k]| = |a_i \\geq 0| - |\\cup_{i=1}^n a_i \u0026gt; k|$$\n简单说就是 无限制 减去 至少有一个 $\u0026gt;k$ 的情况。\n那么怎么求第二项，至少有一个 $\u0026gt;k$ 的情况？\n由容斥原理我们可以得到：\n$$|\\cup_{i=1}^n a_i \u0026gt; k| = \\sum\\limits_{i=1}^n |a_i \u0026gt; k| - \\sum\\limits_{i\u0026lt;j,i,j\\in [1,n]} |a_i \u0026gt; k \\cap a_j \u0026gt; k| + \u0026hellip; - \u0026hellip; $$\n那么对于右手边的第 $j$ 项，就相当于：\n  对于 $sum$ 符号，相当于：我们首先从 $n$ 项里面选择 $j$ 项出来，使得它们 $\u0026gt;k$，所以共有 $C_{n}^j$ 种选法（每一种选法，得到的方案数都一样，所以可以替代 sum）。\n  那么对于已经确定的 $j$ 个 $\u0026gt;k$ 的数，相当于 $\\geq k+1$，所以我们把这些数先减去 $(k+1)$，剩下的就没有限制了（均为 $\\geq 0$），就等同于 $$a_1'+a_2'+\u0026hellip;+a_j'+a_{j+1}+\u0026hellip;+a_n = m-j(k+1)$$\n其中每一项 $\\geq 0$ 的方案数，那也就是 $C_{n+m-j(k+1)-1}^{n-1}$\n  另外如果 $j$ 是偶数，就是加号，否则为减号，所以右手边的第 $j$ 项等于：\n$$(-1)^j * C_n^j * C_{n+m-j(k+1)-1}^{n-1}$$\n • 最后提一下，这个：\n$$a_1+a_2+\u0026hellip;+a_{n-m+1} = m,~~ a_i \\in [0,k]$$\n也可以用生成函数做，相当于 $f(x) = 1+x+x^2+\u0026hellip;+x^k$，求 $f(x)^{n-m+1}$ 的第 $m$ 项系数，多项式快速幂即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; ll f[maxn]; ll fac[maxn], inv_fac[maxn]; // C(a,b) = a! / b! / (a-b)! ll C(ll a, ll b) { if (b \u0026lt; 0 || a \u0026lt; b) return 0; return fac[a] * inv_fac[b] % mod * inv_fac[a-b] % mod; } ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) { res = res * a % mod; } a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } // 计算最大连续 \u0026lt;= k 的情况数 ll cal(ll n, ll m, ll k) { if (k \u0026gt; m || m \u0026gt; n) return 0; if (k == 0) return (m == 0); // n-m+1 个空里面 插 m 个球，限制为 [0,k] // a_1 + a_2 + ... a_{n-m+1} = m, a_i in [0,k] n = n - m + 1; // a_1 + a_2 + ... a_{n} = m, a_i in [0,k] ll ans = 0; for (ll j = 0; j \u0026lt;= n; j++) { ll res = C(n,p) * C(n+m-j*(k+1)-1, n-1); if (p \u0026amp; 1) ans = (ans - res + mod) % mod; else ans = (ans + res) % mod; } return ans; } ll n,m,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; if (n-m+1 \u0026lt;= 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } fac[0] = inv_fac[0] = 1; for (ll i = 1; i \u0026lt;= maxn-2; i++) { fac[i] = fac[i-1] * i % mod; } inv_fac[maxn-2] = qpow(fac[maxn-2], mod-2); for (ll i = maxn-3; i \u0026gt;= 1; i--) { inv_fac[i] = inv_fac[i+1] * (i+1) % mod; } cout \u0026lt;\u0026lt; (cal(n,m,k) - cal(n,m,k-1) + mod) % mod \u0026lt;\u0026lt; endl; }   例2 Atcoder ABC235G Gardens 题意\n给定 $a$ 个苹果种子，$b$ 个香蕉种子，$c$ 个樱桃种子，同类型的种子之间没有区别。\n有 $n$ 个花园（花园之间是有区别的），我们要满足以下条件：\n 每个花园至少种下一个种子。 对于每个花园，每一类的种子最多只能有一个。 不一定需要使用完所有种子。  求所有方案数？答案对 $998244353$ 取模。\n其中，$1 \\leq n \\leq 5 \\times 10^6, a,b,c \\in [0,n]$。\n 题解 先膜jiangly的神仙讲解。\n对于容斥的问题，一种常见的套路是 先去掉一个条件。\n我们如果去掉第一个条件的话，我们会发现每一类的种子其实是独立的！\n所以我们考虑苹果种子，我们可以枚举使用种子的数量 $i$，$i$ 的取值范围是 $i \\in [0, \\min \\{n,a\\}]$。\n如果我们用了 $i$ 个苹果种子，那么方案数就有 $C_n^i$ 种。\n那么对于苹果种子来说，总方案数就是：\n$$\\sum\\limits_{i=0}^{\\min \\{n,a\\}} C_n^i$$\n有两种情况：\n 如果 $a \\geq n$，总方案数就是 $\\sum\\limits_{i=0}^{n} C_n^i = 2^n$。 如果 $a \u0026lt; n$，总方案数就是 $\\sum\\limits_{i=0}^{a} C_n^i$。  其他两类种子一样，乘起来即可。\n 现在我们需要考虑上第一种条件了。\n这个容斥跟上一题很像，因为这个 每个花园至少种一个种子 实际上就是 花园 $i$ 种子数 $\\geq 1$ 的并集（从 $1$ 并到 $n$），所以方案数是\n无限制 - 一个为空 + 两个为空 - 三个为空 ……\n 写成数学表达式就是：\n$$\\sum\\limits_{j=0}^n \\{(-1)^j * C_n^j * (\\sum\\limits_{i=0}^{\\min \\{n,a\\}} C_n^i) * (\\sum\\limits_{i=0}^{\\min \\{n,b\\}} C_n^i) * (\\sum\\limits_{i=0}^{\\min \\{n,c\\}} C_n^i)\\}$$\n这里 $j$ 代表有多少个花园是空的。$C_n^j$ 就是 $n$ 个中选择 $j$ 个花园作为空花园。\n 不过还剩下一个问题，这看起来是个 $O(n^2)$ 的做法，我们需要快速计算\n$$\\sum\\limits_{i=0}^{\\min \\{n,a\\}} C_n^i$$\n因为我们只需要考虑 $a \u0026lt; n$ 的情况，所以只要计算：\n$$\\sum\\limits_{i=0}^{a} C_n^i$$\n根据组合数的性质：\n$$C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$$\n那么上式就可以化简为：\n$$\\sum\\limits_{i=0}^{a} C_n^i = \\sum\\limits_{i=0}^{a} (C_{n-1}^{i-1} + C_{n-1}^i) = \\sum\\limits_{i=0}^{a-1}C_{n-1}^i + \\sum\\limits_{i=0}^{a} C_{n-1}^i = 2 * \\sum\\limits_{i=0}^{a} C_{n-1}^i - C_{n-1}^a$$\n所以我们只要算出 $\\sum\\limits_{i=0}^{a} C_{n-1}^i$，我们可以在 $O(1)$ 时间内算出 $\\sum\\limits_{i=0}^{a} C_{n}^i$。\n所以 $j$ 从 $n$ 往 $0$ 枚举即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e6+5; template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } }; Z fac[maxn], inv_fac[maxn], P[maxn], pre[3]; Z C(int n, int m) { return fac[n] * inv_fac[n-m] * inv_fac[m]; } int n, a, b, c; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; fac[0] = inv_fac[0] = P[0] = 1; for (int i = 1; i \u0026lt;= n; i++) fac[i] = fac[i-1] * i, P[i] = P[i-1] * 2; inv_fac[n] = qpow(fac[n], mod-2); for (int i = n-1; i \u0026gt;= 1; i--) inv_fac[i] = inv_fac[i+1] * (i+1); Z ans = 0; for (int j = n; j \u0026gt;= 0; j--) { int flag = (j \u0026amp; 1) ? -1 : 1; Z res = flag; res *= C(n, j); Z asum = (a \u0026gt;= n-j) ? (P[n-j]) : (pre[0] * 2 - C(n-j-1, a)); Z bsum = (b \u0026gt;= n-j) ? (P[n-j]) : (pre[1] * 2 - C(n-j-1, b)); Z csum = (c \u0026gt;= n-j) ? (P[n-j]) : (pre[2] * 2 - C(n-j-1, c)); res *= asum * bsum * csum; pre[0] = asum, pre[1] = bsum, pre[2] = csum; ans += res; } cout \u0026lt;\u0026lt; ans.val() \u0026lt;\u0026lt; endl; }   ","date":"2022-01-15T21:52:47+08:00","permalink":"https://tom0727.github.io/post/066-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["数学",""],"title":"组合数学"},{"categories":["算法"],"contents":"拉格朗日插值 给定 $n$ 个点，我们可以确定唯一的最高 degree 为 $(n-1)$ 的多项式。\n设多项式为 $f(x)$，第 $i$ 个点的坐标为 $(x_i,y_i)$，那么这个多项式在 $k$ 处的取值为：\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\prod\\limits_{i\\neq j} \\frac{k-x_j}{x_i-x_j}$$\n时间复杂度：$O(n^2)$\n拉格朗日插值板子 const int maxn = 2005; int n; ll k; ll x[maxn], y[maxn]; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll solve(ll k) { ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ll nu = 1, de = 1; for (int j = 1; j \u0026lt;= n; j++) { if (j == i) continue; nu = nu * (k - x[j] + mod) % mod; de = de * (x[i] - x[j] + mod) % mod; } de = qpow(de, mod-2); ans = (ans + y[i] * nu % mod * de % mod) % mod; } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; ll ans = solve(k); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   $x$ 坐标为连续整数的拉格朗日插值 如果 $x$ 坐标是连续的整数，那么我们可以在 $O(n)$ 求出 $f(k)$。\n我们假设 $x_i = i$，那么：\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\prod\\limits_{i\\neq j} \\frac{k-x_j}{x_i-x_j}$$\n可以转化为：\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\prod\\limits_{i\\neq j} \\frac{k-j}{i-j}$$\n分类讨论 $j \u0026lt; i$ 和 $j \u0026gt; i$ 的情况：\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\prod\\limits_{j=1}^{i-1} \\frac{k-j}{i-j} \\prod\\limits_{j=i+1}^n \\frac{k-j}{i-j}$$\n所以可得：\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\frac{1}{(i-1)!} (k-1)(k-2)\u0026hellip;(k-(i-1)) \\frac{1}{-1*-2*\u0026hellip;*(-(n-i))} (k-i)(k-(i+1))\u0026hellip;(k-n)$$\n化简得到：\n$$f(k) = \\sum\\limits_{i=1}^n \\frac{y_i}{(-1)^{n-i} *i! * (n-i)!} \\prod\\limits_{j=1}^{i-1}(k-j) \\prod\\limits_{j=i+1}^n(k-j)$$\n• 注意，后面这部分不能变成 $\\frac{\\prod\\limits_{j=1}^{n}(k-j)}{k-i}$，因为我们无法确定 $k-i \\neq 0$。\n对于 $\\prod\\limits_{j=1}^{i-1}(k-j) \\prod\\limits_{j=i+1}^n(k-j)$，我们只要预处理出来一个前缀积和后缀积即可。\n所以对于每一项（每个 $i$），我们都可以 $O(1)$ 时间算出对应值，总复杂度 $O(n)$。\n重心拉格朗日插值 用于解决动态加点的问题。\n利用重心拉格朗日插值，每加入一个新的点，我们可以在 $O(n)$ 时间内算出新的多项式。\n$$f(k) = \\sum\\limits_{i=1}^ny_i \\prod\\limits_{i\\neq j}^n \\frac{k-x_j}{x_i-x_j}$$\n我们设 $g(k) = \\prod\\limits_{i=1}^n(k-x_i)$，则有：\n$$f(k) = g(k)\\sum\\limits_{i=1}^n \\frac{1}{k-x_i} \\prod\\limits_{i\\neq j}^n \\frac{y_i}{x_i-x_j}$$\n设 $t_i = \\frac{y_i}{\\prod\\limits_{j \\neq i}^n (x_i-x_j)}$，则有：\n$$f(k) = g(k) \\sum\\limits_{i=1}^n \\frac{t_i}{k-x_i}$$\n所以每次添加一个新的点 $(x_{n+1}, y_{n+1})$ 时：\n 重新计算一下所有的 $t_i = t_i * \\frac{1}{x_i - x_{n+1}}, i \\in [1,n]$。 计算 $t_{n+1}$。 计算 $g(k)$。  • 注意，在求 $f(k)$ 时需要先判断一下是否有 $k=x_i$，有的话直接返回 $y_i$。（这个特判仅需要在重心拉格朗日插值中进行）。\n重心拉格朗日插值板子 int Q; ll x[maxn], y[maxn], t[maxn]; int n; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll solve(ll k) { for (int i = 1; i \u0026lt;= n; i++) { if (x[i] == k) // 需要特判是否 k = x[i] return y[i]; } ll ans = 0; ll g = 1; ll sum = 0; for (int i = 1; i \u0026lt;= n; i++) { g = g * (k - x[i] + mod) % mod; sum = (sum + t[i] * qpow((k - x[i] + mod) % mod, mod - 2) % mod) % mod; } ans = g * sum % mod; return ans; } int main() { cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { // 添加 (xx,yy) 的点 ll xx, yy; cin \u0026gt;\u0026gt; xx \u0026gt;\u0026gt; yy; n++; x[n] = xx, y[n] = yy; ll de = 1; for (int j = 1; j \u0026lt; n; j++) { de = de * (x[n] - x[j] + mod) % mod; // 更新 t[n] t[j] = t[j] * qpow((x[j] - x[n] + mod) % mod, mod - 2) % mod; } de = qpow(de, mod - 2); t[n] = y[n] * de % mod; } else { ll k; cin \u0026gt;\u0026gt; k; // 求 f(k) cout \u0026lt;\u0026lt; solve(k) \u0026lt;\u0026lt; endl; } } }   常用模型  $\\sum\\limits_{i=1}^k i^n = 1^n+2^n+\u0026hellip;k^n$ 是一个多项式 $f(k)$，其中 $deg(f)=n+1$（意味着需要 $n+2$ 个点进行插值）。  例题 例1 CF622F The Sum of the k-th Powers 题意\n给定 $k,n$，求：\n$$\\sum\\limits_{i=1}^k i^n = 1^n+2^n+\u0026hellip;k^n$$\n其中，$0 \\leq k \\leq 10^9, 1 \\leq n \\leq 10^6$。\n 题解 上面说了这是一个多项式 $f(k)$，其中 $deg(f)=n+1$，意味着需要 $n+2$ 个点进行插值。\n又因为 $x_i = i, y_i = \\sum\\limits_{j=1}^i j^n$，我们直接按照上述 $O(n)$ 的连续整数来插值即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll k,n; ll fac[maxn], inv_fac[maxn], t[maxn]; ll y[maxn], pre[maxn], suf[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n; n += 2; fac[0] = inv_fac[0] = 1; pre[0] = suf[n+1] = 1; for (ll i = 1; i \u0026lt;= n; i++) { fac[i] = fac[i-1] * i % mod; y[i] = (y[i-1] + qpow(i, n-2)) % mod; pre[i] = pre[i-1] * (k - i + mod) % mod; } for (ll i = n; i \u0026gt;= 1; i--) suf[i] = suf[i+1] * (k - i + mod) % mod; inv_fac[n] = qpow(fac[n], mod-2); for (ll i = n-1; i \u0026gt;= 1; i--) { inv_fac[i] = inv_fac[i+1] * (i+1) % mod; } ll ans = 0; for (ll i = 1; i \u0026lt;= n; i++) { int flag = ((n-i) \u0026amp; 1 ? -1 : 1); ll res = y[i] % mod * inv_fac[i-1] % mod * inv_fac[n-i] % mod * pre[i-1] % mod * suf[i+1] % mod; res = (res * flag + mod) % mod; ans = (ans + res) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF1731F. Function Sum 题意\n如果我们有一个正整数数组 $a_1,a_2\u0026hellip;,a_n$，定义 $ls(i)$ 为：$i$ 的左边比它小的数量，$gr(i)$ 为：$i$ 的右边比它大的数量。\n如果对于index $i$，$ls(i) \u0026lt; gr(i)$，说明 $i$ 是good的。\n定义 $f(a)$（$a$ 是一个数组 $a_1,a_2\u0026hellip;,a_n$）的值为：所有的 good $i$ 的对应 $a_i$ 的和。\n 现给定 $n, k$，求所有长度为 $n$，保证 $\\forall i \\in [1,n], a_i \\in [1,k]$ 的所有可能的数组 $a$，$f(a)$ 的和。\n其中，$n \\in [1, 50], k \\in [2, 998244353)$，答案对 $998244353$ 取模。\n 题解 典中典之：看见 “所有满足xx条件” 就想到贡献。\n考虑每一个位置 $i$ 的每一个可能的值 $j$ 对答案会贡献多少？\n我们设 $f(i,j)$ 为：如果 $a_i = j$，那么满足 $ls(i) \u0026lt; gr(i)$ 的数组数量。\n则 $j$ 这个数的贡献就是 $j * f(i,j)$。\n形式化的，我们最终要求的答案就是\n$$\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^k j * f(i,j)$$\n 怎么求 $f(i,j)$？\n我们枚举 $ls(i)$ 和 $gr(i)$ 的值，设 $k_1 = ls(i), k_2 = gr(i)$，有：\n$$f(i,j) = \\sum\\limits_{k_1=0}^{i-1} \\sum\\limits_{k_2 = k_1+1}^{n-i} C_{i-1}^{k_1} (j-1)^{k_1}(k-j+1)^{i-1-k_1} C_{n-i}^{k_2}(k-j)^{k_2}(j)^{n-i-k_2}$$\n简单解释一下：\n$C_{i-1}^{k_1} (j-1)^{k_1}(k-j+1)^{i-1-k_1}$：其中 $C_{i-1}^{k_1}$ 代表从 $i$ 左边元素里选出 $k_1$ 个比它小的，而这 $k_1$ 个元素取的值只要 $\u0026lt;j$ 就可以了，所以有 $(j-1)^{k_1}$ 种，而剩下的 $(i-1-k_1)$ 个元素则只要满足 $\\geq j$ 即可，所以有 $(k-j+1)^{i-1-k_1}$ 种。\n$C_{n-i}^{k_2}(k-j)^{k_2}(j)^{n-i-k_2}$ 同理。\n 注意到 $n \\leq 50$，所以枚举 $i$ 是没问题，但是 $k$ 非常大所以不能枚举。\n但是，我们发现如果固定了 $i$，那么就只有一个变量 $j$ 了。\n看一下 $\\sum\\limits_{j=1}^k j * f(i,j)$ 中，$j$ 的最高系数是 $1 + k_1 + (i-1-k_1) + k_2 + (n-i-k_2) = n$。\n所以 $\\sum\\limits_{j=1}^k j * f(i,j)$ 是一个多项式，参考上面的常用模型，$\\sum\\limits_{j=1}^k a_j j^n$ 是一个 $deg = n+1$ 的多项式，需要 $(n+2)$ 个点来插值。\n插值的点，我们就选 $j' = 1\u0026hellip;55$，$x_{j'} = j'$，而 $y_{j'} = \\sum\\limits_{j'=1}^j f(i,j')$。插值结束后可以得到一个多项式 $h(x)$，直接求 $h(k)$ 的值即可。\n 如果 $k \\leq 55$ 使得插值的点数量不够呢？那对于较小的 $k$ 我们直接暴力计算就可以了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} Z(ll x) : x(norm(x % mod)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, Z \u0026amp;a) { ll v; is \u0026gt;\u0026gt; v; a = Z(v); return is; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const Z \u0026amp;a) { return os \u0026lt;\u0026lt; a.val(); } }; const int maxn = 1e4+5; const int maxm = 1e5+5; const int M = 1e4; int n, k; Z x[maxn], y[maxn]; Z solve(Z k) { Z ans = 0; for (int i = 1; i \u0026lt;= 55; i++) { Z nu = 1, de = 1; for (int j = 1; j \u0026lt;= 55; j++) { if (j == i) continue; nu = nu * (k - x[j]); de = de * (x[i] - x[j]); } de = de.inv(); ans = ans + y[i] * nu * de; } return ans; } Z fac[maxm], inv_fac[maxm]; Z C(Z i, Z j) { return fac[i.val()] * inv_fac[j.val()] * inv_fac[(i-j).val()]; } // brute force calculate f(i, j) Z cal(Z i, Z j) { Z ans = 0; for (Z k1 = 0; k1.val() \u0026lt;= (i-1).val(); k1 = k1+1) { for (Z k2 = k1+1; k2.val() \u0026lt;= (n-i).val(); k2 = k2+1) { ans = ans + C(i-1, k1) * qpow(j-1, k1.val()) * qpow(k-j+1, (i-1-k1).val()) * C(n-i, k2) * qpow(k-j, k2.val()) * qpow(j, (n-i-k2).val()); } } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; fac[0] = 1; for (int i = 1; i \u0026lt;= M; i++) fac[i] = fac[i-1] * i; inv_fac[M] = fac[M].inv(); for (int i = M-1; i \u0026gt;= 0; i--) inv_fac[i] = inv_fac[i+1] * (i+1); if (k \u0026lt;= 55) { Z ans = 0; for (Z i = 1; i.val() \u0026lt;= n; i = i + 1) { for (Z j = 1; j.val() \u0026lt;= k; j = j + 1) { ans = ans + (j * cal(i, j)); } } cout \u0026lt;\u0026lt; ans.val() \u0026lt;\u0026lt; endl; } else { Z ans = 0; for (Z i = 1; i.val() \u0026lt;= n; i = i + 1) { // 插值 f(i,j) for (int j = 1; j \u0026lt;= 55; j++) { x[j] = j; y[j] = y[j-1] + cal(i, j) * j; } ans += solve(k); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } }   ","date":"2022-01-12T12:43:19+08:00","permalink":"https://tom0727.github.io/post/065-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/","tags":["拉格朗日插值",""],"title":"拉格朗日插值"},{"categories":["算法"],"contents":"定义 闭合子图 对于一个 有向图 $G=(V,E)$，它的一个闭合子图 $G'=(V',E')$ 满足：\n$\\forall u \\in V'$，如果 $(u,v) \\in E$，则 $v \\in V', (u,v) \\in E'$\n 简单来说，就是对于子图中的每一个点 $u$，它的所有后继（它指向的）节点 $v$ 都在子图中。\n最大权闭合子图 如果这个图有点权，那么最大权闭合子图就是一个 最大点权和 的 闭合子图。\n算法 最大权闭合子图问题可以利用最小割解决。\n结论  建立超级源点 $s$，对于所有点权 $w_u \u0026gt;0$ 的点 $u$，连 $(s,u,w_u)$。 建立超级汇点 $t$，对于所有点权 $w_v \u0026lt; 0$ 的点 $v$，连 $(v,t,|w_v|)$。 对于原图中的所有边 $(u,v)$，都连一条无限大的边 $(u,v,\\infty)$。  • 点权为 $0$ 的点不用和 $s,t$ 相连。\n那么答案就等于：\n最大权闭合子图的权值和 $=$ 所有权值为正的权值和 $-$ 最小割\n 证明 我们有以下 lemma：\n 结论1：最小割为简单割（容量不为正无穷）\n很明显可以通过割与 $s,t$ 相连的边获得最小割，所以最小割不会包括正无穷的边。\n 结论2：最小割将原图分为 $S,T$ 两个集合（指分别包含 $s,t$ 的两个集合），$S$ 集合是一个闭合子图。\n由于最小割不包含正无穷的边，$S$ 内不存在连向集合 $T$ 的边，所以 $S$ 内所有的出边都指向 $S$ 内部，满足闭合图定义。\n 结论3：$S$ 集合是所求的最大权闭合子图。\n（不会证明）\n 结论4：最大权闭合子图的权值和 $=$ 所有权值为正的权值和 $-$ 最小割\n我们定义 $a_S$ 分别为 $S$ 内所有正权值之和，$b_S$ 为 $S$ 内所有负权值之和的绝对值，形式化的：\n$$a_S = \\sum\\limits_{u\\in S, w_u\u0026gt;0}w_u, b_S = |\\sum\\limits_{u\\in S, w_u\u0026lt;0}w_u|$$\n则，$S$ 的权值（最大权闭合子图的权值）$W_S$ 就等于：\n$$W_S = a_S - b_S$$\n再定义最小割 $C$ 为一个边集的权值集合 $C = \\{w_{C_1},w_{C_2},\u0026hellip;\\}$，并且定义 $a_C$ 为 $C$ 内所有正权值之和，$b_C$ 为 $C$ 内所有负权值之和的绝对值。\n则最小割的值 $W_C$等于：\n$$W_C = a_C + b_C$$\n因为 $S$ 内所有拥有负权值的节点，必然指向 $t$，且由于 $S$ 是闭合子图，所以最小割中，所有负边必然都来自于 $S$ 内的负权值节点。\n所以 $b_S = b_C$。\n同理，$a_S$ 与 $a_C$ 互补，即 $a_S + a_C = a_G$，其中 $a_G$ 代表原图中所有正权值之和。\n所以：\n$$W_S + W_C = a_G$$\n可得：\n$$W_S = a_G - W_C$$\n例题 例1 洛谷P4174 [NOI2006] 最大获利 题意\n有一共 $n$ 个中转站，$m$ 个用户。\n建立第 $i$ 个中转站所需的成本为 $P_i$。\n每个用户的信息为 $A_i,B_i,C_i$，代表这个用户将会使用中转站 $A_i$ 和 $B_i$ 进行通讯，并且可以带来 $C_i$ 的利润。\n求最大净利润（利润减去成本）？\n其中，$n \\leq 5000, m \\leq 50000$。\n 题解 对于这种 满足某种条件才能获得利润，而这些条件 需要一定成本才能满足 的题，就可以考虑最大权闭合子图。\n把每个中转站看作一个节点，然后这些节点向汇点 $t$ 连边，容量为 $P_i$。\n把每个用户（获利条件）看作一个节点，比如一个条件 $(A_i,B_i,C_i)$ 就看作一个节点 $x_i$。\n然后连 $(s,x_i,C_i)$ 代表选择这个节点可以获得 $C_i$ 的利润，再连 $(x_i,A_i,\\infty), (x_i,B_i,\\infty)$ 代表如果要获得这个利润，则必须建立中转站 $A_i,B_i$。\n求出最大权闭合子图的权值即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 55005; const int maxm = 1e6+55005+10; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int val[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = 55001, t = 55002; for (int i = 1; i \u0026lt;= n; i++) { int p; cin \u0026gt;\u0026gt; p; add(i, t, p); } int sum = 0; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add(i+n, u, 1e9); add(i+n, v, 1e9); add(s, i+n, w); sum += w; } int res = maxflow(); cout \u0026lt;\u0026lt; sum - res \u0026lt;\u0026lt; endl; }   例2 CCPC2021威海 H city safety 题意\n给定一个 $n$ 个节点的树。对于每个节点 $i$，初始状态下没有加固。加固节点 $i$ 的代价为 $w_i$。\n对于每一个节点，如果距离它 $\\leq j$ 的所有节点均被加固了，则它会提供额外 $v_j$ 的收益。\n求加固方案，使得净收益最大？\n其中，$n \\leq 200, v_j \\leq v_{j+1}$。\n 最小割题解 最大权闭合子图。\n拆点，对于每个节点 $u$，我们把它拆成 $u,u_0,u_1,u_2,\u0026hellip;,u_{n-1}$。\n其中 $u_j$ 代表对于节点 $u$，距离它 $\\leq j$ 的所有节点均被加固了。\n我们知道 $u_j$ 就代表一种收益，那么这个收益有什么条件呢？\n  如果要选 $u_j$，则我们必须选择 $u_{j-1}$，这样我们就保证了选择 $u_j$ 也会选择到所有距离 $\\leq (j-1)$ 的点。\n  如果选了 $u_j$，我们必须选择距离 $u$ 恰好为 $j$ 的点。\n  所以连边的方案就是：\n 连 $(s,u_j,v_j-v_{j-1})$：代表选择了 $u_j$ 这个收益，注意到选择 $u_j$ 后默认选择了 $u_{j-1}$，所以我们只需要给这个点赋值一个增量 $v_j-v_{j-1}$ 即可。 连 $(u_j,u_{j-1},\\infty)$ 连 $(u_j,v,\\infty)$：代表我们需要选择距离 $u$ 距离 $u$ 恰好为 $j$ 的点 $v$。 对于每一个 $v \\in [1,n]$，连 $(v,t,w_v)$：代表需要付出 $w_v$ 的代价来加固点 $v$。   比如对于样例：$n=3, E = \\{(1,2),(1,3)\\}$，且 $v_0=1, v_1=3, v_2=4, w_1 = 2,w_2=3,w_3=4$，则建的图如下：\n 最小割代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 210; const int maxm = 8e5+5; int n,m,s,t; int head[maxn*maxn], ecnt = 2, cur[maxn*maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn*maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } ll w[maxn], val[maxn]; vector\u0026lt;int\u0026gt; adj[maxn]; int id[maxn][maxn]; int d[maxn][maxn]; int dep[maxn]; void dfs(int u, int p) { for (int v : adj[u]) { if (v == p) continue; dep[v] = dep[u] + 1; dfs(v, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; val[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } int ID = 0; for (int k = 0; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { id[k][i] = ++ID; } } s = ++ID, t = ++ID; memset(d, 63, sizeof(d)); for (int i = 1; i \u0026lt;= n; i++) { for (int j : adj[i]) d[i][j] = 1; d[i][i] = 0; } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } for (int i = 1; i \u0026lt;= n; i++) { add(id[0][i], t, w[i]); } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { add(s, id[k][i], val[k] - val[k-1]); add(id[k][i], id[k-1][i], 1e18); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int k = d[i][j]; add(id[k+1][i], id[0][j], 1e18); } } ll sum = (ll)n * val[n]; ll res = maxflow(); cout \u0026lt;\u0026lt; sum - res \u0026lt;\u0026lt; endl; }   树形DP题解 这题还有个玄学的树形DP解法（我不能理解，先放在这）：\n对于每个节点 $u$，设 dp[u][j] 为离 $u$ 的距离都 $\\leq j$ 的所有节点均被加固了，dp的值为 $u$ 所在子树内的最优解之和。\n则对于 $u$ 的每个直接的 child $v$，$v$ 可以选择加固周围 $\\leq k$ 的所有节点，其中 $k = \\{j-1,j,j+1\\}$。\n然后利用 探索当前子树 的思想来更新 dp[u][j]。\n 树形DP代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 222; vector\u0026lt;int\u0026gt; adj[maxn]; int n, ans = 0; int dp[maxn][maxn], w[maxn], val[maxn\u0026lt;\u0026lt;1]; void dfs(int u, int p) { dp[u][0] = 0; for (int j = 1; j \u0026lt;= n; j++) dp[u][j] = -w[u] + val[j]; for (int v : adj[u]) { if (v == p) continue; dfs(v, u); int tmp[n+5]; fill(tmp, tmp+n+5, -1e9); for (int j = 0; j \u0026lt;= n; j++) { for (int k = max(0,j-1); k \u0026lt;= min(n,j+1); k++) { tmp[j] = max({tmp[j], dp[u][j] + dp[v][k]}); } } for (int j = 0; j \u0026lt;= n; j++) dp[u][j] = tmp[j]; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; val[i]; for (int i = 1; i \u0026lt; n; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } dfs(1,0); int ans = 0; for (int j = 0; j \u0026lt;= n; j++) { ans = max(ans, dp[1][j]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P2805 [NOI2009] 植物大战僵尸 题意\n给定一个 $N \\times M$ 的矩阵，每个格子内都有一个植物，每个植物拥有一个 score，代表吃掉这个植物以后会获得的分数（可以为负）。每个植物还有一个攻击位置集合，代表它可以攻击到的一些位置，它无法攻击它自己所在的位置。\n现在我们可以放置僵尸，僵尸只能从某一行的最右侧开始向左走，如果僵尸来到了一个可以被植物攻击到的位置，它会立刻死亡，否则它可以吃掉这个植物并且继续向前走。\n我们组织无限次僵尸攻击，并且每次攻击我们可以任选将僵尸放在哪一行。\n求最大分数？\n其中，$1 \\leq N \\leq 20, 1 \\leq M \\leq 30$。\n 题解 首先我们可以知道，这是一个格子之间互相保护的问题（保护有两种，一种是通过植物的攻击，第二种是同一行中，一个植物会保护它左边的那个植物）。\n假如 $(x_1,y_1)$ 保护 $(x_2,y_2)$，这意味着如果我们吃了 $(x_2,y_2)$，则我们必须得吃 $(x_1,y_1)$。\n这在有向图里表示的话就是 $(x_2,y_2) \\rightarrow (x_1,y_1)$，所以问题变成了求最大权闭合子图。\n不过我们需要注意，因为这个有向图中可能有环，怎么解决？\n拓扑排序先把环求出来，然后求出环所保护的节点，一直拓展下去，最后我们可以知道：\n所有环 + 所有被环直接/间接 保护的节点都不可以被吃掉，所以直接将这些点删掉即可。\n • 拓扑排序的时候，我们进行反向建边：假如 $(x_1,y_1)$ 保护 $(x_2,y_2)$，则建立 $(x_1,y_1) \\rightarrow (x_2,y_2)$，这样的话拓扑排序求出来那些 deg \u0026gt; 0 的就是这些无法被吃掉的点了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 605; const int maxm = 8e5+5; // 最大流板子略 int N,M,s,t, id[22][33], ID; int score[22][33]; int head[maxn], ecnt = 2, cur[maxn], deg[maxn]; // ecnt 从 2 开始，方便取反向边 vector\u0026lt;int\u0026gt; adj[maxn]; bool ring[maxn]; void topo() { fill(ring, ring+maxn, 1); vector\u0026lt;int\u0026gt; tmp; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= M; j++) { if (!deg[id[i][j]]) tmp.push_back(id[i][j]); } } while (tmp.size()) { int u = tmp.back(); tmp.pop_back(); ring[u] = 0; for (int v : adj[u]) { deg[v]--; if (!deg[v]) { tmp.push_back(v); } } } } vector\u0026lt;int\u0026gt; pos[22][33]; int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= M; j++) { id[i][j] = ++ID; } } for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= M; j++) { if (j \u0026gt; 1) adj[id[i][j]].push_back(id[i][j-1]), deg[id[i][j-1]]++; cin \u0026gt;\u0026gt; score[i][j]; int w; cin \u0026gt;\u0026gt; w; while (w--) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x++,y++; pos[x][y].push_back(id[i][j]); adj[id[i][j]].push_back(id[x][y]); deg[id[x][y]]++; } } } topo(); s = ++ID, t = ++ID; int sum = 0; for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= M; j++) { if (ring[id[i][j]]) continue; if (score[i][j] \u0026gt; 0) add(s, id[i][j], score[i][j]), sum += score[i][j]; if (score[i][j] \u0026lt; 0) add(id[i][j], t, -score[i][j]); if (j \u0026gt; 1 \u0026amp;\u0026amp; !ring[id[i][j-1]]) add(id[i][j-1], id[i][j], 1e9); for (int p : pos[i][j]) { if (!ring[p]) { add(id[i][j], p, 1e9); } } } } int res = maxflow(); cout \u0026lt;\u0026lt; max(0, sum - res) \u0026lt;\u0026lt; endl; }   参考链接  https://www.cxymm.net/article/Q755100802/100001647 https://www.cnblogs.com/dilthey/p/7565206.html https://linkfqy.github.io/posts/Maximum_Weight_Closure_of_a_Graph/  ","date":"2022-01-10T11:11:05+08:00","permalink":"https://tom0727.github.io/post/064-%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/","tags":["最大权闭合子图","最小割"],"title":"最大权闭合子图"},{"categories":["算法"],"contents":"曼哈顿距离 定义两个点 $A(x_1,y_1), B(x_2,y_2)$，则 $A,B$ 之间的曼哈顿距离为：\n$$d(A,B) = |x_1 - x_2| + |y_1 - y_2|$$\n曼哈顿距离的性质：\n 对称性：$d(A,B) = d(B,A)$ 三角形不等式：$d(A,C) \\leq d(A,B) + d(B,C)$  曼哈顿距离的应用场景：\n 单位网格图上，只能往 上下左右 $4$ 个方向走，那么网格图上两点之间的距离为 曼哈顿距离。 国际象棋棋盘上，车从一个格子走到另外一个格子就是曼哈顿距离。  距离原点的曼哈顿距离为 $1$ 组成的点：\n 切比雪夫距离 定义两个点 $A(x_1,y_1), B(x_2,y_2)$，则 $A,B$ 之间的切比雪夫距离为：\n$$d(A,B) = \\max \\{|x_1 - x_2|,|y_1 - y_2|\\}$$\n 单位网格图上，可以 上下左右，也可以 斜着，共往 $8$ 个方向走，那么网格图上两点之间的距离为 切比雪夫距离。 国际象棋棋盘上，王从一个格子走到另外一个格子就是切比雪夫距离。  由于可以互相转化，所以切比雪夫距离也遵循曼哈顿距离的性质。\n距离原点的切比雪夫距离为 $1$ 组成的点：\n 曼哈顿距离 转 切比雪夫距离 对于曼哈顿坐标系中的所有点 $(x,y)$，我们都把它转到切比雪夫坐标系中，得到 $(x+y,x-y)$。\n$$(x,y) \\rightarrow (x+y,x-y)$$\n那么，曼哈顿坐标系中的 曼哈顿距离 等于 切比雪夫坐标系中的 切比雪夫距离。\n• 证明：略，大概就是将坐标系中的单位正方形进行转化即可。\n切比雪夫距离 转 曼哈顿距离 对于切比雪夫坐标系中的所有点 $(x,y)$，我们都把它转到曼哈顿坐标系中，得到 $(\\frac{x+y}{2},\\frac{x-y}{2})$。\n$$(x,y) \\rightarrow (\\frac{x+y}{2},\\frac{x-y}{2})$$\n那么，切比雪夫坐标系中的 切比雪夫距离 等于 曼哈顿坐标系中的 曼哈顿距离。\n• 证明：使用上面的逆变换，即可得到答案。\n例题 例1 洛谷P2906 [USACO08OPEN]Cow Neighborhoods G 题意\n在二维平面上 给定 $n$ 个奶牛的整数坐标 $(x_i,y_i)$，给定正整数 $C$，若满足以下两个条件之一，则我们定义两个奶牛 $i,j$ 为一个群：\n $i,j$ 之间的曼哈顿距离 $\\leq C$。 存在奶牛 $k$，使得 $i,k$ 和 $k,j$ 为一个群。  求牛群数量，并求出最大的牛群大小。\n其中，$n \\leq 10^5, C,x_i,x_j \\in [1,10^9]$\n 题解 很明显是并查集，现在我们要观察怎么并。\n可以发现，本题主要的难点就在于如何减少并查集合并数量。所以我们在 sort 以后就要想办法如何使用最少的合并次数，达到答案？\n首先，我们把曼哈顿距离转为切比雪夫距离。经过变换以后，可得到 $(x_i',y_i') = (x_i+y_i,x_i-y_i)$。\n然后，我们知道对于两个限制的常用套路是 分开讨论。\n我们根据 $x$ 坐标先 sort 一下所有的点，然后从 $1$ 枚举到 $n$。\n当我们位于第 $i$ 个点时，我们可以利用滑动窗口知道有哪些点是 $i$ 可以合并到的。（保证 $|x_j - x_i| \\leq C$ 即可，其中 $j\\in [1,i]$）。\n然后在这个滑动窗口内，我们只要找出 $\\geq y_i$ 的第一个 $y_{j_1}$ 和 $\\leq y_i$ 的第一个 $y_{j_2}$，然后合并 $(i,j_1)$ 和 $(i,j_2)$ 即可。\n• 为什么只需要合并这两个元素呢？\n证：考虑我们最终合并出来的结果，是一个个联通块。那么对于联通块内的一个 $(x_i,y_i)$，它必然通过上述过程与 $\\geq y_i$ 的第一个 $y_{j_1}$ 和 $\\leq y_i$ 的第一个 $y_{j_2}$ 所合并了。\n最后，我们用 set 来维护这个滑动窗口并且找出 $y_{j_1}$ 和 $y_{j_2}$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,par[maxn],sz[maxn]; ll c; struct Node { int id; ll x,y; bool operator\u0026lt;(const Node\u0026amp; other) const { if (y == other.y) return x \u0026lt; other.x; return y \u0026lt; other.y; } } arr[maxn]; int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return; par[v] = u; } set\u0026lt;Node\u0026gt; s; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; arr[i].x = x + y; arr[i].y = x - y; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.x \u0026lt; b.x; }); for (int i = 1; i \u0026lt;= n; i++) par[i] = i, arr[i].id = i; int l = 1; s.insert(arr[1]); for (int r = 2; r \u0026lt;= n; r++) { while (arr[r].x - arr[l].x \u0026gt; c) { s.erase(arr[l]); l++; } // 找第一个 \u0026lt;= y 的 auto p = s.upper_bound({0,0,arr[r].y}); if (p != s.begin()) { if (abs(prev(p)-\u0026gt;y - arr[r].y) \u0026lt;= c) unions(arr[r].id, prev(p)-\u0026gt;id); } // 找第一个 \u0026gt;= y 的 p = s.lower_bound({0,0,arr[r].y}); if (p != s.end()) { if (abs(p-\u0026gt;y - arr[r].y) \u0026lt;= c) unions(arr[r].id, p-\u0026gt;id); } s.insert(arr[r]); } int mx = 0, cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { int u = finds(i); sz[u]++; } for (int i = 1; i \u0026lt;= n; i++) { if (sz[i]) cnt++, mx = max(sz[i], mx); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; }   例2 洛谷P3964 [TJOI2013]松鼠聚会 题意\n二维平面上给定 $n$ 个点 $(x_i,y_i)$，每个点到它周围的 $8$ 个点\n$$(x−1,y),(x+1,y),(x,y-1),(x,y+1),(x-1,y+1)(x-1,y-1), (x+1,y+1), (x+1,y-1)$$\n距离均为 $1$。\n求一个点，使得它到其他所有的点的距离和最小，求这个最小和。\n 题解 这实际上就是切比雪夫距离。\n问题变成平面上求一个点，使得它到其他点的切比雪夫距离之和最小。\n这个问题不好求，不如转化成曼哈顿距离。\n$$(x,y) \\rightarrow (\\frac{x+y}{2},\\frac{x-y}{2})$$\n为了防止小数的问题，我们把所有坐标乘上 $2$，最后答案除以 $2$ 即可。\n转化以后就变成求一个点，使得它到其他点的曼哈顿距离之和最小。\n这就好做了，因为曼哈顿距离的 $x,y$ 坐标贡献是独立的，互不影响。\n所以先根据 $x$ 坐标 sort 一下所有点，用前缀和即可得到每个点到其他点曼哈顿距离的 $x$ 坐标上的贡献。\n再根据 $y$ 坐标 sort 一下，用前缀和即可得到每个点到其他点曼哈顿距离的 $y$ 坐标上的贡献。\n把两个贡献加起来即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n; struct Node { int id; ll x,y; } arr[maxn]; ll pre[maxn], suf[maxn], sumx[maxn], sumy[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { ll x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; arr[i].x = x + y; arr[i].y = x - y; arr[i].id = i; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.x \u0026lt; b.x; }); for (int i = 1; i \u0026lt;= n; i++) pre[i] = pre[i-1] + arr[i].x; for (int i = n; i \u0026gt;= 1; i--) suf[i] = suf[i+1] + arr[i].x; for (int i = 1; i \u0026lt;= n; i++) { int id = arr[i].id; sumx[id] = (ll)(i) * arr[i].x - pre[i] + suf[i] - (ll)(n-i+1) * arr[i].x; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.y \u0026lt; b.y; }); for (int i = 1; i \u0026lt;= n; i++) pre[i] = pre[i-1] + arr[i].y; for (int i = n; i \u0026gt;= 1; i--) suf[i] = suf[i+1] + arr[i].y; for (int i = 1; i \u0026lt;= n; i++) { int id = arr[i].id; sumy[id] = (ll)(i) * arr[i].y - pre[i] + suf[i] - (ll)(n-i+1) * arr[i].y; } ll mn = 1e18; for (int i = 1; i \u0026lt;= n; i++) { mn = min(mn, sumx[i] + sumy[i]); } cout \u0026lt;\u0026lt; mn / 2 \u0026lt;\u0026lt; endl; }   例3 洛谷P4648 [IOI2007] pairs 动物对数 题意\n给定 $4$ 个正整数，$B,N,D,M$。\n在 $B$ 维空间中，有 $N$ 个点，定义两个点之间的距离为他们的曼哈顿距离，并且它们的坐标大小都在 $[1,M]$ 中。\n求距离 $\\leq D$ 的点对数量？\n规定：\n$B \\in [1,3], N \\in [1,10^5], D \\in [1, 10^9]$。\n当 $B = 1$ 时，$M \\leq 7.5 \\times 10^8$。\n当 $B = 2$ 时，$M \\leq 7.5 \\times 10^4$。\n当 $B = 3$ 时，$M \\leq 75$。\n 题解 $B=1$：\n直接 sort 一下，然后滑动窗口即可。\n $B=2$：\n曼哈顿距离转一下切比雪夫距离，然后老套路，按照 $x$ 坐标 sort 一下，接着从 $1$ 枚举到 $n$。\n设我们现在到第 $i$ 个元素了，那么我们就可以维护一个滑动窗口保证窗口内的所有元素 $j$ 都满足 $x_i-x_j \\leq D$。\n接着我们只需要查询这个窗口内，有多少个元素满足 $y_j \\in [x_i-D, x_i+D]$ 即可。\n那么这个开一个权值线段树维护一下就行了，值域在 $[1, 1.5 \\times 10^5]$。\n• 注意一下转切比雪夫距离之后，$y$ 坐标有可能有负数，那么就把所有点的 $y$ 坐标都加上 $M$，这样 $y_i \\in [1, 2M]$了。\n $B=3$：\n老套路，仍然是按照 $x$ 坐标先 sort 一下。\n然后我们把点按照 $x$ 坐标分类，所以每个 $x$ 坐标对应的就是一个二维平面。由于 $M \\leq 75$，所以这样的二维平面只有 $75$ 个。\n然后我们枚举每个点，对于每个点 $i$，都在每一个二维平面 $j$ 上询问一下这个平面上有多少点到它的曼哈顿距离为 $d$，其中\n$$d = D - |x_i - x_j|$$\n这个询问的过程，完全是一个二维平面上的问题。\n我们再将曼哈顿距离转成切比雪夫距离。\n注意到，在二维平面上，距离一个点的切比雪夫 $\\leq d$ 的点形成的实际上是一个正方形。\n所以这就变成了一个查询二维平面上，一个正方形内点的数量有多少了。\n于是用二维前缀和就可以 $O(1)$ 查询。\n• 最后要记得把答案减去 $n$，因为每个点都会把自己算一次。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int B, n; ll D, M; void solve1() { int a[maxn]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } sort(a+1, a+n+1); int l = 1; ll ans = 0; for (int r = 1; r \u0026lt;= n; r++) { while (a[r] - a[l] \u0026gt; D) l++; ans += (ll)(r-l); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int id = 0; void update(int* sum, int cur, int l, int r, int p, int x) { sum[cur] += x; if (l == r) { return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(sum, cur\u0026lt;\u0026lt;1, l, mid, p, x); if (p \u0026gt; mid) update(sum, cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); } int query(int* sum, int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) return sum[cur]; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(sum, cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(sum, cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } void solve2() { int sum[(M+100)\u0026lt;\u0026lt;3]; memset(sum, 0, sizeof(sum)); pii arr[maxn]; for (int i = 1; i \u0026lt;= n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; arr[i].first = x + y; arr[i].second = x - y + M; // 移动 M 格 } sort(arr+1, arr+n+1); ll ans = 0; int l = 1; for (int r = 1; r \u0026lt;= n; r++) { while (arr[r].first - arr[l].first \u0026gt; D) { update(sum, 1, 1, 2 * M, arr[l].second, -1); l++; } ans += (ll)(query(sum, 1, 1, 2 * M, max(1LL, arr[r].second - D), min(2 * M, arr[r].second + D))); update(sum, 1, 1, 2 * M, arr[r].second, 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void solve3() { const int MM = 77; vector\u0026lt;pii\u0026gt; arr[MM]; int sum[MM][MM*2][MM*2]; memset(sum, 0, sizeof(sum)); for (int i = 1; i \u0026lt;= n; i++) { int x,y,z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; arr[x].push_back({y+z, y-z+M}); sum[x][y+z][y-z+M]++; } ll ans = -n; for (int i = 1; i \u0026lt;= M; i++) { for (int j = 1; j \u0026lt;= 2 * M; j++) { for (int k = 1; k \u0026lt;= 2 * M; k++) { sum[i][j][k] += sum[i][j-1][k] + sum[i][j][k-1] - sum[i][j-1][k-1]; } } } for (int ii = 1; ii \u0026lt;= M; ii++) { for (pii a : arr[ii]) { ll x = a.first, y = a.second; for (int i = 1; i \u0026lt;= M; i++) { ll d = D - abs(i - ii); // 只考虑 y,z 内的距离 if (d \u0026gt;= 0) { int x1 = min(2*M, x + d), y1 = min(2*M, y + d); int x2 = max(1LL, x - d) - 1, y2 = min(2*M, y + d); int x3 = max(1LL, x - d) - 1, y3 = max(1LL, y - d) - 1; int x4 = min(2*M, x + d), y4 = max(1LL, y - d) - 1; ans += (ll)(sum[i][x1][y1] - sum[i][x2][y2] - sum[i][x4][y4] + sum[i][x3][y3]); } } } } cout \u0026lt;\u0026lt; ans/2 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } int main() { cin \u0026gt;\u0026gt; B \u0026gt;\u0026gt; n \u0026gt;\u0026gt; D \u0026gt;\u0026gt; M; if (B == 1) solve1(); if (B == 2) solve2(); if (B == 3) solve3(); }   参考链接  https://www.luogu.com.cn/blog/xuxing/Distance-Algorithm  ","date":"2021-12-29T19:14:56+08:00","permalink":"https://tom0727.github.io/post/063-%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/","tags":["曼哈顿距离","切比雪夫距离"],"title":"曼哈顿距离 和 切比雪夫距离"},{"categories":["算法"],"contents":"介绍 这篇博客主要介绍一些并查集的高级应用。\n目前我所知的并查集应用有：\n 权值并查集 可撤销并查集 可持久化并查集（还没学）  权值并查集 略，目前我所知的方法就只有开多倍空间，维护不同元素之间的关系，经典例题见 NOI2001 食物链。\n可撤销并查集 意思如其名，可以将之前合并的操作撤销。\n思想并不难，只要拿一个额外的 stack 记录一下每次操作 更改的信息，然后回退的时候将 stack 内的信息 pop 出来，恢复一下当时的状态即可。\n有几个需要注意的点：\n 并查集 不能路径压缩，否则会破坏结构。为了保证时间复杂度，需要使用启发式合并。 无论 unions(u,v) 是否成功，都要记录在栈中。因为我们回退时并不知道这一步合并当时是否成功了。  模版 ll ans = 0; ll cal(ll x) { return x*(x-1) / 2; } struct State { int u, v, szu, szv; } st[maxm]; // 注意这里是 maxm，应该是边的数量 struct DSU { int par[maxn], sz[maxn], tail = 0; inline void init() { for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1; tail = 0; } int finds(int u) { if (par[u] == u) return u; return finds(par[u]); // 无路径压缩 } void unions(int u, int v) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); // sz[u] \u0026gt;= sz[v] st[++tail] = {u, v, sz[u], sz[v]}; // 无论是否 union 成功都要push到 stack 里 if (u == v) return; par[v] = u; ans = ans - cal(sz[u]) - cal(sz[v]) + cal(sz[u] + sz[v]); sz[u] += sz[v]; } void cancel() { if (tail \u0026gt; 0) { int u = st[tail].u, v = st[tail].v; par[v] = v; if (sz[u] != st[tail].szu) { ans = ans - cal(sz[u]) + cal(st[tail].szu) + cal(st[tail].szv); } sz[u] = st[tail].szu; sz[v] = st[tail].szv; tail--; } } } dsu;   例题 例1 [HNOI2016]最小公倍数 题意\n给定一个 $n$ 个节点，$m$ 条边的无向图。每个边有权值，权值都可以被表示为 $2^a \\times 3^b$ 的形式。\n现在给出 $q$ 个询问，每次询问 $u ~ v ~ a ~ b$，我们需要回答在 $u,v$ 之间，是否存在一条路径使得路径上所有边权的 LCM 等于 $2^a \\times 3^b$？\n路径可以不为简单路径（可以经过重复的边）。\n其中，$1 \\leq n,q \\leq 5 \\times 10^4, 1 \\leq m \\leq 10^5, 0 \\leq a_i,b_i \\leq 10^9$。\n 题解 题目实际上就想要我们找，每条边的权值表示为 $(a_i,b_i)$，每次询问 $u ~ v ~ a ~ b$，回答是否存在路径使得路径上的 $\\max \\{a_i\\} = a, \\max \\{b_i\\} = b$？\n我们先用最暴力的思路来想：\n对于每次询问，我们只要把所有满足 $a_i \\leq a, b_i \\leq b$ 的边全都加进去，然后判断一下 $u,v$ 是否联通，并且这个联通块内 $\\max \\{a_i\\} = a, \\max \\{b_i\\} = b$ 是否成立即可。这可以用并查集实现。\n接下来考虑优化。\n 对于这种拥有 $2$ 个条件的题目，一种套路是：\n 将第一种权值 sort 一下，然后分块。\n每个块内（或者多个块一起）对第二种权值 sort。然后把所有询问放进对应的块内进行处理。\n 对于本题，我们先把所有的边按照 $a_i$ 的大小进行 sort，然后进行分块。\n对于每一条边 $(u,v,a,b)$，我们找到一个块 $B$ 满足，在 $[1,B-1]$ 这些块内，最大的 $a_i$ 都 $\\leq a$，且这个 $B$ 尽可能大。\n之后，我们对于每一个块进行处理。\n假设我们现在在块 $B$ 内，那么我们将 $[1,B-1]$ 这些块看作一个整体，然后对这个整体，按照 第二种权值 $b_i$ 进行 sort。\n然后我们将块 $B$ 内的所有询问按照 $b_i$ 进行 sort。\n然后我们开始回答询问 $(u,v,a,b)$。\n首先注意到此时，$[1,B-1]$ 这些块内的元素一定满足 $a_i \\leq a$，所以不用关心前面这些块内的 $a_i$。\n然后考虑 $[1,B-1]$ 这些块内的元素的 $b_i$，注意到它们此时是按照 $b_i$ sort 好的，而我们的询问也是按照 $b$ sort 的，所以我们可以直接用一个指针维护一下现在我们在 $[1,B-1]$ 这些块内，有哪些元素的 $b_i$ 是 $\\leq b$ 的。\n这样，$[1,B-1]$ 这些块就都处理好了，只剩下当前这个块 $B$ 了。\n对于当前块 $B$，我们只要暴力向并查集内加入当前块内，所有满足 $a_i \\leq a, b_i \\leq b$ 的边即可。\n在回答完这个询问后，把当前块 $B$ 的所有边都从并查集中撤销，然后开始回答下一个询问。\n 总时间复杂度：设块的大小为 $B$，那么总共有 $\\frac{m}{B}$ 个块。\n每一个块的处理：首先要对前面的块进行sort，所以是 $O(m\\log m)$。\n对于每一个询问，我们都要暴力遍历一个块内的所有边，总共有 $B$ 条边，每次加入操作需要 $O(\\log m)$（因为没有路径压缩），所以是 $O(B \\log m)$。\n于是最终的复杂度就是：\n$$T(n) = \\frac{m}{B} m\\log m + qB \\log m$$\n取 $B = \\sqrt m$ 或者 $\\frac{m}{\\sqrt q}$ 之类的都可以过。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 1e5+5; struct Query { int u, v, a, b, be, id; } query[maxn]; vector\u0026lt;Query\u0026gt; vec[maxn]; struct Edge { int from, to, a, b; } edges[maxm]; bool cmpA(const Edge\u0026amp; e1, const Edge\u0026amp; e2) { return e1.a \u0026lt; e2.a; } bool cmpB(const Edge\u0026amp; e1, const Edge\u0026amp; e2) { return e1.b \u0026lt; e2.b; } int ecnt = 0, n, m, B, blockcnt, Q; void addEdge(int u, int v, int a, int b) { Edge e = {u, v, a, b}; edges[++ecnt] = e; } struct State { int u, v, szu, amaxu, bmaxu; } st[maxm]; int tail = 0; int par[maxn], sz[maxn], amax[maxn], bmax[maxn]; inline void init() { for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1, amax[i] = bmax[i] = -1; tail = 0; } int finds(int u) { if (par[u] == u) return u; return finds(par[u]); } void unions(int u, int v, int a, int b) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); st[++tail] = {u, v, sz[u], amax[u], bmax[u]}; amax[u] = max(amax[u], a); // 注意不管是否成功，都要更改 amax, bmax bmax[u] = max(bmax[u], b); if (u == v) return; par[v] = u; sz[u] += sz[v]; amax[u] = max(amax[u], amax[v]); bmax[u] = max(bmax[u], bmax[v]); } void cancel() { if (tail \u0026gt; 0) { int u = st[tail].u, v = st[tail].v; par[v] = v; sz[u] = st[tail].szu; amax[u] = st[tail].amaxu; bmax[u] = st[tail].bmaxu; tail--; } } bool ans[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,a,b; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; addEdge(u,v,a,b); } sort(edges+1, edges+ecnt+1, cmpA); B = sqrt(n); // block size blockcnt = (ecnt + B - 1) / B; cin \u0026gt;\u0026gt; Q; // block 1: [1 ... B], block 2: [B+1, ... , 2B], for (int i = 1; i \u0026lt;= Q; i++) { cin \u0026gt;\u0026gt; query[i].u \u0026gt;\u0026gt; query[i].v \u0026gt;\u0026gt; query[i].a \u0026gt;\u0026gt; query[i].b; query[i].id = i; query[i].be = 1; for (int b = 1; b \u0026lt;= blockcnt-1; b++) { if (edges[b * B].a \u0026lt;= query[i].a) { query[i].be = b+1; } } vec[query[i].be].push_back(query[i]); } for (int b = 1; b \u0026lt;= blockcnt; b++) { if (!vec[b].size()) continue; // 若这个块为空 sort(vec[b].begin(), vec[b].end(), [](auto a, auto b) { return a.b \u0026lt; b.b; // 把所有询问按照 b 的大小 sort 一下 }); init(); if (b \u0026gt; 1) { int R = (b-1) * B; // 前一个块的右端点 sort(edges+1, edges+R+1, cmpB); // 开始处理询问 int j = 0; for (Query que : vec[b]) { int qa = que.a, qb = que.b; // 先将前面的块满足条件的都加进去 while (j + 1 \u0026lt;= R \u0026amp;\u0026amp; edges[j+1].b \u0026lt;= qb) { unions(edges[j+1].from, edges[j+1].to, edges[j+1].a, edges[j+1].b); j++; } // 然后开始处理当前块 int curt = tail; // 记录当前 stack 的 tail 位置 for (int i = R+1; i \u0026lt;= min(b*B, ecnt); i++) { // 当前块 if (edges[i].a \u0026lt;= qa \u0026amp;\u0026amp; edges[i].b \u0026lt;= qb) { unions(edges[i].from, edges[i].to, edges[i].a, edges[i].b); } } int u = finds(que.u), v = finds(que.v); if (u == v \u0026amp;\u0026amp; amax[u] == qa \u0026amp;\u0026amp; bmax[u] == qb) { ans[que.id] = 1; } while (tail != curt) cancel(); // 退回当前块的所有操作 } } } for (int i = 1; i \u0026lt;= Q; i++) { cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   注意事项\n 在 unions(u,v,a,b) 时，无论 u,v 是否已经联通，都要更新 a,b。 可撤销并查集的栈只记录被更改的信息，其他的就不用记了。   例2 BZOJ4668 冷战 题意\n给定 $n$ 个点 和 $m$ 次询问。\n每次询问有两种格式：\n$0 ~ u ~ v$：将 $u,v$ 用一条边链接起来。\n$1 ~ u ~ v$：询问最早在加入哪条边以后，$u,v$ 在同一个联通块中。如果此时尚未联通，则输出 $0$。\n所有询问强制在线。\n其中，$n,m \\leq 5 \\times 10^5$。\n 题解 启发式合并并查集的题。\n第一反应是每次链接的时候，新建一个 parent 节点储存这是第几条边，然后把 $u', v'$ 作为它的两个 child。（$u',v'$ 是在 finds(u), finds(v) 得到的根节点）。类似于 kruskal 重构树的思路。\n然后每次询问 $1 ~ u ~ v$ 的时候，直接找到 LCA 位置的那个节点即可。\n 这样是正确的，不过有个更优雅的写法：\n注意到有效的链接只有 $(n-1)$ 次，普通的启发式合并刚好生成的就是一棵树，也不用新建节点了。直接启发式合并的时候，把当前是第几条边，记录在链接用的那一条树边上。\n这样，$(n-1)$ 条树边，刚好对应的就是 $(n-1)$ 次启发式合并。\n每次询问 $1 ~ u ~ v$ 的时候，直接暴力往上跳到 LCA，然后取边上的最大值即可。（就相当于 $u,v$ 之间链上的边权最大值）。\n由于启发式合并的性质，暴力跳 LCA 的时间是 $O(\\log n)$。\n所以复杂度就是 $O(n \\log n)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; int n,m, dep[maxn], par[maxn], sz[maxn], val[maxn]; int finds(int u) { if (par[u] == u) { dep[u] = 0; return u; } int res = finds(par[u]); dep[u] = dep[par[u]] + 1; return res; } void unions(int u, int v, int id) { u = finds(u), v = finds(v); if (u == v) return; if (sz[u] \u0026lt; sz[v]) swap(u,v); sz[u] += sz[v]; par[v] = u; val[v] = id; // 链接 (v,u) 的边权为 id } // 寻找 u,v 链上最大的值 int find_max(int u, int v) { if (finds(u) != finds(v)) return 0; if (dep[u] \u0026lt; dep[v]) swap(u,v); int res = 0; while (dep[u] \u0026gt; dep[v]) { res = max(res, val[u]); u = par[u]; } if (u == v) return res; while (u != v) { res = max({res, val[u], val[v]}); u = par[u]; v = par[v]; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { par[i] = i; sz[i] = 1; } int last = 0, id = 0; while (m--) { int op,u,v; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u ^= last, v ^= last; if (op == 0) { unions(u, v, ++id); } else { int res = find_max(u, v); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; last = res; } } }   ","date":"2021-12-27T18:43:41+08:00","permalink":"https://tom0727.github.io/post/062-%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["并查集",""],"title":"并查集"},{"categories":["算法"],"contents":"介绍 最短路径树是指一个图，在以 某个点 为根，跑出来单源最短路以后，形成的树结构。\n具体建树方法就是：在跑单源最短路的时候，用一个 pre[] 数组记录一下每个点的最短路径是从哪个点更新而来的即可。\n然后 pre[u] 就是 u 在最短路径树里的 parent 了。\n统计最短路径树的数量 注意到每个节点 $u$ 的 parent 不一定就是最短路径树中的那个parent，只要找到一个邻居 $v$，满足：\n$$dis[u] = dis[v] + w(v,u)$$\n那么这个 $v$ 也可以成为最短路径树中，$u$ 的parent。\n所以对于每个节点 $u$ 统计一下可能的 parent 数量 cnt[u]，然后把所有节点的 cnt[u] 乘起来即可得到答案。\n例1 洛谷P2934 [USACO09JAN]Safe Travel G 题意\n给定一个 $n$ 个节点，$m$ 条边的无向图（边带权），对于每个 $i \\in [2,n]$，求出在 不经过 原本 $1$ 节点到 $i$ 节点的最短路的最后一条边的前提下，$1 \\rightarrow i$ 的最短路。\n其中，$3 \\leq n \\leq 10^5, 2 \\leq m \\leq 2 \\times 10^5$。\n 题解 先说个假做法：对于每个 $i$，求 $\\min \\{d_u+w(u,i)\\}$，其中 $u$ 为 $i$ 的 neighbor 且不为原来最短路使用的那个 $u$。\n为什么假了？因为我们没有办法保证 $1\\rightarrow u$ 的最短路上有没有经过 $i$，如果经过了，它就有可能用到了不被允许使用的边。\n下面说正解。\n 对于本题，首先就是从 $1$ 开始求一个最短路，然后构建出来最短路径树。\n那么 $1$ 节点到 $i$ 节点的最短路就是树上的一条路径。\n现在我们只考虑这个最短路径树，如果 $1 \\rightarrow i$ 的最后一条边被断开了，那么 $1$ 与 $i$ 就会被分割在两个不同的联通块内。\n• 注意到每个联通块也是一棵树，$1$ 和 $i$ 分别是 2 个树的根节点。\n这意味着我们需要使用一条非树边将 $1$ 和 $i$ 所在的两个联通块重新链接起来。\n假设这条边是 $(u,v)$，那么新的 $1 \\rightarrow i$ 最短路就等于：\n$$d[u] + w(u,v) + d[v] - d[i]$$\n这里 $d[u]$ 指原先从 $1 \\rightarrow u$ 的最短路长度，注意到对于固定的 $i$，这个 $d[i]$ 是个常数。所以我们只关心\n$$d[u] + w(u,v) + d[v]$$\n我们会发现这个对于每条边 $(u,v)$ 也是个定值。\n那么现在我们只需要考虑，有哪些 $(u,v)$ 能对 $i$ 产生这样的贡献就行了。\n那么还是老套路，把点的问题转成链的问题，那么一个非树边 $(u,v,w)$ 就相当于把 $d[u] + w(u,v) + d[v]$ 的这个值赋最小值给 $(u,v)$ 路径（指树上路径）上的所有边。\n然后每个节点 $i$ 对应的就是 $(i, par[i])$ 这条边。\n所以用树剖维护链的更新和查询即可。\n• 注：为什么不直接更新点……我也没想明白？尝试了一下似乎会WA。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n,m; struct Edge { int from, to, nxt, w; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, d[maxn], pre[maxn]; bool vis[maxn]; void addEdge(int u, int v, int w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } struct Node { int u, dis; bool operator\u0026lt;(const Node\u0026amp; other) const { return dis \u0026gt; other.dis; } }; priority_queue\u0026lt;Node\u0026gt; pq; void dijkstra() { pq.push({1,0}); memset(d, 63, sizeof(d)); while (!pq.empty()) { auto nd = pq.top(); pq.pop(); int u = nd.u, dis = nd.dis; if (vis[u]) continue; vis[u] = 1; d[u] = dis; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w; if (d[v] \u0026gt; d[u] + w) { d[v] = d[u] + w; pre[v] = u; pq.push({v,d[v]}); } } } } struct Node2 { int to, w; }; vector\u0026lt;Node2\u0026gt; adj[maxn]; int dep[maxn], par[maxn], sz[maxn], son[maxn], top[maxn], id[maxn], ID, arr[maxn], ans[maxn]; void dfs1(int u, int p) { dep[u] = dep[p] + 1; par[u] = p; sz[u] = 1; for (Node2 nd : adj[u]) { int to = nd.to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; sz[son[u]]) son[u] = to; } } void dfs2(int u, int t) { id[u] = ++ID; top[u] = t; arr[ID] = 1e9; if (!son[u]) return; dfs2(son[u], t); for (Node2 nd : adj[u]) { int to = nd.to; if (to == par[u] || to == son[u]) continue; dfs2(to, to); } } struct Tree_Node { int mn = 1e9, lazy = 1e9; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].mn = min(tr[cur\u0026lt;\u0026lt;1].mn, tr[cur\u0026lt;\u0026lt;1|1].mn); } void push_down(int cur) { if (tr[cur].lazy == 1e9) return; int lazy = tr[cur].lazy; tr[cur].lazy = 1e9; int l = cur\u0026lt;\u0026lt;1, r = l+1; tr[l].lazy = min(tr[l].lazy, lazy); tr[l].mn = min(tr[l].mn, lazy); tr[r].lazy = min(tr[r].lazy, lazy); tr[r].mn = min(tr[r].mn, lazy); } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].lazy = min(tr[cur].lazy, x); tr[cur].mn = min(tr[cur].mn, x); return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) return tr[cur].mn; push_down(cur); int lres = 1e9, rres = 1e9; int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) lres = query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) rres = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return min(lres, rres); } void update_path(int u, int v, int x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, 1, n, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); if (id[u] + 1 \u0026lt;= id[v]) update(1, 1, n, id[u]+1, id[v], x); } int query_path(int u, int v) { int res = 1e9; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = min(res, query(1, 1, n, id[top[u]], id[u])); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); if (id[u] + 1 \u0026lt;= id[v]) res = min(res, query(1, 1, n, id[u]+1, id[v])); return res; } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); return u; } void rebuild() { for (int i = 2; i \u0026lt;= n; i++) { adj[i].push_back({pre[i], d[i] - d[pre[i]]}); adj[pre[i]].push_back({i, d[i] - d[pre[i]]}); } dfs1(1, 0); dfs2(1, 1); } void solve() { for (int e = 2; e \u0026lt; ecnt; e++) { int u = edges[e].from, v = edges[e].to, w = edges[e].w; if (pre[u] == v || pre[v] == u) continue; // 树边 update_path(u, v, d[v] + w + d[u]); } for (int u = 2; u \u0026lt;= n; u++) { int q = query_path(u, par[u]); ans[u] = -d[u] + q; cout \u0026lt;\u0026lt; (ans[u] \u0026gt; 1e8 ? -1 : ans[u]) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(ans, 63, sizeof(ans)); for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dijkstra(); rebuild(); solve(); }   例2 洛谷P2505 [HAOI2012]道路 题意\n给定 $n$ 个节点，$m$ 条边的有向图，边上有权值。\n对于每一条边，我们要统计有多少条最短路径经过了这条边。答案对 $10^9+7$ 取模。\n定义最短路径 $(u,v)$ 为：不存在路径上权值之和严格小于该最短路径的，从 $u$ 到 $v$ 的路径。\n其中，$n \\leq 1500, m \\leq 5000, w \\in [1,10000]$。\n 题解 看到 $n \\leq 1500$，我们想到枚举每一个最短路径的起点 $u$。\n也就是从 $1$ 到 $n$，分别为起点，总共跑 $n$ 次 dijkstra。\n每次跑一个 dijkstra，我们就可以得到以 $u$ 为起点的最短路径。\n这里我们不妨设以 $1$ 为起点。\n那么我们可以枚举每一条边，然后判断这条边被经过了多少次。\n对于一条边 $(u,v)$，它被经过的次数就等于：\n$1 \\rightarrow u$ 的最短路径条数 乘上 $\\sum (1 \\rightarrow x$ 的最短路径条数$)$，其中 $x$ 在 $v$ 的“子树”（应该叫子图）中。\n 所以我们设 $f_x$ 为：$1 \\rightarrow x$ 的最短路径条数。\n注意到，如果我们构建好 最短路径图（就是将保留所有满足 $dis[v] = dis[u] + w(v,u)$ 的边 $(v,u)$）后，这个最短路径图是一个 DAG。\n所以就可以跑 DAG 上的 DP了（用拓扑排序）。\n• 注意这个 DAG 是最短路径图！每个节点为起点的 dijkstra 所形成的最短路径图都各不相同！\n所以从 $1$ 出发跑拓扑排序（入度为 $0$ 开始），就可以求出 $1 \\rightarrow u$ 的最短路径条数。\n然后我们再将拓扑序列存下来，用拓扑序列反向跑一次 DP，就可以求出 $\\sum (1 \\rightarrow x$ 的最短路径条数$)$ （通过拓扑序的反序，将 $v$ 子图内的所有点加到 $v$ 上）。\n时间复杂度：每个点开始跑一个 dijkstra，然后跑两次拓扑排序，然后枚举每一个边，所以\n$$T(n) = n * (n \\log m + 2n + m) = O(n^2\\log m)$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1505; const int maxm = 5005; struct Edge { int u, v, nxt, w; } edges[maxm]; int head[maxn], ecnt = 1, n, m; void addEdge(int u, int v, int w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } struct Node { int v, d; bool operator\u0026lt;(const Node\u0026amp; other) const { return d \u0026gt; other.d; } }; int dis[maxn]; bool vis[maxn]; priority_queue\u0026lt;Node\u0026gt; pq; ll ans[maxm], dp1[maxn], dp2[maxn]; vector\u0026lt;int\u0026gt; tmp; int ind[maxn]; void dijkstra(int start) { while (pq.size()) pq.pop(); tmp.clear(); fill(dis, dis+maxn, 1e9); fill(vis, vis+maxn, 0); fill(dp1, dp1+maxn, 0); fill(dp2, dp2+maxn, 0); fill(ind, ind+maxn, 0); dis[start] = 0; pq.push({start, 0}); while (!pq.empty()) { int u = pq.top().v, d = pq.top().d; pq.pop(); if (vis[u]) continue; vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].v, w = edges[e].w; if (d + w \u0026lt; dis[v]) { dis[v] = d + w; pq.push({v, dis[v]}); } } } } vector\u0026lt;int\u0026gt; topo_seq; void topo(int start) { for (int e = 1; e \u0026lt;= m; e++) { int u = edges[e].u, v = edges[e].v, w = edges[e].w; if (dis[u] + w == dis[v]) ind[v]++; } tmp.clear(); topo_seq.clear(); tmp.push_back(start); topo_seq.push_back(start); dp1[start] = 1; while (tmp.size()) { int u = tmp.back(); tmp.pop_back(); for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].v, w = edges[e].w; if (dis[v] == dis[u] + w) { dp1[v] = (dp1[v] + dp1[u]) % mod; ind[v]--; if (!ind[v]) tmp.push_back(v), topo_seq.push_back(v); } } } // 反向 topo reverse(topo_seq.begin(), topo_seq.end()); for (int u : topo_seq) { dp2[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].v, w = edges[e].w; if (dis[v] == dis[u] + w) { dp2[u] = (dp2[u] + dp2[v]) % mod; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); } for (int i = 1; i \u0026lt;= n; i++) { dijkstra(i); topo(i); for (int e = 1; e \u0026lt;= m; e++) { int u = edges[e].u, v = edges[e].v, w = edges[e].w; if (dis[v] == dis[u] + w) { ans[e] = (ans[e] + dp1[u] * dp2[v] % mod) % mod; } } } for (int e = 1; e \u0026lt;= m; e++) { cout \u0026lt;\u0026lt; ans[e] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   参考链接  https://www.noobdream.com/post/1216/  ","date":"2021-12-24T18:19:49+08:00","permalink":"https://tom0727.github.io/post/061-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91/","tags":["最短路径树",""],"title":"最短路径树"},{"categories":["算法"],"contents":"介绍 最小生成树就是给定一张边有权值的图，求一个生成树使得边权和最小。\n最小生成树有着以下几个性质：\n 最小生成树不唯一，次小生成树可以通过枚举非树边 $(u,v)$，然后替换最小生成树上 $(u,v)$ 这条链上最大边来实现。 所有的最小生成树中，相同权值的边的数量一定相同。 所有的最小生成树中，对于任意的权值 $w$，如果把所有权值 $\\leq w$ 的边单独拿出来，那么构成的图的连通性均相同。  证明：\n如果不相同，那么这违背了第一条。因为拥有相同权值的次小生成树一定是通过替换一个相同权值的边实现的。（这一条其实也可以直接通过第三条结论得出）。 如果有两种不同的连通性 $G_1,G_2$，那么必然存在一对点 $(u,v)$ 使得 $(u,v)$ 在 $G_1$ 联通，而在 $G_2$ 中不联通。根据 kruskal，这说明我们可以在 $G_2$ 中想办法将 $(u,v)$ 连在一起（因为这样的边一定存在于 $G_1$ 当中）。这不可能发生，因为所有权值 $\\leq w$ 的都被拿出来了。   常用的算法 Prim 和 Kruskal 就不再赘述了。\nPrim 的思想主要是维护一个联通块，然后逐渐往这个块上加新的点。\nKruskal 的思想是将所有边按照边权 sort 一下，然后用并查集维护联通性防止环的产生。\n其实还有一个比较冷门的算法：Boruvka 算法\nBoruvka 算法 Boruvka 算法比较适合处理拥有特殊性质的 完全图。比如给定一种计算两点之间边权的方式，然后求最小生成树之类的。\n算法总共有 $O(\\log V)$ 轮。\n每一轮开始：\n 对于每一个连通块 $i$，我们都找出它与其他连通块的最小边 $(u_i,v_i,w_i)$。 对于每个联通块 $i$ 对应的最小边 $(u_i,v_i,w_i)$，尝试连接 $u$ 和 $v$，如果连接成功，就将连通块合并。  直到只剩下一个联通块。\n一般考察这个算法的时候，主要的难点都在于对于每一个联通块，找到它与其他联通块的最小边。\n然后因为每次合并，最坏都可以将连通块数量减半，所以最多只有 $O(\\log V)$ 轮。\n例1 洛谷P2619 [国家集训队]Tree I 题意\n给定一个 $n$ 个节点，$m$ 条边的无向联通带权图，每条边是黑色或者白色。\n给定非负整数 $k$，求一个刚好包含 $k$ 条白色边的最小生成树权值。\n其中，$n \\leq 5 \\times 10^4, m \\leq 10^5$，所有边权均为在 $[1,100]$ 之间的正整数。\n数据保证有解。\n 题解 wqs二分（虽然我并不知道这是什么神奇的算法）。\n这个算法针对的是 恰好选 $K$ 个，然后最大/最小化 某些值的问题。\n具体证明和相关例题以后再学习。\nwqs二分的主要思想是给这些 恰好选 $K$ 个 的物品，每个都加上一定的权值（可正可负），相当于 鼓励/打击 选取这种物品的行为，加上以后再跑原算法。\n然后根据原算法跑出来的结果（选取了多少个），然后用二分调整这个额外权值。\n 所以对于本题，就是给每个白色边添加一个权值，然后跑最小生成树，如果跑出来的最小生成树拥有 $\\geq k$ 条白色边，那么就将额外权值往大的那个方向二分（打击选取白边的行为），否则往小二分（鼓励选取白边）。\n那什么时候更新答案呢？\n我们应当在最小生成树跑出 $\\geq k$ 条白边时更新答案，而不是刚好等于 $k$！\n首先，我们不确定这个二分的过程是否会出现：额外权值等于 $x$ 时最小生成树有 $(k-1)$ 条白边，额外权值为 $(x+1)$ 时最小生成树有 $(k+1)$ 条白边 的情况。\n为什么有可能出现呢？\n因为最小生成树有可能不唯一！\n不过，既然数据保证了一定有解，我们不妨在所有答案中都尽可能的多选白边，那么对于真正的答案对应的额外权值 $x$，一定可以通过非严格的次小生成树来将一些白边替换成黑边，从而保证恰好选择了 $k$ 个白边。\n所以只要在最小生成树跑出 $\\geq k$ 条白边时更新答案即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 1e5+5; struct Edge { int from, to, nxt, w, c; bool operator\u0026lt;(const Edge\u0026amp; other) const { if (w == other.w) return c \u0026lt; other.c; return w \u0026lt; other.w; } } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v, int w, int c) { Edge e = {u, v, head[u], w, c}; head[u] = ecnt; edges[ecnt++] = e; } int n,m,k,par[maxn]; int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } bool unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return 0; par[v] = u; return 1; } Edge tmp[maxm\u0026lt;\u0026lt;1]; int ans = 1e9; // return true if cnt \u0026gt;= k bool kruskal(int delta) { for (int i = 1; i \u0026lt;= n; i++) par[i] = i; for (int i = 1; i \u0026lt; ecnt; i++) { tmp[i] = edges[i]; if (tmp[i].c == 0) tmp[i].w += delta; } sort(tmp+1, tmp+ecnt); int res = 0, cnt = 0, allcnt = 0; for (int i = 1; i \u0026lt; ecnt; i++) { int u = tmp[i].from, v = tmp[i].to; if (finds(u) == finds(v)) continue; unions(u,v); res += tmp[i].w; if (tmp[i].c == 0) cnt++; allcnt++; if (allcnt == n-1) break; } if (cnt \u0026gt;= k) ans = res - k * delta; return cnt \u0026gt;= k; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w,c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; c; u++; v++; addEdge(u,v,w,c); addEdge(v,u,w,c); } int low = -200, high = 200; while (high - low \u0026gt;= 10) { int mid = (low + high) / 2; if (kruskal(mid)) { low = mid+1; } else { high = mid-1; } } for (int mid = low; mid \u0026lt;= high; mid++) kruskal(mid); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF888G Xor-MST 题意\n给定 $n$ 个节点的无向完全图。每个点有点权 $a_i$。\n连接 $i,j$ 节点的边权为 $a_i \\text{ xor } a_j$。\n求这个图的最小生成树权值。\n其中，$n \\leq 2 \\times 10^5, a_i \\in [0,2^{30})$。\n 法一 Boruvka算法 Boruvka 算法。\n为什么它可做呢？因为它的合并操作只有 $O(\\log n)$ 轮。\n而每一轮操作需要找所有联通块向其他联通块连边的最小边。\n如果我们正在处理联通块 $i$，那么要找这个最小边，实际上只要维护一个 01-Trie 来包含所有的点权，然后：\n 先将联通块 $i$ 内的所有元素从 01-Trie 中删除。 然后对于联通块内的每一个元素 $a_j$，都找 01-Trie 内 XOR 起来最小的那个元素。 这说明这个联通块的最小边找到了，我们再把块内所有元素 插入回 01-Trie（保证这个 01-Trie 里面维护的始终是所有的点权）。  找到所有联通块 $i$ 对应的最小边以后，开始连边操作。这样，一轮就结束了。\n时间复杂度 $O(n \\log n \\log 2^{30})$，虽然有点慢，但是可过。\n 不过这题有个问题，如果有的点权值重复了怎么办？\n因为我们在 01-Trie 中寻找到的是一个 XOR 起来最小的点权，但这个点权对应的点可能不唯一。\n思考后可以发现，我们先把所有相同的点权全都连起来就好了，毕竟它们之间的边权为 $0$，一定是在最小生成树里的。\n然后所有点权相同的点一定在一个联通块内了，我们用一个 map 把一个点权 map 到它们之中的任意一个点即可。\n 法一 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int M = 31; struct Node { int cnt; int child[2]; } trie[maxn * (M+1)]; int id = 1; void insert(int x) { int c = 1; for (int i = M; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; } } void erase(int x) { int c = 1; for (int i = M; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); c = trie[c].child[k]; trie[c].cnt--; } } // query the minimum xor inside the tree int query(int x) { int res = 0, c = 1; for (int i = M; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); if (trie[trie[c].child[k]].cnt == 0) { res |= (1LL\u0026lt;\u0026lt;i); c = trie[c].child[k^1]; } else { c = trie[c].child[k]; } } return res; } bool root[maxn]; // is root int par[maxn]; int n, a[maxn]; vector\u0026lt;int\u0026gt; child[maxn]; // children of root x in dsu int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u); v = finds(v); if (u == v) return; if (child[u].size() \u0026lt; child[v].size()) swap(u,v); par[v] = u; root[v] = 0; while (child[v].size()) { int r = child[v].back(); child[v].pop_back(); child[u].push_back(r); } } map\u0026lt;int,int\u0026gt; mp; ll minval[maxn]; pii link[maxn]; // 用于储存对应的最小边 void boruvka() { int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) if (root[i]) cnt++; ll ans = 0; while (cnt \u0026gt; 1) { for (int i = 1; i \u0026lt;= n; i++) { minval[i] = -1; link[i] = {-1,-1}; if (root[i]) { for (int u : child[i]) erase(a[u]); minval[i] = 4e9; for (int u : child[i]) { int res = query(a[u]); if (res \u0026lt; minval[i]) { minval[i] = res; int v = mp[res ^ a[u]]; link[i] = {u, v}; } } for (int u : child[i]) insert(a[u]); } } for (int i = 1; i \u0026lt;= n; i++) { if (root[i]) { int u = link[i].first, v = link[i].second; if (finds(u) != finds(v)) { ans += (a[u] ^ a[v]); unions(u, v); cnt--; } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } sort(a+1, a+n+1); for (int i = 1; i \u0026lt;= n; i++) { par[i] = i; root[i] = 1; child[i].push_back(i); mp[a[i]] = i; insert(a[i]); } for (int i = 2; i \u0026lt;= n; i++) { if (a[i] == a[i-1]) unions(i, i-1); } boruvka(); }   法二 01-Trie 子树合并 另外一种做法更加优雅，并且它充分利用了 01-Trie 的特点。\n首先我们把所有的 $a_i$ 插入进 01-Trie，看一下 01-Trie 的结构：\n然后我们有几个性质：\n 每个叶子节点都是原数组里的 $a_i$。 拥有 $2$ 个 child 的节点恰好有 $(n-1)$ 个。 两个数字 $a_u,a_v$ 若位于两个叶子节点 $u,v$，设 $x=LCA(u,v)$，那么它们 XOR 起来的值可以忽略掉 $x$ 上面的部分，只用考虑 $x$ 子树内的部分即可。设 $x$ 所在的高度（叶子的高度为 $0$）为 $m$，则 $a_u \\text{ xor } a_v$ 对答案的贡献至少为 (1\u0026lt;\u0026lt;m)。  这些性质说明了什么？首先 拥有 $2$ 个 child 的节点恰好有 $(n-1)$ 个，我们可以发现构建一棵最小生成树所需的合并次数刚好也是 $(n-1)$ 次，所以我们每次加入一条边进入MST的过程其实就是这样的 child 合并左右两个子树的过程。\n并且因为深度越深的节点带来的贡献越小，所以我们应该先合并深度较深的节点。\n那么找到这些节点的话，其实只要在 01-Trie 上跑一个 DFS 即可。\n 当我们到节点 $x$ 的时候，有三种情况：\n 只有 左child，那么就接着 DFS 左child。 只有 右child，那么就接着 DFS 右child。 有 左右child，那么就 DFS 左child 和 右child，然后给答案加上 (1\u0026lt;\u0026lt;m)，最后加上 $a_u \\text{ xor } a_v$ 的最小值，其中 $u$ 在左子树内，$v$ 在右子树内。   最后剩下的问题就在于，如何求：\n$a_u \\text{ xor } a_v$ 的最小值，其中 $u$ 在左子树内，$v$ 在右子树内？\n想想并查集的启发式合并，对于较小的那个子树，我们枚举子树内的每一个元素 $a_u$，然后在较大的那个子树内查询 XOR 值最小的那个元素即可。\n那就有两个问题：\n 如何遍历子树内的每一个元素？ 如何在一个子树内查询 XOR 最小值？  回答第一个问题：我们一开始把所有的 $a_i$ sort一下，然后根据 01-Trie 的性质，每个子树就会对应到原数组的一个区间了，就可以得到子树内的元素列表了。\n回答第二个问题：和普通查询一样，只不过改一下在 01—Trie 内的起点即可，同时维护一下当前所在的深度。\n 法二 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int M = 31; struct Node { int cnt; int child[2]; int L = 1e9, R = -1; } trie[maxn * (M+1)]; int id = 1; void insert(int idx, int x) { int c = 1; for (int i = M; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; trie[c].L = min(trie[c].L, idx); trie[c].R = max(trie[c].R, idx); } } int query(int c, int x, int m) { int res = 0; for (int i = m; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); if (trie[trie[c].child[k]].cnt == 0) { res |= (1LL\u0026lt;\u0026lt;i); c = trie[c].child[k^1]; } else { c = trie[c].child[k]; } } return res; } int n, a[maxn]; ll dfs(int c, int m) { int lc = trie[c].child[0], rc = trie[c].child[1]; int lcnt = trie[trie[c].child[0]].cnt, rcnt = trie[trie[c].child[1]].cnt; ll ans = 0; if (lcnt \u0026amp;\u0026amp; rcnt) { ans += dfs(lc, m-1); ans += dfs(rc, m-1); ans += (1LL \u0026lt;\u0026lt; m); int mn = INT_MAX; if (trie[lc].R - trie[lc].L \u0026lt; trie[rc].R - trie[rc].L) { for (int nc = trie[lc].L; nc \u0026lt;= trie[lc].R; nc++) { mn = min(mn, query(rc, a[nc], m-1)); } } else { for (int nc = trie[rc].L; nc \u0026lt;= trie[rc].R; nc++) { mn = min(mn, query(lc, a[nc], m-1)); } } ans += mn; } else if (lcnt) { return dfs(lc, m-1); } else if (rcnt) { return dfs(rc, m-1); } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } sort(a+1, a+n+1); for (int i = 1; i \u0026lt;= n; i++) { insert(i, a[i]); } ll ans = dfs(1, M); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P4180 [BJWC2010]严格次小生成树 题意\n给定一个无向联通图，求其严格次小生成树的权值。\n定义严格次小生成树为：一个权值第二小的生成树，且权值严格大于最小生成树的权值。\n其中，$n \\leq 10^5, m \\leq 3 \\times 10^5$，边权 $\\leq 10^9$，数据保证严格次小生成树一定存在。\n 题解 次小生成树有两种：\n 非严格次小生成树（权值不一定严格大于最小生成树） 严格次小生成树  方法都是一样的，先求出最小生成树，然后枚举每一条 不在 最小生成树上的边 $(u,v)$，然后求最小生成树上 $u,v$ 之间链的最大值，然后把那个边换成这条新的边即可。\n树上链的最大值可以用倍增或者树剖。\n这种方法只能求出非严格次小生成树。\n对于严格次小生成树，只要我们维护链的最大值和次大值（保证次大值严格小于最大值）即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 3e5+5; struct Edge { int from, to, nxt, w; bool operator\u0026lt;(const Edge\u0026amp; other) const { return w \u0026lt; other.w; } } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, m, par[maxn]; void addEdge(int u, int v, int w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } bool used[maxm\u0026lt;\u0026lt;1]; int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return; par[v] = u; } struct Node { int to; int w; }; vector\u0026lt;Node\u0026gt; adj[maxn]; ll kruskal() { for (int i = 1; i \u0026lt;= n; i++) par[i] = i; sort(edges+2, edges+ecnt); int cnt = 0; ll res = 0; for (int i = 2; i \u0026lt; ecnt; i++) { int u = edges[i].from, v = edges[i].to; if (finds(u) == finds(v)) continue; unions(u,v); used[i] = used[i^1] = 1; adj[u].push_back({v, edges[i].w}); adj[v].push_back({u, edges[i].w}); res += (ll)edges[i].w; cnt++; if (cnt == n-1) break; } return res; } int p[maxn][18], dep[maxn]; pii val[maxn][18]; inline void update(pii\u0026amp; p1, pii p2) { static int tmp[4]; tmp[0] = p1.first, tmp[1] = p1.second, tmp[2] = p2.first, tmp[3] = p2.second; sort(tmp, tmp+4, greater\u0026lt;int\u0026gt;()); p1.first = tmp[0]; for (int i = 1; i \u0026lt; 4; i++) { if (tmp[i] != tmp[0]) { p1.second = tmp[i]; break; } } } void dfs(int u, int pa) { for (int j = 1; j \u0026lt;= 17; j++) { p[u][j] = p[p[u][j-1]][j-1]; if (p[u][j]) { pii p1 = val[u][j-1], p2 = val[p[u][j-1]][j-1]; update(p1, p2); val[u][j] = p1; } else { val[u][j] = {-1,-1}; } } for (Node nd : adj[u]) { int v = nd.to, w = nd.w; if (v == pa) continue; p[v][0] = u; val[v][0] = {w, -1}; dep[v] = dep[u] + 1; dfs(v, u); } } // 查询 u,v 之间的最大值和次大值 pii query(ll u, ll v) { pii res = {-1,-1}; if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; for (int j = 17; j \u0026gt;= 0; j--) { if (d \u0026amp; (1\u0026lt;\u0026lt;j)) { update(res, val[u][j]); u = p[u][j]; } } if (u == v) return res; for (int j = 17; j \u0026gt;= 0; j--) { if (p[u][j] != p[v][j]) { update(res, val[u][j]); update(res, val[v][j]); u = p[u][j], v = p[v][j]; } } update(res, val[u][0]); update(res, val[v][0]); return res; } ll solve(ll res) { int mn = 1e9+7; val[1][0] = {-1,-1}; dfs(1, 0); for (int i = 2; i \u0026lt; ecnt; i++) { if (used[i]) continue; int w = edges[i].w; int u = edges[i].from, v = edges[i].to; pii r = query(u,v); if (w != r.first) { mn = min(mn, w - r.first); } else if (w != r.second \u0026amp;\u0026amp; r.second \u0026gt;= 0) mn = min(mn, w - r.second); } return res + mn; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u == v) continue; addEdge(u,v,w); addEdge(v,u,w); } ll res = kruskal(); ll ans = solve(res); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例4 CF160D Edges in MST 题意\n给定一个 $n$ 个节点的无向图，有 $m$ 条带权边。\n对于每一条边，都回答它属于以下的哪种情况：\n 一定在所有 MST（最小生成树）上。 一定在至少一个 MST 上。 不可能在任何 MST 上。  其中，$n \\leq 10^5, m \\in [n-1, \\min(10^5, \\frac{n(n-1)}{2})]$。\n数据保证无自环和重边。\n 题解 先求出一棵 MST。\n然后对于每个非树边 $(u,v,w)$，要么为 $2$，要么为 $3$。\n那么和非严格次小生成树的求法一样，只要求一下 $(u,v)$ 在树上的路径中，最大的权值是否等于 $w$ 即可。如果等于就是 $2$，否则是 $3$。\n 对于每个树边，要么为 $1$，要么为 $2$。\n那么其实只要判断是否存在一条非树边，能够将它替换掉即可。\n所以在处理每个非树边 $(u,v,w)$ 时，把 $(u,v)$ 在树上的这条路径全部赋最小值 $w$，全部非树边处理完毕后，查看一下这个树边被覆盖的最小值是多少，如果等于树边的权值就是 $2$，否则就一定大于这个权值，所以是 $1$。\n 那么路径上的询问，还有赋值，都可以用树剖解决，注意一下维护的是链而不是点，所以要特别处理一下 $LCA(u,v)$。\n 注意点\n一开始求 MST 的时候不需要建双向边，因为整个边的数组被 sort 了，所以后面处理一个边是否是树边的时候会比较麻烦。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e5+5; int n,m,head[maxn],ecnt = 2, pa[maxn]; struct Edge { int from, to, nxt, w, id; bool operator\u0026lt;(const Edge\u0026amp; other) const { return w \u0026lt; other.w; } } edges[maxm]; bool used[maxm]; void addEdge(int u, int v, int w, int id) { Edge e = {u, v, head[u], w, id}; head[u] = ecnt; edges[ecnt++] = e; } int finds(int u) { if (pa[u] == u) return u; return pa[u] = finds(pa[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return; pa[v] = u; } void kruskal() { sort(edges+2, edges+ecnt); for (int i = 1; i \u0026lt;= n; i++) pa[i] = i; int cnt = 0; for (int i = 2; i \u0026lt; ecnt; i++) { int u = edges[i].from, v = edges[i].to; if (finds(u) == finds(v)) continue; int w = edges[i].w; unions(u,v); used[i] = 1; cnt++; if (cnt == n-1) break; } } struct Node { int to, w; }; vector\u0026lt;Node\u0026gt; adj[maxn]; int dep[maxn], par[maxn], sz[maxn], son[maxn], top[maxn], id[maxn], ID, val[maxn], arr[maxn]; void dfs1(int u, int p) { dep[u] = dep[p] + 1; par[u] = p; sz[u] = 1; int maxsz = -1; for (Node nd : adj[u]) { int v = nd.to, w = nd.w; if (v == p) continue; dfs1(v, u); val[v] = w; sz[u] += sz[v]; if (sz[v] \u0026gt; maxsz) { son[u] = v; maxsz = sz[v]; } } } void dfs2(int u, int t) { id[u] = ++ID; top[u] = t; arr[ID] = val[u]; if (!son[u]) return; dfs2(son[u], t); for (Node nd : adj[u]) { int v = nd.to; if (v == par[u] || v == son[u]) continue; dfs2(v, v); } } struct Tree_Node { int mn = 1e9+7, w = 1e9+7; int lazyw = 1e9+7; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; tr[cur].mn = max(tr[l].mn, tr[r].mn); tr[cur].w = min(tr[l].w, tr[r].w); } void push_down(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; if (tr[cur].lazyw \u0026lt; 1e9) { tr[l].lazyw = min(tr[cur].lazyw, tr[l].lazyw); tr[l].w = min(tr[cur].lazyw, tr[l].w); tr[r].lazyw = min(tr[cur].lazyw, tr[r].lazyw); tr[r].w = min(tr[cur].lazyw, tr[r].w); tr[cur].lazyw = 1e9+7; } } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].lazyw = min(tr[cur].lazyw, x); tr[cur].w = min(tr[cur].w, x); return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // op = 0: query mn (初始值) // op = 1: query w (非树边给的值) int query(int cur, int l, int r, int L, int R, int op, bool ismax) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { if (op == 0) return tr[cur].mn; if (op == 1) return tr[cur].w; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int lres, rres; if (ismax) lres = -1, rres = -1; else lres = 1e9+7, rres = 1e9+7; if (L \u0026lt;= mid) { lres = query(cur\u0026lt;\u0026lt;1, l, mid, L, R, op, ismax); } if (R \u0026gt; mid) { rres = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, op, ismax); } push_up(cur); if (ismax) return max(lres, rres); else return min(lres, rres); } void build_tree(int cur, int l, int r) { if (l == r) { tr[cur].mn = arr[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build_tree(cur\u0026lt;\u0026lt;1, l, mid); build_tree(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void rebuild() { for (int i = 2; i \u0026lt; ecnt; i++) { if (used[i]) { int u = edges[i].from, v = edges[i].to, w = edges[i].w; adj[u].push_back({v,w}); adj[v].push_back({u,w}); } } val[1] = 1e9+7; dfs1(1, 0); dfs2(1, 1); } // update the w void update_path(int u, int v, int x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, 1, n, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); if (id[u] + 1 \u0026lt;= id[v]) update(1, 1, n, id[u]+1, id[v], x); } int query_path(int u, int v, int op, bool ismax) { int res; if (ismax) res = -1; else res = 1e9+7; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); if (ismax) res = max(res, query(1, 1, n, id[top[u]], id[u], op, ismax)); else res = min(res, query(1, 1, n, id[top[u]], id[u], op, ismax)); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); if (id[u] + 1 \u0026lt;= id[v]) { if (ismax) res = max(res, query(1, 1, n, id[u]+1, id[v], op, ismax)); else res = min(res, query(1, 1, n, id[u]+1, id[v], op, ismax)); } return res; } int ans[maxn]; void solve() { for (int i = 2; i \u0026lt; ecnt; i++) { if (!used[i] \u0026amp;\u0026amp; !ans[edges[i].id]) { int u = edges[i].from, v = edges[i].to, w = edges[i].w; int res = query_path(u,v,0,1); if (res == w) { ans[edges[i].id] = 2; } else ans[edges[i].id] = 3; update_path(u,v,w); } } for (int i = 2; i \u0026lt; ecnt; i++) { if (used[i] \u0026amp;\u0026amp; !ans[edges[i].id]) { int u = edges[i].from, v = edges[i].to, w = edges[i].w; int res = query_path(u,v,1,0); if (res == w) ans[edges[i].id] = 2; else ans[edges[i].id] = 1; } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w,i); } kruskal(); rebuild(); build_tree(1, 1, n); solve(); for (int i = 1; i \u0026lt;= m; i++) { if (ans[i] == 1) cout \u0026lt;\u0026lt; \u0026quot;any\\n\u0026quot;; if (ans[i] == 2) cout \u0026lt;\u0026lt; \u0026quot;at least one\\n\u0026quot;; if (ans[i] == 3) cout \u0026lt;\u0026lt; \u0026quot;none\\n\u0026quot;; } }   例5 CF891C Envy 题意\n给定一个 $n$ 个点，$m$ 条边的无向联通图，每个边有边权 $w_i$。\n现在给定 $q$ 个询问，每次询问 $k_i$ 条边 $e_1,e_2,\u0026hellip;,e_{k_i}$。\n对于每个询问，我们需要回答这些边是否能存在于同一个最小生成树当中。\n其中，$n,m,q,w_i \\leq 5 \\times 10^5$。\n并且保证所有询问中，询问的边数的总和不超过 $5 \\times 10^5$。\n 题解 由最小生成树的性质第二条和第三条，我们可以发现不同权值的边之间不会互相影响。\n所以我们考虑按照权值分开来处理。\n换而言之，我们不再按照每个询问来回答，而是把每个询问中的权值相同的边都拿出来分别处理。这样，问题就变成了：\n 给定一些权值相同（均为 $w$）的边，判断这些边是否能存在于同一个 MST 中？\n 根据 MST 性质的第三条，我们只需要处理出最小生成树中 权值严格小于 $w$ 的边的连通性。然后判断一下这些边在当前联通图下，是否都能够 unions() 即可。处理完当前询问，就用可撤销并查集退回。\n所以，我们只要把每个询问中所有权值相同的边都拿出来，然后从小到大开始跑 kruskal，跑的过程中回答当前权值的询问即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; const int maxm = 5e5+5; struct Edge { int u, v, w; } edges[maxm], edges_tmp[maxm]; struct Query { int id; vector\u0026lt;int\u0026gt; vec; }; struct State { int u, v, szu; }; int par[maxn], sz[maxn]; State st[maxn]; int tail = 0; int finds(int u) { if (par[u] == u) return u; return finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); if (u == v) return; st[++tail] = {u, v, sz[u]}; par[v] = u; sz[u] += sz[v]; } void cancel() { int u = st[tail].u, v = st[tail].v; par[v] = v; sz[u] = st[tail].szu; tail--; } int n, m, q; bool ans[maxn]; vector\u0026lt;Query\u0026gt; val_query[maxn]; // val_query[i]: 询问权值为 i 的 int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; edges[i].u \u0026gt;\u0026gt; edges[i].v \u0026gt;\u0026gt; edges[i].w; edges_tmp[i] = edges[i]; } sort(edges_tmp+1, edges_tmp+m+1, [](auto a, auto b) { return a.w \u0026lt; b.w; }); cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= q; i++) { int k; cin \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; tmp; for (int j = 1; j \u0026lt;= k; j++) { int e; cin \u0026gt;\u0026gt; e; tmp.push_back(e); } sort(tmp.begin(), tmp.end(), [\u0026amp;](auto a, auto b) { return edges[a].w \u0026lt; edges[b].w; }); for (int j = 0; j \u0026lt; k; j++) { int e = tmp[j]; int w = edges[tmp[j]].w; if (j == 0 || edges[tmp[j]].w != edges[tmp[j-1]].w) { val_query[w].push_back({i, vector\u0026lt;int\u0026gt;()}); } val_query[w].back().vec.push_back(e); } } fill(ans+1, ans+q+1, 1); int pt = 0; for (int w = 1; w \u0026lt;= 5e5; w++) { for (Query que : val_query[w]) { int id = que.id; int curt = tail; for (int e : que.vec) { int u = edges[e].u, v = edges[e].v; if (finds(u) == finds(v)) { ans[id] = 0; break; } unions(u,v); } while (tail != curt) { cancel(); } } while (pt + 1 \u0026lt;= m \u0026amp;\u0026amp; edges_tmp[pt+1].w == w) { pt++; Edge ce = edges_tmp[pt]; int u = ce.u, v = ce.v; if (finds(u) != finds(v)) unions(u,v); } } for (int i = 1; i \u0026lt;= q; i++) { cout \u0026lt;\u0026lt; (ans[i] ? \u0026quot;YES\u0026quot; : \u0026quot;NO\u0026quot;) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   参考链接  Boruvka算法：https://luckyglass.github.io/2019/19Oct31stArt1/   ","date":"2021-12-21T21:33:24+08:00","permalink":"https://tom0727.github.io/post/060-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","tags":["最小生成树",""],"title":"最小生成树"},{"categories":["算法"],"contents":"介绍 01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。\nTrie可以解决以下问题：\n  给定一些数 $a_1,a_2,\u0026hellip;,a_n$，给定 $x$，求 $a_i$，使得 $a_i \\text{ xor } x$ 最大。\n  维护异或和：给定一些数，支持全体加一，插入数字，删除数字，求全体异或和等操作。\n  Trie可以将数字从低位到高位储存，也可以反过来，根据具体题目而定。\n为了方便，我们在写 01Trie 的时候都会把每个数补成同样的位数。\n• 注意 id = 1 的是 Root，所以 id 要从 $1$ 开始。\n维护最大XOR 指第一个例子，这里我们的 01Trie 将会 从高位到低位 储存。\n在给定一个查询 $x$ 时，我们从 $x$ 的高位开始看，设当前到了第 $i$ 位，那么我们看第 $i$ 位的bit $a_i$，然后判断一下第 $i$ 位的值为 a[i] ^ 1 的数字是否存在即可，如果存在，往那个方向走，否则往另外一个方向走。\n板子 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int id = 1; // 注意，从 1 开始 struct Node { int cnt = 0; int child[2]; } trie[maxn\u0026lt;\u0026lt;4]; void insert(int x) { int c = 1; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; } } // 求 trie中的一个数 a_i, 使得 a_i ^ x 最大 int query(int x) { int c = 1; int res = 0; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; k ^= 1; if (trie[c].child[k]) { c = trie[c].child[k]; res |= (1\u0026lt;\u0026lt;j); } else { c = trie[c].child[k^1]; } } return res; }   维护XOR和 指第二个例子，这里我们的 01Trie 从低位到高位储存。\n要维护异或和，我们只需要知道每一位上 $0$ 和 $1$ 个数的奇偶性即可。\n对于每一个节点，我们记录三个量：\n 两个子节点的编号 w：指当前这个节点，到它的parent这条边 $(p,u)$ 上，被经过的次数。每有一个数字在插入过程中经过这个边，这个 w 就会加一。 val：指以当前节点为根，它子树内包含的所有数字的 XOR和。  所以维护信息的时候就有：\nvoid push_up(int cur) { trie[cur].val = trie[cur].w = 0; // 先清空 int c0 = trie[cur].child[0], c1 = trie[cur].child[1]; // 更新 w if (c0) trie[cur].w += trie[c0].w; if (c1) trie[cur].w += trie[c1].w; // 更新 val if (c0) { trie[cur].val ^= (trie[c0].val \u0026lt;\u0026lt; 1); } if (c1) { trie[cur].val ^= ((trie[c1].val \u0026lt;\u0026lt; 1) | (trie[c1].w \u0026amp; 1)); // 如果 c1 的 w 为奇数，就提供了 1 的贡献 } }  解释: 注意是从低位到高位储存的，所以子树内储存的只是数字的二进制的一部分。\n所以要把 val 进行左移。\n也就是说，实际上只有 根节点 的 val 是真正有意义的，因为只有根节点才记录的是完整的数字的 XOR和。\n 插入和删除就不提了，看代码即可。注意插入删除合并起来，可以达成单点修改的效果。\n最后说一下全局加一。\n全局加一指的是将整个01Trie维护的所有数字都加一。\n在二进制下的加一，相当于从低位到高位找第一个出现的 $0$，然后将其变成 $1$。\n最后，比这一位低的所有位都将会从 $1$ 变成 $0$。\n// add 1 to all numbers maintained by cur void addall(int cur) { swap(trie[cur].child[0], trie[cur].child[1]); if (trie[cur].child[0]) { addall(trie[cur].child[0]); } push_up(cur); }  板子 const int M = 21; // 最大深度 int id = 0; struct Node { int w; // 到 parent 这条边上的个数 int val; // subtree 内的XOR和 int child[2]; } trie[maxn*(M+1)]; void push_up(int cur) { trie[cur].val = trie[cur].w = 0; // 先清空 int c0 = trie[cur].child[0], c1 = trie[cur].child[1]; // 更新 w if (c0) trie[cur].w += trie[c0].w; if (c1) trie[cur].w += trie[c1].w; // 更新 val if (c0) { trie[cur].val ^= (trie[c0].val \u0026lt;\u0026lt; 1); } if (c1) { trie[cur].val ^= ((trie[c1].val \u0026lt;\u0026lt; 1) | (trie[c1].w \u0026amp; 1)); // 如果 c1 的 w 为奇数，就提供了 1 的贡献 } } // cur: index, x: 当前的数字, dep: 深度 void insert(int\u0026amp; cur, int x, int dep) { if (!cur) cur = ++id; if (dep \u0026gt;= M) { trie[cur].w++; // w += 1 return; } int c = x \u0026amp; 1; insert(trie[cur].child[c], (x\u0026gt;\u0026gt;1), dep+1); push_up(cur); } void del(int\u0026amp; cur, int x, int dep) { if (!cur) cur = ++id; if (dep \u0026gt;= M) { trie[cur].w--; // w -= 1 return; } int c = x \u0026amp; 1; insert(trie[cur].child[c], (x\u0026gt;\u0026gt;1), dep+1); push_up(cur); } // add 1 to all numbers maintained by cur void addall(int cur) { swap(trie[cur].child[0], trie[cur].child[1]); if (trie[cur].child[0]) { addall(trie[cur].child[0]); } push_up(cur); }   可持久化01-Trie 和主席树相似，可持久化01-Trie主要是为了让我们获得任何一个区间 $[L,R]$ 内组成的 01-Trie。\n使用 Node 的 cnt 来决定 01-Trie 的内容。\n板子 const int maxn = 6e5+5; const int M = 28; struct Node { int cnt; int child[2]; } trie[maxn * (M+3)]; int n, q, root[maxn], a[maxn], id; void insert(int pre, int cur, int x) { for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; trie[cur].cnt = trie[pre].cnt + 1; // cnt 加一 if (!trie[cur].child[c]) trie[cur].child[c] = ++id; // 新建节点 trie[cur].child[c^1] = trie[pre].child[c^1]; // 复制另外一个子节点 cur = trie[cur].child[c]; pre = trie[pre].child[c]; } trie[cur].cnt = trie[pre].cnt + 1; } // find the maximum value for a ^ x (a is in [pre, cur]) int query(int pre, int cur, int x) { int res = 0; for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; c ^= 1; if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) { // cnt \u0026gt; 0 cur = trie[cur].child[c]; pre = trie[pre].child[c]; res |= (1\u0026lt;\u0026lt;i); } else { cur = trie[cur].child[c^1]; pre = trie[pre].child[c^1]; } } return res; } int main() { for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum[i] = sum[i-1] ^ a[i]; if (!root[i]) root[i] = ++id; insert(root[i-1], root[i], sum[i]); } // 查询 [L,R] -\u0026gt; (l-1,r) int res = query(root[max(0,l-1)], root[r], x); }   例题 例1 洛谷P4551 最长异或路径 题意\n给定一个 $n$ 个节点的树，边上有权值。\n寻找树上的两个节点，使得路径上的边权 XOR和 最大，输出这个最大值。\n其中，$n \\leq 10^5$。\n 题解 常见套路：设 $f_x$ 为从 $1$（根节点）到 $x$ 的路径上的 XOR和。\n那么 $(u,v)$ 路径上的 XOR和 就等于 $f_u \\text{ xor } f_v$。因为 $1$ 到 $LCA(u,v)$ 的部分被抵消掉了。\n所以就相当于建立一个 01Trie，储存所有的 $f_u$，然后对于每个 $u$，都询问一下最大的XOR即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const ll mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 30; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } int dp[maxn]; void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] = dp[u] ^ edges[e].w; dfs(to, u); } } int id = 1; struct Node { int cnt = 0; int child[2]; } trie[maxn\u0026lt;\u0026lt;4]; void insert(int x) { int c = 1; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; } } int query(int x) { int c = 1; int res = 0; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; k ^= 1; if (trie[c].child[k]) { c = trie[c].child[k]; res |= (1\u0026lt;\u0026lt;j); } else { c = trie[c].child[k^1]; } } return res; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0); for (int i = 1; i \u0026lt;= n; i++) insert(dp[i]); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = max(ans, query(dp[i])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF817E Choosing The Commander 题意\n给定 $q$ 个询问，共有3种：\n$1 ~ p$：将 $p$ 加入集合。\n$2 ~ p$：将 $p$ 从集合中删除。\n$3 ~ p ~ l$：询问集合中有多少个元素在 XOR $p$ 之后小于 $l$。\n其中，$q \\leq 10^5$。\n 题解 在 01-Trie 每个节点处加上一个 count 就可以了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 27; int Q, id = 1; struct Node { int child[2]; int cnt = 0; } trie[maxn\u0026lt;\u0026lt;3]; void insert(int x) { int c = 1; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; } } void del(int x) { int c = 1; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt--; } } int query(int p, int l) { int c = 1; int res = 0; for (int j = maxm; j \u0026gt;= 0; j--) { if (l \u0026amp; (1\u0026lt;\u0026lt;j)) { // 如果这一位有，说明要往这一位为 1 的方向走 int k = ((p \u0026amp; (1\u0026lt;\u0026lt;j)) \u0026gt; 0); res += trie[trie[c].child[k]].cnt; if (trie[trie[c].child[k^1]].cnt) c = trie[c].child[k^1]; else break; } else { // 如果这一位没有，就往 0 的方向走 int k = ((p \u0026amp; (1\u0026lt;\u0026lt;j)) \u0026gt; 0); if (trie[trie[c].child[k]].cnt) c = trie[c].child[k]; else break; } } return res; } int main() { fastio; cin \u0026gt;\u0026gt; Q; while (Q--) { int op, p, l; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; p; if (op == 1) { insert(p); } else if (op == 2) { del(p); } else { cin \u0026gt;\u0026gt; l; int res = query(p,l); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例3 洛谷P6018 [Ynoi2010] Fusion tree 题意\n给定一棵 $n$ 个节点的树，每个节点 $i$ 上有权值，初始权值为 $a_i$。\n给出 $m$ 个询问，询问的类型有3种：\n$1 ~ x$：将所有与节点 $x$ 距离为 $1$ 的节点的权值加一。\n$2 ~ x ~ v$：将节点 $x$ 的权值减去 $v$。\n$3 ~ x$：询问所有与节点 $x$ 距离为 $1$ 的节点权值的XOR和。\n其中，$n,m \\leq 5 \\times 10^5$，初始权值 $\\leq 10^5$。\n 题解 这里是 01-Trie 用来维护XOR和。\n我们可以对于每一个节点，都把它的孩子（距离为 $1$）的XOR和 维护在一个 01Trie里面。\n因为 01-Trie 是动态开点的，所以总共复杂度也就 $n\\log(10^5)$。\n然后因为每个节点都只有一个 parent，就单独维护即可。\n然后对于操作 $1 ~ x$，我们需要做的几件事：\n 单独更新 $x$ 的parent。 给 $x$ 打上一个懒标记，代表它要给它的孩子加上 $lazy$ 的值。 在 $x$ 维护的 01-Trie 上进行全体加一操作。  然后在每次操作之前，都先检查一下 $parent$ 的懒标记，将其下放。\n当然这里的下放不太一样，一个节点可能有非常多个孩子，所以我们选择给每一个节点 $x$ 都定义一个值 add[x]，代表它已经从parent那里得到了多少下放的懒标记。\n然后就给 $x$ 的权值加上 (lazy[p] - add[x])。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; const int M = 21; // 最大深度 int id = 0; struct Node { int w; // 到 parent 这条边上的个数 int val; // subtree 内的XOR和 int child[2]; } trie[maxn*(M+1)]; int root[maxn], lazy[maxn], add[maxn]; void push_up(int cur) { trie[cur].val = trie[cur].w = 0; // 先清空 int c0 = trie[cur].child[0], c1 = trie[cur].child[1]; // 更新 w if (c0) trie[cur].w += trie[c0].w; if (c1) trie[cur].w += trie[c1].w; // 更新 val if (c0) { trie[cur].val ^= (trie[c0].val \u0026lt;\u0026lt; 1); } if (c1) { trie[cur].val ^= ((trie[c1].val \u0026lt;\u0026lt; 1) | (trie[c1].w \u0026amp; 1)); // 如果 c1 的 w 为奇数，就提供了 1 的贡献 } } // cur: index, x: 当前的数字, dep: 深度 void insert(int\u0026amp; cur, int x, int dep) { if (!cur) cur = ++id; if (dep \u0026gt;= M) { trie[cur].w++; return; } int c = x \u0026amp; 1; insert(trie[cur].child[c], (x\u0026gt;\u0026gt;1), dep+1); push_up(cur); } void del(int\u0026amp; cur, int x, int dep) { if (!cur) cur = ++id; if (dep \u0026gt;= M) { trie[cur].w--; return; } int c = x \u0026amp; 1; insert(trie[cur].child[c], (x\u0026gt;\u0026gt;1), dep+1); push_up(cur); } // add 1 to all numbers maintained by cur void addall(int cur) { swap(trie[cur].child[0], trie[cur].child[1]); if (trie[cur].child[0]) { addall(trie[cur].child[0]); } push_up(cur); } int n, m, a[maxn], par[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u]) continue; par[to] = u; insert(root[u], a[to], 0); dfs(to); } } // modify u to have the value val void modify(int u, int val) { // a[u] is previous value int p = par[u]; if (p) { del(root[p], a[u], 0); insert(root[p], val, 0); } a[u] = val; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } dfs(1); while (m--) { int op, x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if (op == 1) { addall(root[x]); int p = par[x]; if (p) { a[p] = a[p] + lazy[par[p]] - add[p]; add[p] = lazy[par[p]]; modify(par[x], a[p] + 1); } lazy[x]++; } if (op == 2) { int v; cin \u0026gt;\u0026gt; v; a[x] = a[x] + lazy[par[x]] - add[x]; add[x] = lazy[par[x]]; modify(x, a[x] - v); } if (op == 3) { int res = trie[root[x]].val; int p = par[x]; if (p) { a[p] = a[p] + lazy[par[p]] - add[p]; add[p] = lazy[par[p]]; res ^= a[p]; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例4 洛谷P4735 最大异或和 题意\n给定一个非负整数序列 $a_1,a_2,\u0026hellip;,a_n$。\n现给定 $m$ 个操作，有以下两种操作类型：\n$A ~ x$：在序列末尾添加一个数 $x$。\n$Q ~ L ~ R ~ x$：输出一个位置 $p$，满足 $p \\in [L,R]$，使得 $a_p \\bigoplus a_{p+1} \\bigoplus \u0026hellip; \\bigoplus a_n \\bigoplus x$ 最大。\n其中，$n,m \\leq 3 \\times 10^5, a_i \\in [0,10^7]$。\n 题解 可持久化 01-Trie 的模版题。\n首先，先考虑前缀XOR数组 $s_i = a_1 \\bigoplus a_2 \\bigoplus \u0026hellip; \\bigoplus a_i$。\n那么\n$$a_p \\bigoplus a_{p+1} \\bigoplus \u0026hellip; \\bigoplus a_n \\bigoplus x = (s_n \\bigoplus s_{p-1}) \\bigoplus x$$\n所以现在问题就变成：\n每次询问 $Q ~ L ~ R ~ x$，输出一个位置 $p$，满足 $p \\in [L-1,R-1]$，使得 $(s_n \\bigoplus s_{p-1}) \\bigoplus x$ 最大。\n那就很简单了，令 $y = s_n \\bigoplus x$，剩下的就是在一个区间 $[L-1,R-1]$ 内找出一个元素 $s_p$ 使得 $s_p \\bigoplus y$ 最大。\n对于每一个区间都可以用 01-Trie 解决的问题，就是可持久化 01-Trie了。\n 最后需要注意一下这个样例：\n4 1 2 4 8 16 Q 1 4 1  答案应为 $31$，但我输出 $29$。\n这是因为我们要单独处理一下 $s_0$ 的情况。换而言之我们要将 $s_0 = 0$ 插入到 root[1] 当中。\n所以 root[1] 需要包含 $2$ 个元素：$s_0,s_1$。\n对于一个版本插入 $2$ 个元素，只要在第二次插入时使用 insert(root[1], root[1], 0) 即可。\n最后再注意一下一些边界条件如 $[L-1,R-1]=[0,0]$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 6e5+5; const int M = 28; struct Node { int cnt; int child[2]; } trie[maxn * (M+1)]; int sum[maxn]; // sum[n] 代表 a[1] ^ a[2] ... ^ a[n] int n, q, root[maxn], a[maxn], id; void insert(int pre, int cur, int x) { for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; trie[cur].cnt = trie[pre].cnt + 1; // cnt 加一 if (!trie[cur].child[c]) trie[cur].child[c] = ++id; // 新建节点 trie[cur].child[c^1] = trie[pre].child[c^1]; // 复制另外一个子节点 cur = trie[cur].child[c]; pre = trie[pre].child[c]; } trie[cur].cnt = trie[pre].cnt + 1; } // find the maximum value for a ^ x (a is in [pre, cur]) int query(int pre, int cur, int x) { int res = 0; for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; c ^= 1; if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) { // cnt \u0026gt; 0 cur = trie[cur].child[c]; pre = trie[pre].child[c]; res |= (1\u0026lt;\u0026lt;i); } else { cur = trie[cur].child[c^1]; pre = trie[pre].child[c^1]; } } return res; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum[i] = sum[i-1] ^ a[i]; if (!root[i]) root[i] = ++id; insert(root[i-1], root[i], sum[i]); if (i == 1) insert(root[1], root[1], 0); } while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == 'A') { int x; cin \u0026gt;\u0026gt; x; a[++n] = x; sum[n] = sum[n-1] ^ a[n]; if (!root[n]) root[n] = ++id; insert(root[n-1], root[n], sum[n]); } else { int l,r,x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; l--; r--; x ^= (sum[n]); if (l == 0 \u0026amp;\u0026amp; r == 0) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } int res = query(root[max(0,l-1)], root[r], x); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例5 CF241B Friends 题意\n给定一个长度为 $n$ 的非负整数数组 $a_1,a_2,\u0026hellip;,a_n$。\n现在选择 $m$ 个pair $(i,j)$，使得这 $m$ 个pair 对应的 $a_i \\text{ xor } a_j$ 值的 sum 最大。\n其中，$n \\leq 5 \\times 10^4, a_i \\leq 10^9$，答案对 $10^9+7$ 取模。\n• $(i,j)$ 和 $(j,i)$ 算作一个 pair。\n 题解 神仙题。\n本题要求的是前 $m$ 大的XOR pair的和。\n我们先列出本题的过程：\n 求出第 $m$ 大。 求出 XOR 小于等于 $x$ 的所有pair的和。 对于一个区间 $[L,R]$，在 $O(1)$ 求出 $\\sum\\limits_{i=L}^R y \\text{ xor } a_i$。   第一步：求第 $m$ 大\n• 虽然 $(i,j)$ 和 $(j,i)$ 算作一个 pair，但我们只要把所有东西都乘以 $2$ 就行了。所以我们求第 $2m$ 大。\n最简单粗暴的方法当然是二分最终的结果 $x$，然后对于每一个 $a_i$，判断一下在 Trie 中有多少个数字和它 XOR 起来 $\\geq x$，把这些 count 累加起来然后查看 count \u0026gt;= 2m 与否，来调整 $x$ 的值。\n这样的时间复杂度是 $O(n\\log^2 10^9)$，本题可过，但是另外一个版本不可过。\n于是我们思考一下能不能直接在 Trie 上模拟这个二分的过程来构建最终的结果 $x$。\n发现是可以的，我们从高位到低位，枚举每一位取 $1$ 还是 取 $0$。\n然后我们对于每一个 $a_i$ 都判断一下 count 的总和，如果 count \u0026gt;= 2m，则说明这一位可以取 $1$。否则的话需要取 $0$，同时问题变成寻找第 $2m - count$ 大（有点类似于主席树寻找第 $k$ 大的思路）。\n• 这个过程是在所有 $a_i$ 上进行的，所以我们维护 $n$ 个指针 ptr[] 代表 $a_i$ 目前在 Trie 的什么位置。\n复杂度为 $O(n\\log 10^9)$。\n 第二步：求出 XOR 小于等于 $x$ 的所有pair的和\n如果这个问题不是求出和，而是求出个数的话，就是例 $2$ 的问题了。\n可惜不是，那怎么处理？\n一样，我们从每个 $a_i$ 开始进行 check，对于每一个 Trie 上的节点，我们可以维护一个 cnt[31]，其中 cnt[j] 代表当前Trie节点的子树里有多少个数字满足第 $j$ 位为 $1$。\n这样当然可以算，但是空间复杂度 $O(n\\log^2 10^9)$，本题或许可过，但另外一个版本仍然不可过。\n我们这里给出一个非常优秀的结论：\n 如果 $a_i$ 是 sorted 的，那么 Trie 上任意一个节点的子树 对应 $a_i$ 上的一段连续区间。\n 这个也不难理解，因为 Trie 的一个子树对应的是拥有一个 \u0026ldquo;特定前缀\u0026rdquo; （如 \u0026ldquo;1101\u0026rdquo;）的所有数字的集合。\n有了这个结论以后，我们在枚举 $a_i$ 时，假设我们目前到了第 $j$ 位，就分两种情况：\n $x$ 的第 $j$ 位为 $1$：那么我们就往 $1$ 的方向走。 $x$ 的第 $j$ 位为 $0$：我们把 $a_i$ XOR 上 $1$ 的那个子树，求出sum，给答案加上，然后往 $0$ 的方向走。  注意到 $a_i$ XOR 上一个子树的 sum，可以转化成一个区间上的问题，那么就有第三步：\n 第三步：对于一个区间 $[L,R]$，在 $O(1)$ 求出 $\\sum\\limits_{i=L}^R y \\text{ xor } a_i$。\n由于 $a_i$ 总共有 $n$ 个，所以不能直接求前缀和。\n但我们可以把区间内的每个数都 拆成二进制。\n然后对于拆开的二进制，每一位分别 XOR 上 $0$ 和 $1$，然后都进行一个前缀和。\n这样给定一个数字 $y$，就可以把 $y$ 拆成二进制，然后对于每一位 $j$，把 $[L,R]$ 内对应的和用 $O(1)$ 时间内求出来即可。\n• 所以我们要做的事就是先 sort 一下整个 $a_i$ 数组，然后在构建 Trie 的时候记录一下每个子树对应哪个区间即可。\n 最后要注意，由于第 $2m$ 大有可能 等于 第 $2m+1, 2m+2 \u0026hellip;$ 大，所以要处理掉额外加上的部分。\n答案除以 $2$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const ll mod = 1e9+7; const int maxn = 5e4+5; const int M = 31; struct Node { int cnt = 0; int child[2]; int L = 1e9, R = -1; // left and right segments } trie[maxn * (M+1)]; int id = 1; void insert(int idx, ll x) { int c = 1; for (int i = M; i \u0026gt;= 0; i--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) ? 1 : 0); if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; trie[c].L = min(trie[c].L, idx); // 维护子树对应的区间 trie[c].R = max(trie[c].R, idx); } } ll a[maxn]; ll n,m; // 寻找第 k 大 (本题是找到第 2m 大) int ptr[maxn]; // 每一个 ai 对应的 Trie 上的 ptr ll find_kmax(ll t) { ll res = 0; fill(ptr+1, ptr+n+1, 1); // 开始都在 1 for (int j = M; j \u0026gt;= 0; j--) { ll cnt = 0; // 找这一位 \u0026gt;= 1 的有多少个 for (int i = 1; i \u0026lt;= n; i++) { int k = ((a[i] \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); k ^= 1; cnt += trie[trie[ptr[i]].child[k]].cnt; } int nxt; if (cnt \u0026gt;= t) { res |= (1LL\u0026lt;\u0026lt;j); nxt = 1; } else { t -= cnt; nxt = 0; } for (int i = 1; i \u0026lt;= n; i++) { int k = ((a[i] \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); k ^= nxt; // 由这一步决定的哪一个来判断每一个 ptr 的更新位置 ptr[i] = trie[ptr[i]].child[k]; } } return res; } int sum[maxn][M+1][2]; // 计算 a[L,R] ^ x 之和 ll sum_range(ll l, ll r, ll x) { ll ans = 0; for (int j = M; j \u0026gt;= 0; j--) { int k = ((x \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); ll s = sum[r][j][k] - sum[l-1][j][k]; ans += s * (1LL \u0026lt;\u0026lt; j); ans %= mod; } return ans; } ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } // 获得 ai ^ aj \u0026gt;= x 的所有数之和 ll get_sum(ll x) { // 先把每个数拆成二进制，做前缀和 for (int j = M; j \u0026gt;= 0; j--) { for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 1; k++) { int c = ((a[i] \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); c ^= k; sum[i][j][k] = sum[i-1][j][k] + c; } } } ll ans = 2 * x % mod; ll cnt = 0; // 使用的对数 for (int i = 1; i \u0026lt;= n; i++) { int c = 1; for (int j = M; j \u0026gt;= 0; j--) { int k = ((a[i] \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); int d = ((x \u0026amp; (1LL\u0026lt;\u0026lt;j)) ? 1 : 0); if (d == 0) { // 加上所有 xor 起来为 1 的部分, 然后走到 0 int p = trie[c].child[k^1]; if (p) { ans += sum_range(trie[p].L, trie[p].R, a[i]); cnt += (trie[p].R - trie[p].L + 1); ans %= mod; } c = trie[c].child[k]; } else { c = trie[c].child[k^1]; } } } cnt += 2; ans = (ans - ((cnt - 2 * m) % mod * x % mod) + mod) % mod; // 减去重复的部分 ans = ans * qpow(2, mod-2) % mod; return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; if (!m) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } sort(a+1, a+n+1); for (int i = 1; i \u0026lt;= n; i++) insert(i, a[i]); ll x = find_kmax(2 * m); ll ans = get_sum(x); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例6 CF1625D Binary Spiders 题意\n给定 $n$ 个非负整数，和一个非整数 $k$。\n求 $n$ 个非负整数的一个 subset，使得这个 subset 最大，并且 subset内 每两个数之间的 XOR $\\geq k$。\n其中，$n \\leq 3 \\times 10^5, k,a_i \\in [0,2^{30}-1]$。\n 题解 首先我们设 $k$ 的最高位为 $j$。\n那么我们将所有的 $a_i$ 分成三个部分：\n 最高位 $\\geq j+1$ 的。 最高位 $= j$ 的。 最高位 $\\leq j-1$ 的。  那么我们可以发现，对于 Case 2, Case 3，各只能最多选出 $1$ 个数来。\n那么对于 Case 1 呢？\n不如我们只考虑它们 bitmask的 prefix，即 $[j+1,30]$ 的这一部分。\n我们注意到，如果两个 prefix 不同的数，一定是可以共存的。\n如果两个数的 prefix 相同呢？是 有可能 可以共存的！\n更准确的来说，如果两个数的 prefix 相同，我们可以把这部分抵消掉，那么问题就变成了最高位 $\\leq j$ 的一些数可以最多选多少个出来共存。\n这实际上就是 Case 2 和 Case 3 的并集，我们很容易发现这个并集内，最多可以选 $2$ 个数。\n所以问题就简化了，我们只要根据 prefix 分类这些数，然后在每个分类中，选出最多两个数来即可。\n而选择最多两个数判断是否 $\\geq k$，用 01-Trie 可以轻松解决。\n 实现的过程：\n 先找出 $k$ 的最高位 $j$。 将所有的数字按照 $[j+1,30]$ 这一部分的prefix分类。 对于每一类，都构建 01-Trie 判断是否存在两个数的 XOR $\\geq k$，存在就选择这两个数，否则只选一个。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; const int maxm = 30; int id = 1; // 注意，从 1 开始 struct Node { int cnt = 0; int child[2]; } trie[maxn\u0026lt;\u0026lt;4]; void insert(int x, int delta) { int c = 1; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt += delta; } } // maximum query int query(int x) { int c = 1; int res = 0; for (int j = maxm; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; k ^= 1; if (trie[trie[c].child[k]].cnt) { c = trie[c].child[k]; res |= (1\u0026lt;\u0026lt;j); } else { c = trie[c].child[k^1]; // res |= (1\u0026lt;\u0026lt;j); } } return res; } int n,k; struct Nd { int val, id; } a[maxn]; int b[maxn]; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;pii\u0026gt; vec[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i].val, a[i].id = i; sort(a+1, a+n+1, [](auto a, auto b) { return a.val \u0026gt; b.val; }); if (k == 0) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; return 0; } int p = 0; for (int j = 0; j \u0026lt;= 30; j++) { if (k \u0026amp; (1\u0026lt;\u0026lt;j)) p = j; } int ptr = 0; for (int i = 1; i \u0026lt;= n; i++) { b[i] = a[i].val; for (int j = 0; j \u0026lt;= p; j++) { if (b[i] \u0026amp; (1\u0026lt;\u0026lt;j)) b[i] ^= (1\u0026lt;\u0026lt;j); } if (!(i \u0026gt; 1 \u0026amp;\u0026amp; b[i] == b[i-1])) { ++ptr; } vec[ptr].push_back({a[i].val, a[i].id}); } for (int i = 1; i \u0026lt;= ptr; i++) { if (vec[i].size() \u0026gt;= 2) { bool ok = 0; for (int j = 0; j \u0026lt; vec[i].size(); j++) { if (!ok \u0026amp;\u0026amp; query(vec[i][j].first) \u0026gt;= k) { for (int a = 0; a \u0026lt; j; a++) { if ((vec[i][j].first ^ vec[i][a].first) \u0026gt;= k) { ans.push_back(vec[i][j].second); ans.push_back(vec[i][a].second); ok = 1; break; } } } insert(vec[i][j].first, 1); } if (!ok) { ans.push_back(vec[i][0].second); } for (int j = 0; j \u0026lt; vec[i].size(); j++) { insert(vec[i][j].first, -1); } } else if (vec[i].size() == 1) { ans.push_back(vec[i][0].second); } } if (ans.size() \u0026lt;= 1) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int j : ans) cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } }   例7 CF1665E. MinimizOR 题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$ 和 $q$ 个询问，每次询问 $[l_i, r_i]$ 之间，选出两个index $j \\neq k$，使得 $j,k \\in [l_i, r_i]$ 且 $a_j | a_k$ 最小，求最小值。\n其中，$n \\in [2, 10^5], a_i \\in [0, 2^{30}), q \\in [1, 10^5], 1 \\leq l_i \u0026lt; r_i \\leq n$。\n 题解 可持久化01-trie。\n可持久化保证了我们可以对于每一个区间找 $a_j | a_k$ 最小值。\n怎么找呢？\n考虑从 01-trie 上开始 dfs，如果发现 $0$ 对应的子树中有 $\\geq 2$ 个数字，那么说明这一位可以取 $0$，否则只能取 $1$。\n但有的情况下，$0$ 对应的子树中只有 $1$ 个数字 $a$，此时我们只能取 $1$，但是这个数字 $a$ 也是要拿出来的，因为它有可能在下一层被用到，所以我们单独用一个 vector\u0026lt;int\u0026gt; tmp 来储存这些 $a$。\n最后注意一下，当我们在某一层取了 $0$ 时，要重新判断一下 tmp 中的数字 $a$ 在这一位是否为 $1$，如果是，说明最终答案中一定不可能考虑到这个数字 $a$，扔掉即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int M = 30; struct Node { int cnt; int child[2]; } trie[maxn * (M+1)]; int n, root[maxn], id; void insert(int pre, int cur, int x) { for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; trie[cur].cnt = trie[pre].cnt + 1; // cnt 加一 if (!trie[cur].child[c]) trie[cur].child[c] = ++id; // 新建节点 trie[cur].child[c^1] = trie[pre].child[c^1]; // 复制另外一个子节点 cur = trie[cur].child[c]; pre = trie[pre].child[c]; } trie[cur].cnt = trie[pre].cnt + 1; } // find the maximum value for a ^ x (a is in [pre, cur]) int query(int pre, int cur, int x) { int res = 0; for (int i = M; i \u0026gt;= 0; i--) { int c = 0; if (x \u0026amp; (1 \u0026lt;\u0026lt; i)) c = 1; c ^= 1; if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) { // cnt \u0026gt; 0 cur = trie[cur].child[c]; pre = trie[pre].child[c]; res |= (1\u0026lt;\u0026lt;i); } else { cur = trie[cur].child[c^1]; pre = trie[pre].child[c^1]; } } return res; } int ans = 0; vector\u0026lt;int\u0026gt; tmp, tmp2; void dfs(int pre, int cur, int d) { if (d \u0026lt; 0) return; int cnt0 = 0, cnt1 = 0; cnt0 = trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt; cnt1 = trie[trie[cur].child[1]].cnt - trie[trie[pre].child[1]].cnt; for (int j : tmp) { if (!(j \u0026amp; (1\u0026lt;\u0026lt;d))) cnt0++; } if (cnt0 \u0026gt;= 2) { tmp2.clear(); // 如果为0，这里只能保留这一位为0的！ for (int j : tmp) { if (!(j \u0026amp; (1\u0026lt;\u0026lt;d))) tmp2.push_back(j); } tmp = tmp2; dfs(trie[pre].child[0], trie[cur].child[0], d-1); } else { if (trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt) { assert(trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt == 1); int tcur = trie[cur].child[0], tpre = trie[pre].child[0], tx = ans; for (int j = d-1; j \u0026gt;= 0; j--) { if (trie[trie[tcur].child[0]].cnt - trie[trie[tpre].child[0]].cnt) { tcur = trie[tcur].child[0]; tpre = trie[tpre].child[0]; } else { tcur = trie[tcur].child[1]; tpre = trie[tpre].child[1]; tx |= (1\u0026lt;\u0026lt;j); } } tmp.push_back(tx); } ans |= (1\u0026lt;\u0026lt;d); dfs(trie[pre].child[1], trie[cur].child[1], d-1); } } void clear(int cur) { for (int c = 0; c \u0026lt;= 1; c++) { if (trie[cur].child[c]) clear(trie[cur].child[c]); } memset(\u0026amp;trie[cur], 0, sizeof(trie[cur])); } void clearall() { id = 0; for (int i = 1; i \u0026lt;= n; i++) { if (root[i]) clear(root[i]), root[i] = 0; } } void Query(int l, int r) { ans = 0; tmp.clear(); dfs(root[l-1], root[r], M); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int T, a[maxn]; int main() { cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (!root[i]) root[i] = ++id; insert(root[i-1], root[i], a[i]); } int q; cin \u0026gt;\u0026gt; q; while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; Query(l, r); } clearall(); } }   例8 UniversalCup 12 N.XOR Reachable 题意\n给定 $n$ 个点，$m$ 条边的带权无向图。给定一个非负整数 $K$。\n现在给定 $Q$ 个询问，每次询问给定一个非负整数 $D$。对于这次询问，我们保留所有权值为 $C_i$ 的边使得 $C_i \\text{ xor } D \u0026lt; K$，然后回答在这个图中，有多少个pair $u,v$ 使得 $u$ 和 $v$ 能够互相到达。\n其中，$1 \\leq n,m,Q \\leq 10^5, K,C_i,D_j \\in [0, 2^{30})$。\n询问之间互相独立，并且图中可能有重边（无自环）。\n 题解 首先可以看出要用到 01-Trie。\n我们可以考虑将所有的边都存进 01-Trie 里面，然后对于每一个询问我们可以执行一次 DFS 找到所有这样的边。\n计算有多少个 $u,v$ 可以互相到达，肯定是维护一个并查集，然后求每个联通块的大小。\n但这样复杂度太高了，我们考虑怎么样只跑一次 DFS 就可以回答所有的询问？\n 发现本题是离线的，我们不妨把所有的询问也存进 01-Trie 里面，并且只存在叶子节点。\n然后我们只跑一次 DFS，当我们 DFS 到一个叶子节点的时候，就回答这个叶子节点储存的所有询问。\n怎么 DFS 呢？\n我们考虑 $K$ 的每一位，我们现在 DFS 到了第 $i$ 位，假设 $K$ 的第 $i$ 位是 $1$。\n那么我们在 DFS 的过程中：\n 对于所有第 $i$ 位为 $1$ 的询问 $D$，说明我们应该加上所有第 $i$ 位为 $1$ 的边 $C$，然后继续 DFS 考虑所有第 $i$ 位为 $0$ 的边。 对于所有第 $i$ 位为 $0$ 的询问 $D$，说明我们应该加上所有第 $i$ 位为 $0$ 的边 $C$，然后继续 DFS 考虑所有第 $i$ 位为 $1$ 的边。  • 但这样会发现一个问题，我们希望的是 DFS 到询问所在的叶子，在 DFS 过程中加上边，但这样的话需要 DFS 的询问和边不在同一棵子树里，我们无法在知道具体是哪个询问的同时，知道我们加上了哪些边。\n所以我们可以先将所有询问 $D$ 执行 D ^= K，相当于将 $K$ 所有为 $1$ 的位置，都在 $D$ 中翻转了一下。\n这样我们就得到\n 对于所有第 $i$ 位为 $1$ 的询问 $D$，说明我们应该加上所有第 $i$ 位为 $0$ 的边 $C$，然后继续 DFS 考虑所有第 $i$ 位为 $1$ 的边。 对于所有第 $i$ 位为 $0$ 的询问 $D$，说明我们应该加上所有第 $i$ 位为 $1$ 的边 $C$，然后继续 DFS 考虑所有第 $i$ 位为 $0$ 的边。  这样就没问题了。\n同理，如果 $K$ 的第 $i$ 位是 $0$，我们不需要加上某一棵子树中的边，直接 DFS 即可，由于 $K$ 的第 $i$ 位是 $0$ 所以 D ^= K 的操作没有影响。\n 对于所有第 $i$ 位为 $1$ 的询问 $D$，DFS 考虑所有第 $i$ 位为 $1$ 的边。 对于所有第 $i$ 位为 $0$ 的询问 $D$，DFS 考虑所有第 $i$ 位为 $0$ 的边。  • 注意 DFS 回溯时，还需要把加上的边撤销掉，这个利用可撤销并查集来做就可以了，每次操作时间复杂度 $O(\\log n)$。\n 时间复杂度是多少？\n我们只执行一次 DFS，复杂度为 $O(30n)$。\n对于每一条边，它只会被它的所有祖先加上，所以总共加上 + 撤销的操作也是 $O(30n)$，总时间复杂度就是 $O(30n \\log n)$。\n• 最后注意，DFS 的时候如果深度为 $-1$ 说明我们到达了叶子节点（不是深度为 $0$！）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n, m, K, Q; struct Edge { int from, to, w; }; vector\u0026lt;Edge\u0026gt; adj[maxn]; struct State { int u, v, szu, szv; } st[maxm]; ll ans = 0, res[maxn]; ll cal(ll x) { return x*(x-1) / 2; } struct DSU { int par[maxn], sz[maxn], tail = 0; inline void init() { for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1; tail = 0; } int finds(int u) { if (par[u] == u) return u; return finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (sz[u] \u0026lt; sz[v]) swap(u,v); // sz[u] \u0026gt;= sz[v] st[++tail] = {u, v, sz[u], sz[v]}; if (u == v) return; par[v] = u; ans = ans - cal(sz[u]) - cal(sz[v]) + cal(sz[u] + sz[v]); sz[u] += sz[v]; } void cancel() { if (tail \u0026gt; 0) { int u = st[tail].u, v = st[tail].v; par[v] = v; if (sz[u] != st[tail].szu) { assert(sz[u] == st[tail].szu + st[tail].szv); ans = ans - cal(sz[u]) + cal(st[tail].szu) + cal(st[tail].szv); } sz[u] = st[tail].szu; sz[v] = st[tail].szv; tail--; } } } dsu; struct Node { int cnt = 0; int child[2]; vector\u0026lt;Edge\u0026gt; vec; vector\u0026lt;int\u0026gt; que; // queries 的编号 }; const int M = 30; bool tag[33]; struct Trie01 { int id = 1; // 注意，从 1 开始 Node trie[maxn\u0026lt;\u0026lt;5]; void insert(Edge e) { int x = e.w; int c = 1; for (int j = M; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; trie[c].vec.push_back(e); } } void insert(int x, int i) { int c = 1; for (int j = M; j \u0026gt;= 0; j--) { int k = 0; if (x \u0026amp; (1\u0026lt;\u0026lt;j)) k = 1; if (!trie[c].child[k]) trie[c].child[k] = ++id; c = trie[c].child[k]; trie[c].cnt++; } trie[c].que.push_back(i); // 只保留叶子即可 } void addall(int u) { for (Edge e : trie[u].vec) { dsu.unions(e.from, e.to); } } void clearall(int u) { for (int i = 0; i \u0026lt; trie[u].vec.size(); i++) dsu.cancel(); } // 从 d = M 开始 dfs void dfs(int u, int d) { if (!u) return; if (d == -1) { // 走完了，开始统计答案 for (int id : trie[u].que) res[id] = ans; return; } int c[2]; c[0] = trie[u].child[0], c[1] = trie[u].child[1]; if (tag[d]) { // 需要加一边，然后dfs另外一边 for (int o = 0; o \u0026lt; 2; o++) { addall(c[o^1]); dfs(c[o], d-1); clearall(c[o^1]); } } else { dfs(c[0], d-1); dfs(c[1], d-1); } } } tr; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({u,v,w}); adj[v].push_back({v,u,w}); tr.insert({u,v,w}); } cin \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= Q; i++) { int D; cin \u0026gt;\u0026gt; D; D ^= K; tr.insert(D, i); } dsu.init(); for (int i = M; i \u0026gt;= 0; i--) tag[i] = (K \u0026amp; (1\u0026lt;\u0026lt;i)); tr.dfs(1, M); for (int i = 1; i \u0026lt;= Q; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://oi-wiki.org/string/trie/#_6 https://oi-wiki.org/ds/persistent-trie/  ","date":"2021-12-17T14:23:29+08:00","permalink":"https://tom0727.github.io/post/059-01trie/","tags":["Trie",""],"title":"Trie 和 01 Trie"},{"categories":["算法"],"contents":"单调栈介绍 单调栈可以在 $O(n)$ 时间内解决 \u0026ldquo;对于每一个index，求右侧/左侧第一个对应数字比它大/小的index\u0026rdquo; 的问题。\n例1 Leetcode2281 Sum of Total Strength of Wizards 题意\n给定一个包含 $n$ 个正整数的数组。现在求所有连续的 subarray 的权重和。\n一个 subarray 的权重和的定义：这个subarray中的 最小值 乘上 subarray 的和。\n其中，$n \\leq 10^5, a_i \\in [1, 10^9]$，答案对 $10^9+7$ 取模。\n 题解 首先考虑每一个元素能作为哪些subarray的最小值，很明显这是一个单调栈问题，寻找每个元素左/右的第一个比它小的值。\n然而这样可能会产生重复，如 [2,2,2,2] 可能会有问题。\n一个常见的套路是 一边开，一边闭。\n即：我们对于每个index $i$，找它右侧的第一个 $\\leq a_i$ 的index，再找它左侧的第一个 $\u0026lt; a_i$ 的index，这样就解决了重复问题。\n对于一个index $i$，我们假设它影响到的区间为 $[L,R]$，那么我们只要找这个区间内，所有 包含了 $i$ 的subarray的和即可。\n 这样的和怎么找？考虑左边和右边的贡献。\n我们将 $[L, i-1]$ 定义为左边，$[i, R]$ 定义为右边。\n我们求出前缀和数组 $s[]$，再求出前缀和数组的前缀和 $pre[]$，令：\n$$lsum = \\sum\\limits_{l=L}^{i-1} sum(a[l, i-1]) = \\sum\\limits_{l=L}^{i-1} (s[i-1] - s[l-1]) = (i-L)*s[i] - \\sum\\limits_{l=L-1}^{i-2}s[l] = (i-L)*s[i] - (pre[i-2] - pre[L-1])$$\n$$rsum = \\sum\\limits_{r=i}^R sum(a[r, R]) = -(R-i+1)*s[i-1] + (pre[R] - pre[i-1])$$\n最后，这个sum就为\n$$sum = lsum * rlen + rsum * llen$$\n其中 $llen = length[L, i-1] = i-L, rlen = R-i+1$。\n 代码 class Solution { public: #define ll long long #define maxn 100005 const int mod = (int)(1e9+7); ll a[maxn]; ll sum[maxn], pre[maxn]; int l[maxn], r[maxn]; ll get_presum(int l, int r) { if (r \u0026lt; 0 || l \u0026gt; r) return 0; if (l \u0026gt; 0) return (pre[r] - pre[l-1] + mod) % mod; return pre[r]; } int totalStrength(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) a[i] = arr[i-1]; for (int i = 1; i \u0026lt;= n; i++) sum[i] = (sum[i-1] + a[i]) % mod; for (int i = 1; i \u0026lt;= n; i++) pre[i] = (pre[i-1] + sum[i]) % mod; stack\u0026lt;int\u0026gt; st; fill(r, r+maxn, n+1); for (int i = 1; i \u0026lt;= n; i++) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026gt;= a[i]) { r[st.top()] = i; st.pop(); } st.push(i); } while (st.size()) st.pop(); for (int i = n; i \u0026gt;= 1; i--) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026gt; a[i]) { l[st.top()] = i; st.pop(); } st.push(i); } for (int i = 1; i \u0026lt;= n; i++) { ll L = l[i] + 1, R = r[i] - 1; // Case1: lsum * rlen ll res = 0; ll lsum = ((i - L) * sum[i-1] - get_presum(L-1, i-2) + mod) % mod; ll rlen = R - i + 1; res += lsum * rlen % mod; // Case2: rsum * llen ll rsum = (-(R - i + 1) * sum[i-1] + get_presum(i, R) + mod) % mod; ll llen = i - L + 1; res += rsum * llen % mod; res %= mod; ans = (ans + res * a[i] % mod) % mod; ans %= mod; } return ans; } };   例2. Serval的数学课堂 题意\n定义一个可重集合 $S$ 的 exavg 为：\n$$\\text{exavg }(S) = \\frac{(\\sum\\limits_{x\\in S} x) - \\max S - \\min S}{|S| - 2}$$\n也就是去掉最大最小值后，取平均值。\n• exavg 仅对大小至少为 $3$ 的集合有定义。\n给定一个整数序列 $A_1, \u0026hellip;, A_n$，求所有子区间 $[L,R]$ 的 exavg 的平均值，形式化的，求：\n$$\\text{avg } \\{\\text{exavg }(A[L\u0026hellip;R]) ~|~ 1 \\leq L \u0026lt; R \\leq n, R-L+1 \\geq 3\\}$$\n其中，$3 \\leq n \\leq 5 \\times 10^5, A_i \\in [0, 998244353)$，答案对 $998244353$ 取模。\n 题解 经典老套路之：讨论每个数的贡献。\n很明显我们只要求 $\\text{exavg }$ 的 sum 就行。\n贡献可以分为三部分，一个是正常贡献，一个是要减去的最大值，还有一个是要减去的最小值。\n对于正常贡献，假设当前这个数为 $a_i$，我们希望知道有哪些区间穿过了 $a_i$，假设一个区间的长度为 $l$，那么我们要求的是\n$$\\sum\\limits_{l} \\frac{1}{l-2}$$\n其中，区间必须穿过 $a_i$，并且长度 $l \\geq 3$。\n怎么求呢？\n我们令 $C_i$ 为一个长度为 $i$ 的区间内，所有子区间的长度 $l$ 的 $\\frac{1}{l-2}$ 的值的和，形式化的：\n$$C_i = \\sum\\limits_{L,R \\in [1,i], R-L+1 \\geq 3}\\frac{1}{(R-L+1)-2}$$\n那么就有\n$$C_1 = C_2 = 0$$\n$$C_i = 2C_{i-1} - C_{i-2} + \\frac{1}{i-2}, \\forall i \\geq 3$$\n 那么要求所有穿过 $a_i$ 的区间的 $\\frac{1}{l-2}$ 之和，假设 $a_i$ 的贡献影响范围是 $[L,R]$，那么有：\n也就是\n$$\\sum\\limits_{l} \\frac{1}{l-2} = C_{R-L+1} - C_{i-L} - C_{R-i}$$\n那么对于每一个正常贡献，影响范围就是 $L = 1, R = n$。\n对于最大最小值，影响范围用单调栈求出即可。\n• 为了防止两个值相同导致的贡献重叠，我们利用 这里 的套路：左闭右开 的单调栈即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; int n; Z C[maxn]; // C[i]: 区间内所有长度 x 的区间的 1/(x-2) 的和 int a[maxn]; int l[maxn], r[maxn]; Z ans = 0; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 3; i \u0026lt;= n; i++) { C[i] = C[i-1] * 2 - C[i-2] + Z(1) / (i-2); } // 小于的部分 stack\u0026lt;int\u0026gt; st; fill(r, r+maxn, n+1); fill(l, l+maxn, 0); for (int i = 1; i \u0026lt;= n; i++) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026gt;= a[i]) { r[st.top()] = i; st.pop(); } st.push(i); } for (int i = n; i \u0026gt;= 1; i--) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026gt; a[i]) { l[st.top()] = i; st.pop(); } st.push(i); } while (st.size()) st.pop(); for (int i = 1; i \u0026lt;= n; i++) { int L = l[i] + 1, R = r[i] - 1; ans -= (C[R-L+1] - C[R-i] - C[i-L]) * a[i]; } fill(r, r+maxn, n+1); fill(l, l+maxn, 0); for (int i = 1; i \u0026lt;= n; i++) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026lt;= a[i]) { r[st.top()] = i; st.pop(); } st.push(i); } for (int i = n; i \u0026gt;= 1; i--) { while (st.size() \u0026amp;\u0026amp; a[st.top()] \u0026lt; a[i]) { l[st.top()] = i; st.pop(); } st.push(i); } while (st.size()) st.pop(); for (int i = 1; i \u0026lt;= n; i++) { int L = l[i] + 1, R = r[i] - 1; ans -= (C[R-L+1] - C[R-i] - C[i-L]) * a[i]; } for (int i = 1; i \u0026lt;= n; i++) { int L = 1, R = n; ans += (C[R-L+1] - C[R-i] - C[i-L]) * a[i]; } Z cnt = 0; for (int i = 3; i \u0026lt;= n; i++) cnt += n-i+1; ans /= cnt; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 CF1795E. Explosions? 题意\n给定一个长度为 $n$ 的正整数数组。\n我们可以执行若干次操作，每次操作可以选定一个数，让它 $-1$（不能减到负数），每次操作消耗 $1$ 点法力值。\n然后我们会选择一个index $i$，消耗 $a_i$ 点法力值，它会被引爆，对两个邻居造成 $a_i - 1$ 点伤害，然后如果邻居被炸死了（比如 $a_{i-1} \\leq a_i-1$），则它会继续引爆，对邻居造成 $a_{i-1}-1$ 点伤害。\n最后的引爆过程只能进行一次，并且要保证引爆后所有的数都被炸死。\n求最小法力值消耗？\n其中，$n \\leq 3 \\times 10^5, a_i \\in [1, 10^6]$。\n 题解 考虑最后引爆的index $i$。\n可以知道，在引爆之前，整个数组应该是长这样：\n$[a_1,\u0026hellip;,a_i]$ 是严格单调递增，$[a_i,\u0026hellip;,a_n]$ 是严格单调递减。\n有一个特殊情况，$0,0,0,1,2$ 这种也算“严格”单调递增。\n现在就是要求 $f_i$，其中 $f_i$ 表示将 $1\u0026hellip;i$ 变成严格单调递增的最小操作次数。\n这个可以用单调栈在 $O(n)$ 时间算出所有 $f_i$。\n具体操作是我们对于栈内元素维护一个pair，$(a_i, cnt_i)$，其中 $a_i$ 就是元素本身，$cnt_i$ 代表以 $i$ 开始，它往前的严格递减（差值恰好为 $1$）的序列长度。\n比如 $(9, 1)$ 代表的就是 $[9]$，$(5,3)$ 代表 $[3,4,5]$。\n所以我们就用 dp 和单调栈来模拟这个过程即可，注意一些细节即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int T, n; ll a[maxn], f[maxn], g[maxn]; vector\u0026lt;pll\u0026gt; st; ll cal(ll x) { return x*(x+1)/2; } void solve() { st.clear(); for (int i = 1; i \u0026lt;= n; i++) { ll cnt = 1; while (!st.empty() \u0026amp;\u0026amp; st.back().first \u0026gt;= a[i] - cnt + 1) { ll c = st.back().first; ll d = st.back().second; st.pop_back(); cnt += d; if (cnt \u0026lt;= a[i]) { f[i] += (c - (a[i]-(cnt-d))) * d; // starting with a[i] - cnt } else { f[i] += (cal(c) - cal(c-d)); // x + (x-1) + (x-2) + ... cnt = 1时 f[i] -= cal(max(0LL, a[i] - (cnt-d))); // if d = 3, a[i] = 9, cnt = 8, cnt + d = 11, a[i] = 9, only used 1 } } st.push_back({a[i], min(a[i], cnt)}); f[i] += f[i-1]; } } int main() { fastio; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], f[i] = g[i] = 0; solve(); for (int i = 1; i \u0026lt;= n; i++) g[i] = f[i], f[i] = 0; // swap(f, g); reverse(a+1, a+n+1); solve(); reverse(f+1, f+n+1); reverse(a+1, a+n+1); ll ans = 1e18; for (int i = 1; i \u0026lt;= n; i++) { ans = min(ans, f[i] + g[i] + a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   单调队列介绍 单调队列可以用于解决滑动窗口最值问题。\n简单来说，单调队列内维护的是 index，单调队列要满足两个特性：\n q[tail] - q[head] \u0026lt; m，其中 $m$ 是窗口的大小。 队列中的元素，对应的值单调递减/递增。  要维护第二条的话，就需要在插入一个新的元素时，从队列的尾部不断 pop 掉元素，保证单调性（本质上和单调栈一样）。\n例1 洛谷P2627 [USACO11OPEN]Mowing the Lawn G 题意\n给定一个包含 $n$ 个正整数的数组，从中选取一些数，使得不存在连续的 $\u0026gt;k$ 个数。\n输出选取方案中，可能的最大和。\n其中，$n \\leq 10^5$\n 题解 DP。设 $dp[i]$ 为前 $i$ 个数字所能得到的最大答案。\n所以我们枚举一下上一个不选的位置 $j$，则有\n$$dp[i] = \\max_{j=i-k}^i\\{dp[j-1]+sum(j+1,i)\\}$$\n$$=\\max_{j=i-k}^i\\{dp[j-1]+sum[i] - sum[j]\\}$$\n由于 $i$ 固定，所以可以把 $sum[i]$ 拿出来，我们只要求\n$$\\max_{j=i-k}^i\\{dp[j-1] - sum[j]\\}$$\n这个东西只与 $j$ 有关，所以就是一个滑动窗口最小值问题了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll q[maxn\u0026lt;\u0026lt;1], a[maxn], sum[maxn], dp[maxn]; int head = 1, tail = 0, n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], sum[i] = sum[i-1] + a[i]; for (int i = 1; i \u0026lt;= k; i++) { dp[i] = sum[i]; while (head \u0026lt;= tail \u0026amp;\u0026amp; dp[q[tail]] - sum[q[tail]+1] \u0026lt;= dp[i-1] - sum[i]) tail--; q[++tail] = i-1; } for (int i = k+1; i \u0026lt;= n; i++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; dp[q[tail]] - sum[q[tail]+1] \u0026lt;= dp[i-1] - sum[i]) tail--; q[++tail] = i-1; while (q[tail] - q[head] \u0026gt;= k+1) head++; int j = q[head]; dp[i] = sum[i] + dp[j] - sum[j+1]; } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; }   ","date":"2021-11-17T17:24:34+08:00","permalink":"https://tom0727.github.io/post/058-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","tags":["",""],"title":"单调栈/队列"},{"categories":["算法"],"contents":"定义 基环树指的是一个 $n$ 个节点，$n$ 条边的联通图。\n叫基环树的原因是：给定一棵树，在这棵树上加上 任意一条边，就可以形成一个基环树了。\n基环树的性质很优秀，比如：\n 去掉环上的任意一条边，就可以转化为一棵树。 基环树可以看作一个环上挂了很多棵子树，如果将环缩成一个点，那么得到的就是一棵树。  所以基环树的常用套路有：\n 找环，然后删掉环上的任意一条边 $(u,v)$，对 $u$ 为根的树进行一次树形DP（并强制不选 $u$），再对 $v$ 为根的树进行一次树形DP（并强制不选 $v$）。 将环缩成一个点，然后分类讨论答案是否经过环两种情况。  例1 洛谷P2607 [ZJOI2008]骑士 题意\n给定 $n$ 个骑士，每个骑士有一个能力值 $a_i$，和他的一个痛恨的人 $b_i$（痛恨的人不能是自己）。\n从这些骑士中选出若干个，使得两两之间没有痛恨的人，求出最大的能力值总和。\n其中，$n \\leq 10^6$。\n 题解 按照每个人 $i$ 与他痛恨的人 $b_i$ 连边，这就可以形成一个基环森林了（由多个基环树组成的森林）。\n现在，只考虑一个基环树的话怎么办？\n首先发现，如果断开一条边，在树上考虑这个问题的话，就是一个非常简单的树形DP了。\n所以我们不妨断开环上的任意一条边 $(u,v)$。\n然后以 $u$ 为根，在这个新的树上进行一次树形DP，并强制不选 $u$。\n同理，以 $v$ 为根，在这个新的树上进行一次树形DP，并强制不选 $v$。\n求两次树形DP得出的最大值即可。\n最终答案就是每个基环树求出的最大值之和。\n 找环的话，只要发现一个 backward edge，记录一下这个 edge 的编号 E，标记一下 E 和 E^1，在树形DP中避开这两条边，就可以达到断开边的效果了。这要求我们建图时，使用 ecnt = 2。\n• 需要格外注意一下，在断边的时候，必须判断当前枚举的边 e 是否等于 E 或者 E^1，而不能判断边的两端端点，这是防止出现 $(1,2), (2,1)$ 这种情况，可以参考这里。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, head[maxn], ecnt = 2; ll a[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int ed, dep[maxn], par[maxn], E; void dfs1(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u]) continue; if (dep[to]) { E = e; } else { dep[to] = dep[u] + 1; par[to] = u; dfs1(to); } } } ll ans = 0, tot = 0; ll dp[maxn][2]; void dfs2(int u, int p) { dp[u][0] = 0; dp[u][1] = a[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || e == E || e == (E^1)) continue; dfs2(to, u); dp[u][0] += max(dp[to][0], dp[to][1]); dp[u][1] += dp[to][0]; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; v; addEdge(i,v); addEdge(v,i); } for (int u = 1; u \u0026lt;= n; u++) { if (!dep[u]) { ans = 0; E = 0; dep[u] = 1; dfs1(u); int c1 = edges[E].to, c2 = edges[E^1].to; dfs2(c1, 0); ans = max(ans, dp[c1][0]); dfs2(c2, 0); ans = max(ans, dp[c2][0]); tot += ans; } } cout \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; }   例2 洛谷P4381 [IOI2008] Island 题意\n给定一个基环树组成的森林，每条边上有边权，求出每个基环树的最长链的长度之和。\n最长链的定义为：一条路径，不经过重复的节点。\n其中，$n \\leq 10^6$。\n 题解 既然是基环森林，那就只考虑每个基环树怎么求最长链。\n注意到一个基环树由一个环，以及每个环的子树组成，长这样：\n所以我们可以讨论这个最长链的位置：\n第一种情况：最长链不经过环\n这说明最长链完全在一个子树内，那么这就是一个树的直径问题。\n第二种情况：最长链经过环\n如果经过了环，我们设它从环上的某个点 $u$ 的子树开始，到环上另外一个点 $v$ 的子树结束。\n并且设 $dis(u,v)$ 为 $u,v$ 在环上的最长距离，设 $d(u)$ 为 $u$ 的子树最大深度。\n所以答案就是\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n但找这样的 $(u,v)$ 是 $O(n^2)$ 的，考虑一下如何优化？\n如果我们将一个环 $1,2,3,\u0026hellip;,n$ 断开，并复制一份，得到 $1,2,3,\u0026hellip;,n,1',2',3',\u0026hellip;,n'$，则我们可以快速的算出 $dis(u,v)$。\n不妨设 $u\u0026lt;v$，并且求一个距离的前缀和 $a[]$，其中 $a[i]=a[i-1]+w(i-1,i)$。\n那么\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n就可以写成\n$$\\max_{(u,v)}\\{d(u)+d(v)+a[v]-a[u]\\}, u,v\\in[1,n] \\cup [1',n'], (v-u) \\in [1, n-1]$$\n当 $v$ 确定时，我们要求的实际上就是\n$$\\max_u \\{d(u) - a[u]\\}, u \\in [v-n+1,v-1]$$\n这就是个单调队列优化dp。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, in[maxn]; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } bool vis[maxn], ring[maxn]; ll ans = 0; // solve the component containing u vector\u0026lt;int\u0026gt; ver; // vertex in current component void bfs(int u) { vis[u] = 1; ver.push_back(u); int p = 0; while (p \u0026lt; ver.size()) { int v = ver[p]; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to]) continue; vis[to] = 1; ver.push_back(to); } p++; } } ll dep[maxn], maxdep[maxn]; vector\u0026lt;int\u0026gt; tmp; // used for storing leaf int maxi = 0, n; int q[maxn\u0026lt;\u0026lt;1], hd, tail, par[maxn]; void bfs2(int u) { int o = u; hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; if (dep[u] \u0026gt; dep[maxi]) maxi = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || ring[to]) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } maxdep[o] = dep[maxi]; } ll md = 0; void bfs3(int u, int v) { hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; md = max(md, dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || (ring[to] \u0026amp;\u0026amp; to != v)) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } } vector\u0026lt;int\u0026gt; rings; bool tag[maxn\u0026lt;\u0026lt;1]; struct Node { ll a, d; } nd[maxn\u0026lt;\u0026lt;1]; bool del[maxn]; void solve(int u) { ver.clear(); tmp.clear(); bfs(u); ll res = 0; for (int v : ver) { if (in[v] == 1) tmp.push_back(v); } while (!tmp.empty()) { int v = tmp.back(); tmp.pop_back(); del[v] = 1; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!del[to]) { in[v]--; in[to]--; if (in[to] == 1) tmp.push_back(to); } } } for (int v : ver) { if (in[v] \u0026gt;= 2) ring[v] = 1; // v is on the ring } rings.clear(); int cnt = 0; for (int v : ver) { if (ring[v]) { cnt++; if (!rings.size()) rings.push_back(v); maxi = 0; md = 0; bfs2(v); dep[maxi] = 0; bfs3(maxi, v); res = max(res, md); hd = 1, tail = 0; } } // get the ring if (rings.size()) { while (rings.size() \u0026lt; cnt) { int v = rings.back(); for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!ring[to] || (rings.size() \u0026gt; 1 \u0026amp;\u0026amp; to == rings[rings.size()-2])) continue; if (to == rings[0]) { goto done; } rings.push_back(to); break; } } } done:; int ptr = 0; if (rings.size()) { rings.push_back(rings.front()); nd[++ptr] = {0, maxdep[rings[0]]}; } int m = rings.size(); for (int i = 0; i \u0026lt; m-1; i++) { int v = rings[i]; int v2 = rings[i+1]; for (int e = head[v]; e; e = edges[e].nxt) { if (edges[e].to == v2 \u0026amp;\u0026amp; !tag[e]) { ll w = edges[e].w; nd[ptr+1].a = nd[ptr].a + w; nd[ptr+1].d = maxdep[v2]; ptr++; tag[e] = tag[e^1] = 1; // 标记边，防止有大小为2的环！ break; } } } for (int i = 0; i \u0026lt; m-2; i++) { nd[ptr+1].a = nd[ptr].a + (nd[i+2].a - nd[i+1].a); nd[ptr+1].d = maxdep[rings[i+1]]; ptr++; } hd = 1, tail = 0; q[++tail] = 1; m--; // now: m is the size of the ring for (int i = 2; i \u0026lt;= ptr; i++) { while (hd \u0026lt;= tail \u0026amp;\u0026amp; i - q[hd] \u0026gt;= m) hd++; if (hd \u0026lt;= tail) { res = max(res, nd[i].a + nd[i].d + nd[q[hd]].d - nd[q[hd]].a); } while (hd \u0026lt;= tail \u0026amp;\u0026amp; nd[i].d - nd[i].a \u0026gt;= nd[q[tail]].d - nd[q[tail]].a) tail--; q[++tail] = i; } ans += res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int v; ll w; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(i,v,w); addEdge(v,i,w); in[i]++; in[v]++; } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { solve(i); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   注意点\n 所有的树上/图上操作（包括找树的直径）都必须用 bfs 进行，因为 $n \\leq 10^6$，dfs 会爆栈。 找环的时候用拓扑排序，不过注意这个是无向图，所以写法略有不同。 找出环以后，要按照环的顺序把环断开，不能只考虑哪些节点在环上而不考虑顺序。 一定要注意 大小为 $2$ 的环，我们在断环为链的时候不能考虑节点之间的关系，而是要标记 edge，因为双向图的缘故，大小为 $2$ 的环之间会有重边，一定要注意！   例3 洛谷P1399 [NOI2013] 快餐店 题意\n给定一个 $n$ 个节点，$n$ 条边的无向图（基环树），边上有权值。\n现在要在树上找一个位置 $x$，这个位置 $x$ 可以位于边上的任意一处，也可以位于节点上。\n如何选择 $x$ 的位置，使得它到 所有节点的最短距离的最大值 最小？输出这个最小值。\n形式化的，求：\n$$\\min_x \\{\\max_u\\{dis(x,u)\\}\\}$$\n其中，$n \\leq 10^5$。\n 题解 先考虑，如果这是一棵树的话怎么办？\n那我们只要求出这棵树的直径，然后答案就是 直径/2 了。\n对于基环树，我们一般都是断环，得到一棵树，那么对于这个题我们有类似的想法：\n猜想：环上必然存在一条边，使得这条边断开以后对整个答案没有任何影响。\n证明：我们考虑 $x$ 的位置\n $x$ 在环上 $x$ 在一棵子树中  对于第一种情况，我们注意到 $x$ 到所有节点的最短路径中，由环上路径和树内路径组成。\n我们只考虑环上的路径（因为我们要证明的是环上的所有边不可能都被用到，至少有一个是用不上的）。\n那么问题就相当于，$x$ 到环上所有节点的最短路径，是否存在一条边用不上？\n确实如此，因为无论我们怎么画，都会有一条边被断开以后没有任何影响，如图：\n• 对于第二种情况也完全一样，所以这个结论是正确的。\n 所以问题就转化成了：\n给定一棵基环树，我们现在要断开环上的一条边，求所有断开的方案中，树的直径最小的一个方案，求出最小值？\n然后这题就和上一个例子差不多了，一样分类讨论直径在哪：\n 断开后，树的直径在子树内 断开后，树的直径在原先的环上  对于第一种情况，无论断开哪个都不影响答案，所以对于每个子树统计一下直径即可。\n对于第二种情况，上一题的单调队列套路不好使了，我们形式化的描述一下这个问题：\n给定一个环 $1,2,\u0026hellip;,n$，对于每一种断环方案，都求出：\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\}$$\n然后取所有断环方案对应的最小值。\n这里有了个断环方案要讨论，就变得非常不友好，就算断环成链也没什么思路，我们考虑另外一种方法：\n假设我们要断开 $(i,i+1)$，那么此时，这个所求的最大值对应的 $(u,v)$ 有几种情况呢？\n $(u,v)$ 都在 $[1,i]$ 内。 $(u,v)$ 都在 $[i+1,n]$ 内。 $u$ 在 $[1,i]$，$v$ 在 $[i+1,n]$。  对于第一种，我们同样用前缀和的方式来看，因为 $dis(u,v) = sum(v) - sum(u)$，所以和上一题一样处理一个前缀和即可，本题甚至都不需要单调队列，维护一下前缀的 -sum[u] + d[u] 的最大值即可。\n然后我们就可以处理出一个 pre[] 数组，pre[i] 的意思就是如果 $(u,v)$ 都在 $[1,i]$ 内，可以得到的最大值。\n同理对于第二种我们用后缀处理一下即可，可以得到 suf[]。\n对于第三种，我们可以发现我们所求的 $dis(u,v) + d(u) + d(v)$，等于\n$u$ 的 前缀链 + $v$ 的 后缀链 + $w(n,1)$\n 所以我们只要把这个前缀链的最大值 maxl[i] 求出即可（同理后缀链最大值也求出 maxr[]）。\n那么，当我们断开 $(i,i+1)$ 时，就有\n$$\\max_{(u,v)}\\{d(u)+d(v)+dis(u,v)\\} = \\max\\{pre(i), suf(i+1), maxl(i) + maxr(i+1) + w(n,1)\\}$$\n然后将 $i$ 从 $1$ 枚举到 $n$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, in[maxn]; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } bool ring[maxn]; ll ans = 0; ll dep[maxn], maxdep[maxn]; vector\u0026lt;int\u0026gt; tmp; // used for storing leaf int maxi = 0, n; int q[maxn\u0026lt;\u0026lt;1], hd, tail, par[maxn]; void bfs2(int u) { int o = u; hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; if (dep[u] \u0026gt; dep[maxi]) maxi = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || ring[to]) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } maxdep[o] = dep[maxi]; } ll md = 0; void bfs3(int u, int v) { hd = 1, tail = 0; q[++tail] = u; par[u] = 0; dep[u] = 0; while (hd \u0026lt;= tail) { u = q[hd]; hd++; md = max(md, dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[u] || (ring[to] \u0026amp;\u0026amp; to != v)) continue; par[to] = u; q[++tail] = to; dep[to] = dep[u] + edges[e].w; } } } vector\u0026lt;int\u0026gt; rings; bool tag[maxn\u0026lt;\u0026lt;1]; struct Node { ll a, d; } nd[maxn\u0026lt;\u0026lt;1]; bool del[maxn]; ll maxl[maxn], maxr[maxn], pre[maxn], suf[maxn]; void solve() { ll res = 0; for (int v = 1; v \u0026lt;= n; v++) { if (in[v] == 1) tmp.push_back(v); } while (!tmp.empty()) { int v = tmp.back(); tmp.pop_back(); del[v] = 1; for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!del[to]) { in[v]--; in[to]--; if (in[to] == 1) tmp.push_back(to); } } } for (int v = 1; v \u0026lt;= n; v++) { if (in[v] \u0026gt;= 2) ring[v] = 1; // v is on the ring } int cnt = 0; for (int v = 1; v \u0026lt;= n; v++) { if (ring[v]) { cnt++; if (!rings.size()) rings.push_back(v); maxi = 0; md = 0; bfs2(v); dep[maxi] = 0; bfs3(maxi, v); res = max(res, md); hd = 1, tail = 0; } } // get the ring if (rings.size()) { while (rings.size() \u0026lt; cnt) { int v = rings.back(); for (int e = head[v]; e; e = edges[e].nxt) { int to = edges[e].to; if (!ring[to] || (rings.size() \u0026gt; 1 \u0026amp;\u0026amp; to == rings[rings.size()-2])) continue; if (to == rings[0]) { goto done; } rings.push_back(to); break; } } } done:; int ptr = 0; if (rings.size()) { rings.push_back(rings.front()); nd[++ptr] = {0, maxdep[rings[0]]}; } int m = rings.size(); for (int i = 0; i \u0026lt; m-1; i++) { int v = rings[i]; int v2 = rings[i+1]; for (int e = head[v]; e; e = edges[e].nxt) { if (edges[e].to == v2 \u0026amp;\u0026amp; !tag[e]) { ll w = edges[e].w; nd[ptr+1].a = nd[ptr].a + w; nd[ptr+1].d = maxdep[v2]; ptr++; tag[e] = tag[e^1] = 1; // 标记边，防止有大小为2的环！ break; } } } for (int i = 0; i \u0026lt; m-2; i++) { nd[ptr+1].a = nd[ptr].a + (nd[i+2].a - nd[i+1].a); nd[ptr+1].d = maxdep[rings[i+1]]; ptr++; } hd = 1, tail = 0; ll R = res; res = 1e18; m--; // now: m is the size of the ring // maxl: record a+d for (int i = 1; i \u0026lt;= m; i++) maxl[i] = max(maxl[i-1], nd[i].a + nd[i].d); for (int i = m; i \u0026gt;= 1; i--) maxr[i] = max(maxr[i+1], nd[m+1].a - nd[i].a + nd[i].d); // pre: record the maximum of two i,j \u0026lt;= pre, which dis(i,j) + d[i] + d[j] is maximum (just record minimum of -a + d) ll mn = 0; for (int i = 1; i \u0026lt;= m; i++) { pre[i] = max(pre[i-1], mn + nd[i].a + nd[i].d); mn = max(mn, -nd[i].a + nd[i].d); } mn = 0; for (int i = m; i \u0026gt;= 1; i--) { suf[i] = max(suf[i+1], mn + nd[m+1].a - nd[i].a + nd[i].d); mn = max(mn, -(nd[m+1].a - nd[i].a) + nd[i].d); } for (int i = 1; i \u0026lt;= m; i++) { // break (i,i+1) ll r1 = 0, r2 = 0; r1 = max(pre[i], suf[i+1]); r2 = maxl[i] + maxr[i+1]; res = min(res, max(r1,r2)); } ans += max(R, res); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); in[u]++; in[v]++; } solve(); printf(\u0026quot;%.1f\\n\u0026quot;,(double)(ans)*0.5); }   例4 BAPC2022H. House Numbering 题意\n给定一个 $n$ 个点，$n$ 条边的联通无向图。\n每条边有一个权值 $w$，意味着这条边的两端需要分别标上 $1,w$ 或者 $w,1$。\n问是否存在一种方案，使得所有点的边上没有被标上相同的元素。有，则输出方案。\n其中，$n \\leq 10^5$，所有边的 $w \u0026gt; 1$。\n如图，这就是一种合理标号方式，其中 $w_{1,2}=2, w_{2,3}=9, w_{1,3}=3$。\n 题解 首先注意这是一个基环树。所以要围绕环做文章。\n经过一段时间的观察后可以发现，如果我们把这个看作一个有向图，箭头指向的点会获得这个边的 $1$，另外一个点获得 $w$，那么所有不在环上的，都应该是向外指的。\n因为一旦有一个向内指的，环上一旦出现一个来自于树的 $1$，那么就不成立了。\n所以不在环上的部分都可以决定了。\n剩下的只有环了。\n可以发现环要么是顺时针指，要么是逆时针指，所以只要判断这两个情况就行。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n; struct Edge { int to, nxt, w; int idx; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2; void addEdge(int u, int v, int w, int idx) { Edge e = {v, head[u], w, idx}; head[u] = ecnt; edges[ecnt++] = e; } bool iscycle[maxn]; bool vis[maxn]; int cu, cv, cidx, pre[maxn]; bool found = 0; void dfs(int u) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w; if (v == pre[u]) continue; if (vis[v]) { if (found) return; found = 1; int cur = u; while (cur != v) { iscycle[cur] = 1; cur = pre[cur]; } iscycle[v] = 1; cu = u, cv = v; cidx = edges[e].idx; } else { pre[v] = u; dfs(v); } } } int ans[maxn]; void dfs2(int u, int p, int f) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w, idx = edges[e].idx; if (v == p) continue; if (vis[v]) { if (!found) ans[idx] = (f ? u : v), found = 1; continue; } if (!iscycle[v]) { // then must point to v ans[idx] = v; } else { assert(iscycle[u] \u0026amp;\u0026amp; iscycle[v]); if (f) { ans[idx] = u; } else { ans[idx] = v; } } dfs2(v, u, f); } } bool check() { for (int u = 1; u \u0026lt;= n; u++) { set\u0026lt;int\u0026gt; se; int cnt = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w, idx = edges[e].idx; if (ans[idx] == u) se.insert(1); else se.insert(w); cnt++; } if (se.size() != cnt) return 0; } return 1; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w,i); addEdge(v,u,w,i); } dfs(1); memset(vis, 0, sizeof(vis)); found = 0; dfs2(cu, -1, 0); // start with any point on the cycle if (check()) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } memset(vis, 0, sizeof(vis)); found = 0; dfs2(cu, -1, 1); // start with any point on the cycle if (check()) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } cout \u0026lt;\u0026lt; \u0026quot;impossible\\n\u0026quot;; }   ","date":"2021-11-16T15:38:25+08:00","permalink":"https://tom0727.github.io/post/057-%E5%9F%BA%E7%8E%AF%E6%A0%91/","tags":["",""],"title":"基环树"},{"categories":["解题报告"],"contents":"排名 Solve: 5 (ADEFJ)\nPenalty: 767\nRank: 122/343 (35%)\n题解 D - Exam Results 题意\n给定 $n$ 个学生，第 $i$ 个学生的分数要么为 $a_i$，要么为 $b_i$。\n给定整数 $P \\in [1,100]$，如果最高分为 $x$，则分数 $\\geq x * \\frac{P}{100}$ 的学生可以及格。\n求所有可能的情况中，及格学生的最大数量？\n其中，$1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i \\leq b_i \\leq 10^9$。\n 题解 直接枚举可能出现的最高分，我们知道要保证 $x$ 为最高分，必须有 $x \\geq \\max \\{a_i\\}$。\n如果我们从小到大枚举 $x$，会发现 $[x * \\frac{P}{100}, x]$ 是一个滑动的窗口。\n所以本题只要先把所有的 $a_i, b_i$ 放在一起，然后 sort 一下，从 $\\max \\{a_i\\}$ 开始枚举 $x$，在窗口滑动的过程中，利用类似于莫队的思想维护及格人数即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+7; ll n,p,ans = 0; struct Point { ll x, id; } arr[maxn*2]; int cnt[maxn]; ll cur = 0; void add(int x) { cnt[x]++; if (cnt[x] == 1) cur++; } void minu(int x) { cnt[x]--; if (!cnt[x]) cur--; } int main() { int T; read(T); for (int t = 1; t \u0026lt;= T; t++) { ans = 0; read(n), read(p); cur = 0; ll lmax = 0; for (int i = 1; i \u0026lt;= n; i++) { ll a,b; read(b); read(a); a *= 100LL, b *= 100LL; lmax = max(lmax, a); arr[i*2 - 1] = {a, i}, arr[i*2] = {b, i}; } sort(arr+1, arr+2*n+1, [](auto a, auto b) { return a.x \u0026lt; b.x; }); int st = 0; for (int i = 1; i \u0026lt;= 2*n; i++) { if (arr[i].x \u0026gt;= lmax) { st = i; break; } } int lptr = 0, rptr = 0; for (int i = st; i \u0026lt;= 2*n; i++) { ll L = arr[i].x / 100 * p, R = arr[i].x; while (rptr + 1 \u0026lt;= 2*n \u0026amp;\u0026amp; arr[rptr+1].x \u0026lt;= R) { rptr++; add(arr[rptr].id); } while (lptr + 1 \u0026lt;= rptr \u0026amp;\u0026amp; arr[lptr+1].x \u0026lt; L) { lptr++; minu(arr[lptr].id); } ans = max(ans, cur); } printf(\u0026quot;Case #%d: %lld\\n\u0026quot;, t, ans); fill(cnt, cnt+n+5, 0); } }   J - Kingdom\u0026rsquo;s Power 题意\n给定一棵 $n$ 个节点的有根树，根为 $1$。$1$ 的位置有无限个飞船。\n每一步操作中，可以选定任意一个飞船，让它走向它的一个邻居。\n求最少操作数使得所有节点被访问至少一次？\n其中，$n \\leq 10^6$\n 题解 猜想 $1$：\n任意时刻，只有一个飞船是 有用的。\n要么我们动这个飞船，要么我们动 $1$ 里面的无限个飞船。如果我们在访问某个子树时没有使用这个飞船，那么这个飞船就再也不会被用到了。\n这个猜想是正确的（然而我也不确定怎么严格证明）。\n猜想 $2$：\n我们可以利用贪心，从 $1$ 开始 dfs，根据 最大深度 的顺序，从小到大 dfs 它的 child。\n这个贪心也是正确的，感性理解的话可以考虑最简单的情况：\n这里从 $2$ 出发的话应该是先访问 $3,4$ ，最后访问 $5$。\n 利用以上贪心就可以写出一个 $O(n\\log n)$ 的解法：\n直接维护当前 有用 飞船的位置 $x$，然后每次要移动到下一个点 $y$ 的时候，比较一下 $d(x,y)$ 和 $d(1,y)$ 的距离即可，然后更新 $x=y$。\n比赛的时候就是这样写的，然后愉快的T了。\n $O(n)$ 正解：\n我们发现，对于一个节点 $u$，我们定义 $dp[u]$ 为：访问完 $u$ 的整个子树，并且飞船不回来（即停留在访问时的哪个节点）所需要的步数。\n$dp[u]$ 怎么转移？\n对于 $u$ 的每个child $v$，除了最后一个访问的 $v$ 以外，其他的 child 都需要访问结束以后，再回到 $u$。\n回到 $u$ 的飞船，要么是访问完 $v$ 的那个飞船再走回来，要么我们直接从 $1$ 派一个飞船到 $u$，看哪个距离更近就好了。\n所以有：\n$$dp[u] = \\sum\\limits_v \\{1 + dp[v] + \\min \\{maxdep[v] - dep[u], dep[u]\\} \\}$$\n注意到这个转移把 最后一个child $v$ 需要回到 $u$ 的贡献也算上了，且我们知道最后一个child $v$ 访问完毕时，停留的节点深度为 $maxdep[u]$，所以我们需要减掉这个贡献：\n$$dp[u] = dp[u] - \\min \\{maxdep[u] - dep[u], dep[u]\\}$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+3; int T, n; int dep[maxn], maxdep[maxn], head[maxn], ecnt = 1; ll dp[maxn]; struct Edge { int to, nxt; } edges[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u) { maxdep[u] = dep[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dep[to] = dep[u] + 1; dfs1(to); maxdep[u] = max(maxdep[u], maxdep[to]); } } void dfs2(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs2(to); dp[u] += (dp[to] + min(maxdep[to] - dep[u], dep[u]) + 1); } dp[u] -= (min(maxdep[u] - dep[u], dep[u])); } int main() { read(T); for (int t = 1; t \u0026lt;= T; t++) { read(n); for (int u = 2; u \u0026lt;= n; u++) { int v; read(v); addEdge(v, u); } dep[1] = 0; dfs1(1); dfs2(1); printf(\u0026quot;Case #%d: %lld\\n\u0026quot;,t, dp[1]); fill(maxdep, maxdep+n+2, 0); fill(dp, dp+n+2, 0); ecnt = 1; fill(head, head+n+2, 0); } }   H - Interstellar Hunter 题意\n在一个无限大的二维平面中，我们的初始位置为 $(0,0)$，现在给定 $Q$ 个询问，每次询问为两种格式：\n$1 ~ x ~ y$：获得 $(x,y)$ 的跳跃能力。\n$2 ~ x ~ y ~ w$：在 $(x,y)$ 的位置出现一个价值为 $w$ 的宝藏，可以选择走到这里拿宝藏。\n当我们拥有 $(a,b)$ 的跳跃能力时，可以将我们的坐标 $(x,y)$ 变为 $(x+a,y+b)$ 或者 $(x-a,y-b)$。\n求最大的宝藏价值总和？\n其中，$Q \\leq 10^6$。\n 题解 获得一个跳跃能力以后，我们每次移动就多了一种移动方式。\n注意到我们当前坐标为多少不会影响答案，因为这个获得的跳跃能力，相当于在一个 整数域 中维护一些向量组成的 $span$。每次都看作是从 $(0,0)$ 出发就好了。\n现在问题就在于如何维护向量集合了。\n有一个结论：\n如果集合中有 $\\geq 2$ 个不共线向量，则可以用 $(d,0), (x_2,y_2)$ 来表示这个向量集合的 $span$，其中 $d \\leq x_2$。\n证明？我也不会。\n现在考虑一下如果我们加入了一个新的向量 $(x,y)$，怎么更新这些向量？\n在整数域下，就需要保证 $d$ 尽量小，而 $y_2$ 也尽量小。\n所以我们可以先用 $(x_2,y_2)$ 与 $(x,y)$ 构造出一个 $(x',0)$ 的向量，然后更新 $d = \\gcd(d,x')$。\n要令 $y_2$ 尽量小，则我们用 $(x_2,y_2)$ 与 $(x,y)$ 构造出 $(x'', \\gcd(y_2,y))$。\n这个构造的过程，就是一个 linear combination 的过程。\n那么怎么构造呢？注意到是在整数域下，所以用 $exgcd$！\n所以设：\n$$ay_2 + by = 0$$\n令 $g = \\gcd(y_2,y)$，就有：\n$$a\\frac{y_2}{g} + b\\frac{y}{g} = 0$$\n所以 $a = -\\frac{y}{g}, b = \\frac{y_2}{g}$，就有：\n$$a(x_2,y_2) + b(x,y) = (x', 0)$$\n然后同理，解出\n$$a(x_2,y_2) + b(x,y) = (x'', \\gcd(y_2,y))$$\n解出来以后，令 $x_2 = x'', y_2 = \\gcd(y_2,y)$ 即可。\n• 注意需要单独处理 $d,x,y=0$ 的情况。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+3; int T, Q; ll curx, cury; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int cnt = 0; ll d = 0, x2, y2; int main() { read(T); for (int tt = 1; tt \u0026lt;= T; tt++) { read(Q); d = x2 = y2 = 0; ll ans = 0; while (Q--) { int t; ll x,y,w; read(t); read(x); read(y); if (t == 1) { if (y == 0) { d = gcd(d, x); continue; } ll a,b; ll g = exgcd(y, y2, a, b); // 因为 y2 = 0 无所谓，所以 g != 0 ll xx = abs(-y2 * x + y * x2) / g; d = gcd(d, xx); y2 = g; x2 = a * x + b * x2; if (d) x2 = (x2 % d + d) % d; } else { read(w); if (y == 0) { if (!d \u0026amp;\u0026amp; !x) ans += w; if (d \u0026gt; 0 \u0026amp;\u0026amp; x % d == 0) ans += w; } else { if (y2 \u0026amp;\u0026amp; y % y2 == 0) { ll c = y / y2; x -= c * x2; if (d \u0026amp;\u0026amp; x % d == 0) ans += w; if (!d \u0026amp;\u0026amp; !x) ans += w; } } } } printf(\u0026quot;Case #%d: %lld\\n\u0026quot;, tt, ans); } }   参考链接\nhttps://www.silllage.com/2020-ccpc-qhd-i-interstellar-hunter/ https://blog.csdn.net/nagisa2019/article/details/115414362 https://blog.csdn.net/wanherun/article/details/114477252 https://www.cnblogs.com/st1vdy/p/13870452.html\n ","date":"2021-10-31T11:32:46+08:00","permalink":"https://tom0727.github.io/post/056-ccpc2020%E7%A7%A6%E7%9A%87%E5%B2%9B/","tags":["",""],"title":"CCPC2020秦皇岛"},{"categories":["算法"],"contents":"二次剩余用于解决在 模意义下开根 的问题：\n题意\n给定一个质数 $P$ 和一个非负整数 $N$，求 $x$ 使得\n$$x^2 \\equiv N (\\text{mod } P)$$\n本问题等价于求 $$\\sqrt N ~(\\text{mod } P)$$\n 性质  这个问题可能无解，如果有解，则有两个解，它们互为相反数。   模版 // 求 sqrt(a) 在 mod P 下的值 // 调用 solve(a, P, r1, r2) // 若有解，r1, r2 分别为两个解，其中 r1 小，r2 大 // 若无解，r1 == -1 namespace Quadratic_residue { ll qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } bool check_if_residue(ll x, ll P) { return qpow(x, (P - 1) \u0026gt;\u0026gt; 1, P) == 1; } void solve(ll a, ll P, ll\u0026amp; r1, ll\u0026amp; r2) { if (a \u0026lt;= 1) { r1 = a, r2 = P - a; return; } if (!check_if_residue(a, P)) { r1 = -1; return; } ll x; while (1) { x = 1LL * rand() * rand() % P; if (qpow((x*x-a+P)%P,(P-1)/2, P)!=1) break; } ll w = (x * x - a + P) % P; pll res = {1,0}, t = {x,1}; auto Mul=[\u0026amp;](pll a,pll b){ // 复数乘法 ll x=(1LL * a.first * b.first + 1LL * a.second * b.second % P * w) % P; ll y=(1LL * a.first * b.second + 1LL * a.second * b.first) % P; return make_pair(x,y); }; ll d = (P+1) / 2; while (d) { if(d \u0026amp; 1) res = Mul(res,t); t = Mul(t,t); d \u0026gt;\u0026gt;= 1; } ll r = (res.first % P + P) % P; r1 = min(r, (P - r) % P); r2 = max(r, (P - r) % P); } };  参考链接  https://chasingdeath.github.io/articles/2020/08/15/2244ecc3.html （模版来源） https://www.luogu.com.cn/problem/P5491  ","date":"2021-10-30T11:19:19+08:00","permalink":"https://tom0727.github.io/post/055-%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/","tags":["二次剩余"],"title":"二次剩余"},{"categories":["算法"],"contents":"介绍 生成函数可以解决形如 满足XX条件的方案数共有多少种 的问题，它也能够解决 推导通项公式 等问题，生成函数常常与多项式运算结合在一起。\n定义 对于一个无限数列\n$$a = \\{a_0, a_1, a_2, \u0026hellip;\\}$$\n它的生成函数为\n$$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; = \\sum\\limits_{i=0}^{\\infty}a_ix^i$$\n其中 $x$ 的值并没有意义。\n• 有限数列 $\\{a_0, a_1, a_2, \u0026hellip;, a_n\\}$ 的生成函数就是 $f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n = \\sum\\limits_{i=0}^{n}a_ix^i$\n• 我们定义 $[x^{k}]f(x)$ 为 $f(x)$ 表达式中，$x^k$ 的系数。（为了方便表达，有的时候也会使用 $a_k, b_k$）\n封闭形式与展开形式 生成函数有 封闭形式 和 展开形式 两种形态。\n封闭形式适合进行生成函数之间的运算，展开形式则可以得到生成函数各项的系数（通项公式），从而获得最终的答案（方案数的统计）。\n例如，对于无限数列\n$$\\{1,1,1,1,\u0026hellip;\\}$$\n它的生成函数展开形式为：\n$$f(x) = 1+x+x^2+x^3+\u0026hellip;$$\n很明显这是一个等比数列，公比为 $x$，进行求和可以得到封闭形式：\n$$f(x) = 1+x+x^2+x^3+\u0026hellip; = \\frac{1}{1-x}$$\n一些常见的封闭式与展开式的对应    封闭形式 展开形式 数列 通项公式     $\\frac{1}{1-x}$ $\\sum\\limits_{i=0}^{\\infty}x^i = 1+x+x^2+x^3+\u0026hellip;$ $\\{1,1,1,1,\u0026hellip;\\}$ $b_k = 1$   $\\frac{1}{(1-x)^2}$ $\\sum\\limits_{i=0}^{\\infty}(i+1)x^i = 1+2x+3x^2+4x^3+\u0026hellip;$ $\\{1,2,3,4,\u0026hellip;\\}$ $b_k = k+1$   $\\frac{1}{1-ax}$ $\\sum\\limits_{i=0}^{\\infty}a^ix^i = 1+ax+a^2x^2+a^3x^3+\u0026hellip;$ $\\{1,a,a^2,a^3,\u0026hellip;\\}$ $b_k = a^{k}$   $\\frac{1}{(1-ax)^n}$ $\\sum\\limits_{i=0}^{\\infty}C_{(n-1)+i}^{(n-1)}a^ix^i$ $\\{1, C_{n}^{1}a^1, C_{n+1}^{2}a^2,C_{n+2}^{3}a^3,\u0026hellip;\\}$ $b_k = C_{n+k-1}^{k}a^k$   $\\frac{1}{1+x}$ $\\sum\\limits_{i=0}^{\\infty}(-1)^ix^i = 1-x+x^2-x^3+\u0026hellip;$ $\\{1,-1,1,-1,\u0026hellip;\\}$ $b_k = -1^k$     证明 证明1 $$\\frac{1}{1-x} = 1+x+x^2+x^3+\u0026hellip;$$\n证：等比数列，公比为 $x$。\n 证明2 $$\\frac{1}{(1-x)^2} = 1+2x+3x^2+4x^3+\u0026hellip;$$\n证：因为\n$$\\frac{1}{(1-x)^2} = (\\frac{1}{1-x})^2 = (1+x+x^2+x^3+\u0026hellip;)^2$$\n根据组合意义，对于 $x^k$，有 $(0,k),(1,k-1),\u0026hellip;,(k,0)$ 共 $(k+1)$ 种组合方式，并且每一种的系数为 $1$，所以 $x^k$ 的系数为 $(k+1)$。\n 证明3 $$\\frac{1}{1-ax} = 1+ax+a^2x^2+a^3x^3+\u0026hellip;$$\n证：等比数列，公比为 $ax$。\n 证明4 $$\\frac{1}{(1-ax)^n} = \\sum\\limits_{i=0}^{\\infty}C_{(n-1)+i}^{(n-1)}a^ix^i$$\n证：因为\n$$\\frac{1}{(1-ax)^n} = (1+ax+a^2x^2+a^3x^3+\u0026hellip;)^n$$\n根据组合意义，对于 $x^k$ 而言，每个 $(1+ax+a^2x^2+a^3x^3+\u0026hellip;)$ 都可以贡献给 $k$，而这样的式子有 $n$ 个。\n所以相当于：\n求 $a_1+a_2+\u0026hellip;+a_n = k$ 的非负整数解的个数。\n 这是 小球放盒子 模型，$k$ 个球放入 $n$ 个盒子并且允许空盒，用隔板法即可，方案数为 $C_{(n-1)+k}^{(n-1)}$，这就是 $a^kx^k$ 的系数。\n 证明5 $$\\frac{1}{1+x} = 1-x+x^2-x^3+\u0026hellip;$$\n等比数列，公比为 $-x$。\n 计算例子 例1 题意\n求无限数列 $a_i = i^2$ 的生成函数。\n分别求出展开式和封闭式。\n 展开式 $\\Rightarrow$ 封闭式 数列 $a$ 为：\n$$a = \\{0,1,4,9,16,\u0026hellip;\\}$$\n那么生成函数的展开式为：\n$$f(x) = x + 4x^2 + 9x^3 + 16x^4 + \u0026hellip; = \\sum\\limits_{i=1}^{\\infty}i^2x^i$$\n 在推导生成函数的封闭式时，一个非常重要的 trick 是给展开式 乘上一个 $x$。\n 那么乘上 $x$ 以后，相当于整个展开式向右移动了一位，对应的生成函数就是\n$$xf(x) = 0 + x^2 + 4x^3 + 9x^4 + \u0026hellip; = \\sum\\limits_{i=1}^{\\infty}(i-1)^2x^i$$\n所以两者相减，可得：\n$$(1-x)f(x) = \\sum\\limits_{i=1}^{\\infty}(i^2 - (i-1)^2)x^i = \\sum\\limits_{i=1}^{\\infty}(2i-1)x^i$$\n$$=2\\sum\\limits_{i=1}^{\\infty}ix^i - \\sum\\limits_{i=1}^{\\infty}x^i$$\n$$=\\frac{2x}{(1-x)^2} - \\frac{x}{1-x}$$\n• 注意到因为求和是从 $i=1$ 开始的，相当于 $i=0$ 的情况整体右移了一位，所以要乘上 $x$ 得到 $\\frac{2x}{(1-x)^2}$\n所以生成函数 $f(x)$ 的封闭式为：\n$$f(x) = \\frac{2x}{(1-x)^3} - \\frac{x}{(1-x)^2} = \\frac{x(x+1)}{(1-x)^3}$$\n 封闭式 $\\Rightarrow$ 展开式 已知 $f(x)$ 的封闭式为\n$$f(x) = \\frac{x(x+1)}{(1-x)^3}$$\n我们将其化简为上面 常用表 里面的组合，也就是 裂项：\n$$f(x) = \\frac{x(x+1)}{(1-x)^3} = \\frac{2x}{(1-x)^3} - \\frac{x}{(1-x)^2}$$\n考虑第 $k$ 项的系数，注意到我们可以将分子中的 $x$ 提出来，所以 $f(x)$ 的第 $k$ 项系数 $a_k$ 就等于 $g(x) = (\\frac{2}{(1-x)^3} - \\frac{1}{(1-x)^2})$ 的第 $(k-1)$ 项系数 $b_{k-1}$。\n$$\\frac{2}{(1-x)^3} = 2\\sum\\limits_{i=0}^{\\infty}C_{2+i}^{2}x^i, ~ \\frac{x}{(1-x)^2} = \\sum\\limits_{i=0}^{\\infty}(i+1)x^i$$\n所以 $g(x)$ 的第 $(k-1)$ 项系数为：\n$$b_{k-1} = [x^{k-1}]2(\\sum\\limits_{i=0}^{\\infty}C_{2+i}^{2}x^i) - \\sum\\limits_{i=0}^{\\infty}(i+1)x^i = 2C_{k+1}^2 - k = k^2$$\n所以 $f(x)$ 的第 $k$ 项系数为 $a_k = b_{k-1} = k^2$。\n于是生成函数的展开式为：\n$$f(x) = \\sum\\limits_{i=0}^{\\infty}i^2x^i = x + 4x^2 + 9x^3 + 16x^4 + \u0026hellip;$$\n 例2 题意\n求斐波那契数列 $$f_0 = 0, f_1 = 1, f_i = f_{i-1} + f_{i-2}$$\n的生成函数，分别求出展开式（通项公式）和封闭式。\n 封闭式 注意到\n$$f(x) = f_0 + f_1x^1 + f_2x^2 + f_3x^3 + \u0026hellip;$$\n$$xf(x) = 0 + f_0x^1 + f_1x^2 + f_2x^3 + \u0026hellip;$$\n$$x^2f(x) = 0 + 0+ f_0x^2 + f_1x^3 + \u0026hellip;$$\n由于 $f_i = f_{i-1} + f_{i-2}$，所以：\n$$f(x)(1-x-x^2) = f_0 + (f_1-f_0)x^1 = x$$\n所以 $$f(x) = \\frac{x}{1-x-x^2}$$\n 封闭式$\\Rightarrow$展开式 $$f(x) = \\frac{x}{1-x-x^2}$$\n我们希望将它转为表格中存在的形式，所以我们设：\n$$(1-ax)(1-bx) = 1-x-x^2$$\n可得 $a = \\frac{1 + \\sqrt 5}{2}, b = \\frac{1 - \\sqrt 5}{2}$\n设\n$$g(x) = \\frac{f(x)}{x} = \\frac{1}{(1-ax)(1-bx)}$$\n那么要求 $f(x)$ 的第 $n$ 项系数，只要求 $g(x)$ 的第 $(n-1)$ 项系数即可。\n因为\n$$g(x) = \\frac{1}{(1-ax)(1-bx)}$$ $$= \\sum\\limits_{i=0}^{\\infty}a^ix^i * \\sum\\limits_{j=0}^{\\infty}b^jx^j$$ $$= (1+ax+a^2x^2+a^3x^3+\u0026hellip;) * (1+bx+b^2x^2+b^3x^3+\u0026hellip;)$$\n这是个卷积，那么 $g(x)$ 的第 $(n-1)$ 项系数为：\n$$[x^{n-1}]g(x) = \\sum\\limits_{k=0}^{n-1}a^{k}b^{n-1-k}$$\n$$=b^{n-1}\\sum\\limits_{k=0}^{n-1}a^{k}b^{-k}$$\n$$=b^{n-1}\\sum\\limits_{k=0}^{n-1}(\\frac{a}{b})^k$$\n右边就是个等比数列求和了，公比为 $\\frac{a}{b}$，最后可得\n$$[x^n]f(x) = [x^{n-1}]g(x) = \\frac{1}{\\sqrt 5}((\\frac{1+\\sqrt 5}{2})^n - (\\frac{1-\\sqrt 5}{2})^n)$$\n那么求出了 $f(x)$ 的通项公式，展开式也就可以写出来了。\n 例题 例1 洛谷P4721【模板】分治 FFT 题意\n给定 $n-1$ 个非负整数 $g_1, g_2, \u0026hellip; g_{n-1}$。\n定义 $$f_0 = 1, f_i = \\sum\\limits_{j=1}^if_{i-j}g_j$$\n求出 $f_1, f_2, \u0026hellip;, f_{n-1}$，答案对 $998244353$ 取模。\n其中，$2 \\leq n \\leq 10^5$\n 题解  看到 $\\sum\\limits_{j=1}^if_{i-j}g_j$ 就想到卷积，也就是多项式乘法。\n 那么令\n$$f(x) = f_0 + f_1x^1 + f_x2x^2 + \u0026hellip; + f_{n-1}x^{n-1}$$\n$$g(x) = g_0 + g_1x^1 + g_x2x^2 + \u0026hellip; + g_{n-1}x^{n-1}$$\n$$h(x) = f(x)g(x)$$\n则有：\n$$[x^n]h(x) = \\sum\\limits_{i=0}^nf_ig_{n-i}$$\n发现和 $f_n = \\sum\\limits_{j=1}^nf_{n-j}g_j$ 就差一个 $j=0$ 的情况（多了一个 $g_0f_n$），那么我们直接令 $g_0 = 0$ 就没问题了。\n这样的话，当 $n=0$ 时，$h_0 = 0$，其他时候 $h_n = f_n$。\n所以：\n$$f(x)g(x) = h(x) = 0 + f_1x^1 + f_x2x^2 + \u0026hellip; + f_{n-1}x^{n-1} = f(x) - f_0 = f(x) - 1$$\n得到\n$$f(x)(1-g(x)) = 1$$\n$$f(x) = \\frac{1}{1-g(x)}$$\n多项式求逆即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 板子省略 ll f[maxn], g[maxn], invG[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) cin \u0026gt;\u0026gt; g[i]; for (int i = 1; i \u0026lt;= n-1; i++) g[i] = (-g[i] + mod) % mod; g[0] = 1; poly_inverse(g, invG, n); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; (invG[i]) % mod \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   注意点\n多项式的题目中，要注意几个点：\n 看到 $\\sum_{i=0}^n f_ig_{n-i}$ 这种形式，即系数之和无论 $i$ 为多少，均为定值的，就想到 卷积，从而想到 多项式乘法。 转化出来的新多项式要注意 常数项。也就是代入 $n=0$ 判断一下左右两边是否相等。   例2 洛谷P4841 集训队作业2013 城市规划 题意\n求 $n$ 个节点的 简单（无重边无自环）有标号无向 连通 图数目。答案对 $1004535809$ 取模。\n其中，$n \\leq 130000$\n 题解  小tips：计数问题可以想想 dp 怎么做。\n 设 $f_n$ 为 $n$ 个节点的 简单（无重边无自环）有标号无向 连通 图数目。\n设 $g_n$ 为 $n$ 个节点的 简单（无重边无自环）有标号无向图数目。（区别在于不需要连通）\n发现在一个完全图中有 $C_n^2$ 条边，每条边可以选或者不选，那么\n$$g_n = 2^{C_n^2}$$\n我们想要用另外一种方式表示 $g_n$，可以枚举 节点 $1$ 所在的联通块的大小：\n 节点 $1$ 所在联通块大小为 $1$ 时，方案数为：$f_1g_{n-1}$ 节点 $1$ 所在联通块大小为 $2$ 时，方案数为：$C_{n-1}^{1}f_2g_{n-2}$ 节点 $1$ 所在联通块大小为 $k$ 时，方案数为：$C_{n-1}^{k-1}f_kg_{n-k}$  所以联通块大小 $1$ 枚举到 $n$，有：\n$$g_n = \\sum\\limits_{i=1}^n C_{n-1}^{i-1}f_ig_{n-i}$$\n 看到 $f_ig_{n-i}$ 的形式马上想到 卷积，也就是 多项式乘法。\n 但是有一个 $C_{n-1}^{i-1}$，我们把它拆开即可：\n$$g_n = \\sum\\limits_{i=1}^n C_{n-1}^{i-1}f_ig_{n-i}$$\n$$g_n = (n-1)!\\sum\\limits_{i=1}^n\\frac{f_i}{(i-1)!}\\frac{g_{n-i}}{(n-i)!}$$\n令\n$$F_i = \\frac{f_i}{(i-1)!}, G_i = \\frac{g_i}{i!}$$\n则有：\n$$\\frac{g_n}{(n-1)!} = \\sum\\limits_{i=1}^nF_iG_{n-i}$$\n令\n$$F(x) = 0 + F_1x + F_2x^2 + \u0026hellip; + F_{n}x^n$$\n$$G(x) = G_0 + G_1x + G_2x^2 + \u0026hellip; + G_{n}x^n$$\n则可以发现，（注意 $F(x)$ 的常数项为 $0$）：\n$$[x^n]\\frac{g(x)}{(n-1)!} = [x^n]F(x)G(x)$$\n注意到 $\\frac{1}{(n-1)!}$ 是不可以提到外面去的，因为它与 $n$ 有关。\n定义\n$$H_n = \\frac{g_n}{(n-1)!}, H_0 = 0$$\n• $H_0 = 0$ 是因为：如果我们代入 $n=0$ 进 $[x^n]\\frac{g(x)}{(n-1)!} = [x^n]F(x)G(x)$，会发现右边为 $0$，所以 $H_0 = 0$。\n则有：\n$$[x^n]H(x) = [x^n]F(x)G(x)$$\n注意到左右两个多项式的 $n$ 次项系数对于任何 $n$ 都相等，所以有\n$$H(x) = F(x)G(x)$$\n$$F(x) = \\frac{H(x)}{G(x)}$$\n由于 $H(x), G(x)$ 均已知，多项式求逆即可求出 $F(x)$，在每一项系数上乘以 $(n-1)!$ 即可得到 $f(x)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1004535809; const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 多项式板子部分省略 ll f[maxn], g[maxn], G[maxn], invG[maxn], fac[maxn], invfac[maxn], h[maxn]; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; g[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) { g[i] = qpow(2, i * (i-1) / 2); } fac[0] = 1; for (int i = 1; i \u0026lt;= n; i++) fac[i] = fac[i-1] * (ll)i % mod; invfac[n] = qpow(fac[n], mod-2); for (int i = n-1; i \u0026gt;= 0; i--) invfac[i] = invfac[i+1] * (ll)(i+1) % mod; h[0] = 0; for (int i = 0; i \u0026lt;= n; i++) G[i] = g[i] * invfac[i] % mod; for (int i = 1; i \u0026lt;= n; i++) h[i] = g[i] * invfac[i-1] % mod; poly_inverse(G, invG, n+1); poly_multiply(h, n+1, invG, n+1, f); f[n] = f[n] * fac[n-1] % mod; cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; }   注意点\n 计数问题，想想 dp 思路？ 项数不能随便提出去，尤其是与 $n$ 有关的。遇到项数就转化成一个新的多项式来处理。 如果对于任何 $n$，左右两边的多项式第 $n$ 项系数相同，则这两个多项式相等。   例3 CF438E The Child and Binary Tree 题意\n给定一个包含 distinct 正整数的集合 $\\{c_1, c_2, \u0026hellip;, c_n\\}$。\n给定整数 $m$，对于所有的 $s \\in [1,m]$，求出满足以下条件的本质不同的 带点权二叉树个数：\n 每个顶点的权值必须在 $\\{c_1, c_2, \u0026hellip;, c_n\\}$ 中。 所有顶点的权值之和为 $s$。  答案对 $998244353$ 取模。\n其中，$1 \\leq n,m,c_i \\leq 10^5$。\n 题解 首先用 dp 的思路：\n设 $f_n$ 为权值和为 $n$ 的二叉树个数（根的值 尚未确定），设 $g_n$ 为权值和为 $n$ 的二叉树个数（根的值 已经确定）。\n则我们可以得出：\n$$f_n = \\sum\\limits_{i=1}^n g_{n-c_i}$$\n$$g_n = \\sum\\limits_{i=0}^n f_if_{n-i}$$\n解释：\n对于第一个式子，我们枚举根的值即可。\n对于第二个式子，由于根的值已经确定，所以只需要枚举左右子树的权值和即可。\n我们看到 $g_n = \\sum\\limits_{i=0}^n f_if_{n-i}$，发现这就是个卷积，所以有\n$$g(x) = f(x)^2$$\n但第一个式子怎么办呢？这是个加法，无法表示为卷积？\n注意到本题中所有的权值 $\\leq 10^5$，我们不如定义 $h_i$ 为：\n$$h_i = \\begin{cases} 1 ~~~~ \\text{if } i \\in \\{c_1, c_2, \u0026hellip;, c_n\\} \\\\ 0 ~~~~ \\text{if } i \\notin \\{c_1, c_2, \u0026hellip;, c_n\\} \\end{cases}$$\n则我们可以将 $f_n = \\sum\\limits_{i=1}^n g_{n-c_i}$ 转化为：\n$$f_n = \\sum\\limits_{i=1}^nh_ig_{n-i}$$\n这就又是个卷积了，代入 $n=0$ 可以发现：因为 $f_0 = g_0 = 1, h_0 = 0$，所以\n$$f(x) = h(x)g(x) + 1 = h(x)f(x)^2 + 1$$\n所以：\n$$h(x)f(x)^2 - f(x) + 1 = 0$$\n利用公式 $x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ 有：\n$$f(x) = \\frac{1 \\pm \\sqrt{1-4h(x)}}{2h(x)}$$\n有个问题，$h(x)$ 的常数项 $h(0) = 0$ 没法求逆？（注意到求逆的本质是 $h(x) * h^{-1}(x) = 1$）\n没关系，没法求逆就乘到左边去，得到：\n$$2f(x)h(x) = 1 \\pm \\sqrt{1-4h(x)}$$\n代入 $x = 0$，由 $h(0) = 0$ 可以得到右边只能取 负号。\n所以再把 $h(x)$ 除回去，得到：\n$$f(x) = \\frac{1 - \\sqrt{1-4h(x)}}{2h(x)}$$\n上下同乘 $(1 + \\sqrt{1-4h(x)})$ 得到：\n$$f(x) = \\frac{2}{1 + \\sqrt{1-4h(x)}}$$\n多项式求逆求出 $f(x)$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;21) + 5; int n,m; ll h[maxn], H[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int c; cin \u0026gt;\u0026gt; c; h[c] = 1; } for (int i = 1; i \u0026lt;= 1e5; i++) { h[i] = 4LL * h[i] % mod; h[i] = (-h[i] + mod) % mod; } h[0] = (h[0] + 1) % mod; poly_sqrt(h, H, 1e5+1); H[0] = (H[0] + 1) % mod; memset(h, 0, sizeof(h)); poly_inverse(H, h, 1e5+1); for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; h[i] * 2LL % mod \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P4451 整数的lqp拆分 题意\n给定正整数 $N$，对于所有可能的 $m \u0026gt; 0$，一个整数拆分是一个有序数组 $(a_1,a_2,\u0026hellip;,a_m)$ 满足：\n $a_i \u0026gt; 0$ $a_1 + a_2 + \u0026hellip; + a_m = N$  我们定义斐波那契数列为：\n$$F_0 = 0, F_1 = 1, F_2 = 1, F_n = F_{n-1} + F_{n-2}$$\n对于 $N$ 而言，它的一个整数拆分 $(a_1,a_2,\u0026hellip;,a_m)$ 的权值为：\n$$F_{a_1} * F_{a_2} * \u0026hellip; * F_{a_m}$$\n求所有可能的整数拆分的权值之和？形式化的，求：\n$$\\sum\\limits_{(a_1,a_2,\u0026hellip;,a_m)}\\prod_{i=1}^mF_{a_i}$$\n答案对 $10^9 + 7$ 取模。\n其中，$1 \\leq N \\leq 10^{10000}$\n 题解 我们发现这个 $\\sum$ 和 $\\prod$ 的顺序其实可以调换的。\n所以我们枚举一下第一个元素 $a_1$，设 $f_n$ 为我们所求的值，问题就转化为：\n$$f_n = \\sum\\limits_{j=1}^nF_j*f_{n-j}$$\n其中，$f_0 = 1$。\n所以设\n$$G(x) = F(x)f(x)$$\n$$G(0) = F(0)f(0) = 0$$\n所以有\n$$f(x) = G(x) + 1 = F(x)f(x) + 1$$\n得出\n$$f(x) = \\frac{1}{1-F(x)}$$\n斐波那契数列的生成函数为（不记得了就手推一下）：$$F(x) = \\frac{x}{1-x-x^2}$$\n所以得到：\n$$f(x) = \\frac{1-x-x^2}{1-2x-x^2} = 1-\\frac{x}{x^2+2x-1}$$\n我们发现这个常数项 $1$ 对我们的 $n$ 次项系数 $f_n$ 并没有任何影响，所以可以直接忽略。\n现在我们需要裂项了，转化为表里面的形式：\n$$f(x) = \\frac{-x}{x^2+2x-1} = \\frac{c}{1-ax} + \\frac{d}{1-bx}$$\n解方程就可以得到\n$$b = -1\\pm \\sqrt 2, a = -1 \\mp \\sqrt 2$$\n发现随便取哪个符号都一样（毕竟 $a,b$ 本就是对称的），所以有：\n$$b = 1 + \\sqrt 2, a = 1 - \\sqrt 2, c = -\\frac{1}{2\\sqrt 2}, d = \\frac{1}{2\\sqrt 2}$$\n所以\n$$f(x) = \\frac{c}{1-ax} + \\frac{d}{1-bx}$$\n$f(x)$ 的第 $n$ 次项系数为：\n$$[x^n]f(x) = -\\frac{1}{2 \\sqrt 2}(a^n - b^n) = \\frac{1}{2\\sqrt 2}[(1+\\sqrt 2)^n - (1-\\sqrt 2)^n]$$\n最后的问题就是如何求 $(1+\\sqrt 2)^n - (1-\\sqrt 2)^n$ ？\n我们需要先知道 $\\sqrt 2$ 在 $\\text{mod }10^9 + 7$ 意义下的值，可以利用二次剩余解决。\n然后对于 $n$，我们发现它出现在指数位置，而我们由费马小定理知道 $\\forall a, a^{P-1} \\equiv 1 (\\text{mod } P)$\n所以，我们只要将 $n$ 取一个 $n = n(\\text{mod } (P-1))$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const ll mod = 1e9+7; const int maxn = 1e5+7; // 求 sqrt(a) 在 mod P 下的值 // 调用 solve(a, P, r1, r2) // 若有解，r1, r2 分别为两个解，其中 r1 小，r2 大 // 若无解，r1 == -1 namespace Quadratic_residue { ll qpow(ll a, ll b, ll P) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % P; a = a * a % P; b \u0026gt;\u0026gt;= 1; } return res; } bool check_if_residue(ll x, ll P) { return qpow(x, (P - 1) \u0026gt;\u0026gt; 1, P) == 1; } void solve(ll a, ll P, ll\u0026amp; r1, ll\u0026amp; r2) { if (a \u0026lt;= 1) { r1 = a, r2 = P - a; return; } if (!check_if_residue(a, P)) { r1 = -1; return; } ll x; while (1) { x=1ll*rand()*rand()%P; if (qpow((x*x-a+P)%P,(P-1)/2, P)!=1) break; } ll w=(x*x-a+P)%P; pll res = {1,0}, t = {x,1}; auto Mul=[\u0026amp;](pll a,pll b){ // 复数乘法 ll x=(1ll*a.first*b.first+1ll*a.second*b.second%P*w)%P; ll y=(1ll*a.first*b.second+1ll*a.second*b.first)%P; return make_pair(x,y); }; ll d=(P+1)/2; while (d) { if(d\u0026amp;1) res=Mul(res,t); t=Mul(t,t); d\u0026gt;\u0026gt;=1; } ll r = (res.first % P + P) % P; r1 = min(r, (P - r) % P); r2 = max(r, (P - r) % P); } }; ll s2, _; //sqrt(2) ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll readBigint() { string s; cin \u0026gt;\u0026gt; s; ll res = 0; for (int i = 0; i \u0026lt; s.size(); i++) { res = res * 10 % (mod - 1); res = (res + (s[i] - '0')) % (mod - 1); } return res; } int main() { ll n = readBigint(); Quadratic_residue::solve(2, mod, s2, _); ll ans = qpow((1LL + s2) % mod, n) - qpow((1LL - s2 + mod) % mod, n); ans = (ans + mod) % mod; ans = ans * inv(2LL * s2 % mod) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   注意事项\n$$a^b \\equiv a^{b \\text{ mod } (P-1)} (\\text{mod } P)$$\n 参考链接  https://blog.csdn.net/a_forever_dream/article/details/102594411  ","date":"2021-09-23T15:42:20+08:00","permalink":"https://tom0727.github.io/post/054-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","tags":["OGF",""],"title":"普通生成函数（OGF）"},{"categories":["算法"],"contents":"模版 多项式全家桶（比较精简的版本，利用了Z） template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} Z(ll x) : x(norm((int)(x % mod))) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, Z \u0026amp;a) { ll v; is \u0026gt;\u0026gt; v; a = Z(v); return is; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const Z \u0026amp;a) { return os \u0026lt;\u0026lt; a.val(); } }; std::vector\u0026lt;int\u0026gt; rev; std::vector\u0026lt;Z\u0026gt; roots{0, 1}; void dft(std::vector\u0026lt;Z\u0026gt; \u0026amp;a) { int n = a.size(); if (int(rev.size()) != n) { int k = __builtin_ctz(n) - 1; rev.resize(n); for (int i = 0; i \u0026lt; n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1 | (i \u0026amp; 1) \u0026lt;\u0026lt; k; } } for (int i = 0; i \u0026lt; n; i++) { if (rev[i] \u0026lt; i) { std::swap(a[i], a[rev[i]]); } } if (int(roots.size()) \u0026lt; n) { int k = __builtin_ctz(roots.size()); roots.resize(n); while ((1 \u0026lt;\u0026lt; k) \u0026lt; n) { Z e = power(Z(3), (P - 1) \u0026gt;\u0026gt; (k + 1)); for (int i = 1 \u0026lt;\u0026lt; (k - 1); i \u0026lt; (1 \u0026lt;\u0026lt; k); i++) { roots[2 * i] = roots[i]; roots[2 * i + 1] = roots[i] * e; } k++; } } for (int k = 1; k \u0026lt; n; k *= 2) { for (int i = 0; i \u0026lt; n; i += 2 * k) { for (int j = 0; j \u0026lt; k; j++) { Z u = a[i + j]; Z v = a[i + j + k] * roots[k + j]; a[i + j] = u + v; a[i + j + k] = u - v; } } } } void idft(std::vector\u0026lt;Z\u0026gt; \u0026amp;a) { int n = a.size(); std::reverse(a.begin() + 1, a.end()); dft(a); Z inv = (1 - P) / n; for (int i = 0; i \u0026lt; n; i++) { a[i] *= inv; } } struct Poly { std::vector\u0026lt;Z\u0026gt; a; Poly() {} Poly(const std::vector\u0026lt;Z\u0026gt; \u0026amp;a) : a(a) {} Poly(const std::initializer_list\u0026lt;Z\u0026gt; \u0026amp;a) : a(a) {} int size() const { return a.size(); } void resize(int n) { a.resize(n); } Z operator[](int idx) const { if (idx \u0026lt; size()) { return a[idx]; } else { return 0; } } Z \u0026amp;operator[](int idx) { return a[idx]; } Poly mulxk(int k) const { auto b = a; b.insert(b.begin(), k, 0); return Poly(b); } Poly modxk(int k) const { k = std::min(k, size()); return Poly(std::vector\u0026lt;Z\u0026gt;(a.begin(), a.begin() + k)); } Poly divxk(int k) const { if (size() \u0026lt;= k) { return Poly(); } return Poly(std::vector\u0026lt;Z\u0026gt;(a.begin() + k, a.end())); } friend Poly operator+(const Poly \u0026amp;a, const Poly \u0026amp;b) { std::vector\u0026lt;Z\u0026gt; res(std::max(a.size(), b.size())); for (int i = 0; i \u0026lt; int(res.size()); i++) { res[i] = a[i] + b[i]; } return Poly(res); } friend Poly operator-(const Poly \u0026amp;a, const Poly \u0026amp;b) { std::vector\u0026lt;Z\u0026gt; res(std::max(a.size(), b.size())); for (int i = 0; i \u0026lt; int(res.size()); i++) { res[i] = a[i] - b[i]; } return Poly(res); } friend Poly operator*(Poly a, Poly b) { if (a.size() == 0 || b.size() == 0) { return Poly(); } int sz = 1, tot = a.size() + b.size() - 1; while (sz \u0026lt; tot) { sz *= 2; } a.a.resize(sz); b.a.resize(sz); dft(a.a); dft(b.a); for (int i = 0; i \u0026lt; sz; ++i) { a.a[i] = a[i] * b[i]; } idft(a.a); a.resize(tot); return a; } friend Poly operator*(Z a, Poly b) { for (int i = 0; i \u0026lt; int(b.size()); i++) { b[i] *= a; } return b; } friend Poly operator*(Poly a, Z b) { for (int i = 0; i \u0026lt; int(a.size()); i++) { a[i] *= b; } return a; } Poly \u0026amp;operator+=(Poly b) { return (*this) = (*this) + b; } Poly \u0026amp;operator-=(Poly b) { return (*this) = (*this) - b; } Poly \u0026amp;operator*=(Poly b) { return (*this) = (*this) * b; } Poly deriv() const { if (a.empty()) { return Poly(); } std::vector\u0026lt;Z\u0026gt; res(size() - 1); for (int i = 0; i \u0026lt; size() - 1; ++i) { res[i] = (i + 1) * a[i + 1]; } return Poly(res); } Poly integr() const { std::vector\u0026lt;Z\u0026gt; res(size() + 1); for (int i = 0; i \u0026lt; size(); ++i) { res[i + 1] = a[i] / (i + 1); } return Poly(res); } Poly inv(int m) const { Poly x{a[0].inv()}; int k = 1; while (k \u0026lt; m) { k *= 2; x = (x * (Poly{2} - modxk(k) * x)).modxk(k); } return x.modxk(m); } Poly log(int m) const { return (deriv() * inv(m)).integr().modxk(m); } Poly exp(int m) const { Poly x{1}; int k = 1; while (k \u0026lt; m) { k *= 2; x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k); } return x.modxk(m); } Poly pow(int k, int m) const { int i = 0; while (i \u0026lt; size() \u0026amp;\u0026amp; a[i].val() == 0) { i++; } if (i == size() || 1LL * i * k \u0026gt;= m) { return Poly(std::vector\u0026lt;Z\u0026gt;(m)); } Z v = a[i]; auto f = divxk(i) * v.inv(); return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k); } Poly sqrt(int m) const { Poly x{1}; int k = 1; while (k \u0026lt; m) { k *= 2; x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2); } return x.modxk(m); } Poly mulT(Poly b) const { if (b.size() == 0) { return Poly(); } int n = b.size(); std::reverse(b.a.begin(), b.a.end()); return ((*this) * b).divxk(n - 1); } std::vector\u0026lt;Z\u0026gt; eval(std::vector\u0026lt;Z\u0026gt; x) const { if (size() == 0) { return std::vector\u0026lt;Z\u0026gt;(x.size(), 0); } const int n = std::max(int(x.size()), size()); std::vector\u0026lt;Poly\u0026gt; q(4 * n); std::vector\u0026lt;Z\u0026gt; ans(x.size()); x.resize(n); std::function\u0026lt;void(int, int, int)\u0026gt; build = [\u0026amp;](int p, int l, int r) { if (r - l == 1) { q[p] = Poly{1, -x[l]}; } else { int m = (l + r) / 2; build(2 * p, l, m); build(2 * p + 1, m, r); q[p] = q[2 * p] * q[2 * p + 1]; } }; build(1, 0, n); std::function\u0026lt;void(int, int, int, const Poly \u0026amp;)\u0026gt; work = [\u0026amp;](int p, int l, int r, const Poly \u0026amp;num) { if (r - l == 1) { if (l \u0026lt; int(ans.size())) { ans[l] = num[0]; } } else { int m = (l + r) / 2; work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l)); work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m)); } }; work(1, 0, n, mulT(q[1].inv(n))); return ans; } };   多项式全家桶（其他人的，很快） using ll = long long; // END OF HEADER #define ACM_MOD 998244353 const int P = ACM_MOD; #ifdef ACM_MOD int qpow(ll a, ll b = ACM_MOD - 2, ll m = ACM_MOD) { #else int qpow(ll a, ll b, ll m) { #endif ll ret = m != 1; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ret = ret * a % m; a = a * a % m; } return ret; } template \u0026lt;typename T\u0026gt; T tpow(T a, ll b) { T ret; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ret = ret * a; a = a * a; } return ret; } #define ACM_MATH_CIPOLLA_H namespace Qresidue { ll legendre(ll a, ll p) { return qpow(a, (p - 1) / 2, p); } ll find_a(ll n, ll p) { for (ll a = 0; a \u0026lt; p; a++) { ll i = (a * a - n + p) % p; if (qpow(i, (p - 1) / 2, p) == p - 1) return a; } return -1; } ll P, I; struct expnum { ll a = 1, b = 0; }; expnum operator*(expnum i1, expnum i2) { return expnum{(i1.a * i2.a + i1.b * i2.b % P * I) % P, (i1.b * i2.a + i1.a * i2.b) % P}; } std::pair\u0026lt;int, int\u0026gt; Cipolla(ll n, ll _p) { P = _p; if (n % P == 0) // 不互质的情形 return {0, 0}; if (legendre(n, P) != 1) return {-1, -1}; // 返回-1表示无解 ll a = find_a(n, P); I = (a * a - n + P) % P; ll ans = tpow(expnum{a, 1}, (P + 1) / 2).a % P; if (2 * ans \u0026gt; P) ans = P - ans; return {ans, P - ans}; } }; // namespace Qresidue std::pair\u0026lt;int, int\u0026gt; Cipolla(ll n, ll p) { return Qresidue::Cipolla(n, p); } inline int mo(int n) { return n \u0026gt;= P ? n - P : n; } inline int \u0026amp;momo(int \u0026amp;n) { return n \u0026gt;= P ? n -= P : n; } struct m32 { int v = 0; m32(int _v = 0) { v = _v; } m32 \u0026amp;operator=(const int \u0026amp;m) { v = m; return *this; } m32 \u0026amp;operator+=(const m32 \u0026amp;m) { v = (v += m.v) \u0026gt;= P ? v - P : v; return *this; } m32 \u0026amp;operator-=(const m32 \u0026amp;m) { v = (v -= m.v) \u0026lt; 0 ? v + P : v; return *this; } m32 operator-() const { return v == 0 ? 0 : P - v; } m32 \u0026amp;operator*=(const m32 \u0026amp;m) { v = ll(v) * m.v % P; return *this; } m32 operator+(const m32 \u0026amp;m) const { return m32(*this) += m; } m32 operator-(const m32 \u0026amp;m) const { return m32(*this) -= m; } m32 operator*(const m32 \u0026amp;m) const { return m32(*this) *= m; } m32 inv() const { return qpow(v); } m32 pow(int n) const { return qpow(v, n, P); } m32 sqrt() const { #ifdef ACM_MATH_CIPOLLA_H return Cipolla(v, P).first; #else return 1; #endif } }; inline int get_lim(int n) { int m = 1; while (m \u0026lt; n) m *= 2; return m; } struct Poly : std::vector\u0026lt;m32\u0026gt; { using vector::vector; bool isNTT = false; Poly(Poly::const_iterator pi, int len) : Poly(pi, pi + len) { } Poly rev() const { return Poly(rbegin(), rend()); } int deg() const { return size(); } Poly cut(int m) const { return Poly(begin(), begin() + min(deg(), m)); } Poly \u0026amp;resize(int m) { vector::resize(m); return *this; } Poly \u0026amp;fillZeroL(int t) { fill_n(begin(), t / 2, 0); return *this; } Poly \u0026amp;fillZeroH(int t) { fill_n(begin() + t / 2, t / 2, 0); return *this; } friend Poly operator+(Poly f, Poly g); friend Poly operator-(Poly f, Poly g); friend Poly operator*(Poly f, Poly g); Poly \u0026amp;ntt(int m); Poly \u0026amp;nttD(int m); Poly \u0026amp;intt(int m); Poly \u0026amp;invD(Poly f2, Poly nx, int t); Poly inv() const; Poly div(Poly g) const; Poly deriv() const; Poly integr() const; Poly ln() const; Poly exp() const; Poly sqrt() const; Poly pow(int k) const; Poly mod() const; }; Poly w, Inv; void pre_w(int n, int w0 = 3) { static int lim = (w = {1, 1}, 2); n = get_lim(n); if (n \u0026lt;= lim) return; w.resize(n); for (int l = lim; l \u0026lt; n; l *= 2) { m32 p = m32(w0).pow((P - 1) / l / 2); for (int i = 0; i \u0026lt; l; i += 2) { w[(l + i)] = w[(l + i) / 2]; w[l + i + 1] = w[l + i] * p; } } lim = n; } void pre_inv(int n) { static int LIM = (Inv = {1, 1}, 2); if (n \u0026lt;= LIM) return; Inv.resize(n); for (int i = LIM; i \u0026lt; n; i++) { Inv[i] = Inv[P % i] * (P - P / i); } LIM = n; } static int ntt_size = 0; void ntt(Poly::iterator f, int deg) { pre_w(deg); ntt_size += deg; for (int l = deg \u0026gt;\u0026gt; 1; l; l \u0026gt;\u0026gt;= 1) for (auto fi = f; fi - f \u0026lt; deg; fi += l * 2) for (int j = 0; j \u0026lt; l; j++) { auto x = fi[j] + fi[j + l]; fi[j + l] = w[j + l] * (fi[j] - fi[j + l]); fi[j] = x; } } void intt(Poly::iterator f, int deg) { ntt_size += deg; for (int l = 1; l \u0026lt; deg; l \u0026lt;\u0026lt;= 1) for (auto fi = f; fi - f \u0026lt; deg; fi += l * 2) for (int j = 0; j \u0026lt; l; j++) { auto x = fi[j], y = fi[j + l] * w[j + l]; fi[j] = x + y, fi[j + l] = x - y; } const auto deg_inv = P - (P - 1) / deg; for (int i = 0; i \u0026lt; deg; i++) f[i] *= deg_inv; std::reverse(f + 1, f + deg); } void nttD(Poly::iterator f, int n) { std::copy_n(f, n, f + n); intt(f + n, n); for (int i = n; i \u0026lt; n * 2; i++) f[i] *= w[i]; ntt(f + n, n); } Poly \u0026amp;Poly::ntt(int n) { if (!isNTT) { resize(n); ::ntt(begin(), n); isNTT = true; } return *this; } Poly \u0026amp;Poly::intt(int m) { ::intt(begin(), m); isNTT = false; return *this; } Poly \u0026amp;Poly::nttD(int n) { resize(n * 2); ::nttD(begin(), n); return *this; } Poly \u0026amp;mul(Poly \u0026amp;f, Poly \u0026amp;g, int t) { f.ntt(t), g.ntt(t); for (int i = 0; i \u0026lt; t; i++) f[i] *= g[i]; return f.intt(t); } Poly operator*(Poly f, Poly g) { if (f.deg() \u0026lt; g.deg()) swap(f, g); int t = f.deg() + g.deg() - 1; return mul(f, g, get_lim(t)).cut(t); } Poly operator+(Poly f, Poly g) { if (f.deg() \u0026lt; g.deg()) std::swap(f, g); for (int i = 0; i \u0026lt; g.deg(); i++) f[i] += g[i]; return f; } Poly operator-(Poly f, Poly g) { for (auto \u0026amp;i : g) i = -i; return std::move(f) + g; } m32 mulAt(const Poly f, const Poly g, int u) { int n = f.deg() - 1, m = g.deg() - 1; m32 ans = 0; for (int i = std::max(0, u - m); i \u0026lt;= std::min(u, n); i++) ans += f[i] * g[u - i]; return ans; } struct PolySemi { using iter = Poly::iterator; const int B = 16; int n, m; Poly F, v1, v2, ret; std::function\u0026lt;void(int, m32 \u0026amp;)\u0026gt; relax; void run(int l, int r, iter g, iter h) { if (r - l \u0026lt;= 64) { for (int i = l; i \u0026lt; r; ++i) { relax(i, ret[i]); for (int j = i + 1; j \u0026lt; r; ++j) ret[j] += ret[i] * F[j - i]; } return; } int len = (r - l) / B, k = 2 * len; iter tg[B], th[B]; for (int i = 0; i \u0026lt; B - 1; i++) tg[i] = g + i * k, th[i] = h + i * k; if (l == 0) { for (int i = 0; i \u0026lt; B - 1; i++) { if ((i + 1) * len \u0026gt;= n) break; copy_n(F.begin() + i * len, k, th[i]); ntt(th[i], k); } } for (int i = 0; i \u0026lt; B; i++) { auto u = l + i * len; if (u \u0026gt;= n) break; Poly s(k); for (int j = 0; j \u0026lt; i; j++) for (int t = 0; t \u0026lt; k; t++) s[t] += tg[j][t] * th[i - j - 1][t]; s.intt(k); for (int t = 0; t \u0026lt; len; t++) ret[t + u] += s[t + len]; run(u, u + len, g + k * B, h + k * B); if (i != B - 1) { copy_n(ret.begin() + u, len, tg[i]); ntt(tg[i], k); } } fill_n(g, k * B, 0); } PolySemi(Poly f) : F(f) { n = F.size(); m = get_lim(n); F.resize(m), ret.resize(m); v1.resize(m * 4), v2.resize(m * 4); ret[0] = 1; } Poly exp() { pre_inv(m); for (int i = 0; i \u0026lt; n; i++) F[i] *= i; relax = [\u0026amp;](int i, m32 \u0026amp;ri) { ret[i] = i == 0 ? 1 : ret[i] * Inv[i]; }; run(0, m, v1.begin(), v2.begin()); return ret.cut(n); } Poly inv() { m32 iv = F[0].inv(); relax = [\u0026amp;](int i, m32 \u0026amp;ri) { ri = i == 0 ? iv : -ri * iv; }; run(0, m, v1.begin(), v2.begin()); return ret.cut(n); } Poly quo(Poly h) { // 注意是 h / f h.resize(m); m32 iv = F[0].inv(); relax = [\u0026amp;](int i, m32 \u0026amp;ri) { ret[i] = i == 0 ? h[0] * iv : (h[i] - ret[i]) * iv; }; run(0, m, v1.begin(), v2.begin()); return ret.cut(n); } }; Poly \u0026amp;Poly::invD(Poly f2, Poly nx, int t) { mul(f2, nx, t).fillZeroL(t); // 6E mul(f2, nx, t); // 4E resize(t); for (int i = t / 2; i \u0026lt; t; i++) (*this)[i] = -f2[i]; return *this; } Poly Poly::inv() const { // 10E Poly x = {front().inv()}; if (deg() == 1) return x; int lim = get_lim(deg()); for (int t = 2; t \u0026lt;= lim; t \u0026lt;\u0026lt;= 1) x.invD(cut(t), x.cut(t), t); return x.cut(deg()); } Poly Poly::div(Poly g) const { return PolySemi(g.resize(deg())).quo(*this); } Poly Poly::deriv() const { Poly f(deg() - 1); for (int i = 1; i \u0026lt; deg(); i++) f[i - 1] = (*this)[i] * i; return f; } Poly Poly::integr() const { Poly f(deg() + 1); pre_inv(deg() + 1); for (int i = deg(); i \u0026gt; 0; --i) f[i] = (*this)[i - 1] * Inv[i]; return f; } Poly Poly::ln() const { return deriv().div(*this).integr(); } Poly Poly::exp() const { return PolySemi(*this).exp(); } Poly Poly::sqrt() const { // 11E Poly x = {front().sqrt()}, g = x.inv(), ng = g; for (int t = 2; t \u0026lt; deg() * 2; t \u0026lt;\u0026lt;= 1) { const Poly \u0026amp;h = *this; Poly f = x; if (t \u0026gt;= 4) { g.invD(f.ntt(t / 2), ng, t / 2); // 3E } mul(f, f, t / 2); // 1E f.resize(t); for (int i = t / 2; i \u0026lt; std::min(h.deg(), t); i++) f[i] = h[i - t / 2] + h[i] - f[i - t / 2]; ng = g; mul(f.fillZeroL(t), ng, t); // 6E x.resize(t); for (int i = t / 2; i \u0026lt; t; i++) x[i] = f[i] * ((P + 1) / 2); } return x.cut(size()); } Poly Poly::pow(int k) const { Poly f = ln(); for (int i = 0; i \u0026lt; size(); i++) f[i] *= k; return f.exp(); } // 计算最大连续 \u0026lt;= k 的情况数 // f(x) = 1+x+x^2+...+x^k m32 cal(ll n, ll m, ll k) { if (k \u0026gt; m || m \u0026gt; n) return 0; if (k == 0) return (m == 0); Poly f(1e5+5, 0); n = n - m + 1; for (int i = 0; i \u0026lt;= k; i++) f[i] = 1; f = f.pow(n); return f[m]; } ll n,m,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; if (k == 0) { if (m \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; else cout\u0026lt;\u0026lt;\u0026quot;1\\n\u0026quot;; } else if(m\u0026gt;n) cout\u0026lt;\u0026lt;\u0026quot;0\\n\u0026quot;; else cout \u0026lt;\u0026lt; (cal(n,m,k) - cal(n,m,k-1)).v \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; cout.flush(); return 0; }   多项式全家桶（自用，很慢） const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { static ll F[maxn], G[maxn]; int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 for (int i = 0; i \u0026lt;= n1; i++) F[i] = f[i]; for (int i = 0; i \u0026lt;= n2; i++) G[i] = g[i]; for (int i = n1+1; i \u0026lt; n; i++) F[i] = 0; for (int i = n2+1; i \u0026lt; n; i++) G[i] = 0; memset(h, 0, sizeof(ll) * n); ntt.ntt(F, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(G, n, 1); for (int i = 0; i \u0026lt; n; i++) h[i] = F[i] * G[i] % mod; ntt.ntt(h, n, -1); } // calculate f^{-1}, store it into g[] // m = deg(f) + 1 void poly_inverse(ll f[], ll g[], const int m) { if (m == 1) { g[0] = ntt.inv(f[0]); // 应该改为二次剩余 return; } static ll F[maxn]; poly_inverse(f, g, (m+1)\u0026gt;\u0026gt;1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; // 因为 deg(h) = (m-1) * 2 for (int i = 0; i \u0026lt; m; i++) F[i] = f[i]; for (int i = m; i \u0026lt; n; i++) F[i] = 0; ntt.ntt(F, n, 1); ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt; n; i++) { g[i] = g[i] * ((2LL - g[i] * F[i] % mod + mod) % mod) % mod; } ntt.ntt(g, n, -1); for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // get f'(x), store it into g[] // n = deg(f) + 1 inline void poly_derivatives(ll f[], ll g[], const int n) { for (ll i = 1; i \u0026lt; n; i++) { g[i-1] = f[i] * i % mod; } g[n-1] = 0; } // get integral f(x)dx, store it into g[] // n = deg(f) + 1 inline void poly_integral(ll f[], ll g[], const int n) { for (ll i = n-1; i \u0026gt;= 1; i--) { g[i] = f[i-1] * ntt.inv(i) % mod; } g[0] = 0; } // get ln(f(x)), store it into g[] // n = deg(f) + 1 void poly_ln(ll f[], ll g[], const int n) { static ll invf[maxn], deriv_f[maxn]; memset(invf, 0, sizeof(invf)); memset(deriv_f, 0, sizeof(deriv_f)); poly_inverse(f, invf, n); poly_derivatives(f, deriv_f, n); poly_multiply(deriv_f, n, invf, n, g); poly_integral(g, g, n); } // get e^f(x), store it into g[] // m = deg(f) + 1 void poly_exp(ll f[], ll g[], const int m) { static ll F[maxn], G[maxn], lng[maxn]; if (m == 1) { g[0] = 1; return; } poly_exp(f, g, (m+1) \u0026gt;\u0026gt; 1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; for (int i = 0; i \u0026lt; m; i++) F[i] = f[i], G[i] = g[i]; for (int i = m; i \u0026lt; n; i++) F[i] = 0, G[i] = 0, lng[i] = 0; poly_ln(g, lng, m); ntt.ntt(F, n, 1); ntt.ntt(G, n, 1); ntt.ntt(lng, n, 1); for (int i = 0; i \u0026lt; n; i++) { g[i] = G[i] * ((1LL - lng[i] + F[i] + mod) % mod) % mod; } ntt.ntt(g, n, -1); for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // given f(x), calculate g(x), such that g(x)^2 = f(x) // m = deg(f) + 1 void poly_sqrt(ll f[], ll g[], const int m) { static ll F[maxn], G[maxn], invG[maxn]; if (m == 1) { g[0] = 1; return; } poly_sqrt(f, g, (m+1) \u0026gt;\u0026gt; 1); int n = 1; while (n \u0026lt;= ((m-1)\u0026lt;\u0026lt;1)) n \u0026lt;\u0026lt;= 1; for (int i = 0; i \u0026lt; m; i++) F[i] = f[i], G[i] = g[i], invG[i] = 0; for (int i = m; i \u0026lt; n; i++) F[i] = 0, G[i] = 0, invG[i] = 0; poly_inverse(G, invG, m); poly_multiply(f, m, invG, m, g); for (int i = 0; i \u0026lt; m; i++) g[i] = (g[i] + G[i]) % mod * ntt.inv(2) % mod; for (int i = m; i \u0026lt; n; i++) g[i] = 0; } // given f(x) and g(x), calculate q(x), r(x) such that f(x) = q(x) * g(x) + r(x) // n = deg(f) + 1, m = deg(g) + 1, deg(q) = n-m, deg(r) \u0026lt; deg(g) - 1 = m void poly_division(ll f[], ll g[], ll q[], ll r[], const int n, const int m) { static ll F[maxn], G[maxn], invG[maxn]; for (int i = 0; i \u0026lt;= n-1; i++) F[i] = f[n-1-i]; for (int i = 0; i \u0026lt;= m-1; i++) G[i] = g[m-1-i]; poly_inverse(G, invG, n-m+1); poly_multiply(F, n-m+1, invG, n-m+1, q); for (int i = n-m+1; i \u0026lt;= 2LL * (n-m+1); i++) q[i] = 0; reverse(q, q+n-m+1); poly_multiply(q, n-m+1, g, m, G); for (int i = 0; i \u0026lt; m; i++) r[i] = (f[i] - G[i] + mod) % mod; } ll f[maxn], g[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; f[i]; poly_sqrt(f, g, n); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   多项式求逆 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$f(x) * g(x) \\equiv 1 ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证有解。\n 定义 $x^n$：指舍弃含有 $x^n$ 及更高次数的项。\n我们设 $g(x)$ 为 $f(x)$ 在 $\\text{ mod } x^n$ 意义下的逆元，设 $G(x)$ 为 $f(x)$ 在 $\\text{ mod } x^{\\lceil{\\frac{n}{2}}\\rceil}$ 意义下的逆元，则有：\n$$f(x)g(x) \\equiv 1 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil}), ~~ f(x)G(x) \\equiv 1 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n所以\n$$f(x)(g(x) - G(x)) \\equiv 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n由于 $deg(f) = n-1$，所以 $f \\neq 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$，所以\n$$g(x) - G(x) \\equiv 0 (\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$$\n两边同时平方，可得\n$$g(x)^2 + G(x)^2 - 2g(x)G(x) \\equiv 0 (\\text{mod } x^n)$$\n由于 $f(x)g(x) \\equiv 1 (\\text{mod } x^n)$，两边同乘以 $f(x)$ 可得：\n$$g(x) + f(x)G(x)^2 - 2G(x) \\equiv 0 (\\text{mod } x^n)$$\n所以\n$$g(x) \\equiv 2G(x) - f(x)G(x)^2 (\\text{mod } x^n)$$\n注意点\n  $G(x)$ 是 $(\\text{mod } x^{\\lceil{\\frac{n}{2}}\\rceil})$ 意义下的逆元，刚好是一个递归的问题，只要求出来 $G(x)$ 即可求出 $g(x)$，而这个式子用 NTT 解决即可。\n  只需要用 DFT 求出 $f(x), G(x)$ 在特殊点的值 $f(x_i), G(x_i)$，然后直接进行上述计算 $2G(x_i) - f(x_i)G(x_i)^2$，然后再 IDFT 回来即可。\n  板子里面使用的 $m$ 代表 $m = deg(f) + 1$，这样是为了递归 base case 的正确处理。\n  如果 $f(x)$ 的常数项 $f(0) = 0$ 则无法求逆。\n    多项式求 $\\ln$ 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv \\ln f(x) ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证有解。\n 两边同时求导，可以得到 $$g'(x) \\equiv \\frac{f'(x)}{f(x)} ~ (\\text{mod } x^n)$$\n多项式求导和积分都很简单，所以右边可以很容易的计算出来。\n计算出来右边以后，两边同时积分即可得到 $g(x)$。\n 多项式求 $exp$ 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv e^{f(x)} ~ (\\text{mod } x^n)$$\n系数对 998244353 取模。\n所有的系数均为非负整数，保证 $f_0 = 0$。\n 前置知识：牛顿迭代法求零点 牛顿迭代法可以快速求出一个函数 $f(x)$ 的零点。\n思想：随便找一个 $x_1$ 作为起点，求出 $(x_1, f(x_1))$ 处的切线方程，设 $x_2$ 为这个切线与 $x$ 轴的交点，继续此过程。\n推导：\n$f(x)$ 在 $x_1$ 处的切线为\n$$y = f'(x_1)(x-x_1) + f(x_1)$$\n令 $y = 0$，得到\n$$x = x_1 - \\frac{f(x_1)}{f'(x_1)}$$\n 上述的过程对于多项式也适用！\n假设我们给定一个多项式 $F(x)$，要求一个多项式 $G(x)$ 使得 $$F(G(x)) \\equiv 0 ~ (\\text{mod } x^n)$$\n则我们可以先求出 $G_1(x)$，满足\n$$F(G_1(x)) \\equiv 0 ~ (\\text{mod } x^{\\lceil \\frac{n}{2} \\rceil})$$\n然后根据牛顿迭代的式子，求出\n$$G(x) = G_1(x) - \\frac{F(G_1(x))}{F'(G_1(x))}$$\n令 $G_2(x) = G(x)$，然后递归此过程直到 $n=1$ 即可。\n• base case 为 $n = 1$，所以总复杂度为 $O(n \\log n)$\n证明？需要用到泰勒展开（数学浓度有一点点高所以我先鸽了）\n 用牛顿迭代求多项式的exp 回顾一下问题：\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求多项式 $g(x)$，使得\n$$g(x) \\equiv e^{f(x)} ~ (\\text{mod } x^n)$$\n两边同时求 $\\ln$，可得：\n$$\\ln (g(x)) - f(x) \\equiv 0 ~ (\\text{mod } x^n)$$\n设\n$$F(g(x)) = \\ln (g(x)) - f(x)$$\n则我们要求的是 $F(x)$ 在 $(\\text{mod } x^n)$ 意义下的零点（注意这个零点本身是个多项式）。\n所以根据牛顿迭代的式子，可以写出：\n$$g_2(x) = g_1(x) - \\frac{F(g_1(x))}{F'(g_1(x))}$$\n注意到 $F'(g(x)) = \\frac{1}{g(x)}$，所以有：\n$$g_2(x) = g_1(x)(1-\\ln (g_1(x)) - f(x))$$\n• 其中 base case 是 $n=1$ 时，由于 $f_0 = 0$，所以\n$$g_0(x) = e^{f_0(x)} = e^0 = 1$$\n 时间复杂度：$T(n) = T(\\frac{n}{2}) + O(n \\log n)$，所以 $T(n) = O(n \\log n)$\n  多项式除法 题意\n给定一个多项式 $f(x)$ 和一个多项式 $g(x)$，$deg(f) = n, deg(g) = m, n \u0026gt; m$，求 $q(x), r(x)$ 使得：\n$$deg(q) = n-m, deg(r) \u0026lt; m$$\n$$f(x) = q(x) * g(x) + r(x)$$\n系数对 998244353 取模。所有的系数均为非负整数。\n 设\n$$F(x) = x^nf(\\frac{1}{x})$$\n可以发现 $F(x)$ 就是 $f(x)$ 所有系数翻转过来 得到的多项式。\n然后有：\n$$f(x) = q(x) * g(x) + r(x)$$\n$$f(\\frac{1}{x}) = q(\\frac{1}{x}) * g(\\frac{1}{x}) + r(\\frac{1}{x})$$\n两边同乘 $x^n$ 可得：\n$$x^nf(\\frac{1}{x}) = x^{n-m}q(\\frac{1}{x}) * x^mg(\\frac{1}{x}) + x^{n-m+1} * x^{m-1}r(\\frac{1}{x})$$\n$$F(x) = Q(x) * G(x) + x^{n-m+1}R(x)$$\n两边同时 $\\text{mod } x^{n-m+1}$ 可得：\n$$F(x) \\equiv Q(x) * G(x) ~ (\\text{mod } x^{n-m+1})$$\n所以\n$$Q(x) \\equiv \\frac{F(x)}{G(x)} ~ (\\text{mod } x^{n-m+1})$$\n发现 $deg(q) = n-m$，所以刚好求出来的 $Q(x)$ 在 $\\text{mod } x^{n-m+1}$ 意义下，就是正确的结果。\n所以可以直接计算出 $Q(x)$，翻转系数得到 $q(x)$。\n至于 $r(x)$，直接由 $$r(x) = f(x) - q(x) * g(x)$$ 即可得到。\n 多项式开根 题意\n给定一个多项式 $f(x)$，$deg(f) = n-1$，求 $g(x)$ 使得：\n$$g^2(x) \\equiv f(x) ~ (\\text{mod } x^{n})$$\n系数对 998244353 取模。保证 $f_0 = 1$，所有的系数均为非负整数。\n 设\n$$F(g(x)) = g^2(x) - f(x)$$\n要求的就是 $F(x)$ 的零点。\n假设我们已经求出了在 $(\\text{mod } x^{\\lceil \\frac{n}{2}} \\rceil)$ 意义下的 $g_1(x)$ 使得 $g_1^2(x) \\equiv f(x) (\\text{mod } x^{\\lceil \\frac{n}{2}} \\rceil)$\n则根据牛顿迭代，有：\n$$g_2(x) = g_1(x) - \\frac{F(g_1(x))}{F'(g_1(x))}$$\n$$= g_1(x) - \\frac{g_1^2(x) - f(x)}{2g_1(x)}$$\n• base case 为 $n=1$ 时，由于 $f_0 = 1$，直接开根得到 $g_0 = \\sqrt 1 = 1$\n• 如果 $f_0 \\neq 1$，需要 二次剩余 来求出 $g_0$\n注：有另外一种不用牛顿迭代的推导方法，可以看 这里\n 多项式快速幂 题意\n给定一个多项式 $f(x)$，和一个正整数 $k$，$deg(f) = n-1$，求 $g(x)$ 使得：\n$$g(x) \\equiv f(x)^k ~ (\\text{mod } x^{n})$$\n系数对 998244353 取模。保证 $f_0 = 1$，所有的系数均为非负整数。\n 两边取 $ln$，可得：\n$$\\ln g(x) \\equiv k \\ln f(x)$$\n所以计算出 $k \\ln f(x)$ 之后，再两边同时取多项式 exp 即可。\n注意事项  在代码中，使用 ntt.ntt() 时注意指定的长度是 $n$，而 不是 $deg(f) = m$ TODO: 所有需要递归的非递归写法？ TODO: 二次剩余  参考链接  https://blog.csdn.net/a_forever_dream/article/details/102483602 https://gauss0320.blog.luogu.org/ti-xie-p4726-mu-ban-duo-xiang-shi-zhi-shuo-han-shuo-duo-xiang-shi-e https://blog.csdn.net/a_forever_dream/article/details/106281196 https://www.luogu.com.cn/blog/user7035/solution-p4512  ","date":"2021-09-21T20:09:39+08:00","permalink":"https://tom0727.github.io/post/053-polynomial/","tags":["多项式",""],"title":"多项式全家桶"},{"categories":["算法"],"contents":"模版 NTT const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;22) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 memset(h, 0, sizeof(ll) * n); ntt.ntt(f, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt; n; i++) h[i] = f[i] * g[i] % mod; ntt.ntt(h, n, -1); } int n1, n2; ll f[maxn/2], g[maxn/2], h[maxn]; int main() { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; // deg(f) = n1 - 1, deg(g) = n2 - 1 for (int i = 0; i \u0026lt; n1; i++) cin \u0026gt;\u0026gt; f[i]; for (int i = 0; i \u0026lt; n2; i++) cin \u0026gt;\u0026gt; g[i]; poly_multiply(f, n1, g, n2, h); for (int i = 0; i \u0026lt;= n1+n2-2; i++) cout \u0026lt;\u0026lt; h[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; }   介绍 NTT（快速数论变换）和 FFT 一样，都是用来解决多项式乘法问题。\nNTT可以处理在 $mod ~ p$ 意义下的多项式乘法，并且不需要处理复数和小数。\n在开始介绍 NTT 之前，我们需要一些基本的前置知识。\n原根 对于一个质数 $p$，在 $mod ~ p$ 意义下，原根 $g$ 满足：\n$$ord(g) = |Z_p^{\\times}| = \\phi(p)$$\n• 注意 $\\phi(p)$ 是 $p$ 的欧拉函数，代表 $[1,p]$ 中与 $p$ 互质的数的数量。\n• $ord(g)$ 代表一个最小的数字 $r = ord(g)$ 使得 $g^r \\equiv 1(mod ~ p)$，且 $\\forall k \\in [1,r-1], g^k \\neq 1(mod ~ p)$\nNTT原理 使用 NTT 的限制条件：\n 模数 $p$ 需要满足 $p = k \\times 2^m + 1$，其中 $k, m \\geq 1$，$p$ 为质数。 若 $p = k \\times 2^m + 1$，则只能处理 $deg(h) \\leq 2^m$ 的情况。   在发现了原根 $g$ 以后，我们会发现令 $g_n = g^{\\frac{p-1}{n}}$，则 $g_n$ 拥有着 FFT 中，$\\omega$ 的优秀性质：\n $g_n^n = 1$，且 $\\forall k \\in [1, n-1], g_n ^ k \\neq 1$ $g_n^{k+\\frac{n}{2}} = -g_n^{k}$  证明：\n 根据原根的定义即可。 只要证 $g_n^{\\frac{n}{2}} = -1$ 即可。因为 $g_n^n = 1$，所以 $g_n^{\\frac{n}{2}} = \\pm 1$，而因为 $\\forall k \\in [1, n-1], g_n ^ k \\neq 1$，所以 $g_n^{\\frac{n}{2}} = -1$   剩下的就和 FFT 一样了，只不过把 $\\omega$ 换成 $g_n = g^{\\frac{p-1}{n}}$ 而已。\n当然注意到，由于 $n$ 需要是 $2^k$，所以 $p-1$ 需要是 $2^k$ 的倍数，故我们需要满足 $p = k \\times 2^m + 1$。\n常用的组合：\n$$p = 998244353, ~~g = 3$$\n参考链接  https://blog.csdn.net/a_forever_dream/article/details/102469390 https://oi-wiki.org/math/poly/ntt/  ","date":"2021-09-18T19:51:17+08:00","permalink":"https://tom0727.github.io/post/052-ntt/","tags":["NTT"],"title":"NTT"},{"categories":["算法"],"contents":"  .center { margin-left: auto; margin-right: auto; display: table; width: auto; }   模版 FFT const int maxn = (1\u0026lt;\u0026lt;22) + 5; // 注意这里需要是 \u0026gt; 2^k struct Complex { double x,y; Complex(double _x = 0.0, double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 1; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 1; i \u0026lt; n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), n1 = deg(f) + 1, n2 = deg(g) + 1 void poly_multiply(const double f[], int n1, const double g[], int n2, double h[]) { int n = 1; n1--, n2--; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = a[i].x; } int n1, n2; double f[maxn/2], g[maxn/2], h[maxn]; int main() { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; // deg(f) = n1 - 1, deg(g) = n2 - 1 for (int i = 0; i \u0026lt; n1; i++) cin \u0026gt;\u0026gt; f[i]; for (int i = 0; i \u0026lt; n2; i++) cin \u0026gt;\u0026gt; g[i]; poly_multiply(f, n1, g, n2, h); for (int i = 0; i \u0026lt;= n1+n2-2; i++) cout \u0026lt;\u0026lt; h[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; }   使用板子的注意事项：\n maxn 的值必须大于一个 $2^k$，且 $2^k \u0026gt; n_1+n_2$  介绍 FFT (Fast Fourier Transform, 快速傅立叶变换) 可以在 $O(n \\log n)$ 的时间内计算两个多项式的乘法，也可以用来计算卷积。\n• 一般卷积的形式为 $$C_k = \\sum\\limits_{i=0}^kA_iB_{k-i} = A_0B_k + A_1B_{k-1} + \u0026hellip; + A_kB_0$$\n在开始介绍 FFT 之前，我们需要一些基本的前置知识。\n多项式 一个多项式有两种表示方法：系数表示法 和 点值表示法。\n系数表示法 $$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n$$\n则 $\\{a_0,a_1,\u0026hellip;,a_n\\}$ 即可表示这个多项式 $f(x)$。\n点值表示法 选取多项式函数上的 $(n+1)$ 个点 $(x_0,y_0), (x_1,y_1), \u0026hellip;, (x_n,y_n)$ 也可以唯一的表示这个多项式 $f(x)$。\n证明：使用高斯消元即可，$(n+1)$ 个未知量，对应 $(n+1)$ 个方程。\n复数 $n$ 次单位根 若 $\\omega$ 满足 $\\omega^n = 1$，那么 $\\omega$ 就是 $n$ 次单位根 (n-th root of unity)。\n若 $\\omega$ 满足 $\\omega^n = 1$，且满足 $\\omega ^ k \\neq 1, \\forall k \\in [1, n-1]$，则 $\\omega$ 就是 $n$ 次本原单位根 (primitive n-th root of unity)\n$\\omega$ 的取值 定理\n$$\\omega_n^k = e^{i\\frac{2k\\pi}{n}} = \\cos(\\frac{2k\\pi}{n}) + i \\sin(\\frac{2k\\pi}{n})$$\n$$\\omega = e^{i \\frac{2\\pi}{n}} = \\cos(\\frac{2\\pi}{n}) + i \\sin(\\frac{2\\pi}{n})$$\n 为了方便，下文我们就写 $\\omega = e^{i \\frac{2\\pi}{n}}$\n$\\omega$ 有几个优秀的性质：\n $\\omega$ 为 $n$ 次本原单位根，这说明 $\\forall k \\in [1, n-1], \\omega^n = 1$，且 $\\omega ^ k \\neq 1$ $\\omega^{k+\\frac{n}{2}} = -\\omega^{k}$  FFT原理 问题\n给定两个已知多项式 $f(x)$ 和 $g(x)$，$deg(f) = n_1, deg(g) = n_2$，求 $h(x) = f(x) * g(x)$？\n FFT 分为三步：\n  DFT：令 $n = n_1 + n_2$，在 $x$ 轴上选择 $(n + 1)$ 个特殊点 $x_0,x_1,\u0026hellip;,x_{n}$，求出 $f(x_0), f(x_1), \u0026hellip;, f(x_n)$ 与 $g(x_0), g(x_1), \u0026hellip;, g(x_n)$ 的值。\n复杂度：$O(n\\log n)$\n  点值乘法：求出 $(n+1)$ 个点上，点值的乘积，即 $h(x_i) = f(x_i) * g(x_i), i \\in [0, n]$\n复杂度：$O(n)$\n  IDFT：给定一个未知 $h(x)$ 上的 $(n+1)$ 个特殊点 $\\{(x_0,y_0), (x_1,y_1), \u0026hellip;, (x_n,y_n)\\}$，求出 $h(x)$ 的系数表达式。\n复杂度：$O(n\\log n)$\n  第一步 DFT 问题\n假设现在有一个 $deg(f) = n$ 的多项式，且 $n$ 为偶数。我们想要求 $f(x)$ 在 $n$ 个不同的特殊点 $x_0,x_1,\u0026hellip;,x_{n-1}$ 上的值。\n  注意到这个问题也等价于一个矩阵乘法，即给定 一个矩阵 $X$ 和一个向量 $\\vec a$，在我们可以自由选择 $x_0,x_1,\u0026hellip;,x_{n-1}$ 的情况下，用 $O(n \\log n)$ 的时间求出 $\\vec y = X \\vec a$ 的值？\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\ 1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\ \u0026hellip;\\\\ 1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\ \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \u0026hellip;\\\\ a_{n-1} \\\\ \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \u0026hellip;\\\\ y_{n-1} \\\\ \\end{bmatrix} $$\n 那么，如何快速求出 $f(x_0), f(x_1), \u0026hellip;, f(x_{n-1})$呢？我们只要选一些特殊的 $x_0, x_1, \u0026hellip;, x_{n-1}$ 即可。\n$X = \\{x_0, x_1, \u0026hellip;, x_{n-1}\\}$ 需要有的性质：$|X^2| = \\frac{|X|}{2}$\n结论：$x_i = \\omega^i$\n 证明：\n因为\n$$f(x) = a_0 + a_1x + a_2x^2 + \u0026hellip; + a_nx^n$$\n$$=(a_0 + a_2x^2 + a_4x^4 + \u0026hellip; + a_{n-2}x^{n-2}) + (a_1x + a_3x^3 + a_5x^5 + \u0026hellip; + a_{n-1}x^{n-1})$$\n令\n$$f_{even}(x) = a_0 + a_2x + a_4x^2 + \u0026hellip; + a_{n-2}x^{\\frac{n}{2} - 1}$$ $$f_{odd}(x) = a_1 + a_3x + a_5x^2 + \u0026hellip; + a_{n-1}x^{\\frac{n}{2} - 1}$$\n则有\n$$f(x) = f_{even}(x^2) + xf_{odd}(x^2)$$\n现在，我们选择 $x_i = \\omega^i$，则我们求 $f(x_i)$ 和 $f(x_{i+\\frac{n}{2}})$，可以发现\n$$x_{\\frac{n}{2}} = \\omega^{\\frac{n}{2}} = -1, ~~x_{i+\\frac{n}{2}} = \\omega^{i+\\frac{n}{2}} = -\\omega^i = -x_i$$\n所以\n$$\\forall i \\in [0,\\frac{n}{2}-1], ~~f(x_i) = f_{even}(x_i^2) + x_if_{odd}(x_i^2), ~~f(x_{i+\\frac{n}{2}}) = f_{even}(x_i^2) - x_if_{odd}(x_i^2)$$\n又因为，求 $\\forall i \\in [0,n], f(x_i)$ 的值，等价于求 $\\forall i \\in [0,\\frac{n}{2}-1], f(x_i) 和 f(x_{i+\\frac{n}{2}})$ 的值，\n所以这个问题就可以等价转化为求 $f_{even}(x_i^2) + x_if_{odd}(x_i^2)$ 的值。而这就是一个规模减半了的子问题。\n所以设 $T(n)$ 为：求出 $\\forall i \\in [0,n], f(x_i)$ 的值所需的时间，则可以列出方程：\n$$T(n) = 2T(\\frac{n}{2}) + O(n)$$\n所以 $T(n) = O(n\\log n)$\n第二步 点值乘法 第一步DFT以后，我们有了 $f(x_0), f(x_1), \u0026hellip;, f(x_{n-1})$ 与 $g(x_0), g(x_1), \u0026hellip;, g(x_{n-1})$ 的值，我们就可以直接将这些值乘起来，得到\n$$h(x_0), h(x_1), \u0026hellip;, h(x_{n-1})$$\n的值。\n第三步 IDFT 问题\n现在给定一个未知的多项式 $h(x)$，且 $deg(h) = n-1$，已知 $h(x)$ 上的 $n$ 个点 $(x_0,h(x_0)), (x_1,h(x_1)), \u0026hellip;, (x_{n-1},h(x_{n-1}))$，求 $h(x)$ 的表达式？\n  注意到这个问题也等价于一个矩阵乘法，即给定 一个矩阵 $X$ 和一个向量 $\\vec y$，已知 $X\\vec a = \\vec y$，如何用 $O(n \\log n)$ 的时间求出 $\\vec a$ 的值？\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\ 1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\ \u0026hellip;\\\\ 1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\ \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \u0026hellip;\\\\ a_{n-1} \\\\ \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \u0026hellip;\\\\ y_{n-1} \\\\ \\end{bmatrix} $$\n 发现了什么？这实际上和第一步 DFT 的过程是一样的，如果我们把 $X^{-1}$ 给两边乘上 ，就变成了\n$$\\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\ 1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\ \u0026hellip;\\\\ 1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\ \\end{bmatrix}^{-1} \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \u0026hellip;\\\\ y_{n-1} \\\\ \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \u0026hellip;\\\\ a_{n-1} \\\\ \\end{bmatrix}$$\n那么，令\n$$X=\\begin{bmatrix}1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \u0026hellip; \u0026amp; x_0^{n-1} \\\\ 1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \u0026hellip; \u0026amp; x_1^{n-1} \\\\ \u0026hellip;\\\\ 1 \u0026amp; x_{n-1} \u0026amp; x_{n-1}^2 \u0026amp; \u0026hellip; \u0026amp; x_{n-1}^{n-1} \\\\ \\end{bmatrix}$$\n把 $x_i = \\omega^i$ 代进去，就可以得到：\n$$X = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ 1 \u0026amp; \\omega^1 \u0026amp; \\omega^{1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{1\\cdot (n-1)} \\\\ \u0026hellip;\\\\ 1 \u0026amp; \\omega^{1} \u0026amp; \\omega^{(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{(n-1)\\cdot (n-1)} \\\\ \\end{bmatrix}$$\n令\n$$V(\\omega) = X = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ 1 \u0026amp; \\omega^1 \u0026amp; \\omega^{1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{1\\cdot (n-1)} \\\\ \u0026hellip;\\\\ 1 \u0026amp; \\omega^{1} \u0026amp; \\omega^{(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{(n-1)\\cdot (n-1)} \\\\ \\end{bmatrix}, ~~~V(\\omega^{-1}) = \\begin{bmatrix}1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ 1 \u0026amp; \\omega^{-1} \u0026amp; \\omega^{-1\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{-1\\cdot (n-1)} \\\\ \u0026hellip;\\\\ 1 \u0026amp; \\omega^{-1} \u0026amp; \\omega^{-(n-1)\\cdot 2} \u0026amp; \u0026hellip; \u0026amp; \\omega^{-(n-1)\\cdot (n-1)} \\\\ \\end{bmatrix}$$\n则有：\n$$V(\\omega) \\cdot V(\\omega^{-1}) = nI$$\n证明：直接进行矩阵运算即可，注意要用到 $\\omega^n = 1$ 的特性。\n这说明\n$$X^{-1} = V(w)^{-1} = \\frac{1}{n} V(\\omega^{-1})$$\n所以上面的 $X^{-1}\\vec y = \\vec a$ 就可以表示为：\n$$V(\\omega)^{-1} \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \u0026hellip;\\\\ y_{n-1} \\\\ \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \u0026hellip;\\\\ a_{n-1} \\\\ \\end{bmatrix} \\Rightarrow \\frac{1}{n}V(\\omega^{-1})\\begin{bmatrix} y_0 \\\\ y_1 \\\\ \u0026hellip;\\\\ y_{n-1} \\\\ \\end{bmatrix} = \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \u0026hellip;\\\\ a_{n-1} \\\\ \\end{bmatrix}$$\n这就等价于我们有一个系数为 $y_0, y_1, \u0026hellip; y_{n}$ 的多项式，然后要在 $x_0^{-1}, x_1^{-1}, \u0026hellip;, x_n^{-1}$ 这些特殊点上进行求值。\n我们发现 $x_0^{-1} = \\omega^{-1}$ 仍然是一个 $n$ 次本原单位根 (primitive n-th root of unity)（证明略），所以它仍然有上述优秀的性质。\n所以这个问题可以用 DFT 解决，求出来的值，就是我们想要的 $h(x)$ 的多项式系数。\n 注意一下，上述所有过程都是完美的分治过程，所以我们需要把 $deg(h)$ 补成一个 $2^k$ 形式，其中 $deg(h) = 2^k \\geq 2(n_1+n_2)$\n 非递归 FFT 递归 FFT 常数过大，不好用，所以我们可以写一个非递归版本的。\n我们手推一下 FFT 的分治过程，每一次分治都是拆分奇数项和偶数项，模拟拆分过程有：\n初始序列：$\\{a_0,a_1,a_2,a_3,a_4,a_5,a_6,a_7\\}$\n第一次拆分：$\\{a_0,a_2,a_4,a_6\\},\\{a_1,a_3,a_5,a_7\\}$\n第二次拆分：$\\{a_0,a_4\\},\\{a_2,a_6\\},\\{a_1,a_5\\},\\{a_3,a_7\\}$\n第三次拆分：$\\{a_0\\},\\{a_4\\},\\{a_2\\},\\{a_6\\},\\{a_1\\},\\{a_5\\},\\{a_3\\},\\{a_7\\}$\n发现了什么？\n 拆分前：0, 1, 2, 3, 4, 5, 6, 7\n拆分后：0, 4, 2, 6, 1, 5, 3, 7\n 化成二进制：\n 拆分前：000, 001, 010, 011, 100, 101, 110, 111\n拆分后：000, 100, 010, 110, 001, 101, 011, 111\n 机智的你或许发现了，拆分前后，每个数字对应的二进制刚好就是翻转了一下，最左边的bit跑到最右边去了，反之亦然。\n那么这个二进制翻转就可以直接 $O(n \\log n)$ 实现了，但是这样不够高效，有一个 $O(n)$ 的基于 DP 的方法：\n设 $R(x)$ 为 $x$ 翻转后的结果，可知 $R(0) = 0$。\n我们从小到大求 $R(x)$，在求 $R(x)$ 时，我们已知了 $R(\\frac{x}{2})$ 的值，相当于：\n$$x = abc[0/1], ~ \\frac{x}{2} = abc, ~ R(\\frac{x}{2}) = cba, ~ R(x) = [0/1]cba$$\n则我们只要判断一下 $x$ 的最低位为 $0$ 还是 $1$，然后给 $R(\\frac{x}{2})$ 的最高位补上一个 $0$ 或者 $1$ 就可以得到 $R(x)$ 了。\nvoid rearrange(Complex a[], const int n) { static int rev[maxn]; for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } }  至于非递归写法的原理，我懒得写了先鸽着吧（\n优化（三步变两步） 暂时没遇到需要优化的情况，先鸽着。\n例题 例1 洛谷P1919 【模板】A*B Problem升级版（FFT快速傅里叶） 题意\n给定正整数 $a,b$，求 $a*b$？\n其中，$1\\leq a,b \\leq 10^{10^6}$\n 题解 把大整数看成多项式，例如 $356$ 就看作 $f(x) = 3x^2 + 5x + 6$\n两个大整数相乘就看作多项式相乘，最后代入 $x = 10$，处理一下进位和前缀零即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = (1\u0026lt;\u0026lt;21) + 5; struct Complex { long double x,y; Complex(long double _x = 0.0, long double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(int f[], int n1, int g[], int n2, int h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn], c[maxn]; for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = (int)(a[i].x + 0.5); } int n1, n2; int f[maxn/2], g[maxn/2], h[maxn]; int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; int n1 = s1.size() - 1, n2 = s2.size() - 1; for (int i = 0; i \u0026lt;= n1; i++) f[i] = s1[n1-i] - '0'; for (int i = 0; i \u0026lt;= n2; i++) g[i] = s2[n2-i] - '0'; poly_multiply(f, n1, g, n2, h); int i = 0; for (i = 0; i \u0026lt; maxn-2; i++) { h[i+1] += h[i] / 10; h[i] %= 10; } string ans = \u0026quot;\u0026quot;; for (int i = 0; i \u0026lt; maxn-2; i++) ans += (char)(h[i] + '0'); for (int j = ans.size()-1; j \u0026gt;= 0; j--) { if (ans[j] == '0') { ans.erase(ans.begin() + j); } else break; } reverse(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P3338 [ZJOI2014]力 题意\n给定 $n$ 个实数 $q_1,q_2,\u0026hellip;,q_n$，定义：\n$$F_j = \\sum\\limits_{i=1}^{j-1}\\frac{q_i \\times q_j}{(i-j)^2} - \\sum\\limits_{i=j+1}^{n}\\frac{q_i \\times q_j}{(i-j)^2}$$\n$$E_j = \\frac{F_j}{q_j}$$\n求 $E_1, E_2, \u0026hellip;, E_n$ 的值？\n其中，$n \\leq 10^5$\n 题解 FFT 可以用于处理卷积问题，我们先化简一下式子：\n$$E_j = \\frac{F_j}{q_j} = \\sum\\limits_{i=1}^{j-1}\\frac{q_i}{(i-j)^2} - \\sum\\limits_{i=j+1}^{n}\\frac{q_i}{(i-j)^2}$$\n令\n$$f_i = q_i, ~~g_i = \\frac{1}{i^2}$$\n则\n$$E_j = \\sum\\limits_{i=1}^{j-1}f_ig_{j-i} - \\sum\\limits_{i=j+1}^{n}f_ig_{i-j}$$\n注意到第一项 $\\sum\\limits_{i=1}^{j-1}f_ig_{j-i}$ 可以写成 $i=0$ 开始，到 $j$ 结束（令 $f_0 = g_0 = 0$ 即可），所以第一项等于 $\\sum\\limits_{i=0}^{j}f_ig_{j-i}$，也就是一个卷积形式，可以利用 FFT 计算。\n 第二项 $\\sum\\limits_{i=j+1}^{n}f_ig_{i-j}$ 怎么写成卷积呢？\n注意到，如果我们令 $f_j' = f_{n-j}$，则有\n$$\\sum\\limits_{i=j+1}^{n}f_ig_{i-j} = \\sum\\limits_{i=j}^{n}f'{n-i}g{i-j} = g_0f'{n-j} + g_1f'{n-j-1} + \u0026hellip; + g_{n-j}f'_0$$\n那么，这就又是一个卷积了，所以最后我们的结果可以表示为：\n$$E_j = \\sum\\limits_{i=0}^{j}f_ig_{j-i} - \\sum\\limits_{i=j}^{n}f'{n-i}g{i-j}$$\n 第一项 $\\sum\\limits_{i=0}^{j}f_ig_{j-i}$：计算多项式 $f(x) * g(x)$，取第 $j$ 项的系数即可。\n第二项 $\\sum\\limits_{i=j}^{n}f'{n-i}g{i-j}$：计算多项式 $f'(x) * g(x)$，取第 $n-j$ 项的系数即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = (1\u0026lt;\u0026lt;21) + 5; struct Complex { double x,y; Complex(double _x = 0.0, double _y = 0.0) { x = _x; y = _y; } Complex operator+(const Complex\u0026amp; b) const { return Complex(x + b.x, y + b.y); } Complex operator-(const Complex\u0026amp; b) const { return Complex(x - b.x, y - b.y); } Complex operator*(const Complex \u0026amp;b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); } Complex operator/(const long double\u0026amp; b) const { return Complex(x/b, y/b); } }; struct FastFourierTransform { void rearrange(Complex a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void fft(Complex a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 Complex wn(cos(2*pi / k), on * sin(2*pi / k)); for (int i = 0; i \u0026lt; n; i += k) { Complex w(1, 0); for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { Complex x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)]; a[j] = x + y; a[j+(k\u0026gt;\u0026gt;1)] = x - y; w = w * wn; } } } if (on == -1) { for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] / n; } } } fft; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(const double f[], int n1, const double g[], int n2, double h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 static Complex a[maxn], b[maxn]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i \u0026lt;= n1; i++) a[i] = Complex(f[i], 0); for (int i = 0; i \u0026lt;= n2; i++) b[i] = Complex(g[i], 0); fft.fft(a, n, 1); // 注意这里用的是 n (不是 n1) fft.fft(b, n, 1); for (int i = 0; i \u0026lt;= n; i++) a[i] = a[i] * b[i]; fft.fft(a, n, -1); for (int i = 0; i \u0026lt;= n; i++) h[i] = a[i].x; } double f[maxn/2], g[maxn/2], h[maxn]; double f2[maxn], h2[maxn]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; f[i]; g[i] = (1.0/i/i); } poly_multiply(f, n, g, n, h); for (int i = 0; i \u0026lt;= n; i++) f2[i] = f[n-i]; // f'[i] = f[n-i] poly_multiply(f2, n, g, n, h2); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026quot;%.3f\\n\u0026quot;, h[i] - h2[n-i]); } }   例3 洛谷P3723 [AH2017/HNOI2017]礼物 题意\n给定两个长度为 $n$ 的正整数序列 $x,y$，我们进行一次以下操作：\n第一步：给其中一个序列的所有数加上一个非负整数 $c$。\n第二步：旋转一个序列，可以旋转任意长度。\n 序列的旋转意思是全部元素左移，或者右移，超出界限的部分从另外一边补齐。\n例如： $[1,2,3,4,5]$ 向右旋转 $2$ 个长度，得到 $[4,5,1,2,3]$。\n 现在我们想知道，如何选择 $c$ 和旋转序列的方式，使得\n$$\\sum\\limits_{i=1}^n(x_i-y_i)^2$$\n最小？\n其中，$1\\leq n \\leq 50000, 1\\leq x_i, y_i \\leq 100$\n 题解 首先由于第一步中，我们可以选择任意一个序列来加上 $c$，所以可以看作选择一个序列，然后加上一个 任意整数 $c$。\n最后我们设旋转后，对齐的两个序列为 $a,b$。\n则\n$$\\sum\\limits_{i=1}^n(x_i-y_i)^2$$\n可以表示为：\n$$\\sum\\limits_{i=1}^n(a_i+c-b_i)^2$$\n$$=\\sum\\limits_{i=1}^n ((a_i^2+b_i^2+c^2)+2c(a_i-b_i) - 2a_ib_i)$$\n$$=nc^2 + \\sum\\limits_{i=1}^n (a_i^2+b_i^2)+2c\\sum\\limits_{i=1}^n(a_i-b_i) - \\sum\\limits_{i=1}^n 2a_ib_i$$\n如果我们暂时不考虑 $c$，则会发现，无论最终旋转的 $a,b$ 是什么样的，前三项均为定值，只有 $\\sum\\limits_{i=1}^n 2a_ib_i$ 的值是个变量。\n所以我们只需要 最大化 $\\sum\\limits_{i=1}^n a_ib_i$ 的值即可。\n 现在问题转化为，如何求一种旋转方式，使得 $\\sum\\limits_{i=1}^n a_ib_i$ 的值最大？\n我们不妨直接把每一种旋转方式的值都求出来，然后取最大即可。\n怎么全部一次性求出呢？卷积！\n令\n$$E_j = \\sum\\limits_{i=j}^na_ib_{i-j+1} + \\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j}$$\n则 $E_j$ 所代表的就是，如果我们如此排列：\n   $a_j$ $a_{j+1}$ \u0026hellip; $a_n$ $a_1$ $a_2$ \u0026hellip; $a_{j-1}$     $b_1$ $b_2$ \u0026hellip; $b_{n+1-j}$ $b_{n+2-j}$ $b_{n+3-j}$ \u0026hellip; $b_{n}$     最后得出来对应位置的乘积的和，就是 $E_j$。\n所以我们只要求出 $E_1, E_2, \u0026hellip;, E_n$，然后取最小值即可。\n如何求呢？\n 先考虑第一项 $\\sum\\limits_{i=j}^na_ib_{i-j+1}$\n把它转成卷积的形式，令 $c_i = a_{n-i}$，则有：\n$$\\sum\\limits_{i=j}^na_ib_{i-j+1} = \\sum\\limits_{i=j}^nc_{n-i}b_{i-j+1} = b_1c_{n-j} + b_2c_{n-j-1} + \u0026hellip; + b_{n-j+1}c_{0}$$\n令 $a_0 = b_0 = 0$，就可以再给上式加一个 $b_0c_{n-j+1}$，得到：\n$$b_0c_{n-j+1} + b_1c_{n-j} + b_2c_{n-j-1} + \u0026hellip; + b_{n-j+1}c_{0}$$\n那么这就是一个卷积了，相当于 $b(x) * c(x)$ 的第 $(n-j+1)$ 项。\n 再考虑第二项 $\\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j}$\n仍然转成卷积形式，令 $d_i = b_{n-i}$，则有：\n$$\\sum\\limits_{i=1}^{j-1}a_ib_{n+1+i-j} = \\sum\\limits_{i=1}^{j-1}a_id_{j-i-1} = a_1d_{j-2} + a_2d_{j-3} + \u0026hellip; + a_{j-1}d_{0}$$\n由于 $a_0 = 0$，给上式加上 $a_0d_{j-1}$，得到：\n$$a_0d_{j-1} + a_1d_{j-2} + a_2d_{j-3} + \u0026hellip; + a_{j-1}d_{0}$$\n这又是一个卷积，相当于 $a(x) * d(x)$ 的第 $(j-1)$ 项。\n 所以 $\\sum\\limits_{i=1}^n a_ib_i$ 的最大值求出来了，剩下的变量只有 $c$ 了。\n注意到 $1 \\leq x_i,y_i \\leq 100$，所以 $c$ 只要取遍所有的可能值，然后判断最小值即可。\n在代码中，$c \\in [-200, 200]$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = (1\u0026lt;\u0026lt;20) + 5; struct NTT { const ll g = 3, invg = inv(g); // mod = 998244353 inline ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } void rearrange(ll a[], const int n) { static int rev[maxn]; // maxn \u0026gt; deg(h) 且 maxn 为 2的k次方 + 5 for (int i = 0; i \u0026lt;= n; i++) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= (n \u0026gt;\u0026gt; 1); } for (int i = 0; i \u0026lt;= n; i++) { if (i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); // 保证每对数字只翻转一次 } } void ntt(ll a[], const int n, int on) { rearrange(a, n); for (int k = 2; k \u0026lt;= n; k \u0026lt;\u0026lt;= 1) { // 模拟分治的合并过程 ll wn = qpow(on == 1 ? g : invg, (mod-1)/k); for (int i = 0; i \u0026lt; n; i += k) { ll w = 1; for (int j = i; j \u0026lt; i + (k\u0026gt;\u0026gt;1); j++) { ll x = a[j], y = w * a[j+(k\u0026gt;\u0026gt;1)] % mod; a[j] = (x + y) % mod; a[j+(k\u0026gt;\u0026gt;1)] = (x - y + mod) % mod; w = w * wn % mod; } } } if (on == -1) { ll invn = inv(n); for (int i = 0; i \u0026lt; n; i++) a[i] = a[i] * invn % mod; } } } ntt; // calculate h(x) = f(x) * g(x), deg(f) = n1, deg(g) = n2 void poly_multiply(ll f[], int n1, ll g[], int n2, ll h[]) { int n = 1; while (n \u0026lt;= n1 + n2) n \u0026lt;\u0026lt;= 1; // deg(h) = n1 + n2 memset(h, 0, sizeof(ll) * n); ntt.ntt(f, n, 1); // 注意这里用的是 n (不是 n1) ntt.ntt(g, n, 1); for (int i = 0; i \u0026lt;= n; i++) h[i] = f[i] * g[i] % mod; ntt.ntt(h, n, -1); } int n1, n2; ll a[maxn/2], b[maxn/2], c[maxn/2], d[maxn/2], r1[maxn], r2[maxn]; int n,m; ll ans = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], c[n-i] = a[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i], d[n-i] = b[i]; ll absum = 0; // a_i - b_i for (int i = 1; i \u0026lt;= n; i++) absum += a[i] - b[i]; ll res = 1e18; for (ll c = -200; c \u0026lt;= 200; c++) { res = min(res, n * c * c + 2LL * c * absum); } ans += res; for (int i = 1; i \u0026lt;= n; i++) { ans += (a[i] * a[i]) + (b[i] * b[i]); } poly_multiply(a, n, d, n, r1); // r1 = a*d poly_multiply(b, n, c, n, r2); // r2 = b*c ll ab = 0; for (int i = 1; i \u0026lt;= n; i++) { ab = max(ab, (r1[i-1] + r2[n-i+1])); } ans -= 2LL * ab; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   参考资料  HKU COMP3250 FFT课件 https://oi-wiki.org/math/poly/fft/ https://oi.men.ci/fft-notes/ https://zhuanlan.zhihu.com/p/128661674  ","date":"2021-09-17T13:52:57+08:00","permalink":"https://tom0727.github.io/post/051-fft/","tags":["FFT"],"title":"FFT"},{"categories":["算法"],"contents":"介绍 线性基是一般用于解决 子集XOR，XOR最值 一类问题的算法。\n定义 线性基是一个 linear space，在这个space中，所有的向量为 非负整数，而 scalar 则为 $\\{0,1\\}$，元素之间的运算为 XOR。\n可以直接与 linear algebra 中，由矩阵组成的 linear space 直接关联起来，并且专属名词的定义与矩阵 linear space 中的基本相同。\n性质   线性基 $S = \\{x_1,x_2,\u0026hellip;,x_n\\}$ 中，所有元素 $\\{x_1,x_2,\u0026hellip;,x_n\\}$ 之间是 linearly independent 的。\n  线性基 $S = \\{x_1,x_2,\u0026hellip;,x_n\\}$ 中的所有元素组成了一个 basis，意味着 $$\\forall x \\in span(S), x = a_1x_1 + a_2x_2 + \u0026hellip; a_nx_n$$ 且 $(a_1,a_2,\u0026hellip;,a_n)$ 是 unique 的。（$a_i \\in \\{0,1\\}$）\n  在线性基中，每个元素的二进制最高位均不同。\n  对于线性基第 $i$ 位上的元素 a[i]，保证 a[i] 二进制第 $i$ 位为 $1$，并且：\n$\\forall j \u0026gt; i$，a[i] 的二进制第 $j$ 位为 $0$。\n对于 $j \u0026lt; i$，a[i] 的二进制第 $j$ 位可以为 $1$ 或者 $0$。\n  推论 根据线性基的性质，有以下推论：\n  从 $S$ 中取任意个（至少 $1$ 个）元素，它们的 XOR 均不为 $0$。\n  $S$ 中任意元素 $x_i$ 均 无法 由其他元素 XOR 得到。\n  对于一个非负整数 $x$，如果在 $S$ 中，取一些元素 $x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}$ 使得 $x = XOR(\\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\})$，则：\n使用 $x$ 替换掉 $x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}$ 中的任意一个，线性基均不变。\n 如何找到这样的 $x_1, x_2, \u0026hellip;, x_k$ 使得 $x = XOR(\\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\})$？\n 答：在正常的 insert() 过程中，如果执行了 x ^= a[j]，就说明 $x_j \\in \\{x_{a_1}, x_{a_2}, \u0026hellip;, x_{a_k}\\}$。\n 注：为了维持线性基的特性，不能直接进行替换。\n 正确方式是在正常的 insert() 过程中，在遇到想要替换的 j 时，进行 swap(x, a[j])，然后再 x ^= a[j]。\n  构造方法 构造线性基是一个 动态过程，意味着我们逐一往线性基中 插入元素 来构造。\n我们利用一个数组 ll a[63] 来维护线性基。\n其中 a[i] 代表线性基中的一个元素，它的二进制最高位为第 $i$ 位（从右往左数）。如果 a[i] = 0，说明这个元素不存在。\ninsert 操作 当我们向线性基中插入一个元素 $x$ 时，遵循以下步骤：\n  从高位往低位，遍历 $x$ 的二进制bit。\n  遍历到第 $i$ 位时，如果 $x$ 的第 $i$ 位为 $0$，直接跳到下一位。\n如果 $x$ 的第 $i$ 位为 $1$，则：\n2.1. 如果 a[i] = 0（说明这一位不存在元素），则令 a[i] = x，然后 break。（说明插入元素成功）。\n2.2. 如果 a[i] \u0026gt; 0（说明这一位存在元素），则令 x = x ^ a[i]，然后继续遍历下一位bit。\n  ll a[63]; bool insert(ll x) { for (int j = 62; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; // 插入元素 x return 1; // 插入元素成功 } } } return 0; // 插入元素失败 }  由以上的过程，可以看出：\n插入元素 $x$ 成功 $\\iff x \\notin span(S)$，插入后 $span(S)$ 的大小翻倍。\n插入元素 $x$ 失败 $\\iff x \\in span(S)$。\nquery 操作 查询一个元素 $x$ 是否满足 $x \\in span(S)$，只要遵循上面的 insert 操作，然后不进行真正的插入即可。\n应用 最大子集 XOR 和 Q: 给定一个数组 $S$，求它的子集 $S' \\subseteq S$，使得 $S'$ 中所有元素的 XOR值 最大。\nA: 构造 $S$ 的线性基，然后从高到低位遍历线性基，如果 ans ^ a[i] 更大，则 ans = ans ^ a[i]。\n例 洛谷P3812 【模板】线性基 题意\n给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; ll a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; break; } } } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { ll x; cin \u0026gt;\u0026gt; x; insert(x); } ll ans = 0; for (int j = 60; j \u0026gt;= 0; j--) { ans = max(ans, (ans ^ a[j])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 洛谷P3857 [TJOI2008]彩灯 题意\n有 $n$ 个彩灯，$m$ 个开关，每个开关会控制一些彩灯的状态。每个彩灯只有开和关两种状态。初始状态下所有彩灯为关。\n求所有可能的彩灯样式数量。\n其中，$n,m \\leq 50$\n 题解 每个开关看成一个数字，然后构建原集合的线性基。\n最终答案为 $2^{|S|}$，其中 $|S|$ 为线性基的大小。\n证明：因为线性基中，对于每个二进制位，如果有，则仅有一个元素 $x$ 使得 $x$ 的最高位为 $1$。\n先令集合 $X = \\{0\\}$，代表 $span(S)$。\n我们从低位开始往高位考虑，对于第 $i$ 位而言，如果 a[i] 存在，则将 $X$ 内所有的元素与 a[i] 进行 XOR，会得到最高位 $i$ 为 $1$ 的元素，而原来 $X$ 中并不存在这样的元素，所以 $X$ 的大小翻倍了。\n 注意，在使用 bit shifting 的时候，要注意用 1LL \u0026lt;\u0026lt; j，而不是 1 \u0026lt;\u0026lt; j，后者会爆 int。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; break; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (!m) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } for (int i = 1; i \u0026lt;= m; i++) { string s; cin \u0026gt;\u0026gt; s; ll x = 0; for (int j = 0; j \u0026lt; n; j++) { if (s[n-j-1] == 'O') { x |= (1LL\u0026lt;\u0026lt;j); } } insert(x); } ll ans = 1, cnt = 0; for (int j = 60; j \u0026gt;= 0; j--) { if (a[j]) cnt++; } ans = (1LL\u0026lt;\u0026lt;cnt) % 2008LL; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P4570 [BJWC2011]元素 题意\n有 $n$ 个矿石，每个矿石 $i$ 拥有一个元素序号 $a_i$，还有一个魔力值 $b_i$。\n请选出一些矿石，使得这些矿石的元素序号的 XOR 不为 $0$，并且使得魔力值之和最大。\n 题解 先根据魔力值从大到小 sort 一下所有矿石，然后根据这个顺序，加入矿石的元素序号到线性基中。\n最终把线性基中，所有矿石对应的魔力值加起来即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[63]; bool insert(ll x) { for (int j = 62; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return 1; } } } return 0; } struct node { ll x, val; } arr[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].x \u0026gt;\u0026gt; arr[i].val; } sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026gt; b.val; }); ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { if (insert(arr[i].x)) { ans += arr[i].val; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P3292 [SCOI2016]幸运数字 题意\n给定一个 $n$ 个节点的树，每个节点 $i$ 都有一个权值 $a_i$。\n现在给定 $q$ 个询问，每次询问 $x ~ y$，回答：\n对于从 $x$ 到 $y$ 的最短路径上的所有节点，选出一个子集使得权值的 XOR 最大，回答这个最大值。\n其中，$n \\leq 2 \\times 10^4, q \\leq 10^5$，所有权值为非负整数。\n 题解 首先暴力做法很好想，直接找 $x \\rightarrow y$ 路径上的所有权值，构建一个线性基即可。\n然后考虑优化：\n看到 树 就立刻想到 树形DP，看到 树形DP 就立刻想到了 树上差分。\n虽然这题不能直接用树上差分，但是差分中常用的 倍增LCA 倒是可以用。\n所以做法就是对于每个节点 $u$，令 $j = 0,1,2,\u0026hellip;$，代表从 $u$ 出发，往上跳 $2^j$ 个节点，从起点到终点之间所有节点的权值构建的线性基。\n所以构建出的数组就是个 ll a[maxn][16][61]; // a[u][k] 代表从 u 开始往上从 2^k 格，形成的线性基。\n构建这个线性基的过程和倍增同理，只不过需要 两个线性基合并为一个。\n这个过程也不难，直接把两个线性基中的所有元素拿出来，然后都 insert 进一个空的线性基即可。\n最后，询问 $x ~ y$ 的话就先找到 $l = lca(x,y)$，然后通过倍增，合并出 $(x,l)$ 和 $(y,l)$ 对应的线性基，然后再将两者合并即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e4+5; const int maxm = 1e5+5; int n,q; ll arr[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][16], dep[maxn]; ll a[maxn][16][61]; // a[u][k] 代表从 u 开始往上从 2^k 格，形成的线性基 // insert 一个元素 x 进入 b[] 中 void insert(ll x, ll b[]) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL\u0026lt;\u0026lt;j)) { if (b[j]) x ^= b[j]; else { b[j] = x; return; } } } } // 将 a1, a2 两个线性基合并为 b void merge(ll a1[], ll a2[], ll b[]) { for (int j = 60; j \u0026gt;= 0; j--) { if (a1[j]) insert(a1[j], b); if (a2[j]) insert(a2[j], b); } } void dfs(int u, int p) { par[u][0] = p; insert(arr[u], a[u][0]); dep[u] = dep[p] + 1; for (int j = 1; j \u0026lt;= 15; j++) { par[u][j] = par[par[u][j-1]][j-1]; merge(a[u][j-1], a[par[u][j-1]][j-1], a[u][j]); } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int jump(int u, ll d, ll b[]) { int j = 0; while (d) { if (d \u0026amp; 1) { for (int k = 60; k \u0026gt;= 0; k--) { if (a[u][j][k]) insert(a[u][j][k], b); } u = par[u][j]; } j++; d \u0026gt;\u0026gt;= 1; } return u; } ll query(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); static ll tmp[61]; memset(tmp, 0, sizeof(tmp)); u = jump(u, dep[u] - dep[v], tmp); if (u == v) { insert(arr[u], tmp); } else { for (int j = 15; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { u = jump(u, (1LL\u0026lt;\u0026lt;j), tmp); v = jump(v, (1LL\u0026lt;\u0026lt;j), tmp); } } u = jump(u, 1, tmp); v = jump(v, 1, tmp); insert(arr[u], tmp); insert(arr[v], tmp); } ll ans = 0; for (int j = 60; j \u0026gt;= 0; j--) { if (tmp[j]) ans = max(ans, (ans ^ tmp[j])); } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); while (q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; query(u,v) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P4151 [WC2011]最大XOR和路径 题意\n给定 $n$ 个节点，$m$ 条边的无向连通图。每条边上有权值。\n考虑从 $1$ 到 $n$ 的所有可能路径中，路径上所有边权值的XOR，求这些路径对应的XOR最大值。\n路径可以包含环，一条边可以被经过多次（经过多次的话，权值也要XOR多次）。\n图中可能包含重边和自环。\n其中，$n \\leq 5 \\times 10^4, m \\leq 10^5$\n 题解 首先考虑一下 无环 的情况，那它就是个树了，那路径只有一种可能。就是从 $1 \\rightarrow n$。\n然后考虑一下 有环 的情况，\n可以发现，最终的答案可以是 $1 \\rightarrow n$ 的路径（我们称之为 主路径），XOR上这些环（也可以不 XOR），而链接环与主路径之间的边，可以忽略不计（因为被经过两次了）。\n所以一个大胆（且正确）的猜想是：\n求出所有的环，随便找一条 $1 \\rightarrow n$ 的简单路径（无环），用所有环的XOR值构造一个线性基，最后和主路径XOR起来，得到最大值。\n然后就有几个问题了：\n Q1. 求出所有的环？复杂度会爆炸的吧？\nA1. 我们可以发现，所有环的 XOR 均由它的 简单环 组成。所以我们只需要考虑简单环即可。\nQ2. 如何求出所有的简单环？\nA2. 用一次DFS，DFS的过程中找到所有的 back-edge 即可，由于 $m$ 最多为 $10^5$，所以 back-edge 也不会超过 $10^5$ 个，所以最多只有 $10^5$ 个简单环。\nQ3. 主路径如果有多条怎么办？\nA3. 注意到，尽管只往线性基里加入了简单环，但是由于线性基的特性，所以任意简单环的组合都可以被线性基所表示。所以这就相当于线性基包含了所有可能的环。\n那么，如果从 $1 \\rightarrow n$ 有多条简单路径，则两条不同的简单路径会形成一个环。\n假如最优的主路径为 $B$，而我们考虑了 $A$ 为主路径，但是 $A ~xor~ B$ 实际上是一个环。所以最后我们在考虑最终答案时，有 $A \\text{ xor } (A \\text{ xor } B) = B$，所以 $B$ 就变成最优解中的主路径了。\nQ4. 如何求出一个环的 XOR？\nA4. 直接从 $1$ 开始DFS，记录一个 d[]，其中 d[u] 代表这个 DFS 过程中，找到的一条 $1 \\rightarrow u$ 的简单路径的 XOR。\n则对于 $u$ 的任意一个neighbor $v$，如果 $(u,v,w)$ 是 back-edge，那么 $(d[u] \\text{ xor } d[v] \\text{ xor } w)$ 就是这个环的 XOR。\n 最后的答案就是 d[n] 作为初始值，所有简单环构建出线性基，然后求最大值。\n• 注意到 d[n] 并不在线性基中，因为 d[n] 是 必须要取 的，所以作为 ans 的初始值。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 1e5+5; int n,m; struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll d[maxn], a[62]; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return; } } } } bool vis[maxn]; void dfs(int u) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (vis[to]) { // 发现 back-edge，对应一个简单环 insert(d[u] ^ d[to] ^ w); // 加入一个简单环 } else { d[to] = d[u] ^ w; dfs(to); } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1); ll ans = d[n]; // 注意 d[n] 作为初始值，因为它必须要存在于最终答案中 for (int j = 60; j \u0026gt;= 0; j--) { ans = max(ans, (ans ^ a[j])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 LOJ 114 k小异或和 题意\n给定 $n$ 个非负整数，$m$ 次询问。\n每次询问一个数字 $k$，输出 $S$ 所有非空子集的不同的XOR中，第 $k$ 小的XOR值。\n如果 $S$ 的所有非空子集中，不同的XOR数量 $\u0026lt; k$，则输出 $-1$。\n其中，$n,m \\leq 10^5$。\n 题解 本题主要考察 线性基的化简。\n首先可以构建线性基，如果在构建中出现了 插入失败 的情况，则说明 $\\exists T \\subseteq S$，使得 $XOR(T) = 0$，这说明最小值为 $0$，否则最小值不为 $0$。\n构建完毕后，我们知道，$span(S)$ 的大小为 $2^{|S|}$。\n我们设 $span(S_i)$ 为：只考虑（从小到大）前 $i$ 位的线性基的 $span$，则有：\n$span(S_i) = span(S_{i-1}) \\sqcup span(S_{i-1}) \\text{ xor } x_i$ （注意 $\\sqcup$ 是 disjoint union）\n由此，我们可以联想到，把 $k$ 写成二进制，然后根据 $k$ 的二进制，来构造这个数字。\n比如，$k = 1101$，那么我们就把线性基的第 $0,2,3$ 位 XOR 起来，得到答案。\n 但是这样有一个问题，这样得到的答案不一定正确。比如说：\n线性基 $\\{1,2\\}$ 和 $\\{1,3\\}$ 实际上是等价的，但是对于同样的 $k$，答案却不相同，只有 $\\{1,2\\}$ 构造出来的答案才是正确的。\n 所以我们有了一个想法：把线性基上 每一位的数字转化为它可能的最小值，也就是 化简线性基。\n这个化简的过程，很像高斯消元，但又不完全一样。\n 怎么化简呢？\n想到我们求一个线性基所能表示的最大值时，使用的 ans = max(ans, (ans ^ a[i]))。\n那么化简也是同理，只不过把它改成 min 而已，然后把 ans 替换为线性基上的某一位即可。\n// 将线性基所有元素变成最小 for (int k = 50; k \u0026gt;= 0; k--) { for (int j = k-1; j \u0026gt;= 0; j--) { a[k] = min(a[k], (a[k] ^ a[j])); } }  这样就化简完毕了，举几个例子：\n $\\{70,32,28,8,4,3,1\\}$ 化简后，得到 $\\{64,32,16,8,4,2,1\\}$ $\\{14, 7\\}$ 化简后，得到 $\\{9,7\\}$  化简后就可以用上面的方法来构造了，注意构造答案的时候，只需要考虑线性基上非空的位。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; ll a[51]; bool insert(ll x) { for (int j = 50; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return 1; } } } return 0; } int main() { cin \u0026gt;\u0026gt; n; bool zero = 0; for (int i = 1; i \u0026lt;= n; i++) { ll x; cin \u0026gt;\u0026gt; x; if (!insert(x)) zero = 1; } int sz = 0; for (int k = 50; k \u0026gt;= 0; k--) { if (a[k]) sz++; } // 将线性基所有元素变成最小 for (int k = 50; k \u0026gt;= 0; k--) { for (int j = k-1; j \u0026gt;= 0; j--) { a[k] = min(a[k], (a[k] ^ a[j])); } } // 只考虑线性基的非空位 vector\u0026lt;int\u0026gt; vec; for (int k = 0; k \u0026lt;= 50; k++) { if (a[k]) vec.push_back(k); } cin \u0026gt;\u0026gt; m; while (m--) { ll k; cin \u0026gt;\u0026gt; k; if (zero) k--; // 最小值为 0 if (k \u0026gt;= (1LL \u0026lt;\u0026lt; sz)) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } ll ans = 0; for (int j = 0; j \u0026lt;= 50; j++) { if (k \u0026amp; (1LL \u0026lt;\u0026lt; j)) { ans ^= (a[vec[j]]); // 只考虑非空位 } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例6 HDU6579 Operation 题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$ 和 $m$ 个询问。\n每次询问为两种：\n$0 ~ l ~ r$：从 $\\{a_l,\u0026hellip;,a_r\\}$ 中选取任意个数字，输出 XOR 的最大值。\n$1 ~ x$：给序列 append 一个数字 $x$，使得 $n = n+1$。\n所有询问强制在线。\n其中，$n,m \\leq 5 \\times 10^5$。\n 题解 前缀线性基。\n对于每个 $i$，我们都根据 $\\{a_1,a_2,\u0026hellip;,a_i\\}$ 来构建一个线性基，所以总共有 $n$ 个线性基。\n构建以后，每次询问 $[L,R]$，我们都可以先找到 $[1,R]$ 对应的线性基。\n 找到 $[1,R]$ 的线性基以后，问题转化成，如何去掉 $[1,L-1]$ 的影响？\n我们维护一个数组 pos[]，其中 pos[j] 代表 最大 的index i，使得 $a_i$ 影响到了 线性基的第 $j$ 位 $x_j$。\n所以，在询问 $[L,R]$ 时，我们遍历 $[1,R]$ 对应的线性基中，每一位 $j \\in [0,50]$，如果 $pos[j] \\geq L$，则说明线性基的第 $j$ 位可以被使用。\n 如何维护 pos[] 数组，并且保证 pos[] 数组内的值尽可能大？\n在线性基的推论第 $3$ 条中，我们提到了如果要使用一个新的元素来替换掉线性基中的旧元素，可以使用 swap() 的方式实现。\n这里也是同理，我们在 insert $a_i$ 时，如果当前考虑到了线性基的第 $j$ 位，那么我们检查 $pos[j] \u0026lt; i$ 是否成立，如果是，就进行替换操作（swap()）。\n • 如果这个题可以离线，就可以预处理一下所有的询问，按照 右端点排序，在从左往右扫的时候维护一个 pos[31] 数组即可。\n离线版本可以见：ABC223H\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; // 注意因为 n 最高可被增加到 1e6，所以这里使用的是 1e6 const int maxm = 1e5+5; int n,m; int a[maxn][31], pos[maxn][31]; // 其中 pos[j] 代表 最大 的index i，使得 $a_i$ 影响到了 线性基的第 $j$ 位 $x_j$。 void insert(int i, int x) { memcpy(a[i], a[i-1], 31 * sizeof(int)); // 注意这里有 sizeof(int) memcpy(pos[i], pos[i-1], 31 * sizeof(int)); int p = i; for (int j = 30; j \u0026gt;= 0; j--) { if (x \u0026amp; (1\u0026lt;\u0026lt;j)) { if (a[p][j]) { if (pos[p][j] \u0026lt; i) { // 进行替换 swap(a[p][j], x); swap(pos[p][j], i); } x ^= a[p][j]; } else { a[p][j] = x; pos[p][j] = i; return; } } } } int query(int l, int r) { int ans = 0; for (int j = 30; j \u0026gt;= 0; j--) { if (pos[r][j] \u0026gt;= l) ans = max(ans, (ans ^ a[r][j])); } return ans; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int lastans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; insert(i, x); } while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 0) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l = (l ^ lastans) % n + 1; r = (r ^ lastans) % n + 1; if (l \u0026gt; r) swap(l,r); lastans = query(l,r); cout \u0026lt;\u0026lt; lastans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { int x; cin \u0026gt;\u0026gt; x; x = x ^ lastans; insert(n+1, x); n++; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 30; j++) { a[i][j] = pos[i][j] = 0; } } } }   例7 ABC141F Xor Sum 3 题意\n给定 $n$ 个非负整数，将它们分为两个非空集合 $A,B$，求 $XOR(A) + XOR(B)$ 的最大值？\n其中，$2 \\leq n \\leq 10^5$\n 题解 分为两个集合的话，就可以考虑二进制每一位的count的奇偶性。\n对于第 $i$ 位bit而言：\n 如果 count 是奇数：那么无论怎么分，最后分出来的两个集合一定是 奇 + 偶 的形式，所以最后一定会贡献 $2^i$ 给答案。 如果 count 是偶数：最后分出来，要么为 奇 + 奇，要么为 偶 + 偶，所以对于这些位置，分出来的两个数 $a,b$ 一定是相同的。  所以我们先把 奇数count 的位置贡献算出来，然后把它们全部置为 $0$，接下来所有的位就只有偶数 count 了，此时无论怎么分，最后得到的两个数字都是相同的，也就是答案等于 $2x$。\n所以我们只要让 $x$ 最大就好了，用线性基解决即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll a[61], arr[maxn], ans = 0; int n; void insert(ll x) { for (int j = 60; j \u0026gt;= 0; j--) { if (x \u0026amp; (1LL \u0026lt;\u0026lt; j)) { if (a[j]) x ^= a[j]; else { a[j] = x; return; } } } } int cnt[61]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i]; for (int j = 60; j \u0026gt;= 0; j--) { if (arr[i] \u0026amp; (1LL \u0026lt;\u0026lt; j)) cnt[j] ^= 1; } } for (int j = 60; j \u0026gt;= 0; j--) { if (cnt[j]) { ans += (1LL \u0026lt;\u0026lt; j); for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026amp; (1LL \u0026lt;\u0026lt; j)) arr[i] -= (1LL \u0026lt;\u0026lt; j); } } } for (int i = 1; i \u0026lt;= n; i++) insert(arr[i]); ll x = 0; for (int j = 60; j \u0026gt;= 0; j--) { x = max(x, (x^a[j])); } cout \u0026lt;\u0026lt; 2LL*x + ans \u0026lt;\u0026lt; endl; }   参考链接  https://oi.men.ci/linear-basis-notes/ https://ouuan.github.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://zhuanlan.zhihu.com/p/68575986  ","date":"2021-09-14T13:44:57+08:00","permalink":"https://tom0727.github.io/post/050-%E7%BA%BF%E6%80%A7%E5%9F%BA/","tags":["线性基"],"title":"线性基"},{"categories":["算法"],"contents":"介绍 高斯消元是矩阵操作里最基础的一个，主要用于解形如 $a_1x_1 + a_2x_2 + a_3x_3 = b_1$ 之类的线性方程组。\n步骤  按 column 进行遍历 遍历到第 $k$ 个 column 时，在这个column中，寻找一个 $maxrow$ 使得 $A[maxrow][k]$ 最大。 将第 $k$ 行 与 第 $maxrow$ 行进行交换。 交换后，以第 $k$ 行作为pivot，减掉其他所有行，消去第 $k$ 列其他行上的数字。 最后会得到一个 diagonal matrix，除以对应系数即可得到 $\\vec{b}$  复杂度：$O(n^3)$\n先上板子：\n模版 P3389 【模板】高斯消元法 题意\n给定一个线性方程组，进行求解。\n输入一个 $n \\times (n+1)$ 的矩阵，每一行为 $a_1, a_2, \u0026hellip;, a_n, b_k$，代表一组方程。\n #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; double A[maxn][maxn]; int n; void solve() { for (int k = 1; k \u0026lt;= n; k++) { int maxrow = k; // 当前行初始情况下为：当前列对应的行数 for (int i = k+1; i \u0026lt;= n; i++) { // 从当前行往下找 if (abs(A[i][k]) \u0026gt; abs(A[maxrow][k])) maxrow = i; } for (int i = 1; i \u0026lt;= n+1; i++) swap(A[k][i], A[maxrow][i]); //交换两行, 保证A[k][k]最大 if (abs(A[k][k]) \u0026lt; eps) { cout \u0026lt;\u0026lt; \u0026quot;Infinite solutions.\u0026quot; \u0026lt;\u0026lt; endl; // 出现一行全是 0 的情况，一般说明有无数个解 return; } for (int i = 1; i \u0026lt;= n; i++) { if (i == k) continue; double m = A[i][k] / A[k][k]; for (int j = 1; j \u0026lt;= n+1; j++) { //更新上下的行 A[i][j] -= (m * A[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { A[i][n+1] /= A[i][i]; // 最后除以斜线上的系数 A[i][i] = 1.0; printf(\u0026quot;%.2f\\n\u0026quot;, A[i][n+1]); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n+1; j++) { cin \u0026gt;\u0026gt; A[i][j]; // 输入矩阵，j=n+1 代表 b } } solve(); }  例题 例1 洛谷P2447 [SDOI2010]外星千足虫 题意\n有 $n$ 个虫子，每只虫子来自地球或者火星。来自地球的虫子有偶数个脚，火星的虫子有奇数个脚。\n现在给定 $m$ 个方程，代表已知哪些虫子的脚数量之和为奇数或者偶数。\n求每个虫子的归属地（地球或者火星）。\n如果有解，输出最小的 $k \\leq n$ 使得仅用前 $k$ 个方程即可得到结果。\n如果无解，则输出 Cannot Determine。\n其中，$1 \\leq n \\leq 10^3, 1 \\leq m \\leq 2 \\times 10^3$。\n 题解 高斯消元即可。现在有几个问题：\nQ1. 如果有解，如何求出 $k$？\nA1. 注意到高斯消元的第二步是寻找一个 $maxrow$。然而这个题中，矩阵中的数要么为 $0$，要么为 $1$。所以只要找到 $1$，就不需要再往下找了。\n所以在寻找 $1$ 的过程中记录一下用到的 row number 的最大值即可，一旦找到就立刻break。\n Q2. 高斯消元是 $O(n^3)$ 的，复杂度不对？\nA2. 再次注意到这个矩阵仅由 $0,1$ 组成，可以用 bitset 进行优化。优化幅度为 $\\frac{1}{w}$，其中 $w=32$。\n所以复杂度为 $O(\\frac{n^2m}{w})$，足以通过本题。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e3+2; const int maxm = 7e5+5; bitset\u0026lt;maxn\u0026gt; A[maxn+maxn]; int ans; int n,m; void solve() { for (int k = n; k \u0026gt;= 1; k--) { int maxrow = n-k+1; for (int i = n-k+1; i \u0026lt;= m; i++) { ans = max(ans, i); if (A[i].test(k)) { maxrow = i; break; } } swap(A[n-k+1], A[maxrow]); if (!A[n-k+1].test(k)) { cout \u0026lt;\u0026lt; \u0026quot;Cannot Determine\\n\u0026quot;; return; } for (int i = 1; i \u0026lt;= m; i++) { if (i == n-k+1) continue; if (A[i].test(k)) A[i] ^= A[n-k+1]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) { if (A[i].test(0)) cout \u0026lt;\u0026lt; \u0026quot;?y7M#\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;Earth\\n\u0026quot;; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (m \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;Cannot Determine\\n\u0026quot;; return 0; } ans = 1; for (int i = 1; i \u0026lt;= m; i++) { string s1,s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; A[i] = bitset\u0026lt;maxn\u0026gt;(s1 + s2); } solve(); }   例2 洛谷P4035 [JSOI2008]球形空间产生器 题意\n在 $n$ 维空间中，有一个球体。现在已知该球面上 $(n+1)$ 个点的坐标，求出球心坐标？\n其中，$1 \\leq n \\leq 10$，数据保证有唯一解。\n 题解 设球心坐标为 $(b_1,b_2,\u0026hellip;,b_n)$，那么就可以列出 $(n+1)$ 个方程：\n$(b_1 - a_{11})^2 + (b_2 - a_{12})^2 + \u0026hellip; + (b_n - a_{1n})^2 = R^2$ \u0026hellip;\n但是这并不是线性方程组。\n为了使其成为线性方程组，将 $(n+1)$ 个方程进行相减，得到\n 方程 $2$ 减去方程 $1$ 方程 $3$ 减去方程 $1$ \u0026hellip;  即可得到 $n$ 个线性方程。\n然后用高斯消元即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 12; double A[maxn][maxn], arr[maxn][maxn]; int n; void solve() { for (int k = 1; k \u0026lt;= n; k++) { int maxrow = k; for (int i = k+1; i \u0026lt;= n; i++) { if (abs(A[i][k]) \u0026gt; abs(A[maxrow][k])) maxrow = i; } for (int i = 1; i \u0026lt;= n+1; i++) swap(A[k][i], A[maxrow][i]); //交换两行, 保证A[k][k]最大 if (abs(A[k][k]) \u0026lt; eps) { cout \u0026lt;\u0026lt; \u0026quot;No Solution\u0026quot; \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= n; i++) { if (i == k) continue; double m = A[i][k] / A[k][k]; for (int j = 1; j \u0026lt;= n+1; j++) { //更新上下的行 A[i][j] -= (m * A[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { A[i][n+1] /= A[i][i]; // 最后除以斜线上的系数 A[i][i] = 1.0; printf(\u0026quot;%.3f \u0026quot;, A[i][n+1]); } } double sq(double a) { return a*a; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n+1; i++) { for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { A[i][j] = arr[i+1][j] - arr[i][j]; } for (int k = 1; k \u0026lt;= n; k++) { A[i][n+1] += sq(arr[i+1][k]) - sq(arr[i][k]); } A[i][n+1] /= 2; } solve(); }   ","date":"2021-09-10T22:00:43+08:00","permalink":"https://tom0727.github.io/post/049-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","tags":[""],"title":"高斯消元"},{"categories":["算法"],"contents":"模型 例1 几何分布 题意\n一次伯努利试验的成功概率为 $p$，那么期望试验多次才能获得第一次成功？\n 答案是 $\\frac{1}{p}$。\n证明：设 $E[X]$ 为期望试验次数。\n用 $X_i = 1$ 表示第 $i$ 次试验成功（$0$ 反之），讨论：第一次试验要么成功，要么失败：\n$$E[X] = p * 1 + (1-p) * (1 + E[X|X_1=0]) = p + (1-p)(1 + E[X])$$\n得到 $E[X] = \\frac{1}{p}$。\n例2 抽卡问题 题意\n卡池里有 $N$ 种卡，每种有无限张，每次抽卡会等概率抽取一张卡，问期望多少次抽到所有种类的卡？\n $N = 1$ 的情况：期望为 $1$。\n$N = 2$ 的情况：先抽一张，获得一种。接下来是一个几何分布问题：有 $\\frac{1}{2}$ 的概率抽到第二种卡，期望 $2$ 次即可抽到，所以总期望为 $1+2=3$。\n那么在 $N$ 的情况下，设事件 $X_i$ 为：已经抽到了 $i$ 种卡，可以发现每次都是一个几何分布问题，根据 $i$ 的值决定试验成功率。\n$$E[X] = E[X_1|X_0] + E[X_2|X_1] + E[X_3|X_2] + \u0026hellip; + E[X_N|X_{N-1}]$$\n其中，$E[X_k|X_{k-1}]$ 代表卡池里 $N$ 种卡已经抽到了 ${k-1}$ 种，还有 $N-k+1$ 种卡没抽到，每次试验成功率（抽到新卡）为 $\\frac{N-k+1}{N}$，故期望值\n$$E[X_k|X_{k-1}] = \\frac{N}{N-k+1}$$\n综上：\n$$E[X] = \\sum_{k=1}^N \\frac{N}{N-k+1} = \\sum_{k=1}^N \\frac{N}{k}$$\n例题 例1 洛谷P1850 [NOIP2016 提高组] 换教室 题意\n有 $n$ 个时间段，每个时间段有 $2$ 节课程。其中在时间段 $i$ 的两节课，分别在教室 $c_i, d_i$ 上。\n对于所有的时间段 $i$，牛牛预先被安排在 $c_i$ 上课。\n对于一个时间段 $i$，牛牛可以申请转到教室 $d_i$ 上课。但这个申请只有 $k_i$ 的概率被批准。\n牛牛最多可以申请 $m$ 个时间段，但是所有申请必须一次性提交。\n同时，校园可以看作是一个图，教室为节点（共 $v$ 个教室），教室之间有双向边（共 $e$ 个边），边有长度。\n每当一节课结束后，牛牛会沿着最短路径走到下一节课所在的教室。\n现在牛牛想知道，怎么申请时间段，使得他在教室间移动的路程长度期望值最小，求出这个最小期望。\n其中，$1 \\leq n \\leq 2000, 0 \\leq m \\leq 2000, 1 \\leq v \\leq 300, 0 \\leq e \\leq 90000$。\n 题解 首先用 floyd $O(n^3)$ 求出每两个节点之间的最短路长度。\n然后一个很明显的 DP 思路：\n设 $dp[i][j][k]$ 为：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前在哪个教室。\n这个思路看起来很有道理，但是不正确。因为题目提到 所有申请必须一次性提交。\n而 $k=0/1$ 如果代表当前在哪个教室，就说明我们已经知道了当前的申请结果，来考虑后面的时间段是否申请。这会导致我们的决策更加的精明，从而使得答案小于正确答案。\n 正确的状态为：$dp[i][j][k]$：当前考虑第 $i$ 个时间段，还剩下 $j$ 次申请机会，$k=0/1$ 代表当前 是否申请过，$dp$ 数组的值代表路径长度期望值。\n然后转移的时候，就要分类讨论 是否申请下一个时间段，得到两个结果，取 $\\min$ 就得到了当前状态的答案。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2002; int n,m,v,e, c[maxn], d[maxn]; double k[maxn]; int adj[302][302], dis[302][302]; double dp[maxn][maxn][2]; // K = 1: 已申请， K = 0: 未申请 double dfs(int i, int j, int K) { if (i \u0026gt;= n) return 0.0; if (dp[i][j][K] \u0026gt;= 0.0) return dp[i][j][K]; double r1 = 1e18, r2 = 1e18; // next: 申请/不申请 if (K) { r1 = k[i] * (dfs(i+1, j, 0) + dis[d[i]][c[i+1]]) + (1.0 - k[i]) * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]); if (j \u0026gt; 0) r2 = k[i] * (k[i+1] * (dfs(i+1, j-1, 1) + dis[d[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[d[i]][c[i+1]])) + (1.0 - k[i]) * (k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]])); } else { r1 = 1.0 * (dfs(i+1, j, 0) + dis[c[i]][c[i+1]]); if (j \u0026gt; 0) r2 = k[i+1] * (dfs(i+1, j-1, 1) + dis[c[i]][d[i+1]]) + (1.0 - k[i+1]) * (dfs(i+1, j-1, 1) + dis[c[i]][c[i+1]]); } return dp[i][j][K] = min(r1, r2); } int main() { scanf(\u0026quot;%d%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;v,\u0026amp;e); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;c[i]); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;d[i]); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%lf\u0026quot;, \u0026amp;k[i]); for (int i = 1; i \u0026lt;= e; i++) { int u,v,w; scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;u,\u0026amp;v,\u0026amp;w); if (adj[u][v]) { if (adj[u][v] \u0026gt; w) adj[u][v] = adj[v][u] = w; } else adj[u][v] = adj[v][u] = w; } memset(dis, 0x3f3f3f3f, sizeof(dis)); for (int i = 1; i \u0026lt;= v; i++) { for (int j = 1; j \u0026lt;= v; j++) { if (adj[i][j]) dis[i][j] = dis[j][i] = adj[i][j]; } } for (int i = 1; i \u0026lt;= v; i++) dis[i][i] = 0; for (int k = 1; k \u0026lt;= v; k++) { for (int i = 1; i \u0026lt;= v; i++) { for (int j = 1; j \u0026lt;= v; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[i][j][0] = dp[i][j][1] = -1; } } double ans1 = 1.0 * dfs(1, m, 0), ans2 = 1e18; if (m \u0026gt; 0) { ans2 = 1.0 * dfs(1, m-1, 1); } double ans = min(ans1, ans2); printf(\u0026quot;%.2lf\\n\u0026quot;, ans); }   例2 洛谷P3830 [SHOI2012]随机树 题意\n给定一棵二叉树，初始状态下只有根节点。每次操作会在所有叶子节点中，等概率选择一个，给它添加左右两个child。\n给定正整数 $n$，求：对于由此生成的含有 $n$ 个叶子节点的二叉树，输出 叶子结点深度 的期望值，和 树深度 的期望值。\n其中，$n \\leq 100$，根节点的深度为 $0$。\n 题解 先考虑一下 叶子结点深度 的期望值。\n每次扩展一个叶子，设其原深度为 $x$，相当于总深度增加了 $2(x+1) - x = x+2$。\n所以设，对于 $n$ 个叶子的树，平均叶子深度若为 $f_n$，则总深度为 $f_n * n$。\n所以在这个树中选择一个叶子展开，平均叶子增加深度为 $f_n + 2$。\n所以 $f_{n+1} = \\frac{(f_n * n + f_n + 2)}{n+1} = f_n + \\frac{2}{n+1}$。\n 然后看第二问，树深度 的期望值。\n在做到这里的时候我的想法出现了一些偏差：我一直在考虑如何将 叶子数为 $(n-1)$ 的状态转移到 叶子数为 $n$ 的状态。\n但是实际做法是一个很神奇的想法：\n 使用 左，右子树 进行转移。\n 设 $dp[i][j]$ 为：有 $i$ 个叶子节点，深度 $\\geq j$ 的概率，枚举 左子树 叶子节点数量 $k$，有以下转移：\n$$dp[i][j] = \\frac{\\sum\\limits_{k=1}^{i-1}dp[k][j-1] + dp[i-k][j-1] - dp[k][j-1] * dp[i-k][j-1]}{i-1}$$\n什么意思呢？我们先看分子：\n显然对于根节点来说，它左右子树必然不为空，所以转移的时候 $k=1$ 开始，到 $(i-1)$，能转移的状态是深度为 $j-1$ 的，所以都加上。\n但是因为两边深度均为 $j-1$ 算重了，所以用容斥减去重复的部分 $dp[k][j-1] * dp[i-k][j-1]$。\n分子 $(i-1)$ 是哪里来的呢？因为考虑到期望的定义是 值 乘上 概率 之和。对于 $k$ 不同的情况，有不同的概率。\n但是我们可以得出结论，每一种概率都是相同的。\n意思就是：对于一棵 $n$ 个叶子节点的树，左子树拥有的叶子节点数量为 $1,2,\u0026hellip;,n-1$，发生的概率均相同。\n 证明：用数学归纳法即可。\n首先可以得到对于 $n=2$ 是相同的。\n我们设 $p[i][j]$ 为：叶子节点数为 $i$ 的树中，左子树有 $j$ 个叶子节点的概率。\n则 $p[i][j] = p[i-1][j-1] * \\frac{j-1}{i-1} + p[i-1][j] * \\frac{(i-1)-j}{i-1}$\n由数学归纳法，设对于 $(i-1)$ 而言，$\\forall j \\in [1,i-2], p[i-1][j] = \\frac{1}{i-2}$。\n则 $p[i][j] = \\frac{1}{i-2} * \\frac{j-1}{i-1} + \\frac{1}{i-2} * \\frac{(i-1)-j}{i-1} = \\frac{1}{i-1}$，与 $j$ 无关。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int q,n; double dp[102][102]; // dp[i][j]: 对于第i步，深度为j的期望叶子节点期望个数 int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;q,\u0026amp;n); double ans = 0.0; if (q == 1) { dp[1][0] = 1.0; // 第 i 步有 2i-1 个节点, 有 i 个叶子节点 for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 0; j \u0026lt;= i-1; j++) { double p = dp[i][j] / (i); dp[i+1][j+1] += p * 2.0; dp[i+1][j] -= p * 1.0; } for (int j = 0; j \u0026lt;= i-1; j++) dp[i+1][j] += dp[i][j]; } for (int j = 0; j \u0026lt;= n; j++) ans += dp[n][j] * j; printf(\u0026quot;%.6f\\n\u0026quot;, ans/(n)); } else { for (int i = 0; i \u0026lt;= n; i++) dp[i][0] = 1.0; dp[0][0] = 1.0; dp[1][0] = 1.0; dp[2][0] = dp[2][1] = 1.0; for (int i = 3; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt; i; j++) { for (int k = 1; k \u0026lt;= i-1; k++) { dp[i][j] += dp[k][j-1] + dp[i-k][j-1] - dp[k][j-1] * dp[i-k][j-1]; } dp[i][j] /= (i-1); } } for (int j = n-1; j \u0026gt;= 0; j--) { double p = - dp[n][j+1] + dp[n][j]; ans += (p * j); } printf(\u0026quot;%.6f\\n\u0026quot;, ans); } }   例3 洛谷 P2221 [HAOI2012]高速公路 题意\n一条线上有 $n$ 个收费站，从第 $i$ 个到第 $(i+1)$ 个收费站之间有一条路，通过一条路需要交费。初始状态下，每条路的费用为 $0$。\n给定 $m$ 个询问，每个询问为两种之一：\n$C ~ l ~ r ~ v$：将第 $l$ 到第 $r$ 个收费站之间的所有道路费用增加 $v$。\n$Q ~ l ~ r$：回答在第 $l$ 到第 $r$ 个收费站之间，等概率选择两个不同的收费站 $a,b$，从 $a$ 行驶到 $b$ 的期望费用？\n其中，$1 \\leq n,m \\leq 10^5, -10^4 \\leq v \\leq 10^4$，在任何时间段，任何一条道路的费用绝对值不超过 $10^4$。\n 题解 线段树。首先把收费站转成道路，就对于所有的 $l,r$，都改成 $l,r-1$。对于线段树，从 $1$ 和 $n-1$ 之间build。\n计算期望的时候，可以知道分母是 $C_{r-l}^2$。分子是从 $l,r$ 之间所有的选择之和。\n现在问题是：如何求出一个区间内，所有可能的 $l,r$ 组合的区间和的和？\n数学表达：对于区间 $[L,R]$，求\n$$\\sum\\limits_{i=L}^R\\sum\\limits_{j=i}^R sum(arr[i\u0026hellip;j])$$\n 直接从线段树的角度来考虑：一个区间的 $\\sum\\limits_{i=l}^r\\sum\\limits_{j=i}^r sum(arr[i\u0026hellip;j])$，能否用左右区间的这个信息来维护？\n可以的，注意到：对于一个区间 $[L,R]$ 来说，所有 $l,r$ 的组合可以分为三种：\n $l,r \\in [L, mid]$ $l,r \\in [mid+1, R]$ $l \\in [L, mid], r \\in [mid+1, R]$  前两种已经被子区间用到了，只要考虑第三种情况即可。\n所以问题就转化成：\n对于一个区间 $[L,R]$，求\n$$\\sum\\limits_{i=L}^{mid}\\sum\\limits_{j=mid+1}^R sum(arr[i\u0026hellip;j])$$\n 对于这个问题，我们可以固定 $l,r$ 其中之一。\n比如我们固定 $l=mid$，那么 $r$ 会从 $mid+1$ 一直iterate到 $R$，得到的 sum 就是：\n$$sum(arr[mid\u0026hellip;mid+1]) + sum(arr[mid\u0026hellip;mid+2]) + \u0026hellip; + sum(arr[mid\u0026hellip;R])$$\n把它从 $mid$ 的位置拆开来，就等于：\n$$(R-mid) * arr[mid] + sum(arr[mid+1\u0026hellip;mid+1]) + sum(arr[mid+1\u0026hellip;mid+2]) + sum(arr[mid+1\u0026hellip;R])$$\n$$=(R-mid) * arr[mid] + \\sum\\limits_{l=mid+1}^R sum(arr[l\u0026hellip;R])$$\n发现：$\\sum\\limits_{l=mid+1}^R sum(arr[l\u0026hellip;R])$ 是可以用线段树来维护的。\n 所以最后，我们维护几个值：\n 一个区间的 $sum$ 一个区间的 $lsum$：指 $\\sum\\limits_{r=L}^R sum(arr[L\u0026hellip;r])$ 一个区间的 $rsum$：指 $\\sum\\limits_{l=R}^L sum(arr[l\u0026hellip;R])$ 一个区间的 $allsum$：指所求，即 $\\sum\\limits_{i=L}^{mid}\\sum\\limits_{j=mid+1}^R sum(arr[i\u0026hellip;j])$  转移方程见代码。\n • 注意到在线段树 $query$ 的过程中，合并的时候仍然要用转移方程，而不能直接用左右的 $allsum$ 的和。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } ll cnt[maxn]; ll n,m; char op; struct node { ll lsum, rsum, sum, allsum; ll lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; ll C(ll a) { return a * (a+1) / 2LL; } void push_down(ll cur, ll L, ll R) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; tr[cur].lazy = 0; ll mid = (L+R) \u0026gt;\u0026gt; 1; ll l = cur\u0026lt;\u0026lt;1, r = l+1; tr[l].lazy += lazy, tr[r].lazy += lazy; ll llen = (mid - L + 1), rlen = (R - mid); tr[l].sum += llen * lazy; tr[r].sum += rlen * lazy; tr[l].lsum += C(llen) * lazy; tr[r].lsum += C(rlen) * lazy; tr[l].rsum += C(llen) * lazy; tr[r].rsum += C(rlen) * lazy; tr[l].allsum += cnt[llen] * lazy; tr[r].allsum += cnt[rlen] * lazy; } void push_up(ll cur, ll L, ll R) { ll l = cur\u0026lt;\u0026lt;1, r = l+1; ll mid = (L+R) \u0026gt;\u0026gt; 1; ll llen = (mid - L + 1), rlen = (R - mid); tr[cur].sum = tr[l].sum + tr[r].sum; tr[cur].lsum = tr[l].lsum + tr[r].lsum + rlen * tr[l].sum; tr[cur].rsum = tr[l].rsum + tr[r].rsum + llen * tr[r].sum; tr[cur].allsum = tr[l].rsum * rlen + tr[r].lsum * llen + tr[l].allsum + tr[r].allsum; } void update(ll cur, ll l, ll r, ll L, ll R, ll val) { ll len = (r-l+1); if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].lazy += val; tr[cur].sum += len * val; tr[cur].lsum += C(len) * val; tr[cur].rsum += C(len) * val; tr[cur].allsum += cnt[len] * val; return; } ll mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur, l, r); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, val); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val); push_up(cur, l, r); } node query(ll cur, ll l, ll r, ll L, ll R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur]; } push_down(cur, l, r); ll mid = (l+r) \u0026gt;\u0026gt; 1; node lnode {}, rnode {}, curnode {}; ll llen = max(mid - max(L, l) + 1, 0), rlen = max(min(R, r) - mid, 0); if (L \u0026lt;= mid) lnode = query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) rnode = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); curnode.sum = lnode.sum + rnode.sum; curnode.lsum = lnode.lsum + rnode.lsum + rlen * lnode.sum; curnode.rsum = lnode.rsum + rnode.rsum + llen * rnode.sum; curnode.allsum = lnode.allsum + rnode.allsum + lnode.rsum * rlen + rnode.lsum * llen; push_up(cur, l, r); return curnode; } void init() { cnt[1] = 1; cnt[2] = 4; for (ll i = 3; i \u0026lt;= maxn-5; i++) { ll mid = (1+i) \u0026gt;\u0026gt; 1; ll j = mid, k = i-mid; cnt[i] = cnt[j] + cnt[k] + C(j) * k + C(k) * j; } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; init(); n--; while (m--) { cin \u0026gt;\u0026gt; op; if (op == 'C') { ll l,r,v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; r--; update(1, 1, n, l, r, v); } else { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; r--; ll res = query(1, 1, n, l, r).allsum; int flag = 1; if (res \u0026lt; 0) flag = -1; res = abs(res); ll d = C(r-l+1); ll g = gcd(res,d); res /= g; d /= g; if (flag \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026quot;-\u0026quot;; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;/\u0026quot; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例4 CF850F Rainbow Balls 题意\n有一个袋子，袋子中有 $n$ 种颜色的球，第 $i$ 种颜色的球有 $a_i$ 个。\n现在持续进行以下操作：\n有顺序地随机取出两个球，把第二个球涂成第一个球的颜色，然后把两个球都放回袋子。\n求操作次数的期望，使得所有球的颜色相同？\n• 可以证明最终答案为 $\\frac{P}{Q}$ 的形式，输出 $P \\times Q^{-1}$ 在 $\\mod (10^9+7)$ 下的值。\n其中，$n \\leq 2500, 1 \\leq a_i \\leq 10^5$。\n 题解 一个比较明显的想法是：先决定最终的颜色。\n在决定好最终颜色（比如红色）后，其他颜色都可以看作同一种颜色（非红色）。\n在问题变成 红色/非红色 之后，可以发现使用 DP 可以表示递推状态。\n并且 DP 的状态仅与 红色球 的数量有关。\n 令 $s = \\sum\\limits_{i=1}^na_i$ （表示总球数）。\n令 $f_i$ 为：现在有 $i$ 个红色球，把所有球都变成 红色 的期望操作次数。\n首先可以知道，$f_s = 0$，且 $f_0$ 不存在。\n 然后考虑转移方程：\n对于 $f_i$ 来说，有 $i$ 个红色球，$(s-i)$ 个非红色球。\n那么随机取两个球，能对状态产生影响的就两种情况：\n 红 + 非红 -\u0026gt; 红色球数 加 $1$ 非红 + 红 -\u0026gt; 红色球数 减 $1$  这两种情况的样本大小均为 $i(s-i)$，而总样本空间的大小为 $s(s-1)$。\n所以，令 $$p_i = \\frac{i(s-i)}{s(s-1)}$$\n则从 $f_i$ 转移到 $f_{i-1}, f_{i+1}$ 的概率均为 $p_i$，而什么都没发生（转移回 $f_i$）的概率为 $(1-2p_i)$。\n 如此，我们可以列出方程：\n$$f_i = p_if_{i-1} + p_if_{i+1} + (1-2p_i)f_i + v$$\n$v$ 是什么？\n注意到转移时，也是会消耗 $1$ 次操作的。\n• 但是注意，$v$ 不等于 $1$！\n这是因为 $f_i$ 的意义是：最终颜色为红色 的情况下的操作期望值。\n所以 $v$ 应该等于 这一次操作 被分到 最终颜色为红色 情况下的 贡献（对于期望值的贡献）。\n相当于把 $1$ 次操作拆成很多份，每一份分别贡献给了每一种最终颜色对应的期望。\n 结论：$v = \\frac{i}{s}$\n证明：从字面上理解来看，$v$ 的值代表了在有 $i$ 个红色球的情况下，最终颜色为红色的概率。\n所以我们求出这个概率即可。\n设 $g_i$ 为：有 $i$ 个红色球的情况下，最终颜色为红色的概率。\n易知 $g_0 = 0, g_s = 1$。\n并且同上转移方程，可得方程：\n$$g_i = p_ig_{i-1} + p_ig_{i+1} + (1-2p_i)g_i$$\n即 $2g_i = g_{i-1} + g_{i+1}$，也就是 $g_{i+1} - g_i = g_i - g_{i-1}$，等差数列。\n所以 $g_i = \\frac{i}{s}$，证毕。\n 所以我们最终的方程就有了：\n$$f_i = p_if_{i-1} + p_if_{i+1} + (1-2p_i)f_i + \\frac{i}{s}$$\n化简一下可得：\n$$2f_i = f_{i-1} + f_{i+1} + \\frac{s-1}{s-i}$$\n其中，$f_s = 0, f_0$ 不存在。\n处理不存在的值 $f_0$，我们不能把它当成 $\\inf$，只能把其当成 $0$。\n所以代入 $i=1$，有 $f_2 = 2f_1 - 1$。\n$i$ 的有效值为 $i \\in [1,s-1]$，未知量为 $f_1, f_2, \u0026hellip;, f_{s-1}$，总共有 $(s-1)$ 个方程 和 $(s-1)$ 个未知量，发现是可以解出来的。\n但是问题在于 $s$ 的范围高达 $2500 * 10^5$，不能直接用高斯消元来解。\n所以只能手推式子了，联立 $(s-1)$ 个方程后，可以手推得出\n$$f_1 = \\frac{(s-1)^2}{s}$$\n剩下的 $f_2, \u0026hellip;, f_{s-1}$ 也可以得出了。\n枚举所有最终颜色的情况，最终的答案就为 $ans = \\sum\\limits_i{f_{a_i}}$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 2505; const int maxm = 1e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = (res * a) % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } int n; ll arr[maxn], s = 0; ll f[maxm]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], s += arr[i]; f[1] = (s-1) * (s-1) % mod * inv(s) % mod; // f1 = (s-1)^2 / s f[2] = (2 * f[1] % mod - 1 + mod) % mod; // f2 = 2f1 - 1 for (int i = 3; i \u0026lt;= maxm-5; i++) { f[i] = (2 * f[i-1] % mod - f[i-2] - (s-1) * inv(s-(i-1)) % mod + 2LL * mod) % mod; // f_k = 2f_{k-1} - f_{k-2} - (s-1)/(s-k+1) } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += f[arr[i]], ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 ABC224F 题意\n给定一个字符串 $S$，仅包含 $1-9$ 的字符。\n现在在任意两个字符之间添加 + 号，就可以得到一个算式。\n求所有添加方案得到的算式的和。\n其中，$|S| \\in [1, 2 * 10^5]$。\n 题解 对于这种 \u0026ldquo;所有方案\u0026rdquo; 的题目，一般考虑下概率问题。\n对于从右往左数的第 $i$ 位，我们考虑它作为个位数，十位数，百位数……的概率：\n$i=1$：个位数概率 $p=1$\n$i=2$：个位数概率 $p=\\frac{1}{2}$，十位数概率 $p=\\frac{1}{2}$\n$i=3$：个位数概率 $p=\\frac{1}{2}$，十位数概率 $p=\\frac{1}{4}$，百位数概率 $p=\\frac{1}{4}$\n$i=4$：个位数概率 $p=\\frac{1}{2}$，十位数概率 $p=\\frac{1}{4}$，百位数概率 $p=\\frac{1}{8}$，千位数概率 $p=\\frac{1}{8}$。\n可以得出结论：除了最高位等同于次高位的概率外，对于 $i=k$ 的情况，从个位数开始往上的概率分别为 $[\\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}\u0026hellip;]$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; T qpow(T a, int b) { T res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int norm(int x) { if (x \u0026lt; 0) { x += mod; } if (x \u0026gt;= mod) { x -= mod; } return x; } struct Z { int x; Z(int x = 0) : x(norm(x)) {} int val() const { return x; } Z operator-() const { return Z(norm(mod - x)); } Z inv() const { assert(x != 0); return qpow(*this, mod - 2); } Z \u0026amp;operator*=(const Z \u0026amp;rhs) { x = (ll)(x) * rhs.x % mod; return *this; } Z \u0026amp;operator+=(const Z \u0026amp;rhs) { x = norm(x + rhs.x); return *this; } Z \u0026amp;operator-=(const Z \u0026amp;rhs) { x = norm(x - rhs.x); return *this; } Z \u0026amp;operator/=(const Z \u0026amp;rhs) { return *this *= rhs.inv(); } friend Z operator*(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res *= rhs; return res; } friend Z operator+(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res += rhs; return res; } friend Z operator-(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res -= rhs; return res; } friend Z operator/(const Z \u0026amp;lhs, const Z \u0026amp;rhs) { Z res = lhs; res /= rhs; return res; } }; Z ans = 0; int main() { fastio; string s; cin \u0026gt;\u0026gt; s; int n = s.size(); Z e = 1, p = 1, num = 1; for (int i = n-1; i \u0026gt;= 0; i--) { Z c = s[i] - '0'; ans = ans + c * e; e -= num * p; p /= 2; e += p * num * 11; num *= 10; } cout \u0026lt;\u0026lt; (ans * (qpow(Z(2), n-1))).val() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2021-07-27T17:57:28+08:00","permalink":"https://tom0727.github.io/post/048-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/","tags":["概率","期望","数学"],"title":"概率期望"},{"categories":null,"contents":"","date":"2021-06-09T12:19:07+08:00","permalink":"https://tom0727.github.io/cf-problems/","tags":null,"title":"CF Problems"},{"categories":["算法"],"contents":"介绍 网络 是一个有向图 $G = (V,E)$，每条边 $(u,v) \\in E$ 都拥有一个容量 $c(u,v)$。\n在一个网络中，拥有两个特殊的节点 $s, t$ （源点，汇点）。\n定义 流 为一个函数 $f(u,v)$，其中 $u,v \\in V$，满足：\n 容量限制：每条边的流不能超过这条边的容量，即 $f(u,v) \\leq c(u,v)$。 斜对称性：每条边的流量，与其相反边的流量，互为相反数，即 $f(u,v) = -f(v,u)$。 流守恒性：从源点 $s$ 流出的流量，等于汇点 $v$ 流入的流量。同时对于每个点 $u$（除了 $s,t$），流入 $u$ 的流量需要等于 流出 $u$ 的流量。  定义 残量网络 为：对于一个流函数 $f$，残量网络 $G_f$ 是网络 $G$ 中 所有的节点 和 剩余容量 $\u0026gt; 0$ 的边 组成的子图。\n残量网络中，可能存在 原图中不存在的边（一条边剩余流量，产生的反向边，也能算入残量网络）。\n 网络流的三种问题类型：最大流，最小割，费用流。\n最大流 定义一个网络的流量为：汇入 $t$ 的流量之和。\n最大流就是求：从 $s$ 流到 $t$ 的最大流量。\n最小割 如果我们要从原图中，切掉一个 边集 $E' \\subseteq E$，使得 $s,t$ 无法联通。\n让这个边集的容量和 最小，就是最小割。\n• 在数值上，最小割 等于 最大流，如果要求出具体是哪些边，可以看残量网络。\n费用流 每一条边 $(u,v)$ 都有一个费用 $w(u,v)$，每当有 $1$ 个单位的流量流过这条边，就要付出 $w(u,v)$ 的代价。\n在 保证最大流 的基础上，求出 最小/最大费用，就是 费用流。\n 算法 定义 增广路 为：残量网络中，一条从 $s$ 到 $t$ 的路径。\n如果我们要求最大流，那么 当前的流是最大流 $\\iff$ 残量网络 $G_f$ 中不存在增广路（即，残量网络中 $s,t$ 不相连）。\nEK算法 $EK$ 算法的思想就是：每一轮增广，都用 BFS 在 残量网络 上找到一个增广路，然后根据这个路径上，最小 的剩余流量，来流过这条路径。然后更新残量网络，直到残量网络中不存在增广路。\n由于实践中一般不用，所以就不多赘述。\nDinic算法 思想与 EK 算法相同，在每一轮增广时，按照以下顺序进行操作：\n 从源点 $s$ 开始进行 BFS，获得一张分层图。 利用 DFS 进行增广，增广过程中保证一定是从 第 $x$ 层增广到 第 $(x+1)$ 层。利用 DFS 增广的好处是可以多路增广，在一条路径增广完毕，回溯的时候可以寻找下一条。  Dinic 算法有几个重要的优化：\n 删点：在一个点 $u$ 尝试向外流的时候，如果成功流出的流量为 $0$，说明这个点 $u$ 已经无法向 $t$ 推送流量了，我们将这个点的 dis[u] = -1。意思为删除这个点。 当前弧优化：在 DFS 过程中，如果我们推完了一条边，然后回溯了，这说明，要么 **走这条边已经无法连通到 $t$**了，要么 入流量用完了。无论是哪一种，都说明我们无法再使用这条边了。所以就在本轮增广中，删去这条边。在代码中，使用 cur[] 数组来实现。  复杂度：$O(n^2m)$，在实际使用中，一般跑的比这个快（所以不用太担心复杂度问题）。\n费用流 在 Dinic 的基础上，把 BFS求分层图 的过程，改成 SPFA求最短路 即可。然后在增广的过程中，只走最短路径。\n同时，如果有费用为 $0$ 的边，使得这条边，及其反向边的费用均为 $0$，这可能会导致算法的最短路一直在这两个节点之间走。为了防止这个问题导致死循环，我们需要一个 vis[] 数组保证在 DFS 过程中每个点只被访问一次。\n复杂度：$O(n^2m^2)$，在实际使用中，一般跑的比这个快（所以不用太担心复杂度问题）。\n• 特别的，对于单位容量的网络，复杂度为 $O(m * \\min(\\sqrt m, n^{\\frac{2}{3}}))$。\n• 对于二分图匹配问题，复杂度为 $O(m\\sqrt n)$。\n 模版 最大流模版 int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add(u, v, w); } cout \u0026lt;\u0026lt; maxflow() \u0026lt;\u0026lt; endl; }   费用流模版 struct Edge { int to, nxt; ll w, c; }; struct MCMF { int n,m,s,t; Edge edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 ll cost = 0; void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll mcmf(bool mincost = true) { ll maxflow = 0; while (spfa(mincost)) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } void clear() { ecnt = 2; memset(head, 0, sizeof(head)); memset(cur, 0, sizeof(cur)); memset(edges, 0, sizeof(edges)); cost = 0; } } flow; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w,c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; c; flow.add(u,v,w,c); } ll maxflow = flow.mcmf(true); // 最小费用流，返回最大流 cout \u0026lt;\u0026lt; maxflow \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; flow.cost \u0026lt;\u0026lt; endl; }   性质 最小割的可行边和必要边 最小割是一个 set of edges，使得割掉这些 edges 将原图一分为二，并且这些 edges 的容量之和最小。\n如何判断哪些边是 必要边（指这条边存在于 所有最小割 中），哪些是可行边（指这条边存在于 至少一个最小割 中）？\n可行边：\n一条边 $(u,v)$ 是可行边当且仅当：\n 必须满流 在残量网络中，$u$ 不存在到达 $v$ 的路径。（等价于 $3$） 在残量网络中，$u,v$ 不在同一个强连通分量中。  证明：\n 根据最小割和最大流的关系，一个边存在于一个最小割中 $\\iff$ 这个边满流。 如果存在 $u$ 到 $v$ 的路径，那么由于残量网络中一定有 $(v,u)$ 这条边（反向边），所以可以退流，通过 $u \\rightarrow v$ 的另外一条路径来走，所以 $(u,v)$ 在一个新的最大流方案中就不再满流了，于是不可能是可行边。 由 $2$，由于 $(v,u)$ 一定存在，所以存在 $u \\rightarrow v$ 的路径 $\\iff$ $u,v$ 在同一个强联通分量中。  必要边：\n一条边 $(u,v)$ 是可行边当且仅当：\n 必须满流 在残量网络中，存在 $s \\rightarrow u$ 的路径，和 $v \\rightarrow t$ 的路径。（等价于 $3$） 在残量网络中，$s,u$ 在同一个强联通分量中，且 $v,t$ 在同一个强联通分量中。  证明：\n  同上\n  考虑最小割的构造方案：我们先跑一发最大流，此时残量网络中不存在 $s \\rightarrow t$ 的路径，然后从 $s$ 开始跑一次 bfs，所有能被 $s$ 访问到的点作为集合 $S$，而剩下的作为集合 $T$，$S \\rightarrow T$ 的边就是最小割了。\n所以如果存在 $s \\rightarrow u$ 的路径，和 $v \\rightarrow t$ 的路径，那么这条边一定是 $S \\rightarrow T$ 的边，意味着如果删掉它，那么最大流的值就会减小，这也意味着它是一个必要边。\n  由于是残量网络，在跑最大流的过程中，一定跑了一条增广路 $s \\rightarrow u \\rightarrow v \\rightarrow t$，这意味着在残量网络中一定有一条 $u \\rightarrow s$ 的路径，同理有一条 $t \\rightarrow v$ 的路径。\n所以 $s,u$ 在同一个强联通分量中，且 $v,t$ 在同一个强联通分量中 $\\iff$ 存在 $s \\rightarrow u$ 的路径，和 $v \\rightarrow t$ 的路径。\n  所以判断可行边和必要边，只要在残量网络上跑一个tarjan处理scc即可。\n• 这也意味着，判断一个最大流/最小割是否是unique的，只要在残量网络上，从 $s$ 出发，然后从 $t$ 出发，看所有的点是否都被访问过即可（这也等价于所有可行边都是必要边）。\n最小割边数的最小割 参考链接\n要在基于最小割的基础上，求出最小割边数。\n于是我们可以先跑一个最大流，跑出所有可能的满流边，问题就转变成 最少割掉多少个满流边，使得 $s$ 无法到达 $t$？\n所以本质上相当于只考虑满流边，权值赋为1，重新跑一次最小割。\n• 实际代码：对于所有未满流边，权值赋为 inf，所有满流边，正向边容量 $+1$，所有反向边都不用动，然后再跑一次最大流即可。\n代码 int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add(u, v, w); } maxflow(); for (int e = 2; e \u0026lt; ecnt; e += 2) { if (edges[e].w == 0) { edges[e].w++; } else { edges[e].w = 1e9; } } cout \u0026lt;\u0026lt; maxflow() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; clearall(); } }   套路 二元决策（最小割模型） 有一类问题：有 $n$ 个元素，每个元素要么放入集合 $A$，要么放入集合 $B$，放入集合 $A,B$ 会产生不同的收益，同时可能还会有 相邻 的元素 / 特定的一些元素组合 在同一个集合/不同集合中，就产生额外的收益。求最大/最小的收益。\n一般套路为：对于每个元素 $u$，连 $(s,u), (u,t)$ 的边。\n例如我们用 $s$ 表示集合 $A$，用 $t$ 表示 $B$。哪条边 被保留下来了，就代表选择了这个元素 $u$ 被放入了哪个集合。\n在最小割中，要么 $(s,u)$ 被割掉，要么 $(u,t)$ 被割掉，这说明每个元素最终只会被放入其中的一个集合。\n 对于 特定元素组合 产生的额外收益，举个例子：\n比如 $u,v$ 都放入集合 $A$ (与 $s$ 相连) 就会产生额外收益 $k$ 的话。就创造一个额外的节点 $x$，连接有向边 $(x,u), (x,v), (s,x)$，其中令 $(x,u), (x,v)$ 的流量为 $inf$，而令 $(s,x)$ 的流量为 $k$。\n解释：流量为 $inf$ 的边代表在最小割中一定不会被割去，而如果 $u,v$ 之间，有任何一个元素 没有被放入集合 $A$，那么它就一定会与 $t$ 相连，此时，为了保证图不联通，在最小割中，就一定会割掉 $(s,x)$ 这条边，所以就损失了 $k$ 的收益。\n区间覆盖模型（不等式模型） 给定多种区间，每种区间可以使用一定次数，每次使用有一个代价 cost，在一条直线上，有一些点我们需要覆盖多次。求最小的 cost 使得这些覆盖条件被满足？\n我们以直线上，每个点作为一个节点。\n对于一个区间 $[a,b]$，使用次数限制为 $w$，代价为 $c$。\n则：由 $a$ 对应的节点 $u$，连一条边到 $b$ 对应的节点 $v$，容量为 $w$（代表这个区间可以被选择 $w$ 次），代价为 $c$。\n 怎么满足/限制 直线上每个点，被覆盖的次数呢？\n直觉上说，由每个节点连边到 $t$。但是这样不对，因为这里的区间是 强制覆盖 $[a,b]$，并不能覆盖一半的。\n 正确的方法是：将所有的点，连边连成一条直线。相当于，原本直线上每个点对应一个节点，现在我们把这些节点按照它们原来的方式连边。\n如果第 $i$ 个点，需要被覆盖 $a_i$ 次，那么就连一条边 $(i,i+1,-a_i,0)$（流量为负数，实现中，可以使用 $inf - a_i$ 来代替），代表这里少了 $a_i$ 个点。\n如何保证这些点一定被覆盖了呢？用最大流来限制即可。\n由 $s$ 向 $1$ 连接容量为 $inf$ 的边，cost 为 0；由 $n$ 向 $t$ 连接容量为 $inf$ 的边，cost 为 0。\n费用流保证最大流的过程中，就会保证每个点被覆盖了相应的次数。\n 网络流例题 例1 洛谷P4016 负载平衡问题 题意\n有 $n$ 个环形排列的仓库，给定每个仓库初始的储存量 $a_i$。\n我们只能在相邻的仓库之间搬运。\n求最少的搬运量，使得 $n$ 个仓库的库存数量相同。（保证储存量的平均数是一个整数）。\n其中，$1 \\leq n \\leq 100$。\n 题解（贪心） 正解实际上是 $O(n\\log n)$ 的贪心，一个标准的均分纸牌问题。（加强版的在这：洛谷P2512 HAOI2008 糖果传递）。\n设第 $i$ 个人 向右传递 了 $x_i$。注意到这里 $x_i$ 可正可负可零。\n则目标是求 $\\min \\{ |x_1| + |x_2| + \u0026hellip; + |x_n|\\}$。\n因为最后每个人都获得了 $a$（$a$ 就是平均数）。\n则有：$a_1 + x_1 - x_2 = a, a_2 + x_2 - x_3 = a$，以此类推。\n进行代换，可得：\n$$x_2 = x_1 - (a-a_1)$$ $$x_3 = x_1 - (2a-a_1-a_2)$$ $$x_4 = x_1 - (3a-a_1-a_2-a_3)$$ $$\u0026hellip;$$ $$x_n = x_1 - ((n-1)a - a_1 - a_2 - \u0026hellip; - a_{n-1})$$\n所以就只剩下一个变量 $x_1$ 了。\n因为 $x_1$ 的值可以随便选，由上面的表达式可以看出，这相当于在一个直线上，有 $n$ 个点，坐标为：\n$$0,(a-a_1 ),(2a-a_1-a_2 ),(3a-a_1-a_2-a_3 ),…,((n-1)a-a_1-a_2-…-a_{n-1} )$$\n选择直线上一个点，使得它到这 $n$ 个点距离之和最短？很明显，选这些点的中位数即可。\n 题解（网络流） 需要最小化搬运数量。很明显是一个费用流。\n 网络流的常见套路 $1$：创建超级源点 $s$ 和 超级汇点 $t$。\n 对于相邻的节点，我们链接一个双向的边，费用为 $1$，容量无限。\n同时创建超级源点 $s$，超级汇点 $t$，使得：\n$s$ 向每个节点 $i$ 连接一个 费用为 $0$，容量等于 $a_i$ 的边。\n每个节点 $i$ 向汇点 $t$ 连接一个 费用为 $0$，容量等于 $avg$（储存量的平均数）的边。\n答案就是最小费用。\n 网络流代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 105; const int maxm = 5e4+5; int n, s, t, mincost = 0; int arr[maxn]; struct Edge { int to, nxt, w, c; } edges[maxn\u0026lt;\u0026lt;4]; int head[maxn], ecnt = 2, cur[maxn]; void addEdge(int u, int v, int w, int c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } bool inq[maxn]; int dis[maxn]; bool spfa() { fill(dis, dis+maxn, 1e9); memset(inq, 0, sizeof(inq)); memcpy(cur, head, sizeof(head)); queue\u0026lt;int\u0026gt; q; q.push(s); dis[s] = 0; inq[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w, c = edges[e].c; if (w == 0) continue; if (dis[u] + c \u0026lt; dis[to]) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != 1e9; } bool vis[maxn]; int dfs(int u, int in) { if (u == t) return in; vis[u] = 1; int out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to, w = edges[e].w, c = edges[e].c; if (w == 0 || vis[to] || dis[u] + c != dis[to]) continue; int res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e9; return out; } int mcmf() { int maxflow = 0; while (spfa()) { memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis int res = dfs(s, 1e9); maxflow += res; mincost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } int main() { fastio; cin \u0026gt;\u0026gt; n; int sum = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; sum /= n; s = n+1, t = n+2; for (int i = 1; i \u0026lt;= n; i++) { addEdge(s, i, arr[i], 0); addEdge(i, s, 0, 0); addEdge(i, t, sum, 0); addEdge(t, i, 0, 0); if (i != n) { addEdge(i, i+1, 1e9, 1); addEdge(i+1, i, 0, -1); addEdge(i+1, i, 1e9, 1); addEdge(i, i+1, 0, -1); } } addEdge(n, 1, 1e9, 1); addEdge(1, n, 0, -1); addEdge(1, n, 1e9, 1); addEdge(n, 1, 0, -1); mcmf(); cout \u0026lt;\u0026lt; mincost \u0026lt;\u0026lt; endl; }   例2 洛谷P2774 方格取数问题 题意\n给定一个 $n \\times m$ 的方格图，每个方格中有一个正整数。\n要从方格中取数，使任意两个数所在方格没有公共边，求取出的数的最大和。\n其中，$n,m \\leq 100$。\n 题解 首先这题的限制条件是 不能相邻。对于一个方格来说，只有相邻的（最多4个）方格不能被选。\n所以我们应该从 禁止选择 的角度考虑这个问题，也就是说，应该先选择所有的方格，然后删掉那些互斥的部分。\n如果进行建图：每个方格都是一个 点，然后按照互斥条件进行 连边。\n可以发现，如果我们把这个方格图进行 二分图染色，一定有一个合理的方案。保证相邻的方格颜色不同即可。\n如果对方格图进行染色，建图后，就可以得到一张 二分图。\n 二分图有什么用呢？\n我们最终的目标是使得 整张图中不存在互斥情况，并且 使得删掉的那些方格权值和最小。\n那么我们建立超级源点 $s$，汇点 $t$，然后将 $s$ 连向所有的左侧点（容量为对应点的权值），所有的右侧点连向 $t$（容量为对应点的权值），我们可以发现：\n $s \\rightarrow u$ 代表节点 $u$ 被选择了。 $v \\rightarrow t$ 代表节点 $v$ 被选择了。 如果整张图是 连通的，说明仍然存在互斥情况。  所以我们要 使得删掉的那些方格权值和最小，只要保证删掉的边的权值和最小，使得整张图不连通即可。\n求这张图的 最小割 即可。答案就是 所有权值的和 减去 最小割。\n 总结一下这题：\n 互斥的点 的颜色一定不同，使得我们可以转化为 二分图模型。 互斥的点之间连边，代表了互斥关系。 图的连通性代表了是否消除了所有的互斥条件。   参考链接：https://www.luogu.com.cn/problem/solution/P2774\n另外一道几乎一样的例题是 骑士共存问题。\n题意大概是在一个 $n \\times n$ 的棋盘上，有些格子不能放，问最多能放几个马，使得它们互相不会攻击。\n我们会发现按照 横坐标 $x$ 和 纵坐标 $y$ 之和 $(x+y)$ 的奇偶性进行染色分类，仍然是个二分图，剩下的就和本题一样了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 4e4+5; int vid[102][102], color[maxn]; ll val[102][102]; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } int delta[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int id = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; val[i][j]; vid[i][j] = ++id; if ((i+j) \u0026amp; 1) color[id] = 1; else color[id] = 0; } } s = n*m+1, t = n*m+2; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { int ID = vid[i][j]; ans += val[i][j]; if (color[ID] == 1) { add(s, ID, val[i][j]); for (int d = 0; d \u0026lt; 4; d++) { int di = delta[d][0] + i, dj = delta[d][1] + j; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= m) { add(ID, vid[di][dj], 1e18); } } } else { add(ID, t, val[i][j]); } } } while (bfs()) { ans -= dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P1251 餐巾计划问题 题意\n总共有 $N$ 天，第 $i$ 天需要 $r_i$ 个干净的餐巾。每天结束时，餐厅需要决定如何处理脏餐巾，有以下几个选项：\n 不处理，留到之后再洗。 送去快洗部，洗一块需要 $m$ 天，费用为 $f$ 元。 送去慢洗部，洗一块需要 $n$ 天，费用为 $s$ 元。  同样，餐厅在每天开始/结束时，可以选择购买新的餐巾，每块新餐巾的费用为 $p$ 元。\n求出最少花费，使得每天需要的餐巾数满足要求，初始情况下，餐巾数为 $0$。\n其中，$N \\leq 2000$。\n 题解  网络流的常见套路 $2$：拆点\n 一个比较明显的费用流思路：\n将每一天看作一个节点，然后每个节点拆成 $2$ 个，分别表示 干净餐巾 和 脏餐巾。\n换个角度来看，就是将每个节点拆成了 每天的开始（需要提供干净餐巾） 和 每天的结束（产出了一些脏餐巾）。\n我们设：第 $i$ 天的节点分别为 $s_i, e_i$ （对应干净，脏）。\n那么对于脏餐巾的处理，我们可以这样连边：\n 不处理，留到之后再洗：从 $t_i$ 连边到 $t_{i+1}$，费用为 $0$，容量为 $\\inf$。 送到快洗部（洗一块需要 $m$ 天，费用为 $f$ 元）：从 $t_i$ 连边到 $s_{i+m}$，费用为 $f$，容量为 $\\inf$。 送去慢洗部（洗一块需要 $n$ 天，费用为 $s$ 元）：从 $t_i$ 连边到 $s_{i+n}$，费用为 $s$，容量为 $\\inf$。  剩下的问题是：购买新餐巾，每天需要提供 $r_i$ 个干净餐巾，每天需要让 $r_i$ 个干净餐巾变成脏的。\n购买新餐巾（一条 $P$ 元）：源点 $s$ 向每个 $i$ 对应的 $s_i$ 连一条边，费用为 $P$，容量为 $\\inf$。 每天需要提供 $r_i$ 个干净餐巾：从每个 $i$ 对应的 $s_i$ 向汇点 $t$ 连一条边，费用为 $0$，容量为 $r_i$。 每天需要让 $r_i$ 个干净餐巾变成脏的：源点 $s$ 向每个 $i$ 对应的 $t_i$ 连一条边，费用为 $0$，容量为 $r_i$。  • 这里重点讲一下 $5,6$：我们如何强制保证干净餐巾够用呢？\n注意到我们求的是最小费用 最大流。所以通过 限制流量 来保证干净餐巾的数量，也就是让每天的干净节点 $s_i$ 都流向汇点 $t$。\n但是如果干净餐巾流向了 $t$，就必须保证从 $s$ 开始有脏餐巾流向 $t_i$，才能保证流量守恒（不买餐巾的情况下，餐巾的总数守恒）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4005; const int maxm = 5e4+5; int n,s,t,arr[maxn]; struct Edge { int to, nxt; ll w, c; } edges[maxn\u0026lt;\u0026lt;4]; int head[maxn], ecnt = 2, cur[maxn]; void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } queue\u0026lt;int\u0026gt; q; ll dis[maxn]; bool inq[maxn]; bool spfa() { memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, 1e18); memcpy(cur, head, sizeof(head)); dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if (dis[u] + c \u0026lt; dis[to]) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != 1e18; } bool vis[maxn]; ll dfs(int u, ll in) { if (u == t) return in; vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0 || vis[to] || dis[to] != dis[u] + c) continue; ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll mincost = 0; ll mcmf() { ll maxflow = 0; while (spfa()) { memset(vis, 0, sizeof(vis)); ll res = dfs(s, 1e18); maxflow += res; mincost += res * dis[t]; } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } int main() { fastio; cin \u0026gt;\u0026gt; n; ll sum = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; ll P,M,F,N,S; cin \u0026gt;\u0026gt; P \u0026gt;\u0026gt; M \u0026gt;\u0026gt; F \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; s = 2*n + 1, t = 2*n+2; for (int i = 1; i \u0026lt;= n; i++) { add(s, i, 1e18, P); add(i, t, arr[i], 0); add(s, i+n, arr[i], 0); if (i != n) { add(i+n, i+n+1, 1e18, 0); } if (i + M \u0026lt;= n) { add(i+n, i+M, 1e18, F); } if (i + N \u0026lt;= n) { add(i+n, i+N, 1e18, S); } } ll ans = mcmf(); assert(ans == sum); cout \u0026lt;\u0026lt; mincost \u0026lt;\u0026lt; endl; }   例4 洛谷P2764 最小路径覆盖问题 题意\n给定一个 DAG（有向无环图），$n$ 个节点，$m$ 条边。\n定义一个路径覆盖为：由多个简单路径组成，覆盖了所有节点，并且每个节点被覆盖了仅一次，一条路径最短可以仅为一个节点。\n求这个 DAG 的最小路径覆盖（路径数量最小）。\n其中，$1 \\leq n \\leq 150, 1 \\leq m \\leq 6000$。\n 题解 我们考虑一下怎么让 路径数量 最小？\n初始状态下，令每一个节点本身都是一条路径，那么我们可以让路径合并，合并的方式就是 一个路径的尾部 和 另外一个路径的头部 连在一起。最后的总路径条数就等于 $n$ 减去合并的次数。\n而每个节点可以作为一个路径的头部，也可以作为一个路径的尾部，且每个节点在路径合并的过程中，最多只能成为一次头部/尾部。\n那我们就进行 拆点。\n将每个节点 $u$ 拆成 $2$ 种，一种是 尾部 $u_1$，一种是 头部 $u_2$。如果 $u \\rightarrow v$ 在 DAG 中是一条边，那么就在新图中，连一条 $u_1 \\rightarrow v_2$ 的边。\n可以发现，这个新图是一个二分图，其最大匹配就是合并路径的次数。\n所以答案就是 $n$ 减去最大匹配。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 155; const int maxm = 6e4+5; int n,m,head[maxn\u0026lt;\u0026lt;1], ecnt = 1, match[maxn\u0026lt;\u0026lt;1], vis[maxn\u0026lt;\u0026lt;1], visid = 0; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } bool dfs(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to] == visid) continue; vis[to] = visid; if (!match[to] || dfs(match[to])) { match[to] = u; return 1; } } return 0; } int from[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v+n); } int ans = n; for (int i = 1; i \u0026lt;= n; i++) { visid++; ans -= dfs(i); } // 处理答案 for (int i = n+1; i \u0026lt;= 2*n; i++) { if (match[i]) from[match[i]] = i-n; } for (int i = n+1; i \u0026lt;= 2*n; i++) { if (!match[i]) { int j = i-n; while (j) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot; \u0026quot;; j = from[j]; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   可相交最小路径覆盖\n注意到，上面说的是不相交的最小路径覆盖。\n对于可相交的最小路径覆盖，我们可以考虑重新建一张图，如果对于所有的 $u,v$，$u$ 能够到达 $v$，那么在新图中建 $u \\rightarrow v$ 这条边。\n然后在新图跑一个最小路径覆盖即可。\n• 对于每一个 $u$ 都跑一个 bfs 就可以得到它能够到达的所有 $v$ 了。\n 例5 洛谷P2766 最长不下降子序列问题 题意\n给定一个正整数序列 $x_1, x_2, \u0026hellip;, x_n$。\n 计算最长不下降子序列（不需要连续）的长度 $s$。 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。 如果允许在取出的序列中多次使用 $x_1, x_n$，（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个 不同的 长度为 $s$ 的不下降子序列。  其中，$1 \\leq n \\leq 500$。\n 题解 第一个问题是标准的 $O(n^2)$ DP。\n第二问和第三问要用到网络流。\n我们如何得到一个合法的子序列？这里利用到了 分层图 思想。\n我们先求出，对于每一个 index $i$，以index $i$ 结尾的最长不下降子序列的长度，设其为 $f_i$。\n那么如果一个子序列合法，子序列中的每个元素 $f_{i_1}$，和它下一个元素 $f_{i_2}$ 的关系一定是 $f_{i_1} + 1 = f_{i_2}$。\n所以我们按照 $f_i$ 的值进行分层，只有 $f_i = x$ 的节点可以连向 $f_j = x+1$ 的节点。\n我们要求最长的子序列，那么就让源点 $s$ 连边到 $u$（$f_u = 1$）。让 $v$ 连边到 $t$（$f_v = s$）。求一个最大流就是答案了。\n 现在考虑第二问：每个元素只允许使用一次。我们发现之前的建图就已经足够了，跑最大流即可。\n第三问：$x_1, x_n$ 允许使用多次。我们可以通过控制 流量 来控制这个变量。\n 如何控制一个节点的入流量和出流量？拆点！\n 将每个节点 $u$ 拆成两个节点，分别代表入点 $u_{in}$ 和 出点 $u_{out}$。\n所有原先 进入 $u$ 的边，现在都改为 进入 $u_{in}$，\n所有原先 离开 $u$ 的边，现在都改为 离开 $u_{out}$。\n连一条边 $u_{in} \\rightarrow u_{out}$。这一条边的流量，就代表了这个节点 $u$ 被限制的入流量和出流量。\n 综上，第二问和第三问的模型都可以拆点，只不过第二问对于每一个节点 $u$，限制的流量均为 $1$。\n而第三问中，对于节点 $1,n$，不限制流量（即 $in, out$ 中间这条边的流量为 $\\inf$）。\n参考链接：https://oi-wiki.org/graph/node/\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; const int maxm = 2e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } int arr[maxn], dp[maxn], len = 0; void solve1() { if (len == 1) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return; } // subtask 1 for (int i = 1; i \u0026lt;= n; i++) { if (dp[i] == 1) add(s, i, 1e18); add(i, i+n, 1); if (dp[i] == len) add(i+n, t, 1e18); for (int j = i+1; j \u0026lt;= n; j++) { if (dp[j] == dp[i] + 1) add(i+n, j, 1); } } ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void solve2() { // subtask 2 if (len == 1) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return; } ecnt = 2; memset(head, 0, sizeof(head)); for (int i = 1; i \u0026lt;= n; i++) { if (dp[i] == 1) add(s, i, 1e18); if (i == 1 || i == n) add(i, i+n, 1e18); else add(i, i+n, 1); if (dp[i] == len) add(i+n, t, 1e18); for (int j = i+1; j \u0026lt;= n; j++) { if (arr[j] \u0026gt;= arr[i] \u0026amp;\u0026amp; dp[j] == dp[i] + 1) add(i+n, j, 1); } } ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void build() { for (int i = 1; i \u0026lt;= n; i++) { dp[i] = 1; for (int j = i-1; j \u0026gt;= 1; j--) { if (arr[j] \u0026lt;= arr[i]) { dp[i] = max(dp[i], dp[j] + 1); } } len = max(len, dp[i]); } cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; s = 2*n+1, t = 2*n+2; solve1(); solve2(); } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; build(); }   例6 洛谷P1646 Happiness 题意\n给定一个 $n \\times m$ 的座位表，每个同学要选择理科或者文科，每个人选择理科时，会获得喜悦值 $a_{ij}$，选择文科时会获得喜悦值 $b_{ij}$。\n位于 $(i,j)$ 的同学，如果和 $(i+1, j)$ 的同学同时选择了理科，会获得额外 $c_{ij}$ 的喜悦值，如果同时选择文科，会获得 $d_{ij}$ 的喜悦值。\n位于 $(i,j)$ 的同学，如果和 $(i, j+1)$ 的同学同时选择了理科，会获得额外 $e_{ij}$ 的喜悦值，如果同时选择文科，会获得 $f_{ij}$ 的喜悦值。\n求喜悦值的最大和。\n其中，$n,m \\leq 100$。\n 题解 最小割的二元选择模型。\n首先每个同学是一个节点 $u$，然后连接 $(s,u,a), (u,t,b)$。\n然后对于两个相邻的同学，创造一个新的节点 $x$，连接 $(s,x,c), (x,u,inf), (x,v,inf)$。（其中 $c$ 代表同时选择文科的额外喜悦值），再创造一个节点 $y$，连接 $(y,t,d), (u,y,inf), (v,y,inf)$\n上面已经解释过了，意思就是只要两个人中，任何一个人选了文，则 理理 的额外收益就没了（被割掉）。任何一个人选了理，则 文文 的额外收益就没了（被割掉）。由此建图即可。\n注意，我们计算的是 最小割，意思是 损失的最小收益，所以最终的答案（最大收益）应该是由 所有可能获得的收益 减去 最小割。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 7e4+5; const int maxm = 5e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int a[103][103], b[103][103]; int N = 0, id[103][103]; ll sum = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = 5*n*m+1, t = s+1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j], id[i][j] = ++N; add(s, N, a[i][j]); sum += a[i][j]; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; b[i][j]; add(id[i][j], t, b[i][j]); sum += b[i][j]; } } for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 1; j \u0026lt;= m; j++) { int aa; cin \u0026gt;\u0026gt; aa; // 文文 add(s, ++N, aa); add(N, id[i][j], 1e9); add(N, id[i+1][j], 1e9); sum += aa; } } for (int i = 1; i \u0026lt;= n-1; i++) { for (int j = 1; j \u0026lt;= m; j++) { int bb; cin \u0026gt;\u0026gt; bb; // 理理 add(++N, t, bb); add(id[i][j], N, 1e9); add(id[i+1][j], N, 1e9); sum += bb; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m-1; j++) { int aa; cin \u0026gt;\u0026gt; aa; add(s, ++N, aa); add(N, id[i][j], 1e9); add(N, id[i][j+1], 1e9); sum += aa; } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m-1; j++) { int bb; cin \u0026gt;\u0026gt; bb; // 理理 add(++N, t, bb); add(id[i][j], N, 1e9); add(id[i][j+1], N, 1e9); sum += bb; } } cout \u0026lt;\u0026lt; sum - maxflow() \u0026lt;\u0026lt; endl; }   例7 CF1404E Bricks 题意\n给定一个 $n \\times m$ 的网格，每个格子要么为黑，要么为白。\n定义一个 brick 为：一个长方形，要么长度为 $1$，宽度任意；要么宽度为 $1$，长度任意。\n我们需要用 brick 来覆盖所有的黑色格子，要求不能覆盖到白色格子上，并且一个黑格子只能被覆盖一次。\n求最少的 brick 数量？\n其中，$1 \\leq n,m \\leq 200$，保证至少有一个黑格子。\n 题解 一个 brick 可以横着摆，也可以纵着摆。\n所以，每个黑格子要么被一个 横brick 覆盖，要么被一个 纵brick 覆盖。\n如果被 横brick 覆盖，就相当于给这个格子填上 $1$。被 纵brick 覆盖就相当于给这个格子填上 $0$。\n我们会发现，如果在横方向上，有两个连续的 $1$，那么这两个格子就可以合并为一个（相当于只用了一个横brick就覆盖了它们两个），纵向同理。\n问题就转化为，怎么给每个格子填上 $0/1$，使得这种合并的发生次数最多。\n让合并的发生次数最多，实际上就和上一题一样了。就是定义两个相邻的格子，同时选0/1时，可以获得一些额外收益，这个收益就是合并次数。\n最终的答案就是 黑格子数量 减去 合并发生次数。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 7e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int grid[205][205], id[205][205], N = 0; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int sum = 0; for (int i = 1; i \u0026lt;= n; i++) { string ss; cin \u0026gt;\u0026gt; ss; for (int j = 1; j \u0026lt;= m; j++) { if (ss[j-1] == '#') grid[i][j] = 1, id[i][j] = ++N, sum++; } } int tmp = sum; s = N+1, t = s+1; for (int i = 1; i \u0026lt;= N; i++) { add(s, i, 1); add(i, t, 1); } N += 3; int delta[2][2] = {{1, 0}, {0, 1}}; int inf = 1e9; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (!id[i][j]) continue; for (int o = 0; o \u0026lt; 2; o++) { int di = delta[o][0] + i, dj = delta[o][1] + j; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= m \u0026amp;\u0026amp; id[di][dj]) { if (o == 0) { // 纵向 add(s, ++N, 1); add(N, id[i][j], inf); add(N, id[di][dj], inf); sum++; } else { // 横向 add(++N, t, 1); add(id[i][j], N, inf); add(id[di][dj], N, inf); sum++; } } } } } cout \u0026lt;\u0026lt; tmp - sum + maxflow() \u0026lt;\u0026lt; endl; }   例8 ABC193F Zebraness 题意\n给定 $n \\times n$ 的网格，每个格子要么为黑色，要么为白色，要么没有颜色。\n现在要将所有没有颜色的格子，涂上黑色或者白色。\n求最终情况下，相邻的不同色格子的最大数量。\n其中，$1 \\leq N \\leq 100$。\n 题解 看起来非常像最小割的二元模型，但是有一点不太一样的在于，这里是两个相邻的，不同颜色 的格子才能产生收益。而上面两道例题，都是 相同颜色 的格子才能产生收益。\n这样的话就没法建图了。\n但是我们可以把问题转化一下，成为 相同颜色 的格子才能产生收益。\n怎么做呢？\n把这些格子分为两类，一类是 $x,y$ 坐标加起来为奇数的，另外一类是 $x,y$ 坐标加起来为偶数的。我们把其中一类格子的颜色全部反过来（如果没有颜色就不用动它）。问题就转化成 相同颜色 的格子产生收益了。\n 但是，这题有一些格子是已经固定好颜色了的。假如一个格子已知为白色，那么就不连 $(u,t)$ 这条边即可。并且为了保证这个格子一定选择了白色，我们连 $(s,u,inf)$。\n对于黑色，就连 $(u,t,inf)$。\n对于没有颜色，就连 $(s,u,1), (u,t,1)$。\n然后相邻的格子仍然按照同色的套路来创建新点，连接容量为 $1$ 的边即可。\n 注意到本题，因为一个格子本身选择什么颜色并不提供价值。所以我们要把 总价值 中，通过选择单个格子获得的价值减掉。\n所以原本 一个黑/白 格子提供的价值为 $1$，现在则为 $0$。原本一个 无色 格子提供的价值为 $2$，现在则为 $1$。相邻格子同色带来的价值不变。\n最后用 总价值 减去 最小割 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e4+5; const int maxm = 7e5+5; int n,m,s,t; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 struct Edge { int to, nxt; ll w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } int dis[maxn]; bool bfs() { queue\u0026lt;int\u0026gt; q; memset(dis, -1, sizeof(dis)); memcpy(cur, head, sizeof(head)); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (dis[to] \u0026gt;= 0 || w == 0) continue; // visited 或者 edge 已经不存在 dis[to] = dis[u] + 1; q.push(to); if (to == t) return 1; // 仍然存在增广路，直接返回 } } return 0; } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w; if (dis[to] != dis[u] + 1 || w == 0) continue; // 不是下一层 或者 edge已经不存在 // 否则，可以往外运输流量 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; // 如果已经没有可以向外流的了，直接 break } if (out == 0) dis[u] = -1; // 说明当前节点已经不能向外运输流量了，忽略不计 return out; } void add(int u, int v, ll w) { addEdge(u, v, w); addEdge(v, u, 0); } ll maxflow() { ll ans = 0; while (bfs()) { ans += dfs(s, 1e18); } return ans; } int arr[102][102]; int vid[102][102], vidcnt = 0; int main() { fastio; cin \u0026gt;\u0026gt; n; int N = n*n; s = 5*N+1, t = 5*N+2; for (int i = 1; i \u0026lt;= n; i++) { string SS; cin \u0026gt;\u0026gt; SS; for (int j = 1; j \u0026lt;= n; j++) { if (SS[j-1] == 'W') arr[i][j] = 0; if (SS[j-1] == 'B') arr[i][j] = 1; if (SS[j-1] == '?') arr[i][j] = -1; if (((i+j)\u0026amp;1) \u0026amp;\u0026amp; arr[i][j] \u0026gt;= 0) arr[i][j] ^= 1; vid[i][j] = ++vidcnt; } } int delta[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; ll ans = 0; int inf = 1e9; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int id = vid[i][j]; if (arr[i][j] == 0) { add(s, id, inf); } if (arr[i][j] == 1) { add(id, t, inf); } if (arr[i][j] == -1) { add(s, id, 1), add(id, t, 1); ans++; } for (int o = 0; o \u0026lt; 2; o++) { int di = i + delta[o][0], dj = j + delta[o][1]; if (di \u0026gt;= 1 \u0026amp;\u0026amp; di \u0026lt;= n \u0026amp;\u0026amp; dj \u0026gt;= 1 \u0026amp;\u0026amp; dj \u0026lt;= n) { int did = vid[di][dj]; add(s, ++vidcnt, 1); add(vidcnt, id, inf); add(vidcnt, did, inf); ans++; add(++vidcnt, t, 1); add(id, vidcnt, inf); add(did, vidcnt, inf); ans++; } } } } ans -= maxflow(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例9 [NOI2008] 志愿者招募 题意\n有 $n$ 天，每天需要 $a_i$ 个人。我们有 $m$ 种人可以招募，第 $i$ 种人会从 第 $s_i$ 天 工作到 第 $t_i$ 天，并且花费 $c_i$ 元。\n求最少费用的方案，满足每天工作的人数？\n其中 $1 \\leq n \\leq 1000, 1 \\leq m \\leq 10000$。\n 题解 区间覆盖模型，上面讲过了。\n连 $(s,1,inf,0), (n+1,t,inf,0)$，同时对于每一个 $i$，连 $(i,i+1,inf-a_i,0)$。\n对于每种工人，连 $(s_i, t_i + 1, inf, c_i)$。\n跑最小费用最大流即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 5e4+5; int n,m,s,t; struct Edge { int to, nxt; ll w, c; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost = true) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll cost = 0; ll mcmf() { ll maxflow = 0; while (spfa()) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = n+2, t = n+3; ll inf = 4e9; add(s, 1, inf, 0); for (int i = 1; i \u0026lt;= n; i++) { ll a; cin \u0026gt;\u0026gt; a; add(i, i+1, inf-a, 0); } add(n+1, t, inf, 0); while (m--) { int l,r,c; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; add(l, r+1, inf, c); } ll maxflow = mcmf(); cout \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; endl; }   例10 洛谷P3358 最长k可重区间集问题 题意\n给定 $n$ 个左闭右开的区间，请选出一些区间，使得直线上任意一点，被覆盖的次数不超过 $k$ 次。\n求这些区间的长度之和的最大值。\n其中，$1 \\leq n \\leq 500, 1\\leq k \\leq 3$，保证每个区间的左右端点为整数，且长度大于等于 $1$。\n 题解 由于区间左右端点可能会有很大的值，甚至负数，所以第一步肯定是离散化。\n如何限定被覆盖的次数不超过 $k$ 次？\n我们只要限制 流量 最多为 $k$ 即可。\n对于区间，仍然是和上面一样的套路。\n 所以建图：\n离散化出直线上的关键点，将它们作为节点，编号为 $1, 2, \u0026hellip;, N$。\n对于 $\\forall i \\in [1,N-1]$，连 $(i,i+1,inf,0)$。\n同时连 $(s,1,k,0), (N,t,k,0)$。\n对于每个区间 $[l,r]$，连接 $(a_l, a_r, 1, r-l)$，其中 $a_l$ 就是 $l$ 在离散化之后对应的节点。\n跑一个最大费用最大流即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 5e5+5; int n,m,s,t,k; struct Edge { int to, nxt; ll w, c; } edges[maxm\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, cur[maxn]; // ecnt 从 2 开始，方便取反向边 void addEdge(int u, int v, ll w, ll c) { Edge e = {v, head[u], w, c}; edges[ecnt] = e; head[u] = ecnt++; } ll dis[maxn]; bool inq[maxn], vis[maxn]; bool spfa(bool mincost = true) { queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); // 这里一定要记得清空 vis (dfs要用) memset(inq, 0, sizeof(inq)); fill(dis, dis+maxn, mincost ? 1e18 : -1e18); memcpy(cur, head, sizeof(head)); // 当前弧优化用到的数组 cur dis[s] = 0; inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (w == 0) continue; if ((mincost \u0026amp;\u0026amp; dis[u] + c \u0026lt; dis[to]) || (!mincost \u0026amp;\u0026amp; dis[u] + c \u0026gt; dis[to])) { dis[to] = dis[u] + c; if (!inq[to]) { inq[to] = 1; q.push(to); } } } } return dis[t] != (ll)(mincost ? 1e18 : -1e18); } ll dfs(int u, ll in) { if (u == t) return in; // 如果已经运到了终点，直接返回入量 vis[u] = 1; ll out = 0; for (int e = cur[u]; e; e = edges[e].nxt) { cur[u] = e; int to = edges[e].to; ll w = edges[e].w, c = edges[e].c; if (vis[to] || w == 0 || dis[to] != dis[u] + c) continue; // 检测: 1. 是否vis过 2. 这条边是否存在 3. 是否是最短路径 ll res = dfs(to, min(in, w)); in -= res; out += res; edges[e].w -= res; edges[e^1].w += res; if (in == 0) break; } if (out == 0) dis[u] = -1e18; return out; } ll cost = 0; ll mcmf() { ll maxflow = 0; while (spfa(false)) { ll res = dfs(s, 1e18); maxflow += res; cost += res * dis[t]; // cost += (流量 * 最短路长度) } return maxflow; } void add(int u, int v, ll w, ll c) { addEdge(u,v,w,c); addEdge(v,u,0,-c); } struct Segment { int l,r; } seg[505]; set\u0026lt;int\u0026gt; bound; map\u0026lt;int, int\u0026gt; mp; // map boundary to index int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; seg[i].l \u0026gt;\u0026gt; seg[i].r; bound.insert(seg[i].l); bound.insert(seg[i].r); } int N = 0; // 线段的数量 for (int a : bound) { mp[a] = ++N; } for (int i = 1; i \u0026lt;= n; i++) { int l = mp[seg[i].l], r = mp[seg[i].r]; add(l, r, 1, seg[i].r - seg[i].l); } s = N+1, t = s+1; for (int i = 1; i \u0026lt;= N; i++) { if (i \u0026lt; N) add(i, i+1, 2e9, 0); } add(s, 1, k, 0); add(N, t, k, 0); ll maxflow = mcmf(); cout \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; endl; }   例11 HDU1853 Cyclic Tour 题意\n给定 $n$ 个点，$m$ 个边的有向图，每个边有边权 $c_i$，求是否存在一些环，使得每个节点被 exactly 一个环使用，并且使得这些环的边权和最小？\n如果不存在，输出 $-1$。\n其中，$n \\leq 100, m \\leq 10^4$。\n 题解 拆点，把每个点拆成入点和出点。\n出点 $u$ 放在左侧，入点 $u+n$ 放在右侧，得到一个二分图。\n对于每一条原图中的边 $(u,v)$ 链接 $(u, v+n, 1, c)$，其中 $c$ 是边权。\n然后链接 $(s, u, 1, 0), (u+n, t, 1, 0)$。\n最后跑最小费用流即可。如果满足答案则最大流 $=n$。\n• 证明：这样保证了每个点的出度和入度均为 $1$，这说明它们一定在一个环上。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int main() { int n, m; while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { for (int i = 1; i \u0026lt;= m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; flow.add(u, v+n, 1, c); } flow.s = 2*n + 1, flow.t = 2*n + 2; for (int i = 1; i \u0026lt;= n; i++) { flow.add(flow.s, i, 1, 0); flow.add(i+n, flow.t, 1, 0); } ll maxflow = flow.mcmf(true); // 最小费用流，返回最大流 if (maxflow != n) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; flow.cost \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } flow.clear(); } }   例12 NAQ2022 J. Room Evacuation 题意\n给定一个 $n \\times m$ 的网格，每个位置要么是 P 代表一个人，E 代表一个出口，# 代表一个障碍物，. 代表一个空地。\n现在给定 $T$ 秒，每一秒，所有人都可以往相邻的格子移动一格，但任意时间，同一个格子上只能站一个人。\n如果一个人来到了一个出口，那么他就安全了，并且在下一秒将会消失在网格中。出口也只能同时站一个人。\n求在规定的 $T$ 秒内，最多有多少个人能安全？\n其中，$n,m \\leq 20, 1\\leq T \\leq 200$。\n 题解 一看数据范围就知道是网络流，并且 $T \\leq 200$，为了限制每一秒，一个格子上只能站一个人，我们将图拆成 $T$ 层（复制 $T$ 份），像 $\\forall i, t=i$ 连边到 $t=i+1$ 的。\n然后 $s$ 向所有 $T=0$ 的 P 连边，所有的 $T=0,1,\u0026hellip;$ 的 E 向 $t$ 连边，所有边的容量为 $1$，然后相邻位置 $t=i$ 连边到 $t=i+1$ 的。\n• 然后需要注意，每个点需要限制流量为 $1$，这是防止多个点通过同一个点走到其他位置，一个经典例子是\n#E#\nPPE\n#P#\n限制流量的方法就是拆点，拆为 in, out。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int id[22][22], cid = 0; vector\u0026lt;int\u0026gt; pe, ex; int d[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; int in_id(int x) { return x; } int out_id(int x) { return x + (T+2) * n * m; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= n; i++) { string ss; cin \u0026gt;\u0026gt; ss; for (int j = 1; j \u0026lt;= m; j++) { grid[i][j] = ss[j-1]; if (grid[i][j] != '#') { id[i][j] = ++cid; } if (grid[i][j] == 'P') { pe.push_back(id[i][j]); } if (grid[i][j] == 'E') { ex.push_back(id[i][j]); } } } s = maxn-5, t = maxn-4; for (int tt = 0; tt \u0026lt; T; tt++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (!id[i][j]) continue; int id1 = id[i][j] + tt * n * m; for (int o = 0; o \u0026lt; 4; o++) { int ni = i + d[o][0], nj = j + d[o][1]; if (ni \u0026gt;= 1 \u0026amp;\u0026amp; ni \u0026lt;= n \u0026amp;\u0026amp; nj \u0026gt;= 1 \u0026amp;\u0026amp; nj \u0026lt;= m \u0026amp;\u0026amp; grid[ni][nj] != '#') { int id2 = id[ni][nj] + (tt+1) * n * m; // if (grid[ni][nj] != 'E') // assert(id1 \u0026lt;= id2); add(out_id(id1), in_id(id2), 1); // add(id1, id2, 1); } } if (tt == 0 \u0026amp;\u0026amp; grid[i][j] == 'P') { add(s, in_id(id1), 1); } if (grid[i][j] == 'E') { add(out_id(id1), t, 1); } add(out_id(id1), in_id(id1+n*m), 1); add(in_id(id1), out_id(id1), 1); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { int id1 = id[i][j] + T * n * m; add(in_id(id1), out_id(id1), 1); if (grid[i][j] == 'E') { add(out_id(id1), t, 1); } } } cout \u0026lt;\u0026lt; maxflow() \u0026lt;\u0026lt; endl; }   例11 洛谷P4126 [AHOI2009]最小割 题意\n给一张有向图和 $s,t$，对每一条边回答它是否为可行边，是否为必要边。\n 题解 上面解释了，注意判断的时候判断 “满流与否”。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // 网络流部分省略 int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { if (!edges[e].w) continue; // 残量网络 int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; } tail--; in[u] = 0; } } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add(u, v, w); } maxflow(); tarjan(); for (int e = 2; e \u0026lt; ecnt; e += 2) { int u = edges[e].from, v = edges[e].to; cout \u0026lt;\u0026lt; (edges[e].w == 0 \u0026amp;\u0026amp; from[u] != from[v]) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; // 判断满流 cout \u0026lt;\u0026lt; (edges[e].w == 0 \u0026amp;\u0026amp; from[u] == from[s] \u0026amp;\u0026amp; from[v] == from[t]) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 判断满流 } }   参考链接  https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic https://www.cnblogs.com/birchtree/p/12912607.html#%E4%B8%80%E4%BA%9B%E8%BF%9E%E8%BE%B9%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93  ","date":"2021-06-04T12:03:44+08:00","permalink":"https://tom0727.github.io/post/047-%E7%BD%91%E7%BB%9C%E6%B5%81/","tags":["网络流","最大流"],"title":"网络流"},{"categories":["算法"],"contents":"二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。\n二分图 - 性质  二分图 $\\iff$ 图中没有奇环（指节点个数为奇数的环） $\\iff$ 可以进行二分图染色  二分图染色 给定一个二分图，我们可以仅用两种颜色将每个节点染上色，并且保证每个 edge 的两端颜色一定不同。\n同理，如果一个图可以进行二分图染色，那么它就是一个二分图（这用于 判断一个图是否为二分图）\n染色的方法：用 DFS 即可。（记得要从每个节点都开始 DFS 一次）\n 随机选择一个点 $u$ 作为出发点，它的颜色为 $c_u = 0$。 看它的 neighbor $v$ 的颜色，如果等于 $c_u$ ^ $1$，或者没染色，就染成 $c_u$ ^ $1$。否则的话产生冲突，说明这不是二分图。  模型转化 网格二分图 一个常见的套路，$n \\times m$ 的矩阵中，某些格子之间有冲突（比如相邻的格子）。我们按照格子 $(i,j)$ 的和 $(i+j)$ 的奇偶性 将格子分为左部分的点和右部分的点，冲突的连边。\n• 在二分图匹配时，一定要分成左右两边的点，并且从左边的点连 单向边 到右边的点。\n例题 例1 CF741C Arpa’s overnight party and Mehrdad’s silent entering 题意\n给定 $n$ 对情侣 $(a_i, b_i)$（$a_i, b_i \\in [1,2n]$），总共有 $2n$ 个人，每个人的编号是从 $1$ 到 $2n$。现在有 $2$ 种食物（$1$ 或者 $2$），求一种分配方式使得：\n 每对情侣 $(a_i, b_i)$ 不能吃同一种食物。 相邻的 $3$ 个编号，食物不能完全相同。（编号是环形的，这意味着 $2n, 1, 2$ 也算是相邻的 $3$ 个人）。  如果无解，输出 $-1$。\n其中，$1 \\leq n \\leq 10^5$。\n 题解 每对情侣 $(a_i, b_i)$ 的食物不同，让我们想到二分图。但是第二个条件怎么办？\n直觉上来说，这个题一定是有解的。\n所以，我们可以做一个特殊的限制，直接强制 $2i-1, 2i$ 的食物不同，这个条件就满足了。\n接下来我们要证明，将第二个限制条件转化以后，仍然有解。\n 对于这个模型建图，将每个人作为一个节点，每对情侣 $(a_i, b_i)$ 作为一条边连起来。然后再将 $(2i-1, 2i)$ 作为一条边连起来。\n那么只要这个图是二分图，就有解。（因为二分图保证了每条边两端的颜色不同）\n如果图中有环，那么必然是由 $x$ 对情侣组成的一个环。所以环的节点数量为 $2x$。所以不可能有奇环。所以这个图是二分图。\n所以建完图以后，跑一个二分图染色即可。\n• 注意，二分图染色的 DFS 要从每一个节点都开始一次。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 1e6; int n; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; int color[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int a[maxn], b[maxn]; bool vis[maxn]; void dfs(int u) { if (vis[u]) return; vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; color[to] = color[u] ^ 1; dfs(to); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i]; addEdge(a[i], b[i]); addEdge(b[i], a[i]); } for (int i = 1; i \u0026lt;= 2*n; i+=2) { addEdge(i, i+1); addEdge(i+1, i); } vis[1] = 1; for (int i = 1; i \u0026lt;= 2*n; i++) dfs(i); for (int i = 1; i \u0026lt;= n; i++) { if (!color[a[i]]) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; if (!color[b[i]]) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 CF553C Love Triangles 题意\n给定 $n$ 个人，每两个人之间，要么互相love，要么互相hate。\n现在已知 $m$ 个关系，每个关系的格式为 $a ~ b ~ c$，代表 $a$ 和 $b$ 互相 love（$c = 1$），或者互相 hate（$c = 0$）。\n请求出，有多少个方案使得整个关系网满足以下条件（答案对 $10^9+7$ 取模）\n 对于任意三个人 $a,b,c$，要么这三个人互相 love，要么 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。\n 其中，$3 \\leq n \\leq 10^5, 0 \\leq m \\leq 10^5$\n 题解 首先我们会发现，love是有传递性的：如果 $a,b$ 互相love，$b,c$ 互相love，那么根据定义，一定有 $a,c$ 互相love。\n所以对于love的关系，我们可以求出一个连通块，使得这个块内每个人互相love，那就可以缩点了。（当然需要注意的是 hate 不具有传递性）。\n于是，我们只需要考虑一下 hate 怎么处理。\n 先放一个结论：\n 如果我们把这个问题考虑为图染色问题，那么两个互相hate，说明颜色不同。而互相love，说明颜色相同。\n如果存在一个合法的染色方式，则说明有解。（本质上是二分图染色，互相love的在同一侧，互相hate的在两侧）\n 证明：存在染色方式 $\\rightarrow$ 有解：\n任取三个节点 $a,b,c$，有两种情况：\n $a,b,c$ 在同一侧，所以满足 $a,b,c$ 互相love。 $a,b$ 在同一侧，$c$ 在另外一侧。这也刚好满足了 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。  证明：有解 $\\rightarrow$ 存在染色方式：\n根据定义染色即可，我们会发现没有冲突情况。\n 方案数怎么计算？\n我们先进行 DFS，求出图中的连通块。\n如果每个连通块内，都没有冲突情况（也就是说，每个连通块都可以做二分图染色）的话，说明有解，否则无解（$ans = 0$）。\n同时我们发现，对于任何一个连通块，我们只要给其中一个节点染上色，这个连通块内的其他所有节点的颜色也都确定了。\n所以我们只需要给每个连通块染色即可。\n设连通块的数量为 $c$，那么答案就是 $2^{c-1}$。\n• 为什么不是 $2^c$？我们只要确定了第一个块的颜色，剩下的 $(c-1)$ 个块随便选颜色。我们答案是否合法，实际上与第一个块的颜色无关。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,m; int head[maxn], ecnt = 1, color[maxn]; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll ans = 1; void dfs(int u) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (color[to] \u0026gt;= 0) { if (color[to] != (color[u] ^ w ^ 1)) ans = 0; } else { color[to] = (color[u] ^ w ^ 1); dfs(to); } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } fill(color, color+maxn, -1); int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (color[i] == -1) { cnt++; color[i] = 0; dfs(i); } } cnt--; for (int i = 1; i \u0026lt;= cnt; i++) { ans = ans * 2LL % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }    二分图匹配 - 定义 一个 匹配 的定义是一个 边集，并且这个边集中，每两个边之间没有共同的顶点。二分图的最大匹配是指 边的数量 最多的一个匹配。\n二分图匹配常用的算法是 匈牙利算法 $O(nm)$，或者 最大流（dinic的复杂度为 $O(\\sqrt n m)$。\n匈牙利算法求最大匹配 匈牙利算法本质上是一个个求增广路（增广路指的是 从左开始，到右结束的路径，其中 左 $\\rightarrow$ 右都是未匹配边，右 $\\rightarrow$ 左都是匹配边）的过程。\n如果我们以男女配对为例子：\n对于每一个男生 $i$（$i$ 在二分图的 左侧点集 中），遍历他每一个心仪的女生 $j$ （$j$ 在二分图的 右侧点集 中）（这说明 $(i,j)$ 是一条边）。那么有两种情况：\n 女生 $j$ 未配对，那么他们两个就配对在一起，match[j] = i。 女生 $j$ 已配对，那么就让女生 $j$ 去问一下她当前的男朋友 match[j]，让她男朋友尝试再换一个新的女朋友（所以就变成一个新的男生尝试配对，那么这就是一个递归的过程）。如果她男朋友成功换掉了女朋友，那么这个男生 $i$ 就可以和 女生 $j$ 配对了。否则 $i$ 就只能单着。  代码片段如下：\nint n, m, adj[maxn][maxn]; int match[maxn], vis[maxn], id = 0; // match[j] 代表女生j 当前的男朋友 i, vis[j] 代表这个女生在当前男生 i 的配对过程中，是否访问过了 bool dfs(int i) { for (int j = 1; j \u0026lt;= m; j++) { if (!adj[i][j] || vis[j] == id) continue; vis[j] = id; if (!match[j] || dfs(match[j])) { match[j] = i; return 1; } } return 0; } int main() { int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { id++; ans += dfs(i); } }  有几个需要注意的点：\n 利用 int vis[] 来代表这个女生 $j$ 在当前男生 $i$ 的配对过程中，是否访问过了。（因为对于每个男生 $i$ 而言，对于每个女生 $j$ 只需要问一次即可）。 利用 id 来记录这是第几次 $dfs(i)$，然后只要判断 $vis[j]$ 是否等于 $id$ 就可以判断，本次 DFS 中是否询问过女生 $j$ 了。（这样就不用每次 DFS 结束都 memset() 一次）。  时间复杂度：每个男生都要询问所有女生，所以是 $O(nm)$（这里 $n$ 代表左边点集的数量，$m$ 代表右边点集）。\n最大匹配，最小点覆盖，最大独立集，最小边覆盖 以下的 $N$ 指所有节点的数量，就是左节点和右节点的数量和。\n最小点覆盖 定义：选择一个最小的点集 $S\\subset V$ 使得每一条边至少有一个端点在 $S$ 中。\n性质：最小点覆盖 $=$ 最大匹配。\n构造方法：从左边的每一个非匹配点（且未打上标记的）出发，沿着非匹配边正向（从左往右）进行遍历，沿着匹配边反向（从右往左）进行遍历。遍历到的所有点进行标记。\n选取左部分中没有被标记过的点，右部分中被标记过的点，则这些点可以形成该二分图的最小点覆盖。\n证明：\n 这个集合的大小等于最大匹配  一条匹配的边两侧一定都有标记（在增广路上）或都没有标记（不在增广路上），如果有标记，右边的点会被算进去，没有标记的话，左边的点会被算进去，无论如何答案等于最大匹配。\n所有边都被覆盖到了  对于匹配边，肯定有一个端点被选中了（理由同上）。对于没有匹配的边，它一定会成为增广路的一部分（如果没有，说明增广路遍历过程尚未结束）。\n它是最小的点覆盖  为了覆盖所有边，不可能比最大匹配更小了，否则违反了最大匹配的定义。\n最大独立集 定义：选择一个最大的点集 $S \\subset V$，使得 $\\forall u,v \\in S$，$(u,v)$ 之间没有边。\n性质：最小点覆盖 $= N -$ 最大匹配。\n构造方法：直接求最小点覆盖，然后取补集即可。\n证明：我们考虑一下每条边 $(u,v)$，根据定义，$u,v$ 中至少有一个在最小点覆盖中，所以 $u,v$ 中最多只能有一个在最小点覆盖的补集中。\n所以最小点覆盖的补集两两之间没有边。\n最小边覆盖 定义：选择一个最小的边集 $A \\subset E$，使得这些边能够覆盖到所有的点。\n性质：最小边覆盖 $= N - $ 最大匹配。\n构造方式：设最大匹配为 $M$。先取所有的匹配边，每次能解决 $2$ 个点。对于剩下的没覆盖的点，随便取它的一条非匹配边来覆盖它。\n证明：根据以上构造，匹配边选了 $M$ 条，非匹配边选了 $N-2M$ 条。总共是 $M + N-2M = N-M$。\n例题 例1 洛谷P1963 NOI2009 变换序列 题意\n给定一个序列 $0,1,\u0026hellip;,N-1$，我们需要求出一个变换序列 $T$，其中 $T$ 是 $0$ 到 $N-1$ 的一个 permutation。\n同时，我们定义任意两个数字 $i,j$ 之间的距离 $D(i,j) = \\min \\{ |i-j|, N-|i-j|\\}$。\n现在给定原序列 和 变换序列 $T$ 之间，每个元素的距离 $D_i$，求出一个字典序最小的变换序列 $T$，如果无解，则输出 \u0026ldquo;No Answer\u0026rdquo;。\n其中，$N \\leq 10^4$。\n 样例：\nInput:\n5 1 1 2 2 1  Output:\n1 2 4 0 3  解释：原序列是 [0,1,2,3,4]，距离序列是 [1,1,2,2,1]，所以最终的变换序列可能是 [0+1, 1+1, 2+2, 3-|5-2|, 4-1] = [1,2,4,0,3]。\n 题解 将 原序列 作为二分图的左部分，变换序列作为二分图右部分。连边的方式就根据 距离序列 来。\n例如原序列的第一个位置是 $0$，对应的距离序列第一个位置是 $1$，所以变换序列对应的值可能是 $1$ 或者 $4$。所以 $0 \\rightarrow 1, 0 \\rightarrow 4$ 连边即可。\n连完边，跑一个最大匹配即可，如果最大匹配的数量等于 $N$ 说明有解，否则无解。\n 最后考虑一下 字典序最小 怎么解决？\n一般来说，看到 字典序最小 就想到 贪心。所以第一个贪心思路是每次匹配的时候都 从小到大 找配对点。\n然而这样有一个问题，比如 $0 \\rightarrow 1$ 以后，有可能因为后续的匹配导致 $0 \\rightarrow 4$。\n所以我们按照编号大小，从后往前进行 DFS 即可。\nfor (int i = n; i \u0026gt;= 1; i--) { // 注意这里是从 n 到 1 id++; dfs(i); }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; int match[maxn], vis[maxn], id = 0, d[maxn], n; set\u0026lt;int\u0026gt; adj[maxn]; bool dfs(int i) { for (int j : adj[i]) { if (vis[j] == id) continue; vis[j] = id; if (!match[j]) { match[j] = i; return 1; } if (dfs(match[j])) { match[j] = i; return 1; } } return 0; } bool ok(int i) { return i \u0026gt;= 1 \u0026amp;\u0026amp; i \u0026lt;= n; } int ans[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; d[i]; for (int i = 1; i \u0026lt;= n; i++) { int j = (i - d[i]); if (ok(j)) adj[i].insert(j); j = (i + d[i]); if (ok(j)) adj[i].insert(j); j = (i + (n - d[i])); if (ok(j)) adj[i].insert(j); j = (i - (n - d[i])); if (ok(j)) adj[i].insert(j); } for (int i = n; i \u0026gt;= 1; i--) { id++; dfs(i); } int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (match[i]) cnt++; } if (cnt \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;No Answer\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { for (int i = 1; i \u0026lt;= n; i++) ans[match[i]] = i; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i]-1 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } }   例2 洛谷 P2825 [HEOI2016/TJOI2016]游戏 题意\n在游戏 \u0026ldquo;泡泡堂\u0026rdquo; 中，给定一个 $n \\times m$ 的网格，其中 * 代表空地，x 代表软石头，# 代表硬石头。\n每个炸弹会影响它所在的行与列。炸弹可以穿透软石头，但是无法穿透硬石头。\n给定一个地图，求最多放置多少个炸弹，使得每两个炸弹之间不会互相炸到？\n 题解 二分图匹配的一个常见套路就是应用在 网格地图 中。\n我们把 每一行 看作一个节点，每一列 也看作一个节点，而每个网格就看作一条边。\n如果我们不考虑硬石头的情况，那么这个题非常简单。把每个空地看作一条边，连起来以后跑一个最大匹配即可。\n但是现在有硬石头。我们会发现一个硬石头可以 隔断纵向的和横向的 炸弹威力。那么，我们把硬石头隔断的部分，也看作是一个节点即可。\n也就是说，现在不再是每一行/每一列作为节点，而是以 横向/纵向 线段 作为单位，每个线段是一个节点。\n现在，每个网格里有 $3$ 种情况：\n 空地：看作一个正常的边 软石头：忽略不计 硬石头：作为分界点，上下是两个不同的线段，左右是两个不同的线段。  图建好了，再跑一个最大匹配即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 55; const int maxm = 2505; int n,m; char arr[maxn][maxn]; vector\u0026lt;int\u0026gt; adj[maxm]; int id, lcnt, rcnt; int l[maxn][maxn], r[maxn][maxn]; int match[maxm], vis[maxm], vis_id; bool dfs(int i) { for (int j : adj[i]) { if (vis[j] == vis_id) continue; vis[j] = vis_id; if (!match[j] || dfs(match[j])) { match[j] = i; return 1; } } return 0; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; arr[i][j]; } } id = 0; for (int i = 1; i \u0026lt;= n; i++) { id++; for (int j = 1; j \u0026lt;= m; j++) { if (arr[i][j] == '#') { id++; continue; } l[i][j] = id; } } lcnt = id; id = 0; for (int j = 1; j \u0026lt;= m; j++) { id++; for (int i = 1; i \u0026lt;= n; i++) { if (arr[i][j] == '#') { id++; continue; } r[i][j] = id; } } rcnt = id; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (arr[i][j] == '*') { adj[l[i][j]].push_back(r[i][j]); } } } int ans = 0; for (int i = 1; i \u0026lt;= lcnt; i++) { vis_id++; ans += dfs(i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-05-30T22:31:30+08:00","permalink":"https://tom0727.github.io/post/046-%E4%BA%8C%E5%88%86%E5%9B%BE/","tags":["二分图","二分图匹配"],"title":"二分图 \u0026 二分图匹配"},{"categories":["算法"],"contents":"介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。\n第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考虑 $u$ 的subtree，求出这样的答案 $dp[u]$。\n第二次DFS：令最终答案为 $ans[u]$，则可知 $ans[1] = dp[1]$。然后我们需要通过已知的 $ans[u]$，来推出它的child $ans[to]$ 的值。一般我们由 $ans[u]$ 来推导 $ans[to]$ 时，需要考虑到换根时 $to$ 子树内的贡献，和子树外的贡献 变化。\n套路 我们考虑一下一种general的情况：从 $u$ 换根到 $v$。\n此时我们一定位于 dfs(u) 中，并且已经求出了 $ans[u]$。现在要求 $ans[v]$。（注：这里的 $ans[u]$ 是广义的，代表 $u$ 相关的信息。不一定真的是最终的 $ans$，比如例4）\n那么换根前是这样：\n换根后，是这样：\n步骤如下：\n 基于 $ans[u]$，将 $u$ 的child $v$ 所带来的贡献删掉，得到 $dp2[u]$。 基于 $dp[v]$，将 $u$ 作为一个新的child 加给 $v$（实际上，就是将 $dp2[u]$ 的贡献加给 $dp[v]$），得到 $ans[v]$。  • 注意，这里的 $dp2[u]$ 实际上是一个临时的变量。对于每一个 $v$ 而言，$dp2[u]$ 互不相同。\n例题 例1 洛谷P3478 [POI2008]STA-Station 题意\n给定 $n$ 个节点的树，求一个节点 $u$ 使得 $u$ 到其他节点的距离和最大。\n即，求出 $u$，使得 $\\sum\\limits_v d(u,v)$ 最大。\n 题解 首先固定 $1$ 为根，进行一次DFS。\n令 dp[u] 为第一次DFS，只考虑 $u$ 的子树内的答案。（考虑深度和即可）\n令 ans[u] 为最终答案，那么有 ans[1] = dp[1]。\n 现在我们要从 $1$ 开始换根。\n比如说，我们已知了 $u$ 的答案 $ans[u]$，我们就可以理解成：整棵树，以 $u$ 作为root的答案已经求出来了，怎么求出 $to$ 的答案？\n换根的过程是一个旋转的过程。我们把 $to$ 的子树向上旋转，将 $to$ 外面的部分（$u$ 和其他的子树）向下旋转。\n则，向上旋转的部分，对于答案贡献了 -sz[to]（因为深度减少了），而向下旋转的部分，对于答案贡献了 (n-sz[to])。\n所以，$ans[to] = ans[u] - sz[to] + (n - sz[to]);$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int n, head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } ll sz[maxn], dp[maxn]; void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; dp[u] += dp[to] + sz[to]; } } ll ans[maxn]; void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ans[to] = ans[u] - sz[to] + ((ll)n - sz[to]); dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(1, 0); ans[1] = dp[1]; dfs2(1, 0); ll maxans = 0, idx = 0; for (int i = 1; i \u0026lt;= n; i++) { if (ans[i] \u0026gt; maxans) { maxans = ans[i]; idx = i; } } cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; }   例2 CF1324F Maximum White Subtree 题意\n给定 $n$ 个节点的树，每个节点有一个值 $1$ 或者 $-1$。\n对于每一个节点 $i$，求 $i$ 所在的连通块中，最大的节点权值和？\n其中，$2 \\leq n \\leq 2 \\times 10^5$\n 题解 首先固定 $1$ 为 root，进行一次DFS。\n这样可以求出一个 dp[u]：代表以 $1$ 为root时，每个节点仅考虑其subtree，得到的最大值。\n在第一次DFS的过程中，再维护一个数组 bool used[]，其中 used[u] = 1 代表 $u$ 的parent $p$ 的答案用到了 $u$ 的这个subtree。\n 然后进行第二次DFS，计算出最终答案 ans[]。\n首先有，ans[1] = dp[1]。\n当我们在 dfs2(u) 时，在求一个child to 的答案 ans[to] 时，我们有两种选择：\n  to 不使用外面的节点：$ans[to] = \\max(ans[to], dp[to])$\n  to 使用外面的节点：分两种情况讨论\n 如果 to 已经被包含在 $u$ 的答案中了（used[to] = 1），则 $ans[to] = \\max(ans[to], ans[u])$ 如果 to 并没有被包含在 $u$ 的答案中，（used[to] = 0），那么 to 的最终答案，就是由 $to$ 的subtree 和 外面节点的合并而来。即 $ans[to] = \\max(ans[to], ans[u] + dp[to])$     代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int n, head[maxn], ecnt = 1, val[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int dp[maxn]; bool used[maxn]; // when calculating answer, whether used[u] is taken into consideration void dfs1(int u, int p) { dp[u] = val[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); if (dp[to] \u0026gt; 0) dp[u] += dp[to], used[to] = 1; } } int ans[maxn]; void dfs2(int u, int p) { ans[u] = max(ans[u], dp[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (used[to]) ans[to] = max(ans[to], ans[u]); else ans[to] = max(ans[to], ans[u] + dp[to]); dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; val[i]; if (val[i] == 0) val[i] = -1; } for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } fill(ans, ans+maxn, -1e9); dfs1(1,0); dfs2(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 洛谷P6419 [COCI2014-2015#1] Kamp 题意\n给定 $n$ 个节点的树。经过每条边都需要时间 $w_i$。\n有 $K$ 个人，初始在 $K$ 个不同的点，他们要集中在一个点聚会。\n聚会结束后，一辆车从聚会点出发（装上所有人），把这 $K$ 个人分别送回去。\n求：如果聚会点在 $i$，则将这些人都送回去，所需最少的时间？\n输出对于所有 $i = 1$ ~ $n$ 的结果。\n其中，$1 \\leq K \\leq n \\leq 5 \\times 10^5, 1 \\leq w \\leq 10^8$。\n 题解 换根DP首先考虑：如果以 $1$ 作为根，怎么求出 $1$ 的答案？\n• 以下，所有初始点我们都打上标记。\n令 $sz[u]$ 为：$u$ 的 subtree（以 $1$ 为根的版本）中，标记点的数量。\n令 $dp[u]$ 为：从 $u$ 出发，经过 $u$ 的 subtree（以 $1$ 为根的版本） 所有标记点，再回到 $u$，所需的最少时间（如果子树内无标记，则为0）。\n那么通过第一次DFS，我们可以求出整个dp数组。\nif (sz[to]) dp[u] += dp[to] + 2*w;   有了 $dp[1]$，我们还需要一个 $d[u]$，代表以 $u$ 为根的子树（以 $1$ 为根的版本）最长的链的长度。\n同时我们再记录 $f[u]$：代表以u为根，包含了最长链的直接child $to$ 的编号。\n最后 $1$ 对应的答案是：$dp[1] - d[1]$。（因为送到最长链，就不用再回到 $1$ 了）。\n 现在问题是，已知 $1$ 的答案，我们需要求出其他点的答案。\n令 $ans[u]$ 为：从 $u$ 出发，经过整棵树的所有标记点，再回到 $u$，所需的最少时间。\n易证 $ans[1] = dp[1]$。\n然后进行第二次DFS，我们需要改变 $d[u]$ 的意义：此时 $d[u]$ 代表从 $u$ 出发的最长链的长度（以整棵树而言）。\n同时，我们再维护一个数组 $s[u]$，代表从 $u$ 出发的第二长链的长度（以整棵树而言），并且第二长链必须和最长链 不在同一个子树内（这里的子树指，以 $u$ 为根的判断标准）。\n我们在从 $u$ 转移到 $to$ 的时候，就有以下的几种情况：\n  $to$ 内无标记：\n先从 $to$ 走到 $u$，访问所有的点，再从 $u$ 回到 $to$。\nans[to] = ans[u] + 2LL * w; d[to] = d[u] + w; // 现在，d[] 表示全局的链    $to$ 里面包含了整棵树的所有标记点：\n最终答案就 等于 以 $to$ 为根，subtree的答案。\nans[to] = dp[to];    $to$ 里面包含了标记，外面也包含了标记：\n那么对于整棵树而言，从 $to$ 出发，还是从 $u$ 出发都一样。所以 ans[to] = ans[u]。\n但是我们需要更新最长链和次长链。这个时候，我们就要分类讨论 f[u] = to 与否。\n如果 $u$ 原本的最长链就不在 $to$ 的子树内，那么换根以后（旋转），$to$ 的最长链必然是 $to \\rightarrow u \\rightarrow f[u]$。\n如果 $u$ 原本用到的最长链是 $to$，而旋转后，$to$ 的最长链就有可能用到 $u$ 的其他子树（除了 $to$ 以外的子树），所以我们需要维护次长链 $s[u]$，并且进行比较。\n相应的，换根过程中，我们也要更新次长链 $s[to]$。\nans[to] = ans[u]; if (f[u] != to) { // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然继承 u 原来的最长链 s[to] = d[to]; d[to] = w + d[u]; f[to] = u; } else { if (s[u] + w \u0026gt;= d[to]) { s[to] = d[to]; d[to] = s[u] + w; f[to] = u; } else if (s[u] + w \u0026gt; s[to]) { s[to] = s[u] + w; } }     代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; int n, K, head[maxn], ecnt = 1; bool tag[maxn]; struct Edge { int to, nxt, w; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } ll dp[maxn]; // dp[u]: 从u出发，只考虑其subtree中有标记的点，再回到u，得到的答案（如果子树内无标记，则为0） ll ans[maxn]; // 从u出发，送完所有人，再回到u得到的答案 ll d[maxn]; // d[u]: 以u为根的子树内，最长的链的长度 ll s[maxn]; // s[u]: 以u为根的子树内，次长的链的长度 (不能和d所在的子树相同) ll f[maxn]; // f[u]: 以u为根，包含了最深的有标记节点的to编号 int sz[maxn]; // sz[u]: 以u为根的subtree里的标记点数量 void chmax(int u, ll val) { if (val \u0026gt; d[u]) { s[u] = d[u]; d[u] = val; } else { if (val \u0026gt; s[u]) s[u] = val; } } void dfs1(int u, int p) { if (tag[u]) { sz[u] = 1; d[u] = 0; s[u] = -1e15; } else { d[u] = s[u] = -1e15; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; dfs1(to, u); if (!sz[to]) continue; // 子树内无标记 dp[u] += dp[to] + 2LL*w; sz[u] += sz[to]; if (d[to] + w \u0026gt;= d[u]) { s[u] = d[u]; d[u] = d[to] + w; f[u] = to; } else if (d[to] + w \u0026gt; s[u]) { s[u] = d[to] + w; } } } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (to == p) continue; if (!sz[to]) { // to 里面没有标记点 ans[to] = ans[u] + 2LL * w; d[to] = d[u] + w; // 现在，d[] 表示全局的链 } else if (K - sz[to] == 0) { // to 里面全是标记点 ans[to] = dp[to]; // 无需更新最长/次长链 } else { // 里外都有标记 ans[to] = ans[u]; if (f[u] != to) { // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然出现在 u 所在的子树里 s[to] = d[to]; d[to] = w + d[u]; f[to] = u; } else { if (s[u] + w \u0026gt;= d[to]) { s[to] = d[to]; d[to] = s[u] + w; f[to] = u; } else if (s[u] + w \u0026gt; s[to]) { s[to] = s[u] + w; } } } dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= K; i++) { int a; cin \u0026gt;\u0026gt; a; tag[a] = 1; } dfs1(1,0); ans[1] = dp[1]; dfs2(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] - d[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF708C Centroids 题意\n给定一个 $n$ 个节点的树，定义树的重心 $u$ 为：如果以 $u$ 为根，每个子树的大小都 $\\leq \\frac{n}{2}$。\n现在，对于每个点 $u$，我们需要判断：\n以 $u$ 为根时，能否在这棵树内，删去一条边，再添加一条边（不能加入已有的边），使得 $u$ 是重心？\n其中，$2 \\leq n \\leq 4 \\times 10^5$\n 题解 首先，如果一个节点本来就是重心，那么它的答案就是 $1$。\n现在考虑，如果一个节点 $u$ 现在不是重心，怎么删边和加边，使得它成为重心？\n我们会发现，如果以 $u$ 为根，对于 $u$ 的所有 neighbor $v$，有且仅有一个 $v$，使得 $v$ 所在的 subtree 的大小 $\u0026gt; \\frac{n}{2}$， 那么我们就从这个 subtree $S_v$ 中，找到一个更小的subtree $S$，满足：\n $S$ 的大小 $\\leq \\frac{n}{2}$。 $S$ 是 $S_v$ 内，所有满足条件中，最大的subtree。  然后我们把这个 subtree $S$ 断开，然后接到 $u$ 上，然后再判断一下 $u$ 此时是否为重心即可。\n 我们会发现，如果以 $u$ 为根，这样的 $S$ 其实很容易找到。现在要考虑换根的问题。\n 对于这道题而言，如果我们仅仅维护一个节点 $u$ 作为根时，subtree的信息，那么换根时会很麻烦。\n我们需要额外维护一个信息 out[u]，其中 $out[u]$ 就代表：以 $1$ 为根时，$u$ 所在子树 $S_u$ 外面的信息。\n具体定义：$out[u]$ 代表：以 $1$ 为根时，设 $u$ 的parent为 $p$。然后令 $p$ 为根，除了 $S_u$ 以外的部分，满足大小 $\\leq \\frac{n}{2}$ 的最大子树。\n然后就是 套路 里所说的：\n先删去 $to$ 对于 $u$ 的贡献，再将 $u$ 加到 $to$ 上。\nvoid dfs2(int u, int p) { if (n - sz[u] \u0026gt; n/2) { if (n - sz[u] - out[u] \u0026gt; n/2) ok[u] = 0; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (n - sz[to] \u0026lt;= n/2) { out[to] = n - sz[to]; } else { // 删去 to 对于 u 的贡献（维护最大值，次大值 是常见套路了） // 再把 u 加到 to 上去（更新 out[to]） if (use[u][0] == to) { out[to] = max(out[u], dp[u][1]); } else { out[to] = max(out[u], dp[u][0]); } } if (sz[to] \u0026gt; n/2) { if (sz[to] - dp[to][0] \u0026gt; n/2) ok[u] = 0; } dfs2(to, u); } }  • 当然注意到上述代码，我们不一定要定义一个 $dp2[]$ 数组。这题的状态转移相对简单，所以直接将两步合成一步就可以了。下一题会用到较复杂的状态转移，此时就需要定义 $dp2[]$ 数组了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4e5+5; int sz[maxn], head[maxn], ecnt = 1, dp[maxn][2], out[maxn], use[maxn][2], n; bool ok[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026lt;= n/2) { if (sz[to] \u0026gt; dp[u][0]) { dp[u][1] = dp[u][0]; dp[u][0] = sz[to]; use[u][0] = to; } else if (sz[to] \u0026gt; dp[u][1]) { dp[u][1] = sz[to]; use[u][1] = to; } } else if (dp[to][0] \u0026gt; dp[u][0]) { dp[u][1] = dp[u][0]; dp[u][0] = dp[to][0]; use[u][0] = to; } else if (dp[to][0] \u0026gt; dp[u][1]) { dp[u][1] = dp[to][0]; use[u][1] = to; } } } void dfs2(int u, int p) { if (n - sz[u] \u0026gt; n/2) { if (n - sz[u] - out[u] \u0026gt; n/2) ok[u] = 0; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (n - sz[to] \u0026lt;= n/2) { out[to] = n - sz[to]; } else { if (use[u][0] == to) { out[to] = max(out[u], dp[u][1]); } else { out[to] = max(out[u], dp[u][0]); } } if (sz[to] \u0026gt; n/2) { if (sz[to] - dp[to][0] \u0026gt; n/2) ok[u] = 0; } dfs2(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } fill(ok, ok+maxn, 1); dfs1(1, 0); dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; ok[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例5 洛谷P3647 [APIO2014]连珠线 题意\n现在有 $n$ 个珠子。珠子之间用线链接，每个线要么是红色，要么是蓝色。\n我们将会从其中一个珠子开始（我们不知道这个珠子是哪个），每次用如下两种方式之一，添加珠子：\n 将一个 新的珠子 $w$ 和已经添加的珠子 $v$，用红线连起来。 将两个已经存在的珠子 $u,v$ 之间相连的红线删掉，然后添加一个 新的珠子 $w$ 使得 $(u,w)$，$(w,v)$ 用蓝线链接。  每条线都具有一个长度，游戏结束后，最终得分为蓝线长度之和。\n给定游戏结束的局面（是一棵树），我们已知 珠子和线的连接方式，以及每条线的长度。但是我们不知道线的颜色。\n求最大可能的得分？\n其中，$1 \\leq n \\leq 2 \\times 10^5$\n 题解 观察一下会发现，如果 $a,b$ 之间有蓝线，$b,c$ 之间也有蓝线。那么 $b$ 就是一个中间节点。这样的节点满足两个条件：\n $b$ 与 $a,c$ 一定是直接的neighbor。 $b$ 只能作为一次中间节点（因为 $b$ 是通过第二种操作添加的新节点） $a,c$ 不能均为中间节点（因为 $a,c$ 之间，必须以红线相连，然后断开才行。这说明 $a,c$ 其中一个必须是通过第一种操作，得到的新珠子）  那么，在最终形成的树中，对于蓝线，有以下两种可能：\n第一种情况：grandparent, parent, child\n第二种情况：parent, child1, child2\n我们发现第二种情况很复杂，因为我们需要分类讨论 $a,c$ 是否本身为中间节点。\n但是第一种情况，就比较好处理。我们只要加一个限定条件：\n如果 $b$ 是中间节点（用 $1$ 来标记），那么它用蓝线相连的child $c$，就不能是中间节点（用 $0$ 来标记）。\n 等等，有两个疑问：\n 为什么我们限定的是蓝线相连的 child $c$？为什么不是parent $a$ ？ 那如果第二种情况的那种出现了，怎么办？  这些问题都可以通过 固定 树的根来解决。\n我们可以发现，如果我们设定树的根为： 最优解 中，最开始的那个珠子（虽然我们不知道它是哪一个），这些问题就都解决了。（比如第二个问题，我们可以保证这种情况不会出现）。\n 如上，我们只需要考虑第一种情况。那么，固定 $1$ 为根时，第一次 DFS 中，我们有：\n设 $dp[u][0]$ 为：如果 $u$ 不是一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。\n设 $dp[u][1]$ 为：如果 $u$ 是一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。\n状态转移方程：\n$$dp[u][0] = \\sum\\limits_{to} \\max(w + dp[to][1], dp[to][0])$$\n对于 $dp[u][1]$，因为它只能选择一个 child。它选择的那个child $v$，对它的贡献是 $w_{u,v} + dp[v][0]$，其他的child $to$ 的贡献都是 $\\max(w + dp[to][1], dp[to][0])$。\n所以只要把这个 $v$ 的贡献减去，再加上新贡献就可以了。\n$$dp[u][1] = dp[u][0] + \\max\\limits_v \\{ w+dp[v][0] - \\max(w+dp[v][1], dp[v][0])\\}$$\n 以 $1$ 为根的情况有了，现在考虑一下换根？\n由换根套路，首先将 $to$ 对于 $u$ 的影响删去（基于 $ans[u]$），有：\n$$dp2[u][0] = ans[u][0] - \\max(w + dp[to][1], dp[to][0])$$\n然后，对于 $dp2[u][1]$，我们分类讨论一下 $to$ 是否为 $u$ 的最佳转移点（也就是说，$ans[u][1]$ 是否用到了 $to$，作为最大值）。\n$$dp2[u][1] = \\begin{cases} ans[u][1] - maxval[u][0] + maxval[u][1] \u0026amp; \\text{If to 是 u 的最佳转移点} \\\\ ans[u][1] \u0026amp; \\text{Otherwise} \\end{cases}$$\n然后，再基于 $dp[to]$ 的基础上，将 $dp2[u]$ 作为 child 给 $to$ 的影响加到 $to$ 上即可。\n最后，答案就是 $\\max\\limits_u \\{ans[u][0]\\}$。（因为 $ans[u][1]$ 并没有意义，$u$ 作为根的时候是没有parent的）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, w, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, dp[maxn][2], dp2[maxn][2], ans[maxn][2]; // dp: 以 1 为根, dp2: 换根后, ans: 最终答案 int use[maxn][2], maxval[maxn][2]; // use[u]: 转移时，所用的前两大的值，对应的两个vertex； maxval[u] : 转移时所用的前两大的值 void addEdge(int u, int v, int w) { Edge e = {v, w, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (to == p) continue; dfs1(to, u); dp[u][0] += max(w + dp[to][1], dp[to][0]); // 转移 dp[u][0] // 转移 dp[u][1] int val = w + dp[to][0] - max(w + dp[to][1], dp[to][0]); if (val \u0026gt; maxval[u][0]) { maxval[u][1] = maxval[u][0]; use[u][1] = use[u][0]; maxval[u][0] = val; use[u][0] = to; } else if (val \u0026gt; maxval[u][1]) { maxval[u][1] = val; use[u][1] = to; } } dp[u][1] = dp[u][0] + maxval[u][0]; } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (to == p) continue; // 删去 to 对于 u 的影响，基于 ans[u]，得到 dp2[u] dp2[u][0] = ans[u][0] - max(w + dp[to][1], dp[to][0]); if (to == use[u][0]) { dp2[u][1] = ans[u][1] - maxval[u][0] + maxval[u][1]; } else { dp2[u][1] = ans[u][1]; } dp2[u][1] -= max(w + dp[to][1], dp[to][0]); // 将 dp2[u] 作为 child，重新加给 to(在 dp[to] 的基础上)，作为新的 child ans[to][0] = dp[to][0] + max(w + dp2[u][1], dp2[u][0]); int val = w + dp2[u][0] - max(w + dp2[u][1], dp2[u][0]); if (val \u0026gt; maxval[to][0]) { maxval[to][1] = maxval[to][0]; use[to][1] = use[to][0]; maxval[to][0] = val; use[to][0] = u; } else if (val \u0026gt; maxval[to][1]) { maxval[to][1] = val; use[to][1] = u; } ans[to][1] = ans[to][0] + maxval[to][0]; dfs2(to, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= n; i++) maxval[i][0] = maxval[i][1] = -1e9; // 注意初始化，否则会有问题 dfs1(1, 0); ans[1][0] = dp[1][0], ans[1][1] = dp[1][1]; dfs2(1, 0); int maxans = 0; for (int i = 1; i \u0026lt;= n; i++) maxans = max(maxans, ans[i][0]); // 注意这里是 ans[i][0] cout \u0026lt;\u0026lt; maxans \u0026lt;\u0026lt; endl; }   例6 CF1725J Journey 题意\n给定一棵树，每条边有边权，现在我们可以从任意节点出发，需要访问每个节点至少一次。\n在访问过程中，我们拥有一次使用传送门的机会，使得我们可以从一个节点无损耗的传送到另外一个节点。\n求访问每个节点至少一次，并且至多使用一次传送门的最小消耗？\n其中，$n \\leq 10^5$。\n 题解 先考虑一下，如果我们不能使用传送门怎么算？\n我们假设从 $x$ 出发，可以看作树以 $x$ 为根，那么每次走完一个子树都要回到 $x$，如果我们的路径最后停留在 $y$，说明 $(x,y)$ 这条路径仅被访问一次，而其他的边都会被访问两次。\n所以对于整棵树而言，我们希望 $(x,y)$ 这条路径尽可能长，也就是这棵树的直径。然后对于其他的边，都访问了两次。所以答案就是：设 $sum$ 为所有边权和，$D$ 为直径长度，答案为 $2 * sum - D$。\n 好的，接下来考虑有传送门的情况。\n有两种情况：\n第一种是在 $u$ 为根的情况，从 $u$ 的其中一个子树中走一圈，然后传送到 $u$ 的另外一个子树中走一圈，每条边都至少被用过一次。\n第二种 $u$ 不是根的情况，设 $u$ 的parent为 $p$，那么先从 $u$ 的子树中走一圈，然后传送到除了 $u$ 的子树以外的位置走一圈，这样这条边 $(p, u)$ 就没有被用到。\n对于第一种情况，以 $u$ 为起点的四条最长链只被访问一次，剩下的都是 $2$ 次，所以只要计算当 $u$ 作为根时，它作为起点的四个最长链（并且不相交，位于不同子树内）的长度。\n对于第二种情况，相当于把一条边割开，然后得到两个分开的子树，这就是两个子树的子问题了，相当于两个子树内走一圈，无法使用传送门，所以只要求两个子树的直径即可。\n注意到，我们需要对每一个 $u$ 都讨论第一种情况，对于每一条边都讨论第二种情况，这可以通过换根 dp 解决。\n 我们先明确我们需要求的内容 （以下均为 $1$ 作为根时讨论）\ndia[u]： $u$子树（包括u）的最长直径。\ndp1[u][3]： $u$子树内，以u为起点的最长链 (前 $3$ 长）长度。\ndp2[u][2]： $u$子树内（不包括 u），最长(前 $2$ 长）的直径长度。\nlen[u]： $(u, par[u])$ 的权值。\nup1[u]： $u$外面（整棵树去掉 $u$ 子树后），以 $par[u]$ 作为起点的最长链。\nup2[u]： $u$外面（整棵树去掉 $u$ 子树后）的最长直径。\n有了这些信息，所有问题都可以解决，现在看下怎么求这些信息？\n 首先是 dia[u]：\n这是一个常规的树形 DP 问题，\n$u$ 子树的直径有两种情况，要么经过了 $u$，要么完全位于 $u$ 的子树里面。\n对于第一种情况，求出以 $u$ 为起点的前 $2$ 个最长链，然后相加即可，这个就是 dp1[u][0] + dp1[u][1]，很好求。\n对于第二种情况，求出 dp2[u][0] 即可.\n 然后是 up1[]，我们看下图，这是正在求 up1[v] 的过程。\n有两种情况：\n $u$ 为起点的最长链经过了 $v$。 $u$ 为起点的最长链没有经过 $v$。  第一种情况下，up1[v] = max(up1[v], dp1[u][1])。\n第二种情况下，up1[v] = max(up1[v], dp1[u][0])。\n 接下来是 up2[]，同样按照上图求 up2[v] 的过程进行分类讨论：\n有两种情况：\n $u$ 的子树内的直径经过了 $u$。 $u$ 的子树内的直径没经过 $u$。  第一种情况下，使用的是 dp1[u][0] + dp1[u][1]，所以只要判断 $v$ 贡献了 dp1[u][?] 即可，比如如果 $v$ 贡献了 dp1[u][1]，那么就让 up2[v] = max(up2[v], dp1[u][0] + dp1[u][2])，即贡献来自其余两个链。\n第二种情况下，使用的子树的直径，也就是 dp2[u][?]，判断是否有 dia[v] == dp2[u][0]，如果有，就用 up2[v] = max(up2[v], dp2[u][1])，否则用 up2[v] = max(up2[v], dp2[u][0])。\n 除此之外，我们还需要换根。也就是在更新 up1[v], up2[v] 之前，要先把 $u$ 看作为根，所以需要把 $u$ 的parent那条链旋转下来，然后更新 dp1[u], dp2[u]。\n 上面解决了问题 $2$，切分子树，然后要解决问题一：找四条最长不相交链的问题。\n这个只要对每个节点维护一个大小为 $4$ 的最小堆即可，在第一次 dfs 的时候找到所有子树的最长链插入堆中，然后在将 up1[u] + len[u] 也就是 parent 的最长链插入即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n; struct Edge { int to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dia[maxn]; // dia[u]: u子树（包括u）的最长直径 ll dp1[maxn][3]; // u子树内，以u为起点的最长链长度 ll dp2[maxn][2]; // u子树内（不包括 u），最长的直径长度 int len[maxn]; // len[u]: w(u, par[u]) ll up1[maxn]; // u外面（整棵树去掉 u子树后）的最长链 ll up2[maxn]; // u外面（整棵树去掉 u子树后）的最长直径 ll sum = 0; // 所有 w 的和 priority_queue\u0026lt;ll, vector\u0026lt;ll\u0026gt;, greater\u0026lt;ll\u0026gt;\u0026gt; chain[maxn]; // chain[u]: 记录以u为起点的前4长的链 void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w; if (v == p) continue; len[v] = w; sum += w; dfs1(v, u); // 更新 dp1[u] ll t = w + dp1[v][0]; for (int j = 0; j \u0026lt;= 2; j++) { if (t \u0026gt;= dp1[u][j]) swap(t, dp1[u][j]); } // 更新 dp2[u] t = dia[v]; for (int j = 0; j \u0026lt;= 1; j++) { if (t \u0026gt;= dp2[u][j]) swap(t, dp2[u][j]); } dia[u] = max({dia[u], dp1[u][0] + dp1[u][1], dp2[u][0]}); // 最后记录 chain[u] chain[u].push(w + dp1[v][0]); if (chain[u].size() \u0026gt; 4) chain[u].pop(); } } ll ans = 0; void dfs2(int u, int p) { // // 此时需要先把 u 外面的那条链转过来，更新 dp1[u] ll t = len[u] + up1[u]; for (int j = 0; j \u0026lt;= 2; j++) { if (t \u0026gt;= dp1[u][j]) swap(t, dp1[u][j]); } // 同理更新 dp2[u] t = up2[u]; for (int j = 0; j \u0026lt;= 1; j++) { if (t \u0026gt;= dp2[u][j]) swap(t, dp2[u][j]); } for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to, w = edges[e].w; if (v == p) continue; // 更新 up1[v] if (w + dp1[v][0] == dp1[u][0]) { // 如果u子树内最长链用到了 v up1[v] = max(up1[v], dp1[u][1]); } else { up1[v] = max(up1[v], dp1[u][0]); } // 更新 up2[v] // Case1: 直径经过 u if (dp1[v][0] + w == dp1[u][0]) { up2[v] = max(up2[v], dp1[u][1] + dp1[u][2]); } else if (dp1[v][0] + w == dp1[u][1]) { up2[v] = max(up2[v], dp1[u][0] + dp1[u][2]); } else { up2[v] = max(up2[v], dp1[u][0] + dp1[u][1]); } // Case2: 直径没经过 u if (dp2[u][0] == dia[v]) { up2[v] = max(up2[v], dp2[u][1]); } else { up2[v] = max(up2[v], dp2[u][0]); } ans = min(ans, sum * 2 - w * 2 - dia[v] - up2[v]); dfs2(v, u); } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u, v, w); addEdge(v, u, w); } dfs1(1, 0); ans = sum * 2; dfs2(1, 0); for (int u = 1; u \u0026lt;= n; u++) { chain[u].push(up1[u] + len[u]); if (chain[u].size() \u0026gt; 4) chain[u].pop(); ll res = 0; while (chain[u].size()) { res += chain[u].top(); chain[u].pop(); } ans = min(ans, sum * 2 - res); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-04-22T21:49:20+08:00","permalink":"https://tom0727.github.io/post/045-%E6%8D%A2%E6%A0%B9dp/","tags":["树形DP","换根DP"],"title":"换根DP"},{"categories":["解题报告"],"contents":"全是数学的一场Div2，$D$ 题是常规操作了，但是考场上没想起来，这里记录一下。\n结尾也记录了 CF1514D，一道使用随机算法的神奇题目。\nCF1516B AGAGA XOOORRR 题意\n给定 $n$ 个元素 $a_1,a_2,\u0026hellip;,a_n$，每次操作可以任选 $2$ 个相邻元素 $a_i, a_{i+1}$，将它们删去，并且用 $a_i \\text{ xor } a_{i+1}$ 来替换（位置不变）。\n问：是否存在一序列操作，使得数组最后只有相同的元素，并且长度 $\\geq 2$？\n其中，$2 \\leq n \\leq 2000$\n 题解 可以发现最后数组长度要么为 $2$，要么为 $3$。\n如果最后长度为 $2$，说明 $a_1 \\text{ xor }a_2 \\text{ xor }\u0026hellip; \\text{ xor }a_n = 0$，特判一下即可。\n如果长度为 $3$，则令 $k = a_1 \\text{ xor }a_2 \\text{ xor }\u0026hellip; \\text{ xor }a_n$，则最后数组一定是 $[k,k,k]$。只要判断是否存在连续的 $3$ 段使得它们的$\\text{ xor }$为 $k$ 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2000+5; int arr[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; int x = arr[1]; for (int i = 2; i \u0026lt;= n; i++) x ^= arr[i]; if (x == 0) { cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; continue; } int cur = 0, cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { cur ^= arr[i]; if (cur == x) cnt++, cur = 0; if (cnt \u0026gt;= 2) break; } if (cnt \u0026gt;= 2) cout \u0026lt;\u0026lt; \u0026quot;YES\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else cout \u0026lt;\u0026lt; \u0026quot;NO\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   CF1516C Baby Ehab Partitions Again 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n问：我们最少要从数组中删去几个元素，使得：不存在任何一种方案，将数组分为 sum 相同的两半？\n输出这个最少删除数量，并且输出删除的index。\n其中，$2 \\leq n \\leq 100, 1 \\leq a_i \\leq 2000$\n 题解 我们按照以下步骤进行check：\n  如果 $sum$ 是奇数，答案为 $0$。\n  如果这个数组本身就无法分为两半（直接用 bitset 模拟），答案为 $0$。\n  如果这个数组内，存在一个奇数，答案为 $1$，把这个奇数删掉即可。\n  如果数组内，不存在奇数。则我们会发现，把整个数组的所有数除以 $2$，答案不变（因为原先的分配方案不会改变）。所以我们就一直除，直到出现一个奇数。答案也为 $1$。\n  如上，答案要么为 $0$，要么为 $1$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 105; const int maxm = 2e5+5; int n, arr[maxn], sum = 0, idx = -1; bitset\u0026lt;maxm\u0026gt; dp; bool check() { dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { dp |= (dp \u0026lt;\u0026lt; (arr[i])); } if (dp[sum/2]) return 0; // can partition into equal parts return 1; // cannot partition into equal parts } void done() { if (idx == -1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; } exit(0); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], sum += arr[i]; if (sum \u0026amp; 1) done(); if (check()) done(); bool ok = 0; while (!ok) { for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026amp; 1) ok = 1, idx = i; } for (int i = 1; i \u0026lt;= n; i++) arr[i] /= 2; } done(); }   CF1516D Cut 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n给定 $q$ 个询问，每次询问 $l,r$，回答：\n对于 $[a_l, \u0026hellip;, a_r]$，最少需要将它分为几个连续的subarray，使得每一个subarray内，所有元素的 $LCM$ 等于它们的乘积？\n其中，$1 \\leq n,q,a_i \\leq 10^5, 1 \\leq l \\leq r \\leq n$。\n 题解 如果一个subarray内，所有元素的 $LCM$ 等于它们的乘积，说明 任选两个元素，$gcd = 1$，也就是说不存在两个元素使得它们共享一个质因子。\n所以一个 trivial 的算法如下：\n每次询问 $L,R$，就从 $L$ 开始出发，一直向右走，直到遇到一个 $x \\in [L+1,R]$ 使得 $[a_L,\u0026hellip;,a_x]$ 不满足上述条件。然后将 $ans+1$，令 $L = x$，然后重复此过程。\n 现在问题在于，对于每一个 $L$，如何快速得到这样的 $x$？\n 法一：（很麻烦）\n根号分治 + 质因数分解，类似于 CF1422F Boring Queries。\n我们先对每个数进行质因子分解，如果一个subarray $[L,R]$ 满足条件，那么：\n对于每一个质因子 $p_i$，在 $[L,R]$ 内，它最多只能出现一个位置上。\n我们就可以处理出一个数组 $pre[j][i] = x$，代表对于第 $j$ 个质数 $p_j$，满足：\n $a_i$ 包含 $p_j$ 这个质因子。 $a_x$ 包含 $p_j$ 这个质因子。 $x \u0026lt; i$，且 $x$ 尽可能大。  然后得到一个数组 $pr[i]$，其中 $pr[i] = \\max\\limits_j \\{ pre[j][i]\\}$。\n那么，查询一个区间 $[L,R]$ 是否满足条件，令 $a = \\max\\limits_{i=L}^R \\{pr[i]\\}$，则只要满足 $a \u0026lt; L$，说明这个区间 $[L,R]$ 是合法的。（这个 $a$ 可以用 $ST$ 表维护）\n• 注意到我们需要用根号分治（$ST$ 表只维护 $\\leq \\sqrt {10^5}$ 的部分。\n• 对于大质因子，由于每个位置，出现次数最多只有一次，直接用 map\u0026lt;int,int\u0026gt; 模拟一下前一个和它相等的数的index即可。\n经过上述处理，我们可以在 $O(1)$ 的时间内，查询一个区间 $[L,R]$ 是否合法。\n那么，对于每一个 $L$，二分 右边界 $R$ 就可以得到最大的合法 $R$ 的值为 $R'$，令 $x = R'+1$ 即可。\n 法二：（正解）\nDP + 质因数分解。\n首先求出每一个数的所有质因子。\n然后我们从 $n$ 遍历到 $1$，维护两个数组 int pnxt[], dp[]：\n pnxt[p]：代表当前情况下，对于质因子 $p$，出现最靠前的位置。 dp[i]：对于位置 $i$，最多能往右走到 dp[i] 这个index（不包括）。  首先我们有 dp[i] = min(dp[i], dp[i+1])，然后对于当前index $i$，我们有：\n$$dp[i] = \\min\\limits_p \\{pnxt[p]\\}$$\n其中，$p$ 是 $a_i$ 的所有质因子。\n处理出 dp[] 数组，就是我们所求的了。\n 现在我们已知，对于每一个 $L$，它最远可以走到 $x$（不包括），那么每次询问 $[L,R]$，怎么快速得到答案？\n模拟肯定不行，如果数组是 $2,2,2,2,2\u0026hellip;,2$ 的话，每次询问复杂度为 $O(n)$。\n使用 $LCA$ 中的倍增思想就可以了。\n我们预处理出 $nxt[i][j]$：代表从 $i$ 出发，走 $2^j$ 次，最远能走到哪。（其中，$nxt[i][0]$ 就是上述的 $dp[i]$）。\n 法一代码（根号分治 \u0026#43; 质因数分解 \u0026#43; ST表） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n, q, arr[maxn], small[maxn]; // small[i] 代表 i 的最小质因子 bool isprime[maxn]; vector\u0026lt;int\u0026gt; primes; bool have[70][maxn]; int pre[70][maxn]; int ptr = 0; // 记录小质因子(\u0026lt;=317) 的数量 int mp[70]; // 1 -\u0026gt; 2, 2 -\u0026gt; 3, 3-\u0026gt;5（因为质因数小于70个，节省空间） int rmap[maxn]; // mp 的 reverse map int pr[maxn]; int st[maxn][18]; int bin[maxn]; int dp[maxn]; int ask_st(int l, int r) { int len = r-l+1; int k = bin[len]; return max(st[l][k], st[r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) st[i][0] = pr[i]; for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i + (1\u0026lt;\u0026lt;k) - 1 \u0026lt;= n; i++) st[i][k] = max(st[i][k-1], st[i+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } void init() { fill(isprime, isprime+maxn, 1); isprime[1] = 0; small[1] = 1; for (int i = 2; i \u0026lt;= 1e5; i++) { if (isprime[i]) primes.push_back(i), small[i] = i; for (int j = 0; j \u0026lt; primes.size(); j++) { int p = primes[j]; if (i*p \u0026gt; 1e5) break; isprime[i*p] = 0; small[i*p] = p; // 注意这里，无论是否有 i%p，都要 small[i*p] = p if (i % p == 0) { break; } } } for (int i = 0; i \u0026lt; primes.size(); i++) { mp[++ptr] = primes[i]; rmap[primes[i]] = ptr; if (primes[i] \u0026gt; 317) break; } for (int i = 1; i \u0026lt;= n; i++) { while (arr[i] \u0026gt; 1) { int p = small[arr[i]]; if (p \u0026gt; 317) break; have[rmap[p]][i] = 1; while (arr[i] % p == 0) arr[i] /= p; } } for (int j = 1; j \u0026lt;= ptr; j++) { for (int i = 1; i \u0026lt;= n; i++) { if (have[j][i-1]) pre[j][i] = i-1; pre[j][i] = max(pre[j][i], pre[j][i-1]); if (have[j][i]) { pr[i] = max(pr[i], pre[j][i]); } } } unordered_map\u0026lt;int,int\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { if (arr[i] \u0026lt;= 317) continue; if (m.count(arr[i])) pr[i] = max(pr[i], m[arr[i]]); m[arr[i]] = i; } build_st(); } // 询问 [L,R] 这个区间是否合法 bool ok(int l, int r) { int a = ask_st(l,r); if (a \u0026lt; l) return 1; return 0; } int nxt[maxn][19]; // nxt[i][j]: 从i开始，跳j步能达到的index int main() { read(n); read(q); for (int i = 1; i \u0026lt;= n; i++) read(arr[i]); init(); for (int L = 1; L \u0026lt;= n; L++) { int l = L, r = n; int res; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (ok(L,mid)) { res = mid; l = mid+1; } else r = mid-1; } nxt[L][0] = res + 1; } fill(nxt[n+1], nxt[n+1] + 19, n+1); for (int k = 1; k \u0026lt;= 18; k++) { for (int i = 1; i \u0026lt;= n; i++) { nxt[i][k] = nxt[nxt[i][k-1]][k-1]; } } while (q--) { int L, R, ans = 0; read(L), read(R); for (int k = 18; k \u0026gt;= 0; k--) { if (nxt[L][k] \u0026lt;= R) L = nxt[L][k], ans += (1\u0026lt;\u0026lt;k); } ans++; write(ans); } }   法二代码（DP \u0026#43; 质因数分解） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n, q, arr[maxn]; vector\u0026lt;int\u0026gt; fac[maxn]; // fac[i]: i的质因子 (不重复) void get_factors() { for (int i = 2; i \u0026lt;= 1e5; i++) { if (fac[i].size() == 0) { // i为质数 fac[i].push_back(i); for (int j = i+i; j \u0026lt;= 1e5; j += i) { fac[j].push_back(i); } } } } int nxt[maxn][18]; // nxt[i][0] = j: 从i开始向右走，最多能走到j（不包括j） int pnxt[maxn]; // pnxt[p] = i: 当前状态下，包含了质因子p的最小index i void init() { get_factors(); fill(pnxt, pnxt+maxn, n+1); fill(nxt[n+1], nxt[n+1] + 18, n+1); for (int i = n; i \u0026gt;= 1; i--) { int cur = arr[i]; nxt[i][0] = nxt[i+1][0]; for (int p : fac[cur]) { nxt[i][0] = min(nxt[i][0], pnxt[p]); pnxt[p] = i; } } for (int k = 1; k \u0026lt; 18; k++) { for (int i = 1; i \u0026lt;= n; i++) { nxt[i][k] = nxt[nxt[i][k-1]][k-1]; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; init(); while (q--) { int L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int ans = 0; for (int j = 17; j \u0026gt;= 0; j--) { if (nxt[L][j] \u0026lt;= R) { L = nxt[L][j]; ans += (1\u0026lt;\u0026lt;j); } } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   CF1514D Cut and Stick 题意\n给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n给定 $q$ 个询问，每次询问 $l,r$，回答：\n对于 $[a_l, \u0026hellip;, a_r]$，最少需要将它分为几个subsequence（不用连续），使得每一个subsequence都满足：如果这个subsequence的长度为 $len$，那么众数的出现次数 $\\leq \\lceil \\frac{len}{2} \\rceil$。\n 题解 对于每次询问，求出 $[l,r]$ 中是否存在出现次数大于一半的数字，这样的数如果有，只能有一个。\n假设存在这样的数，那么我们的方案就是将这个众数一个个单独拿出来，每个单独组成一个subsequence，直到剩下的那个大subsequence满足条件为止。\n令 $len = (r-l+1)$，$f$ 为众数出现次数。\n设我们拿走了 $x$ 个众数。那么有：$\\lceil\\frac{len-x}{2}\\rceil = f-x$，注意到 $\\lceil\\frac{len-x}{2}\\rceil = \\frac{len-x+1}{2}$，则有 $\\frac{len-x+1}{2} = f-x$，推出 $x = 2f-len-1$，再加上单独分出来的那个大subsequence，答案就是 $x+1 = 2f-len$。\n• 当然，如果懒得推公式，也可以直接利用倍增思想模拟 $x$ 的值。（见主席树代码中的倍增部分）\n 求一个区间出现次数大于一半的数字，主席树的模版了。具体做法看代码。\n 我们要重点讲一下的是随机化算法。\n首先我们要预处理出 每个数字 出现的位置，用 vector\u0026lt;int\u0026gt; pos[maxn] 来维护。\n这样，每次询问 $[l,r]$，我们对于任何一个数字 $x$ 都可以求出 $x$ 在 $[l,r]$ 内出现的次数！\nauto itr1 = lower_bound(pos[x].begin(), pos[x].end(), l); auto itr2 = upper_bound(pos[x].begin(), pos[x].end(), r); int cnt = itr2 - itr1;  现在，我们需要找到这个区间内，最多的出现次数。\n那么一个随机化的算法就是：\n有放回的，从 $[l,r]$ 中随机选取 $40$ 个元素，将每个元素的出现次数取最大值。\n假设出现次数超过一半的数字存在，那么它在 $40$ 次随机选择中，都没有被选到的概率最多为 $2^{-40}$。\n 主席树代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; const int maxm = 2e7+5; struct node { int lc, rc, cnt; } tr[maxm]; int root[maxn], id = 0; int build(int l, int r) { int cur = ++id; if (l == r) { return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; // 复制一份上个版本 tr[cur].cnt++; // 添加了一个节点 if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) tr[cur].rc = insert(tr[cur].rc, mid+1, r, p); return cur; } // query the most number in this segment [pre,cur] int query(int pre, int cur, int l, int r, int k) { if (l == r) return tr[cur].cnt - tr[pre].cnt; int prelc = tr[pre].lc, lc = tr[cur].lc; int prerc = tr[pre].rc, rc = tr[cur].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc].cnt - tr[prelc].cnt; int rcnt = tr[rc].cnt - tr[prerc].cnt; if (lcnt \u0026gt; k) return query(prelc, lc, l, mid, k); if (rcnt \u0026gt; k) return query(prerc, rc, mid+1, r, k); return -1; } int main() { int n,q; read(n); read(q); root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; i++) { int a; read(a); root[i] = insert(root[i-1], 1, n, a); } while (q--) { int l,r; read(l); read(r); int len = r-l+1; if (len == 1) { write(1); continue; } int k = len / 2 + (len\u0026amp;1); int res = query(root[l-1], root[r], 1, n, k); if (res == -1) { write(1); continue; } int ans = 1; // 懒得推公式，直接用倍增进行模拟 for (int j = 19; j \u0026gt;= 0; j--) { int d1 = (1\u0026lt;\u0026lt;j); int len2 = len - d1; int res2 = res - d1; if (res2 \u0026gt; len2/2 + (len2\u0026amp;1)) { res -= d1; len -= d1; ans += d1; } } while (res \u0026gt; len/2 + (len\u0026amp;1)) { res--; len--; ans++; } write(ans); } }   随机化代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int arr[maxn]; const int T = 40; vector\u0026lt;int\u0026gt; pos[maxn]; void solve(int l, int r) { int cnt = 0; for (int t = 1; t \u0026lt;= T; t++) { int p = randint(l,r); int cur = arr[p]; auto itr1 = lower_bound(pos[cur].begin(), pos[cur].end(), l); auto itr2 = upper_bound(pos[cur].begin(), pos[cur].end(), r); cnt = max(cnt, itr2 - itr1); } int len = r-l+1; if (cnt \u0026lt;= (len+1)/2) { write(1); } else { write(2 * cnt - len); } } int main() { int n,q; read(n); read(q); for (int i = 1; i \u0026lt;= n; i++) { read(arr[i]); pos[arr[i]].push_back(i); } while (q--) { int l,r; read(l); read(r); solve(l,r); } }   ","date":"2021-04-22T12:07:06+08:00","permalink":"https://tom0727.github.io/post/044-cf1516-tutorial/","tags":["",""],"title":"Codeforces Round #717 (Div.2) 解题报告"},{"categories":["算法"],"contents":"定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。\n树的直径有以下性质：（以下，我们假设所有边上的权值均 $\\geq 0$）。\n  直径一定是由两个 leaf 组成\n  对于任意一个节点 $u$，距离它最远的一个节点，必然为直径的其中一端。\n  在一棵树上，任取两个点集 $S_1, S_2$，设 $S_1$ 这个点集的直径是 $(u_1,v_1)$，设 $S_2$ 这个点集的直径是 $(u_2, v_2)$，那么令 $S = S_1 \\cup S_2$。则点集 $S$ 的直径只可能为以下 $6$ 种的之一：\n$$(u_1, v_1), (u_2, v_2), (u_1, u_2), (u_1, v_2), (v_1, u_2), (v_2, u_2)$$\n即，新的直径一定由原先 $4$ 个端点组成。\n  证明：第二个性质 我们设直径是 $(s,t)$，并且设节点 $a$ 距离最远的节点是 $b$，其中 $b \\neq s, b \\neq t$。\nCase1：$a$ 位于直径 $(s,t)$ 上：\n如上，有 $L_1 \u0026gt; L_2$，$L_1 \u0026gt; L_3$。且 $L_2 + L_3$ 为直径。\n那么 $L_1 + L_3 \u0026gt; L_2 + L_3$，$L_1 + L_2 \u0026gt; L_2 + L_3$。\n所以 $L_1 + L_3$ 或者 $L_1 + L_2$ 才是直径。contradiction。\n Case2：$(a,b)$ 之间的路径横穿了 $(s,t)$，交点为 $x$。\n如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 \u0026gt; L_1 + L_3$，$L_1 + L_2 \u0026gt; L_1 + L_3$。\n那么 $L_2 \u0026gt; L_3$，$L_2 \u0026gt; L_4$。\n所以 $L_2 + L_3 \u0026gt; L_3 + L_4$，$L_2 + L_4 \u0026gt; L_3 + L_4$。\n所以 $L_2 + L_3$ 或者 $L_2 + L_4$ 才是直径。contradiction。\n Case3：$(a,b)$ 之间的路径没有穿过 $(s,t)$，但是 $(a,b)$ 路径上，有一个距离 $(s,t)$ 最短的点 $x$，并且这个 $x$ 通过 $y$ 与 $(s,t)$ 相交。\n如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 \u0026gt; L_1 + L_5 + L_4$，$L_1 + L_2 \u0026gt; L_1 + L_5 + L_3$。\n所以有 $L_2 \u0026gt; L_5 + L_4$，$L_2 \u0026gt; L_5 + L_3$。\n所以 $L_3 + L_5 + L_2 \u0026gt; L_3 + L_4$，$L_4 + L_5 + L_2 \u0026gt; L_3 + L_4$。\n所以 $L_3 + L_5 + L_2$ 或者 $L_4 + L_5 + L_2$ 才是直径。contradiction。\n • 第三个性质的证明不会，先咕着\n求树的直径 求树的直径有两种方法：两次DFS 和 DP。\n法一：两次DFS（推荐） 由性质 $2$，我们可以以任意节点为根，进行DFS。得到一个距离最远的点 $u$ （这个节点的深度最深）。\n然后再以 $u$ 为根，进行第二次DFS。得到距离最远的点 $v$。那么 $(u,v)$ 就是直径了。\n两次DFS：代码 int n, dep[maxn], d1, d2; // d1: 直径一端，d2: 直径另外一端 void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dep[to] = dep[u] + 1; dfs1(to, u); } } int main() { dep[1] = 0; dfs1(1, 0); // 第一次 DFS (以 1 为根) d1 = 1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d1]) { d1 = u; } } dep[d1] = 0; dfs1(d1, 0); // 第二次 DFS (以直径端点 d1 为根) d2 = d1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d2]) { d2 = u; } } }   法二：树形DP 固定 $1$ 为根。记录每个节点向下，最远能延伸的两个节点的距离 $d_1,d_2$，那么直径就是所有 $d_1+d_2$ 的最大值。\n树形DP：代码 int d1[maxn], d2[maxn], d; // d 是直径的值 void dfs(int u, int p) { d1[u] = d2[u] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); int t = d1[v] + 1; if (t \u0026gt; d1[u]) d2[u] = d1[u], d1[u] = t; else if (t \u0026gt; d2[u]) d2[u] = t; } d = max(d, d1[u] + d2[u]); } int main() { dfs(1, 0); }   例题 例1 CF911F Tree Destruction 题意\n给定一棵 $n$ 个节点的无权树，然后进行 $(n-1)$ 次以下操作，每次操作分以下三步：\n 选择两个leaf 将这两个leaf之间的距离，加到 ans 中。 将这两个leaf其中之一，删掉。  初始状态下，ans = 0。求 ans 的最大值，并且输出方案。\n其中，$2 \\leq n \\leq 2 \\times 10^5$\n 题解 利用树的直径的第二个性质：任意一个节点 $u$，距离最远的一定是直径的一端。\n所以我们要最大化最终答案，我们可以最大化每个节点的贡献。所以我们只要保留直径，先将剩下的叶子删掉就行了。\n思路如下：\n 找到直径 $(u,v)$ 使用类似于拓扑排序的方法，维护所有 deg = 1 的节点（除了直径两端的两个节点 $u,v$），将它们删去。这个过程，本质上是将直径看作树干，然后逐一拔掉所有的树枝。 最后只剩下一条直径了，从任意一端开始删除即可。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, dep[maxn], d1, d2; // d1: 直径一端，d2: 直径另外一端 void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs1(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dep[to] = dep[u] + 1; dfs1(to, u); } } ll ans = 0; struct node { int u,v,r; } path[maxn]; int tail = 0; int deg[maxn]; vector\u0026lt;int\u0026gt; leaf; int dis1[maxn], dis2[maxn]; // 初始化：找出每个节点到 d1, d2的距离 void init() { dep[d1] = 0; dfs1(d1, 0); memcpy(dis1, dep, sizeof(dep)); dep[d2] = 0; dfs1(d2, 0); memcpy(dis2, dep, sizeof(dep)); } // 第一步：拔掉所有除了 d1, d2 以外的叶子 void solve1() { for (int i = 1; i \u0026lt;= n; i++) { if (deg[i] == 1 \u0026amp;\u0026amp; i != d1 \u0026amp;\u0026amp; i != d2) leaf.push_back(i); } while (leaf.size()) { int u = leaf.back(); leaf.pop_back(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; deg[to]--; if (deg[to] == 1) { leaf.push_back(to); } } int t; if (dis1[u] \u0026gt; dis2[u]) t = d1, ans += (ll)dis1[u]; else t = d2, ans += (ll)dis2[u]; path[++tail] = {u,t,u}; } } // 第二步：拔掉直径 void solve2() { leaf.push_back(d2); while (leaf.size()) { int u = leaf.back(); leaf.pop_back(); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; deg[to]--; if (deg[to] == 1) { leaf.push_back(to); } } ans += (ll)(dis1[u]); path[++tail] = {u, d1, u}; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); deg[u]++, deg[v]++; } dep[1] = 0; dfs1(1, 0); d1 = 1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d1]) { d1 = u; } } dep[d1] = 0; dfs1(d1, 0); d2 = d1; for (int u = 1; u \u0026lt;= n; u++) { if (dep[u] \u0026gt; dep[d2]) { d2 = u; } } init(); solve1(); solve2(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n-1; i++) { cout \u0026lt;\u0026lt; path[i].u \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; path[i].v \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; path[i].r \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例2 CF1192B Dynamic Diameter 题意\n给定 $n$ 个节点的有权树，和 $q$ 次询问。\n每次询问格式为 $d ~ e$：将第 $d$ 条边的权值改为 $e$。\n在每次询问之后，回答：此时树中直径的长度。\n其中，$2 \\leq n \\leq 10^5, 1 \\leq q \\leq 10^5$。\n 欧拉序介绍 欧拉序和DFS序不同的地方在于：\n在一个节点 $u$ 访问完它的一个child $v$ 之后，回溯到 $u$ 时，也会将 $u$ 记录进序列中。\n如上图，访问的顺序如果是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 3$ 的话，得到的欧拉序就是：\n$[1,2,4,5,4,2,6,2,1,3,1]$。\n欧拉序有以下性质：\n 对于 $n$ 个节点的树，欧拉序的长度一定为 $2n-1$。 在欧拉序中任取两个index $i,j$，它分别对应的节点是 $u,v$ 的话。在 $[i,j]$ 这段欧拉序中，depth 最小的index 所对应的节点 $x$ 就是 $LCA(u,v)$。  • 例如，我们把上述欧拉序按照 depth 重新写一下，就会得到：[0,1,2,3,2,1,2,1,0,1,0]。\n我们任取其中一段，比如：[0,1,2,3,2,1,2,1,0,1,0]，那么对应的就是 $5,4,2,6$ 这几个节点。可以发现这一段中，depth 最小值为 $1$，对应的节点是 $2$。而这一段的两端，对应的就是节点 $5,6$。这说明 节点 $5,6$ 的 LCA 就是 节点 $2$。\n 证明性质 $1$：易知，每条 edge 会在欧拉序中贡献 $2$ 个位置。而根节点 $1$ 又会额外贡献一个。所以总共是 $2 \\times (n-1) + 1 = 2n-1$。\n证明性质 $2$：设一段欧拉序的两端，对应的节点分别为 $u,v$。令 $x = LCA(u,v)$。那么这一段欧拉序，一定会经过 $x$，且一定是完全在 $x$ 所在的子树内的，不可能出现在子树外的节点。所以 $x$ 一定是这一段 depth 最小的那个节点。\n 法一 欧拉序 题解 有两种方法，一种是 欧拉序，复杂度 $O(n\\log n)$。还有一种是 DFS序，时间复杂度 $O(n\\log^2 n)$。\n这里介绍一下 法一欧拉序。\n 我们固定 $1$ 为根。求出每个节点的 depth。然后求出欧拉序。\n有了欧拉序以后，我们可以用线段树维护这个欧拉序序列。我们设这个序列为 $a[]$。\n然后询问两个节点 $u,v$ 之间的距离，就可以先找到 $u$ 对应在欧拉序中的位置 $l$（可能对应多个位置，任选一个即可），$v$ 对应在欧拉序中的位置 $r$。由树上差分，可知 $u,v$ 的距离等于 $d_u + d_v - 2 \\times d_x$，则有：\n$$dist(u,v) = a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$$\n 所以整个问题可以转化为一个序列上的问题：给定一个数组 $a[]$，求：\n$$a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$$\n的最大值？（其中 $l,r$ 任选）\n这个式子有 $2$ 个变量，$l,r$，我们需要用线段树来维护一些额外信息，来将其转化为一个变量的问题。\n设\n$$D[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[l] + a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]\\}$$\n我们考虑固定其中一个变量（比如 $l$），那么剩下的变量就只有 $r$ 了，我们就可以考虑 $a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k]$。\n设\n$$rmax[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[r] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k] \\}$$\n$$lmax[L,R] = \\max\\limits_{l \\leq r, l,r \\in [L,R]} \\{a[l] - 2 \\times \\min\\limits_{l \\leq k \\leq r}a[k] \\}$$\n则，我们有以下转移方程：\n$$rmax[L,R] = \\max \\begin{cases} rmax[L, mid] \\\\ rmax[mid+1, R] \\\\ max[mid+1,R] - 2\\times min[L, mid] \\end{cases} $$\n$$lmax[L,R] = \\max \\begin{cases} lmax[L, mid] \\\\ lmax[mid+1, R] \\\\ max[L, mid] - 2\\times min[mid+1, R] \\end{cases} $$\n$$D[L,R] = \\max \\begin{cases} D[L, mid] \\\\ D[mid+1, R] \\\\ max[L, mid] + rmax[mid+1, R] \\\\ lmax[L, mid] + max[mid+1, R] \\end{cases} $$\n最后，答案就是 $D[1,2n-1]$。\n 上述转移方程有几个点需要注意：\nQ1. 为什么 $D[L,R]$ 可以由 $max[L, mid] + rmax[mid+1, R]$ 转移而来？$rmax[mid+1, R]$ 并没有考虑到 $[L,mid]$ 这一段中的最小值啊？\nA1. 如果最终答案需要考虑到 $[L,mid]$ 这一段的最小值，那么说明 $D[L,R]$ 应该由 $lmax[L, mid] + max[mid+1, R]$ 或者 $D[L, mid]$ 转移而来。这也说明了为什么我们需要使用 $lmax, rmax$ 进行两次转移。\n• 另外，$rmax[L,R]$ 和 $lmax[L,R]$ 的转移过程同理。\n 最后一个问题：修改边的权值，怎么处理？\n因为我们所有的距离都是基于 depth 的，所以，把修改边的权值改为修改 depth 即可。\n假设有一个边 $(u,v)$，令 $v$ 为 child。设原来的权值为 $e_1$，现在改为 $e_2$，那么就相当于给 $v$ 的 subtree 中的所有节点的 depth 加上 $(e_2 - e_1)$。\n 法二 DFS序 题解 根据树的直径的性质 $3$，我们可以求出整棵树的欧拉序，然后用线段树维护点集的直径。比如 $[5,8]$ 这个区间，维护的就是欧拉序为 $[5,6,7,8]$ 的点集的直径。\n可得，$[1,n]$ 这个点集的直径就是整棵树的直径。\n然后在合并区间 $[L, mid]$ 和 $[mid+1, R]$ 时，就可以枚举 $6$ 种情况的直径长度，得到 $[L,R]$ 对应点集的直径。\n 有几个问题：\nQ1. 怎么得到每种情况的直径长度？\nA1. 和上一个方法一样，固定 $1$ 为根，然后两个节点 $(u,v)$ 之间的距离就可以利用 $d_u + d_v - 2 \\times d_{LCA(u,v)}$ 来求出。\nQ2. 修改权值时，直径会受到影响吗？\nA2. 会的。但是如果我们修改了权值，影响了一个 subtree（在DFS序上就是一段连续区间），则如果一个点集完全存在于这个 subtree 之内，就不会受到影响。我们只需要考虑 点集 与 subtree 拥有相交区间，且点集没有被完全覆盖的情况。这实际上就是线段树 update 过程中正常的 lazy tag 和 push_up() 操作。所以不需要特殊处理，该怎么写怎么写就行。\n 注：本题没有用法二来写，因为本题不需要求出直径具体的节点，只要长度。下一题会使用到法二，代码可以参见下一个例题。\n 法一 欧拉序 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; ll W; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn\u0026lt;\u0026lt;1]; // 欧拉序的 dep int in[maxn], out[maxn]; // in[u]: 节点 u 在欧拉序中的起点 int ori_dep[maxn]; // 原本在树中的depth(不算weight) int id = 0; void dfs(int u, int p, ll d) { dep[++id] = d; in[u] = out[u] = id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; ori_dep[to] = ori_dep[u] + 1; dfs(to, u, d + w); dep[++id] = d; out[u] = id; } } int m; struct tree_node { ll mini, maxi, lmax, rmax, ans; ll lazy = 0; } tr[maxn\u0026lt;\u0026lt;3]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; tr[cur].mini = min(tr[l].mini, tr[r].mini); tr[cur].maxi = max(tr[l].maxi, tr[r].maxi); tr[cur].lmax = max(max(tr[l].lmax, tr[r].lmax), tr[l].maxi - 2LL * tr[r].mini); tr[cur].rmax = max(max(tr[l].rmax, tr[r].rmax), tr[r].maxi - 2LL * tr[l].mini); tr[cur].ans = max(max(tr[l].ans, tr[r].ans), max(tr[l].maxi + tr[r].rmax, tr[r].maxi + tr[l].lmax)); } void push_down(int cur) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[cur].lazy = 0; tr[l].lazy += lazy; tr[r].lazy += lazy; tr[l].maxi += lazy; tr[r].maxi += lazy; tr[l].mini += lazy; tr[r].mini += lazy; tr[l].lmax -= lazy; tr[r].lmax -= lazy; tr[l].rmax -= lazy; tr[r].rmax -= lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].mini = tr[cur].maxi = dep[l]; tr[cur].lmax = tr[cur].rmax = -dep[l]; tr[cur].ans = 0; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, ll x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].maxi += x; tr[cur].mini += x; tr[cur].lmax -= x; tr[cur].rmax -= x; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].ans; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } ll last = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; W; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0, 0); m = 2*n - 1; build(1, 1, m); while (q--) { ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d = (d + last) % (n-1) + 1; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 e = (e + last) % W; ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); update(1, 1, m, in[v], out[v], x); last = query(1, 1, m, 1, m); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 将第 d 条边的 weight 改为 e } }   例3 Lightning Routing I 题意\n给定 $n$ 个节点的有权树，和 $q$ 次询问。\n每次询问有 $2$ 种：\n$C ~ e_i ~ w_i$：将第 $e_i$ 条边的权值改为 $w_i$\n$Q ~ v_i$：询问距离 $v_i$ 最远的节点的距离。\n其中，$1 \\leq n \\leq 10^5, 1 \\leq q \\leq 10^5$。\n 题解 和上一题完全一样。\n需要注意的是 $Q ~ v_i$ 这个询问。由树直径的基本性质，对于任意一个节点 $v$，距离最远的节点一定是直径的其中一端。那么问题可以转化为：\n先求出直径的两端，然后判断一下哪一端距离 $v$ 最远。\n• 这样的话，法一欧拉序就需要在线段树区间合并的时候，加一些额外的信息来 track 具体是哪些index被用到了转移中。\n 法一（欧拉序）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; ll W; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn\u0026lt;\u0026lt;1]; // 欧拉序的 dep int in[maxn], out[maxn]; // in[u]: 节点 u 在欧拉序中的起点 int ori_dep[maxn]; // 原本在树中的depth(不算weight) int id = 0; void dfs(int u, int p, ll d) { dep[++id] = d; in[u] = out[u] = id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; ll w = edges[e].w; ori_dep[to] = ori_dep[u] + 1; dfs(to, u, d + w); dep[++id] = d; out[u] = id; } } int m; struct tree_node { ll mini, maxi, lmax, rmax, ans; ll lazy = 0; int mini_idx, maxi_idx, lmax_idx, rmax_idx, L, R; } tr[maxn\u0026lt;\u0026lt;3]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = l+1; if (tr[l].mini \u0026lt; tr[r].mini) { tr[cur].mini = tr[l].mini; tr[cur].mini_idx = tr[l].mini_idx; } else { tr[cur].mini = tr[r].mini; tr[cur].mini_idx = tr[r].mini_idx; } if (tr[l].maxi \u0026gt; tr[r].maxi) { tr[cur].maxi = tr[l].maxi; tr[cur].maxi_idx = tr[l].maxi_idx; } else { tr[cur].maxi = tr[r].maxi; tr[cur].maxi_idx = tr[r].maxi_idx; } if (tr[l].lmax \u0026gt; tr[r].lmax) { tr[cur].lmax = tr[l].lmax; tr[cur].lmax_idx = tr[l].lmax_idx; } else { tr[cur].lmax = tr[r].lmax; tr[cur].lmax_idx = tr[r].lmax_idx; } if (tr[l].maxi - 2LL * tr[r].mini \u0026gt; tr[cur].lmax) { tr[cur].lmax = tr[l].maxi - 2LL * tr[r].mini; tr[cur].lmax_idx = tr[l].maxi_idx; } if (tr[l].rmax \u0026gt; tr[r].rmax) { tr[cur].rmax = tr[l].rmax; tr[cur].rmax_idx = tr[l].rmax_idx; } else { tr[cur].rmax = tr[r].rmax; tr[cur].rmax_idx = tr[r].rmax_idx; } if (tr[r].maxi - 2LL * tr[l].mini \u0026gt; tr[cur].rmax) { tr[cur].rmax = tr[r].maxi - 2LL * tr[l].mini; tr[cur].rmax_idx = tr[r].maxi_idx; } if (tr[l].ans \u0026gt; tr[r].ans) { tr[cur].L = tr[l].L; tr[cur].R = tr[l].R; tr[cur].ans = tr[l].ans; } else { tr[cur].L = tr[r].L; tr[cur].R = tr[r].R; tr[cur].ans = tr[r].ans; } if (tr[l].maxi + tr[r].rmax \u0026gt; tr[cur].ans) { tr[cur].ans = tr[l].maxi + tr[r].rmax; tr[cur].L = tr[l].maxi_idx; tr[cur].R = tr[r].rmax_idx; } if (tr[r].maxi + tr[l].lmax \u0026gt; tr[cur].ans) { tr[cur].ans = tr[r].maxi + tr[l].lmax; tr[cur].L = tr[l].lmax_idx; tr[cur].R = tr[r].maxi_idx; } } void push_down(int cur) { if (!tr[cur].lazy) return; ll lazy = tr[cur].lazy; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[cur].lazy = 0; tr[l].lazy += lazy; tr[r].lazy += lazy; tr[l].maxi += lazy; tr[r].maxi += lazy; tr[l].mini += lazy; tr[r].mini += lazy; tr[l].lmax -= lazy; tr[r].lmax -= lazy; tr[l].rmax -= lazy; tr[r].rmax -= lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].mini = tr[cur].maxi = dep[l]; tr[cur].lmax = tr[cur].rmax = -dep[l]; tr[cur].ans = 0; tr[cur].mini_idx = tr[cur].maxi_idx = tr[cur].lmax_idx = tr[cur].rmax_idx = tr[cur].L = tr[cur].R = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, ll x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].maxi += x; tr[cur].mini += x; tr[cur].lmax -= x; tr[cur].rmax -= x; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].ans; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } ll query_min(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].mini; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; ll r1 = 1e18, r2 = 1e18; if (L \u0026lt;= mid) r1 = query_min(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) r2 = query_min(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return min(r1, r2); } ll dis(int l, int r) { if (l \u0026gt; r) swap(l,r); ll al = query_min(1, 1, m, l, l), ar = query_min(1, 1, m, r, r); ll mi = query_min(1, 1, m, l, r); return al + ar - 2LL * mi; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0, 0); m = 2*n - 1; assert(id == m); build(1, 1, m); cin \u0026gt;\u0026gt; q; while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == 'C') { // 将第 d 条边的 weight 改为 e ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); update(1, 1, m, in[v], out[v], x); } else { int v; cin \u0026gt;\u0026gt; v; v = in[v]; int L = tr[1].L, R = tr[1].R; ll dis1 = dis(L, v); ll dis2 = dis(v, R); cout \u0026lt;\u0026lt; max(dis1, dis2) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   法二（DFS序）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e6; struct Edge { int from, to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 2, n, q; void addEdge(int u, int v, ll w) { Edge e = {u, v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } ll dep[maxn]; int par[maxn][19], idcnt = 0, in[maxn], out[maxn], ver[maxn]; // in[u] ..., ver[id]: the id which corresponds to u int ori_dep[maxn]; // 原本在树中的depth(不算weight) void dfs(int u, int p) { in[u] = ++idcnt; ver[idcnt] = u; par[u][0] = p; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; ll w = edges[e].w; if (to == p) continue; ori_dep[to] = ori_dep[u] + 1; dep[to] = dep[u] + w; dfs(to, u); } out[u] = idcnt; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 18; j++) { if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } int lca(int u, int v) { if (ori_dep[u] \u0026lt; ori_dep[v]) swap(u,v); u = jump(u, ori_dep[u] - ori_dep[v]); for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } if (u == v) return u; return par[u][0]; } struct tree_1 { struct tree_node_1 { ll d = 0, lazy = 0; }; tree_node_1 tr[maxn\u0026lt;\u0026lt;2]; void build(int cur, int l, int r) { if (l == r) { tr[cur].d = dep[ver[l]]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); } void push_down(int cur) { if (!tr[cur].lazy) return; int l = cur\u0026lt;\u0026lt;1, r = l|1; ll lazy = tr[cur].lazy; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].d += lazy, tr[r].d += lazy; tr[cur].lazy = 0; } void update(int cur, int l, int r, int L, int R, ll delta) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += delta; tr[cur].d += delta; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, delta); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, delta); } ll query(int cur, int l, int r, int p) { if (l == r) return tr[cur].d; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(cur\u0026lt;\u0026lt;1, l, mid, p); return query(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } ll query_dis(int id1, int id2) { ll d1 = query(1, 1, n, id1), d2 = query(1, 1, n, id2); ll u1 = ver[id1], u2 = ver[id2]; ll x = lca(u1, u2); int idx = in[x]; ll dx = query(1, 1, n, idx); return d1 + d2 - 2LL * dx; } } tr1; struct tree_2 { struct tree_node_2 { int id1, id2; // 直径的 id }; tree_node_2 tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; int l_id1 = tr[l].id1, l_id2 = tr[l].id2, r_id1 = tr[r].id1, r_id2 = tr[r].id2; ll len = -1; ll dis1 = tr1.query_dis(l_id1, r_id1); ll dis2 = tr1.query_dis(l_id1, r_id2); ll dis3 = tr1.query_dis(l_id2, r_id1); ll dis4 = tr1.query_dis(l_id2, r_id2); ll dis5 = tr1.query_dis(l_id1, l_id2); ll dis6 = tr1.query_dis(r_id1, r_id2); if (dis1 \u0026gt; len) tr[cur] = {l_id1, r_id1}, len = dis1; if (dis2 \u0026gt; len) tr[cur] = {l_id1, r_id2}, len = dis2; if (dis3 \u0026gt; len) tr[cur] = {l_id2, r_id1}, len = dis3; if (dis4 \u0026gt; len) tr[cur] = {l_id2, r_id2}, len = dis4; if (dis5 \u0026gt; len) tr[cur] = {l_id1, l_id2}, len = dis5; if (dis6 \u0026gt; len) tr[cur] = {r_id1, r_id2}, len = dis6; } void build(int cur, int l, int r) { if (l == r) { tr[cur].id1 = tr[cur].id2 = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return; // 完全覆盖不用更新 int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); } } tr2; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dfs(1, 0); tr1.build(1, 1, n); tr2.build(1, 1, n); cin \u0026gt;\u0026gt; q; while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == 'C') { // 将第 d 条边的 weight 改为 e ll d,e; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; d \u0026lt;\u0026lt;= 1; // 编号从 2 开始 ll x = e - edges[d].w; edges[d].w = edges[d^1].w = e; int u = edges[d].from, v = edges[d].to; if (ori_dep[u] \u0026gt; ori_dep[v]) swap(u,v); tr1.update(1, 1, n, in[v], out[v], x); tr2.update(1, 1, n, in[v], out[v]); } else { int v; cin \u0026gt;\u0026gt; v; v = in[v]; // v 的 id 编号 int id1 = tr2.tr[1].id1, id2 = tr2.tr[1].id2; ll dis1 = tr1.query_dis(id1, v); ll dis2 = tr1.query_dis(v, id2); cout \u0026lt;\u0026lt; max(dis1, dis2) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   参考链接  https://www.luogu.com.cn/problem/solution/P6845  ","date":"2021-04-18T15:34:17+08:00","permalink":"https://tom0727.github.io/post/043-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","tags":["树论","树的直径"],"title":"树的直径"},{"categories":["算法"],"contents":"定义 分层图最短路一般用于解决一种特殊的最短路问题：\n给定一个图，在图上可以进行 $k$ 次决策（一般 $k \\leq 10$），每次决策并不影响图的结构，只会影响目前的状态/代价。\n一般可以将决策前的状态 和 决策后的状态 连接一条边，权值为决策代价。\n总体来说，套路如下：\n 给定 $k$ 次决策，将图复制成 $k+1$ 份，分别表示在进行了第 $i$ 次决策后的状态，每一份复制是一层图。 从第 $i$ 层，连单向边到第 $i+1$ 层。（有的时候并不需要专门连边，可以在跑最短路的时候顺便转移状态） 跑最短路。  例题 例1 洛谷P4568 [JLOI2011]飞行路线 题意\n给定 $n$ 个节点，$m$ 条边的无向连通图，每个边具有一个权值。\n现给出一个整数 $k$，代表我们可以免费走过最多 $k$ 条边。\n给出起点 $s$ 和终点 $t$，求 $s$ 到 $t$ 的最短路？\n其中，$2 \\leq n \\leq 10^4, 1 \\leq m \\leq 5 \\times 10^4, 0 \\leq k \\leq 10$\n 题解 分层图模版题。\n我们建立 $k+1$ 层图，当我们位于 第 $j$ 层的 $i$ 节点时，代表我们此时走到了节点 $i$，已经用掉了 $j$ 次免费机会。\n建图时：（实际上并不需要建图，跑dijkstra的时候顺便转移即可）\n 同一层的权值就和原图一样。 从 第 $i$ 层，连单向边到第 $i+1$ 层的权值为 $0$。  然后跑一下Dijkstra就可以了。\n Dijkstra 有以下几个注意的点：\n priority_queue\u0026lt;node\u0026gt; pq;，直接定义 node 的 operator\u0026lt; 函数即可，但是要注意一些细节，如下： struct node { int u, k, d; // 1. 注意，两个const都需要 // 2. pq默认是大顶，所以要反过来用 \u0026gt; bool operator\u0026lt;(const node\u0026amp; other) const { return d \u0026gt; other.d; } }; priority_queue\u0026lt;node\u0026gt; pq;   Dijkstra使用了一个 int dis[maxn][11] 数组，这是需要在 push() 时更新的，而不是 pop() 时才更新。在 push() 之前先看一下 dis 是否比当前的小，如果小，才 push()。这大大减少了pq 内的元素数量。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e4+5; const int maxm = 5e4+5; int dis[maxn][11], head[maxn], ecnt = 1; bool vis[maxn][11]; struct Edge { int to, nxt, w; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int w) { Edge e = {v, head[u], w}; edges[ecnt] = e; head[u] = ecnt++; } struct node { int u, k, d; // 注意，两个const都需要 // pq默认是大顶，所以要反过来用 \u0026gt; bool operator\u0026lt;(const node\u0026amp; other) const { return d \u0026gt; other.d; } }; priority_queue\u0026lt;node\u0026gt; pq; int n,m,K,s,t; void dijkstra() { pq.push({s, 0, 0}); while (!pq.empty()) { node cur = pq.top(); pq.pop(); int u = cur.u, k = cur.k, d = cur.d; if (vis[u][k]) continue; vis[u][k] = 1; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to, w = edges[e].w; if (dis[to][k] \u0026gt; d + w) { // 同一层 dis[to][k] = d + w; pq.push({to, k, d + w}); } if (k+1 \u0026lt;= K \u0026amp;\u0026amp; dis[to][k+1] \u0026gt; d) { // 下一层 dis[to][k+1] = d; pq.push({to, k+1, d}); } } } } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; fill(head, head+maxn, -1); memset(dis, 63, sizeof(dis)); while (m--) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } dijkstra(); int ans = 1e9; for (int k = 0; k \u0026lt;= K; k++) ans = min(ans, dis[t][k]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 洛谷P3119 [USACO15JAN]Grass Cownoisseur G 见 强连通分量（SCC）的这里\n","date":"2021-04-17T22:38:10+08:00","permalink":"https://tom0727.github.io/post/042-%E5%88%86%E5%B1%82%E5%9B%BE/","tags":["分层图","最短路"],"title":"分层图最短路"},{"categories":["算法"],"contents":"定义 割点 在一个 无向图 中，如果删掉节点 $u$ 使得整个图的连通分量增加，那么 $u$ 是一个割点。\n桥 在一个 无向图 中，如果删掉一条边 $(u,v)$ 使得整个图的连通分量增加，那么 $(u,v)$ 是一个桥。\n 点双连通 一个 无向图 是 点双连通 的，当且仅当（以下表达是 equivalent 的）：\n 如果删去任意一个节点，其他节点仍然互相连通。 不包含割点（注意，这个割点是对于 这个子图 而言）。 任取两个点 $u,v$，$u,v$ 之间都存在两条 点不重复 路径。 任取 $2$ 条边，都存在一个简单环（环内不包含其他环），使得这 $2$ 条边在这个简单环内。  • 注意，如果图内只有 $2$ 个连起来的节点，它们仍然点双连通。\n• 点双连通 不具有传递性：\n如上图，$a,b$ 点双连通，$b,c$ 点双连通，但是 $a,c$ 并不点双连通（$a,c$ 不在同一个点双分量内）。\n 边双连通 一个 无向图 是 边双连通 的，当且仅当（以下表达是 equivalent 的）：\n 一个 无向图 中，如果删去任意一条边，其他节点仍然互相连通。 一个 无向图 中，不包含桥（注意，这个桥是对于 整个图 而言）。 一个 无向图 中，任取两个点 $u,v$，$u,v$ 之间都存在两条 边不重复 路径。 一个 无向图 中，任取 $1$ 条边，都存在一个简单环（环内不包含其他环），使得这条边在这个简单环内。  • 点双连通 具有传递性：\n如果 $a,b$ 边双连通，$b,c$ 边双连通，则 $a,c$ 边双连通。\n证明：$a,b$ 边双连通说明 删去图中任意一条边，$a,b$ 仍连通。同理，删去图中任意一条边，$b,c$ 仍连通。所以删去任意一条边，$a,c$ 仍连通。\n 点双连通分量 点双连通分量：一个极大的点双连通的子图。\n 如果把这个子图 单独拿出来，它不存在割点，但是它在原图中，如果它与其他点双分量相连，那么它一定包含 至少一个原图中的割点。 原图中，每个割点 存在于至少 $2$ 个点双分量中。 任意一个 非割点 只存在于一个点双分量中。  点双缩点 利用点双缩点后，得到的新图有以下性质：\n 新图 是一棵树，每个节点要么是一个点双，要么是一个割点。 所有 割点 单独成为一个节点。 点双之间以 割点 相连，并且所有割点的 degree 至少为 $2$。（任意两个点双之间，有且仅有一个公共点，且这个公共点是 割点）。  例1：\n图中的所有点双分量为：$\\{1,2,3\\}, \\{3,4,5\\}$\n图中所有割点为：$3$\n例2：\n图中的所有点双分量为：$\\{1,2\\}, \\{1,3\\}, \\{2,4\\}, \\{2,5\\}, \\{3,6\\}, \\{3,7\\}$\n图中所有割点为：$1,2,3$\n 边双连通分量 边双连通分量：一个极大的边双连通子图。\n相比点双分量来说，边双分量的定义简单很多，因为它 不需要区分 原图和子图！\n 将原图中的所有桥删掉，剩下的分量就是边双连通分量。 桥不属于任何一个边双分量，边双分量之间以桥连接。  例1：\n图中的所有边双分量为：$\\{1,2,7\\}, \\{4,5,6\\}, \\{3\\}$\n图中所有桥为：$(2,3), (2,4)$\n边双缩点 利用边双缩点后，得到的新图有以下性质：\n 新图是 一棵树，每个节点都是一个边双。 原图中 所有的桥，在新图中仍然是桥。   算法 我们利用 tarjan 算法求 割点，桥，点双，边双。\n这里的 tarjan 和 有向图求SCC 的tarjan略有不同，主要体现在：\n 有向图tarjan求SCC：需要记录当前在 栈内 的有哪些元素，更新 low[] 时，需要 to 在栈内才更新。 无向图求割点/桥/点双/边双：需要检查 to 是不是 u 的直接 parent p。（这里指的是 dfs树 内的parent关系），不需要考虑是否在栈内。  另外，求 割点 和 桥 时，也略有不同，主要体现在：\n 求割点时，需要讨论当前节点是否为DFS树的根。但是求桥时，不需要。 求割点时，条件是 $low[to] \\geq dfn[u]$。求桥时，条件是 $low[to] \u0026gt; dfn[u]$。   以下的算法，都要检查 to 是不是 u 的直接 parent p。\n割点 对于一个节点 $u$，在DFS树中，如果：\n 它是DFS树的 根节点：如果 $u$ 拥有 $\\geq 2$ 个子树，那么 $u$ 就是一个割点。 它不是DFS树的 根节点：如果 $u$ 存在一个 direct child $~to$，使得 $low[to] \\geq dfn[u]$。那么 $u$ 就是一个割点。（因为这说明 $to$ 无法到达 $u$ 的上方）  模版题\n题意\n给定一个无向图，求图的所有割点。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e4+5; const int maxm = 1e5+10; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; int dfn[maxn], low[maxn], head[maxn], ecnt = 1, n, m, id; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } vector\u0026lt;int\u0026gt; ans; void dfs(int u, int p) { dfn[u] = ++id; low[u] = id; int child = 0; // 子树数量 bool cut = 0; // 是否为割点 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // 不能直接用parent if (dfn[to]) { low[u] = min(low[u], dfn[to]); continue; } dfs(to, u); child++; low[u] = min(low[u], low[to]); if (p \u0026amp;\u0026amp; low[to] \u0026gt;= dfn[u]) cut = 1; // 如果u不是根节点，且存在 direct child使得 low[to] \u0026gt;= dfn[u]，则u是割点 } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut = 1; // 如果为根节点，且有 \u0026gt;= 2个子树 if (cut) ans.push_back(u); } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i, 0); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } tarjan(); sort(ans.begin(), ans.end()); cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int a : ans) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   桥 判断一个边 $(u,to)$ 是不是桥，我们设 $u$ 在DFS树中，是 $to$ 的parent。\n如果 $low[to] \u0026gt; dfn[u]$，则 $(u,to)$ 是一个桥。（因为这说明 $to$ 无法到达 $u$ 和 $u$ 的上方）。\n 实现过程中，需要注意以下几点：\n 边的编号从 $0$ 开始（记得将 head[] 初始化为 -1），这样保证了 e 和 e^1 刚好为 $(u,v)$ 和 $(v,u)$。 标记桥的时候，一次标记两个边 e 和 e^1。  代码 void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // 注意不能用parent if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { // 注意这里的条件 bridge[e] = bridge[e^1] = 1; } } } }   点双连通分量（dcc） 求点双分量，可以在求割点的时候顺便求出来。\n当我们发现 $low[to] \\geq dfn[u]$ 时，就说明 $to$ 及其子树（加上 $u$）一起形成了一个点双。\n此时，我们将 栈内的点一直pop，pop 到 to 为止（包括 to），但是 不包括 u。这是因为 u 作为割点，可能还属于别的点双分量，之后还要用到。\n• 求点双时，我们并不关心 $u$ 本身是否为割点，只要出现了 $low[to] \\geq dfn[u]$，就说明出现了一个新点双。（例如，在只有 $1,2$ 这两个点的情况下，不存在割点，但是 $1,2$ 仍然是一个点双）。\n代码 int dfn[maxn], low[maxn], id, st[maxn], tail = -1, from[maxn], dcc; bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn]; void dfs(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) { low[u] = min(low[u], dfn[to]); } else { child++; dfs(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { from[to] = ++dcc; while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to） int cur = st[tail--]; from[cur] = from[to]; dcc_list[dcc].push_back(cur); } tail--; // tail--后，指向的是 u dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量 // from[u] = dcc; // from[u] 实际上没有意义 } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) cut[u] = 1; // 割点（非根节点） } } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut[u] = 1; // 割点（根节点） } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i, 0); } } void rebuild() { for (int i = 1; i \u0026lt;= dcc; i++) { for (int j : dcc_list[i]) { if (cut[j]) cut_from[j].push_back(i); } } for (int u = 1; u \u0026lt;= n; u++) { if (cut[u]) { int fu = from[u] = ++dcc; mp[dcc] = u; dcc_list[dcc].push_back(u); for (int fv : cut_from[u]) { adj[fu].push_back(fv); adj[fv].push_back(fu); } } } }   边双连通分量（ecc） 求边双分量，可以根据定义：删去所有的桥，剩下的连通分量，就是边双分量。\n所以求边双分量，分以下两步：\n tarjan 求出所有的桥。 进行一次 dfs()，如果 $(u,to)$ 是桥，则不经过这条边。以此求出所有的连通分量。  代码 int n,m, head[maxn], ecnt = 0, dfn[maxn], low[maxn], id = 0, from[maxn], ecc = 0; bool bridge[maxm\u0026lt;\u0026lt;1]; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { bridge[e] = bridge[e^1] = 1; } } } } // f 代表 from (ecc编号) void dfs(int u, int f) { from[u] = f; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥 dfs(to, f); } } vector\u0026lt;int\u0026gt; adj[maxn]; void rebuild() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; ~e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; adj[fu].push_back(fv); } } } int main() { // ... tarjan(1, 0); for (int i = 1; i \u0026lt;= n; i++) if (!from[i]) dfs(i, ++ecc); rebuild(); // ... }   例题 例1 洛谷P3225 [HNOI2012]矿场搭建 题意\n给定 $M$ 条边的无向图。初始状态下，每个节点没有标记。\n我们需要给节点打上标记，使得：\n删去图中的任意一个节点，其他的所有节点均可到达一个有标记的节点。\n求：标记节点的最少数量，最少标记数量的方案总数。\n其中，$M \\leq 500$，数据保证不存在单个独立点。\n 题解 首先根据 点双连通 进行缩点。缩点以后，整个图会变成一个由 割点 和 点双分量 组成的 树。\n由于点双的性质，我们知道，如果删去点双分量中的任意一个点（除割点以外），该分量仍然和其他的分量连通。\n所以我们不需要考虑删去 非割点 的情况，我们只关心如果删去了一个 割点，会不会使得有些节点无法到达有标记的节点。\n由上可知，我们 不需要标记割点（因为我们只考虑删去 割点 的情况，如果要删去割点，那说明标记割点是无意义的）。\n 对于一个点双分量而言，可以分以下情况讨论：\n 点双内含有 $\\geq 2$ 个割点：无论删去哪个割点，该分量仍然和其他分量连通，所以无需在该分量内标记。 点双内含有 $1$ 个割点：如果该割点被删了，那么这个分量就断开了，所以该分量内部需要标记 $1$ 个节点。（不标记割点），方案数为 $(sz-1)$ （因为分量里面有一个割点，要去掉标记它的可能性）。 点双内没有割点：说明这个分量本来就是独立开的（在缩点后，是单个独立节点）。所以该分量内需要标记 $2$ 个节点。方案数为 $C_{sz}^2$。   实现中的一些细节：\n 由于一个割点可能属于多个点双分量，所以我们采用 vector\u0026lt;int\u0026gt; dcc_list[maxn]; 来记录每个点双里面的节点。 对于一个割点 $u$ 来说，它的 from[] 数组没有意义。（如果需要缩点，则后续会让 from[u] = ++dcc，缩点后的 from[u] 就有意义了） 与 tarjan 求 SCC 不同，我们不需要记录节点是否在栈内。 在 pop 栈的时候，注意我们是 pop 到 to 为止（包括 to），但是 不包括 u。这是因为 u 作为割点，可能还属于别的点双分量，之后还要用到。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; int n,m, head[maxn], ecnt = 1; struct Edge { int to, nxt; } edges[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int dfn[maxn], low[maxn], id, st[maxn], tail = -1, from[maxn], dcc; bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn]; void dfs(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) { low[u] = min(low[u], dfn[to]); } else { child++; dfs(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { from[to] = ++dcc; while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to） int cur = st[tail--]; from[cur] = from[to]; dcc_list[dcc].push_back(cur); } tail--; // tail--后，指向的是 u dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量 // from[u] = dcc; // from[u] 实际上没有意义 } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) cut[u] = 1; // 割点（非根节点） } } if (!p \u0026amp;\u0026amp; child \u0026gt;= 2) cut[u] = 1; // 割点（根节点） } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i, 0); } } void init() { for (int i = 1; i \u0026lt;= dcc; i++) dcc_list[i].clear(); id = 0; tail = -1; dcc = 0; n = 0; ecnt = 1; fill(cut, cut+maxn, 0); fill(from, from+maxn, 0); fill(head, head+maxn, 0); fill(dfn, dfn+maxn, 0); fill(low, low+maxn, 0); } void solve(int T) { init(); for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; n = max(n,u); n = max(n,v); addEdge(u,v); addEdge(v,u); } tarjan(); int ans1 = 0; ll ans2 = 1; for (int i = 1; i \u0026lt;= dcc; i++) { int cut_cnt = 0; int sz = dcc_list[i].size(); for (int j = 0; j \u0026lt; dcc_list[i].size(); j++) { int cur = dcc_list[i][j]; if (cut[cur]) cut_cnt++; } if (cut_cnt \u0026gt;= 2) continue; if (cut_cnt == 1) ans1++, ans2 *= (ll)(sz - 1); if (cut_cnt == 0) ans1+=2, ans2 *= (ll)(sz) * (ll)(sz-1LL) / 2LL; } printf(\u0026quot;Case %d: %d %lld\\n\u0026quot;, T, max(ans1, 2), ans2); } int main() { int T = 0; while (cin \u0026gt;\u0026gt; m \u0026amp;\u0026amp; m) { T++; solve(T); } }   例2 洛谷P5058 [ZJOI2004]嗅探器 题意\n现有 $n$ 个节点的无向图。\n给定两个节点 $a,b$，输出 最小编号的 $u$ 使得 $a,b$ 之间所有的路径都需要经过 $u$，且 $u \\neq a, u \\neq b$。\n如果无解，则输出 \u0026ldquo;No solution\u0026rdquo;。\n 题解 先点双缩点，如果 $a,b$ 在同一个点双内必然无解（根据定义，大小等于 $3$ 的点双内，任意两点之间有点不重复的路径）。\n如果 $a,b$ 在不同的点双内则说明有解，缩点后，$a,b$ 就是树上的两个节点，它们之间有唯一路径，取这个路径上编号最小的割点即可。\n 一些注意事项：\n 每个割点单独形成一个点双。 缩点得到的树，所有的边必然和 割点 相连，所以建边的时候只需要考虑割点所在的dcc，还有它旁边有哪些dcc就可以了。本题中在缩点建树的过程中，使用了数组 vector\u0026lt;int\u0026gt; cut_from[maxn];。其中 cut_from[u] 代表以 $u$ 作为割点，它neighbor的dcc编号。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 5e5+5; int n,a,b,head[maxn],ecnt = 0; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int dfn[maxn], low[maxn], dcc = 0, id = 0, st[maxn], from[maxn], tail = -1; bool cut[maxn]; vector\u0026lt;int\u0026gt; dcc_list[maxn\u0026lt;\u0026lt;1]; vector\u0026lt;int\u0026gt; cut_from[maxn]; // cut_from[u] 代表以 u 作为割点，它neighbor的dcc编号 void tarjan(int u, int p) { dfn[u] = low[u] = ++id; st[++tail] = u; int child = 0; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { child++; tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt;= dfn[u]) { from[u] = ++dcc; while (st[tail] != to) { int cur = st[tail--]; from[cur] = from[u]; dcc_list[dcc].push_back(cur); } tail--; from[to] = from[u]; dcc_list[dcc].push_back(to); dcc_list[dcc].push_back(u); } if (low[to] \u0026gt;= dfn[u] \u0026amp;\u0026amp; p) { cut[u] = 1; } } } if (child \u0026gt;= 2 \u0026amp;\u0026amp; !p) cut[u] = 1; } vector\u0026lt;int\u0026gt; adj[maxn\u0026lt;\u0026lt;1]; // 缩点后的图 int par[maxn\u0026lt;\u0026lt;1], dep[maxn\u0026lt;\u0026lt;1]; // 缩点后，dfs树用到的数组 int mp[maxn\u0026lt;\u0026lt;1]; // map: dcc -\u0026gt; cut vertex id (只有该dcc对应的是 单个割点形成的 dcc才有用) void dfs(int u, int p) { par[u] = p; dep[u] = dep[p] + 1; for (int to : adj[u]) { if (to == p) continue; dfs(to, u); } } int ans = 1e9; void LCA(int u, int v) { int f1 = mp[u], f2 = mp[v]; if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; vector\u0026lt;int\u0026gt; path; while (d--) { path.push_back(u); u = par[u]; } path.push_back(u); while (u != v) { path.push_back(u); path.push_back(v); u = par[u], v = par[v]; } path.push_back(u); path.push_back(v); for (int c : path) { if (mp[c] == f1 || mp[c] == f2) continue; if (cut[mp[c]]) ans = min(ans, mp[c]); } } void rebuild() { for (int i = 1; i \u0026lt;= dcc; i++) { for (int j : dcc_list[i]) { if (cut[j]) cut_from[j].push_back(i); } } for (int u = 1; u \u0026lt;= n; u++) { if (cut[u]) { int fu = from[u] = ++dcc; mp[dcc] = u; dcc_list[dcc].push_back(u); for (int fv : cut_from[u]) { adj[fu].push_back(fv); adj[fv].push_back(fu); } } } } int main() { cin \u0026gt;\u0026gt; n; int u,v; fill(head, head+maxn, -1); while (cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026amp;\u0026amp; u \u0026amp;\u0026amp; v) { addEdge(u,v); addEdge(v,u); } cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) tarjan(i,0); } rebuild(); for (int i = 1; i \u0026lt;= dcc; i++) { if (!dep[i]) dfs(i,0); } LCA(from[a], from[b]); if (ans == 0 || ans == 1e9) cout \u0026lt;\u0026lt; \u0026quot;No solution\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 POJ3694 Network 题意\n给定 $N$ 个节点和 $M$ 条边的无向图，初始图是连通的。\n现在要加 $Q$ 条边（可重复），每次加边后，回答图中有多少个桥。\n其中，$1 \\leq N \\leq 10^5, N-1 \\leq M \\leq 2 \\times 10^5, 1\\leq Q \\leq 1000$\n 题解 既然是桥，那么就直接先求一个边双，然后缩点。\n边双缩点后可以得到一棵树，所有加边操作都放到这个树上来考虑。\n首先会发现，加上的新边必不可能是桥（因为图原本是连通的）。\n每次加边 $(u,v)$，如果 $u,v$ 在同一个边双里，那么不会有任何影响。\n如果 $u,v$ 不在同一个边双里，那么加上的这条新边就会在树上形成一个环，使得环内的所有边均 不再是桥。\n 那么，回忆一下 AcWing 352 暗之连锁 中，我们可以将树边看作主要边，新加上的边就转化为主要边。\n比如，我们加上 $(u,v)$，那么就给 $u,v$ 之间路径上所有的边打一个标记。被标记过的就不是桥，没标记的就都是桥。\n然而树上差分的做法只适用于离线，只有所有修改操作结束后询问才有效。\n在线的做法我们可以利用 树链剖分（询问边），每次修改前，先进行一下询问，查询有多少个在修改前是无标记的，将答案减去这个数量即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n,m, head[maxn], ecnt = 0, dfn[maxn], low[maxn], id = 0, from[maxn], ecc = 0; bool bridge[maxm\u0026lt;\u0026lt;1]; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { bridge[e] = bridge[e^1] = 1; } } } } // f 代表 from (ecc编号) void dfs(int u, int f) { from[u] = f; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥 dfs(to, f); } } vector\u0026lt;int\u0026gt; adj[maxn]; void rebuild() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; ~e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; adj[fu].push_back(fv); } } } int sz[maxn], son[maxn], top[maxn], tr_id[maxn]; int par[maxn][20], dep[maxn]; void dfs2(int u, int p) { sz[u] = 1; dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; int maxsz = -1; for (int i = 0; i \u0026lt; adj[u].size(); i++) { int to = adj[u][i]; if (to == p) continue; dfs2(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) maxsz = sz[to], son[u] = to; } } void dfs3(int u, int p, int topf) { top[u] = topf; tr_id[u] = ++id; if (son[u]) dfs3(son[u], u, topf); for (int i = 0; i \u0026lt; adj[u].size(); i++) { int to = adj[u][i]; if (to == p || to == son[u]) continue; dfs3(to, u, to); } } struct tree_node { int sum; bool lazy; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void push_down(int cur) { if (!tr[cur].lazy) return; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy = tr[r].lazy = 1; tr[l].sum = tr[r].sum = 0; } void update(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = 1; tr[cur].sum = 0; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].sum; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } void build_tree(int cur, int l, int r) { if (l == r) { tr[cur].sum = 1; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build_tree(cur\u0026lt;\u0026lt;1, l, mid); build_tree(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } int jump(int u, int d) { int j = 0; while (d) { if (d\u0026amp;1) u = par[u][j]; j++, d \u0026gt;\u0026gt;= 1; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; u = jump(u, d); if (u == v) return u; for (int j = 19; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } int curans; void update_path_helper(int u, int v) { if (v == -1) return; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); curans -= query(1, 2, ecc, tr_id[top[u]], tr_id[u]); update(1, 2, ecc, tr_id[top[u]], tr_id[u]); u = par[top[u]][0]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); curans -= query(1, 2, ecc, tr_id[u], tr_id[v]); update(1, 2, ecc, tr_id[u], tr_id[v]); } void update_path(int u, int v) { int x = LCA(u,v); int d,ux,vx; d = dep[u] - dep[x]; if (!d) ux = -1; else ux = jump(u, d-1); d = dep[v] - dep[x]; if (!d) vx = -1; else vx = jump(v, d-1); update_path_helper(u, ux); update_path_helper(v, vx); } void clearall() { fill(head, head+n+1, -1); fill(dfn, dfn+n+1, 0); fill(low, low+n+1, 0); fill(from, from+n+1, 0); fill(bridge, bridge+(m\u0026lt;\u0026lt;1)+2, 0); fill(sz, sz+ecc+1, 0); fill(son, son+ecc+1, 0); fill(top, top+ecc+1, 0); fill(tr_id, tr_id+ecc+1, 0); for (int i = 1; i \u0026lt;= 4*ecc+5; i++) tr[i].lazy = 0; for (int i = 1; i \u0026lt;= ecc; i++) for (int j = 0; j \u0026lt;= 19; j++) par[i][j] = 0; fill(dep, dep+ecc+1, 0); for (int i = 1; i \u0026lt;= n; i++) adj[i].clear(); ecnt = id = ecc = 0; } int main() { fastio; int T = 0; fill(head, head+maxn, -1); while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { T++; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } tarjan(1, 0); for (int i = 1; i \u0026lt;= n; i++) { if (!from[i]) dfs(i, ++ecc); } rebuild(); id = 0; dfs2(1, 0); dfs3(1, 0, 1); curans = ecc-1; cout \u0026lt;\u0026lt; \u0026quot;Case \u0026quot; \u0026lt;\u0026lt; T \u0026lt;\u0026lt; \u0026quot;:\\n\u0026quot;; int Q; cin \u0026gt;\u0026gt; Q; if (ecc == 1) { while (Q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } else { build_tree(1, 2, ecc); while (Q--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; update_path(from[u],from[v]); cout \u0026lt;\u0026lt; curans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } clearall(); } }   例4 Universal Cup 9 B. Kawa Exam 题意\n给定一个无向图，有 $n$ 个点和 $m$ 条边。每个点有一个颜色 $a_i$。\n现在对于每条边，回答以下问题：\n如果断开这条边后，统计所有的连通分量，对于每个连通分量，如果这个连通分量中出现次数最多的颜色的出现次数为 $x$，将答案加上 $x$。\n对于每条边，都回答这个 ans。\n其中，$1 \\leq n,m,a_i \\leq 10^5$。\n 题解 首先无向图中，考虑断开一条边对连通分量的影响。\n如果断开边对联通分量有影响，说明这条边是一个桥。否则的话答案不变。\n于是我们先求出边双，然后缩点，就可以得到一棵森林。\n对于每一个联通分量，缩点后都是一棵树，那么有影响的边一定是某棵树上的一条边（这些边都一定是桥）。\nok，现在缩点完毕以后，问题变成断开一棵树上的边，得到两个新的连通分量，对答案有什么影响？\n注意到，得到的两个连通分量是一棵子树，和子树外面的部分，我们可以用树上启发式合并，求出每棵子树对应的信息（指子树中，出现次数最多的颜色的出现次数）。\n那么子树外面的部分的信息怎么办？注意到我们可以先把整棵树的信息加上，然后减去子树的贡献，这其实也能用树上启发式合并，只不过符号从 $+$ 变成 $-$ 罢了。\n • 在启发式合并中，我们会遇到如下的问题：\n 给定一棵子树，我们要将这个子树对颜色数量的贡献减掉，每减掉一个节点，$O(1)$ 计算当前出现次数最多的颜色的出现次数。\n 首先，加上的话很好写，拿全局数组 cnt[] 维护，每次加一个节点的时候更新 mxcnt = max(mxcnt, cnt[a[x]]); 即可。\n如果是减去呢？我们可以利用 cnt[] 数组的 count 数组！\n举个例子，一棵子树里有颜色 $1,1,1,2,2$，那么我们开一个 cnt[] 数组，就有 cnt = [3,2]（cnt[1] = 3 代表颜色 $1$ 有3个）。\n那么我们对 cnt[] 数组再求一次 count数组，叫 oc[]，就有 oc = [0, 1, 1]（cnt[2] = 1 代表数字 $2$ 出现了一次，cnt[3] = 1 代表数字 $3$ 出现了一次）。\n我们记录此时 mxcnt = 3（出现次数最多的颜色是 $1$，出现了3次），那么其实 mxcnt 也就等于最大的 $i$，使得 oc[i] \u0026gt; 0。\n现在，假设我们删掉了一个颜色 $1$，得到 $1,1,2,2$，那么此时 cnt = [2,2]，就有 oc = [0,2,0]，那么此时 mxcnt = 2。\n所以，我们只要维护 oc 这个数组即可 $O(1)$ 得到 mxcnt。\n 最后注意，本题可能有自环和重边，但 tarjan 的逻辑不会被这些所影响，所以不用特殊处理。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; const int maxm = 1e5+55; int T, a[maxn]; int n, m; int head[maxn], ecnt = 0, dfn[maxn], low[maxn], id = 0, from[maxn], ecc = 0; bool bridge[maxm\u0026lt;\u0026lt;1]; struct Edge { int to, nxt, idx; } edges[maxm\u0026lt;\u0026lt;1]; void addEdge(int u, int v, int idx) { Edge e = {v, head[u], idx}; edges[ecnt] = e; head[u] = ecnt++; } void tarjan(int u, int p) { dfn[u] = low[u] = ++id; for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; if (dfn[to]) low[u] = min(low[u], dfn[to]); else { tarjan(to, u); low[u] = min(low[u], low[to]); if (low[to] \u0026gt; dfn[u]) { bridge[e] = bridge[e^1] = 1; } } } } // f 代表 from (ecc编号) vector\u0026lt;int\u0026gt; vec[maxn]; void dfs(int u, int f) { from[u] = f; vec[f].push_back(u); for (int e = head[u]; ~e; e = edges[e].nxt) { int to = edges[e].to; if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥 dfs(to, f); } } vector\u0026lt;pii\u0026gt; adj[maxn]; void rebuild() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; ~e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; adj[fu].push_back({fv, edges[e].idx}); } } } int ans = 0; int mxcnt = 0; int cnt[maxn]; bool vis[maxn]; void dfs1(int u, int p, int f) { vis[u] = 1; for (int x : vec[u]) { cnt[a[x]] += f; mxcnt = max(mxcnt, cnt[a[x]]); } for (auto [v,_] : adj[u]) { if (v == p) continue; dfs1(v, u, f); } } int sz[maxn], son[maxn], pidx[maxn]; void dfs2(int u, int p) { vis[u] = 1; sz[u] = 1; int maxsz = -1; for (auto [to, eidx] : adj[u]) { if (to == p) continue; pidx[to] = eidx; dfs2(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } int oc[maxn]; // 辅助数组，代表 cnt[] 数组的 count数组 void update(int u, int f) { // 单点更新 for (int x : vec[u]) { oc[cnt[a[x]]]--; cnt[a[x]] += f; oc[cnt[a[x]]]++; if (f == 1) { mxcnt = max(mxcnt, cnt[a[x]]); } else { // f == -1 if (oc[mxcnt] == 0) { mxcnt = cnt[a[x]]; } } } } void add(int u, int p, int f) { // f = 1: add, f = -1: del update(u, f); for (auto [to, eidx] : adj[u]) { if (to == p) continue; add(to, u, f); } } int final_ans[maxn], sub_tree_ans[maxn], cur; void dfs3(int u, int p, bool keep, int f) { vis[u] = 1; for (auto [to, _] : adj[u]) { if (to == p || to == son[u]) continue; dfs3(to, u, 0, f); } if (son[u]) dfs3(son[u], u, 1, f); for (auto [to, _] : adj[u]) { if (to == p || to == son[u]) continue; add(to, u, f); } update(u, f); int eidx = pidx[u]; if (f == 1) { final_ans[eidx] += mxcnt; } else { // f == -1 final_ans[eidx] += mxcnt; final_ans[eidx] -= cur; } if (!keep) add(u, p, -f); } int main() { fastio; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; fill(head, head+n+5, -1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v, i); addEdge(v, u, i); } for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) tarjan(i, 0); } for (int i = 1; i \u0026lt;= n; i++) { if (!from[i]) dfs(i, ++ecc); } rebuild(); for (int i = 1; i \u0026lt;= ecc; i++) { mxcnt = 0; if (!vis[i]) { dfs1(i, 0, 1); dfs1(i, 0, -1); sub_tree_ans[i] = mxcnt; ans += mxcnt; } } fill(vis, vis+n+5, 0); for (int i = 1; i \u0026lt;= ecc; i++) { if (!vis[i]) { dfs2(i, 0); } } fill(vis, vis+n+5, 0); for (int i = 1; i \u0026lt;= ecc; i++) { mxcnt = 0; if (!vis[i]) { cur = sub_tree_ans[i]; dfs3(i, 0, 0, 1); add(i, 0, 1); dfs3(i, 0, 0, -1); add(i, 0, -1); } } for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; final_ans[i] + ans; cout \u0026lt;\u0026lt; (i==m ? \u0026quot;\\n\u0026quot; : \u0026quot; \u0026quot;); } fill(vis, vis+n+5, 0); fill(dfn, dfn+n+5, 0); fill(low, low+n+5, 0); fill(final_ans, final_ans+m+5, 0); fill(sub_tree_ans, sub_tree_ans+n+5, 0); fill(sz, sz+n+5, 0); fill(son, son+n+5, 0); fill(pidx, pidx+n+5, 0); fill(oc, oc+n+5, 0); fill(cnt, cnt+n+5, 0); fill(from, from+n+5, 0); ecnt = 0; ecc = 0; id = 0; ans = 0; mxcnt = 0; cur = 0; fill(bridge, bridge+2*m+5, 0); for (int i = 1; i \u0026lt;= n; i++) adj[i].clear(), vec[i].clear(); } }   参考链接  https://cloud.tencent.com/developer/article/1732615 https://oi-wiki.org/graph/bcc/ https://blog.csdn.net/fuyukai/article/details/51303292 https://blog.csdn.net/a_forever_dream/article/details/103019013 https://www.cnblogs.com/Aswert/p/14273854.html https://blog.csdn.net/qq_45458915/article/details/103672762  ","date":"2021-04-14T11:23:25+08:00","permalink":"https://tom0727.github.io/post/041-%E5%89%B2%E7%82%B9-%E6%A1%A5-bcc/","tags":["割点","桥","双连通分量"],"title":"割点 桥 点/边双连通分量（BCC）"},{"categories":["算法"],"contents":"定义 在一个 有向图 中，任意取两个节点 $(u,v)$，$u \\rightarrow v, v \\rightarrow u$ 均有路径，这样的图叫做强连通。\nSCC（强连通分量）：一个极大的强连通子图。\n缩点：当我们求出一个图中的所有 SCC 后，我们可以将每一个 SCC 缩成一个点。缩点过后，我们可以得到一个新的图，我们遍历所有 原图中的边，将原图中的边加到新图中（注意判断 自环，并且一般会出现重复边）。\n• 缩点后得到的图一定是一个 DAG（有向无环图）。\n• DAG 有着很多优秀的性质，比如可以进行 拓扑排序，可以利用 拓扑排序进行 DP 等。\n求一个有向图中的强连通分量，有两种算法，Tarjan 与 kosaraju 算法（复杂度均为 $O(n+m)$）。\nTarjan 求有向图的 SCC 算法流程 定义 $DFS$ 树为：从任意节点出发，形成的一条从上往下的生成树。\n当我们从 $u$ 访问到 direct neighbor $v$ 时，如果 $v$ 尚未被访问过，那么 $(u,v)$ 是一条 树边。否则 $(u,v)$ 是一条 非树边。\n 我们先维护一个栈 st[]，里面储存的是我们当前正在处理的 SCC。\n定义两个数组 $dfn[u], low[u]$。\n $dfn[u]$ ：DFS过程中，节点 $u$ 的编号（前序编号）。 $low[u]$ ：当前，在栈中的所有节点，以下两者的最小值：  $u$ 的子树中，所有节点 $v$ 的 $low[v]$ 最小值。 从 $u$ 出发，经过一条 非树边 达到节点 $v$ 的 $dfn[v]$ 的最小值。    void dfs(int u) { // .... in[u] = 1; // u 进栈 st[++tail] = u; // 进栈 dfn[u] = low[u] = ++id; // 前序编号 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 需要在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } // ....  经过 DFS 后，我们可以发现，在 栈内，有且仅有一个节点 $u$ 使得 $dfn[u] = low[u]$。这个节点就代表 SCC 在DFS树中的根节点。\n所以，当我们进行DFS回溯的时候，检查一下当前节点 $u$ 是否满足 $dfn[u] = low[u]$。如果满足，将栈中所有的节点（直到 $u$ 为止）全部拿出来，就是一个新的 SCC 了。\n// from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小 int n, m; vector\u0026lt;int\u0026gt; adj[maxn]; struct Tarjan { int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int to : adj[u]) { if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); // 要记得在栈内 if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; // 记得这里，将在栈中的标记去掉 } tail--; in[u] = 0; // 记得这里，将在栈中的标记去掉 } } // 跑tarjan void solve() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } } tj;  例题 洛谷P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G 题意\n给定一个 $N$ 个节点，$M$ 条边的有向图。\n定义一个节点 $u$ 为明星，当且仅当：\n对于 任意节点 $v$ ，均有至少一条到 $u$ 的路径。\n问，图中有多少个节点是明星？\n 题解 对原图跑一次tarjan求SCC，然后缩点。\n缩点后，我们会发现 新图中只有一个明星。\n• 如果新图中有 $2$ 个明星，那么 明星 $1$ 存在到 明星 $2$ 的边，反之亦然。那么明星 $1,2$ 就属于同一个SCC，contradiction。\n并且我们会发现，明星的 out-degree 一定为 $0$，否则，明星指向的节点也是一个明星。\n所以，如果缩点后，新图满足：存在 且 仅存在 $1$ 个节点，使得它的 out-degree 为 $0$，那么有解，输出这个SCC对应的大小即可。\n 代码 const int maxn = 1e4+5; const int maxm = 5e4+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1, n,m; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn]; bool in[maxn]; // instack or not int st[maxn], tail = -1; void dfs(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) low[u] = min(low[u], dfn[to]); if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail]; from[cur] = from[u]; sz[scc]++; tail--; in[cur] = 0; } tail--; in[u] = 0; } } int deg[maxn]; void build() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fv == fu) continue; // 记得去掉自环 deg[fu]++; } } } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); int cnt = 0, ans; for (int i = 1; i \u0026lt;= scc; i++) { if (!deg[i]) cnt++, ans = i; } if (cnt \u0026gt; 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; sz[ans] \u0026lt;\u0026lt; endl; }   kosaraju 算法 kosaraju 算法本质上利用了 正反 $2$ 次DFS 求出一个图中的强连通分量。\n算法流程   建立原图 $G$，和一个反图 $G'$（将所有的边反过来）\n  在原图 $G$ 上跑 DFS，回溯 的时候记录 ID。\n  在反图 $G'$ 上跑 DFS，起始节点的顺序是 ID从大到小。每次 DFS 的 起始节点 就代表了一个新的SCC，DFS访问到的所有节点就是这个SCC。\n  感性理解 如果将原图进行一个缩点操作，那么我们可以得到一个DAG：\n如上图，可以看出 节点 $1$ 拥有 支配地位（它能到达别的点，但是别的点无法到达它）。\n也可以说，节点 $1$ 在拓扑序中，位置最靠前。\n由于我们是 回溯 的时候才记录 ID，所以节点 $1$ 的 ID 是最大的。\n 那么，在反图 $G'$ 中，所有节点的地位反转了，节点 $1$ 的地位最低，且它在拓扑序中，位置最靠后。\n为了找到 SCC，我们希望的就是找到一个节点，使得它无法到达任何其他节点。那么节点 $1$ 就是我们想要的。\n这解释了为什么我们要 ID从大到小 进行反图的 DFS。\n 注：原图不一定连通，DFS的时候要注意。\n模版题 洛谷P2863 [USACO06JAN]The Cow Prom S\n题意\n给定 $n$ 个节点，$m$ 条边的有向图。\n求点数大于 $1$ 的SCC个数。\n 代码 const int maxn = 1e4+5; const int maxm = 5e4+5; struct Edge { int to, nxt; } edges[maxm], redges[maxm]; int head[maxn], rhead[maxn], ecnt = 1, recnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void rev_addEdge(int u, int v) { Edge e = {v, rhead[u]}; rhead[u] = recnt; redges[recnt++] = e; } int id[maxn], idcnt = 0; bool vis[maxn]; void dfs(int u) { vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (vis[to]) continue; // 已经访问过了，忽略 dfs(to); } id[++idcnt] = u; // 回溯的时候更新ID } int sz[maxn]; void dfs2(int u) { sz[u] = 1; for (int e = rhead[u]; e; e = redges[e].nxt) { int to = redges[e].to; if (sz[to]) continue; // 已经访问过，忽略 dfs2(to); sz[u] += sz[to]; } } int main() { int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); rev_addEdge(v,u); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) dfs(i); } int ans = 0; for (int i = n; i \u0026gt;= 1; i--) { if (!sz[id[i]]) { // 还没dfs过，说明这是一个新的SCC dfs2(id[i]); if (sz[id[i]] \u0026gt; 1) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 洛谷P3119 [USACO15JAN]Grass Cownoisseur G 题意\n给定一个 $n$ 个节点，$m$ 条边的有向图。\n现在我们需要从 $1$ 号节点出发，走一条路径，再返回到 $1$ 号节点。（每个节点可以被通过多次）。\n我们允许反向穿过一条边，但是只能反向一次。\n输出我们能够访问的 distinct 节点的最大数量。\n其中，$1 \\leq n,m \\leq 10^5$\n 题解 看到 每个节点可以被穿过多次，首先想到缩点。\n缩点后，假设我们去掉 可以反向一次 的这个条件，那么答案就是 $1$ 所属的SCC的大小。\n 因为我们只能反向一次，我们可以想到利用 分层图 的思想。\n我们先缩点，得到一个新图 $G_1$，然后将缩点后的图 复制一份，得到 $G_2$。\n对于 $G_1$ 中的每条边 $(u_1,v_1)$，我们建一条新边 $(v_1, u_2)$，从 $G_1 \\rightarrow G_2$。\n 观察到我们只能由 $G_1 \\rightarrow G_2$，又因为 $G_1 = G_2$ 且 $G_1,G_2$ 均为 DAG，所以整个图中满足以下条件：\n 无环（仍然是一个DAG） $G_1 \\rightarrow G_2$ 只能发生一次。（从 $G_2$ 无法返回 $G_1$）  所以问题就转化为：\n 在这个新图中，从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$，最多能经过多少个节点？\n 将 $G_1,G_2$（包括$G_1 \\rightarrow G_2$）中，所有边 $(u,v)$ 赋上权值 $size[v]$。那么我们只要求\n从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$ 的最长路 即可。\n • 注：最长路不能用 dijkstra，只能用 SPFA。复杂度最坏 $O(nm)$\n• 注2：对于 DAG 而言，求最长路也可以直接用 拓扑排序 + DP。复杂度 $O(n+m)$，在DAG中，可以完美替代 SPFA\n• 注3：需要特判一下原图是不是一个SCC（一般这种题都要特判一下）。如果是，直接输出答案 $n$。\n 正确性证明：我们为什么不需要考虑 重复经过某个节点，然后多算了的情况？\n答：因为我们不可能重复经过某个节点。\n证：如果我们在 $G_1$ 中经过了某个节点 $u$，说明 $1$ 是可以到达 $u$ 的。\n那么，如果在 $G_2$ 中经过了同样的节点 $u$，然后由 $u$ 又返回了 $1$。这说明 $1 \\rightarrow u \\rightarrow 1$ 是一个环。然而缩点后的图不可能有环，contradiction。\n 代码（SPFA） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Edge { int to,nxt; } edges[maxn]; int head[maxn], ecnt = 1, id = 0, scc = 0, from[maxn], sz[maxn], st[maxn], tail = -1, n, m, dfn[maxn], low[maxn]; bool in[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u) { dfn[u] = low[u] = ++id; in[u] = 1; st[++tail] = u; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (dfn[to] \u0026amp;\u0026amp; in[to]) { low[u] = min(low[u], dfn[to]); } if (!dfn[to]) { dfs(to); low[u] = min(low[u], low[to]); } } if (dfn[u] == low[u]) { from[u] = ++scc; sz[scc] = 1; while (st[tail] != u) { int cur = st[tail--]; from[cur] = from[u]; sz[scc]++; in[cur] = 0; } tail--; in[u] = 0; } } void tarjan() { for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) dfs(i); } } struct New_Edge { int to, nxt, w; } new_edges[maxn\u0026lt;\u0026lt;2]; int new_head[maxn\u0026lt;\u0026lt;1], new_ecnt = 1; void new_addEdge(int u, int v, int w) { New_Edge e = {v, new_head[u], w}; new_head[u] = new_ecnt; new_edges[new_ecnt++] = e; } void build() { for (int u = 1; u \u0026lt;= n; u++) { for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; int fu = from[u], fv = from[v]; if (fu == fv) continue; // 注意判重 new_addEdge(fu, fv, sz[fv]); // 原边 new_addEdge(fu+scc, fv+scc, sz[fv]); // 复制 new_addEdge(fv, fu+scc, sz[fu]); // 反向边 } } } int d[maxn\u0026lt;\u0026lt;1]; // 因为复制了一份，记得开2倍大小 bool inq[maxn\u0026lt;\u0026lt;1]; queue\u0026lt;int\u0026gt; q; void spfa() { q.push(from[1]); inq[from[1]] = 1; // 注意是 from[1] while (!q.empty()) { int cur = q.front(); q.pop(); inq[cur] = 0; for (int e = new_head[cur]; e; e = new_edges[e].nxt) { int to = new_edges[e].to, w = new_edges[e].w; if (d[cur] + w \u0026gt; d[to]) { // 无论是否 inq[] 都要更新 d[to] = d[cur] + w; if (!inq[to]) q.push(to); inq[to] = 1; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); spfa(); int ans = d[from[1] + scc]; // 注意是 from[1] if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   代码（拓扑排序 \u0026#43; DP） 因为其他部分完全一样，这里就省略，只保留 main() 和 DP 部分。\nvoid solve() { tail = -1; fill(dp, dp+2*scc+1, -1e9); // 注意赋值为 -inf，因为我们只关心从 from[1] 出发的部分 dp[from[1]] = 0; for (int u = 1; u \u0026lt;= 2*scc; u++) { if (!ind[u]) st[++tail] = u; } while (tail \u0026gt;= 0) { int cur = st[tail--]; for (int e = new_head[cur]; e; e = new_edges[e].nxt) { int to = new_edges[e].to, w = new_edges[e].w; dp[to] = max(dp[to], dp[cur] + w); ind[to]--; if (!ind[to]) st[++tail] = to; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); } tarjan(); build(); solve(); int ans = dp[from[1] + scc]; // 注意是 from[1] if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-04-12T22:02:41+08:00","permalink":"https://tom0727.github.io/post/040-scc/","tags":["tarjan","SCC","kosaraju"],"title":"强连通分量（SCC）"},{"categories":["算法"],"contents":"多重背包二进制优化 代码 int n, V; int dp[2005]; void pack01(int v, int w) { for (int j = V; j \u0026gt;= v; j--) { dp[j] = max(dp[j], dp[j-v] + w); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; V; while (n--) { int v,w,s; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; int k = 1; while (k \u0026lt;= s) { pack01(v*k, w*k); s -= k; k \u0026lt;\u0026lt;= 1; } pack01(v*s, w*s); } int ans = 0; for (int j = 0; j \u0026lt;= V; j++) ans = max(ans, dp[j]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   多重背包（单调队列优化） 代码 struct node { int pos, val; } q[20005]; int head = -1, tail = 0, n, V, dp[20005]; void solve(int v, int w, int s) { for (int j = 0; j \u0026lt; v; j++) { head = 0, tail = -1; q[++tail] = {0,0}; for (int i = 1; i*v + j \u0026lt;= V; i++) { while (i - q[head].pos \u0026gt; s) head++; int cur = i*v + j; int val = dp[cur] - i*w; dp[cur] = max(dp[cur], q[head].val + i*w); while (head \u0026lt;= tail \u0026amp;\u0026amp; val \u0026gt;= q[tail].val) tail--; q[++tail] = {i, val}; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; V; for (int i = 1; i \u0026lt;= n; i++) { int v,w,s; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; solve(v,w,s); } int ans = 0; for (int j = 0; j \u0026lt;= V; j++) ans = max(ans, dp[j]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   背包删除元素 众所周知，背包内加入一个元素是（这里 dp[i] 代表能够装重量和为 $i$ 的物品的方案数）：\nfor (int i = N; i \u0026gt;= w; i--) dp[i] += dp[i - w];  而背包删除一个元素其实也可以反过来做：\nfor (int i = w; i \u0026lt;= N; i++) dp[i] -= dp[i - w];  • 注意这里的枚举顺序，在删除的时候要保证删除时，用的是加入前的状态，所以是从小到大删。\n例题 例1 Google Kickstart 2022 RoundH D. Level Design 题意\n给定一个长度为 $n$ 的permutation。\n如果把permutation看作一个图（第 $i$ 位的值是 $p_i$ 的话，那么有 $i \\rightarrow p_i$）。\n我们可以对这个 permutation 进行任意次数的 swap 操作，每次交换任意的 $p_i, p_j$ 的位置。\n现在对于每一个 $k \\in [1,n]$，回答：\n最少需要多少次 swap 操作，使得，得到的图中至少有一个大小为 $k$ 的cycle。\n其中，$n \\leq 10^5$，每个回答各自独立。\n 题解 首先经过一些观察，可以发现：\n使用 $1$ 次操作，可以让一个cycle合并到另外一个cycle上去，或者也可以将一个大的 cycle 拆成 $2$ 个小cycle。\n所以我们先用 DFS 求出所有 cycle 的大小。\n然后就是一个背包问题：\n 有 $n$ 个物品，每个物品有一个大小 $a_i$，并且每次装到背包中有一个 cost $1$。\n也可以将一个物品分成两个更小的物品，分割的 cost 也为 $1$。\n对于每一个可能的背包大小 $k \\in [1,n]$，求最少的cost使得这个背包刚好被装满？\n 注意到分割操作只有最多一次，因为可以先装背包，将背包装多一点，然后分掉一个使得背包刚好装满。\n那装背包的话，物品数量太多了怎么办？\n想到 多重背包的二进制背包优化，那个是将大的拆成小的。我们也可以将小的合成为大的。\n比如有 $3$ 个大小为 $1$ 的物品，每个cost均为 $1$，我们就可以将其中 $2$ 个合成为一个大小为 $2$，cost为 $2$ 的大物品。\n所以对于大小为 $x$，cost为 $c$ 的物品，如果它有 $\\geq 3$ 个，就将其中 $2$ 个合成为大小为 $2x$，cost为 $2c$ 的物品。\n时间复杂度：所有物品的大小之和为 $n$，所以物品大小的种类数只有 $O(\\sqrt n)$ 个。在合并之后，物品的数量不会超过 $O(\\sqrt n * \\log(10^5))$ 个。\n所以就可以跑背包了，复杂度为 $O(n \\sqrt n)$。\n• 注意背包枚举的时候，外层循环是物品，里层循环是大小。\n• 注意到装第一个物品的 cost 为 $0$，这个直接用 dp[0] = -1 来表示。\n// 背包枚举顺序：外层是物品，里层是大小 for (pii a : item_vec) { for (int i = n; i \u0026gt;= 1; i--) { int item_sz = a.first, cost = a.second; if (item_sz \u0026gt; i) break; dp[i] = min(dp[i], dp[i-item_sz] + cost); } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 1e8+5; int T; int n, p[maxn]; bool vis[maxn]; // int cnt[maxn]; map\u0026lt;int, int\u0026gt; items[maxn]; // items[i]: 大小为 i 的所有物品的 cost (key: cost, value: cnt) vector\u0026lt;pii\u0026gt; item_vec; int dp[maxn]; int main() { cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; t++) { cin \u0026gt;\u0026gt; n; item_vec.clear(); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i]; vis[i] = 0, items[i].clear(), dp[i] = 1e9; } dp[0] = -1; for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { int sz = 0; int u = i; do { vis[u] = 1; sz++; u = p[u]; } while (!vis[u]); items[sz][1]++; } } for (int i = 1; i \u0026lt;= n; i++) { for (auto\u0026amp; itr : items[i]) { int cost = itr.first; while (itr.second \u0026gt;= 3) { itr.second -= 2; items[i*2][cost*2] += 1; } } } for (int i = 1; i \u0026lt;= n; i++) { for (auto itr : items[i]) { int cost = itr.first, cnt = itr.second; while (cnt--) { item_vec.push_back({i, cost}); // 大小, cost } } } // 背包枚举顺序：外层是物品，里层是大小 for (pii a : item_vec) { for (int i = n; i \u0026gt;= 1; i--) { int item_sz = a.first, cost = a.second; if (item_sz \u0026gt; i) break; dp[i] = min(dp[i], dp[i-item_sz] + cost); } } int mn = 1e9; // 考虑拆分物品（最多一次） for (int i = n; i \u0026gt;= 1; i--) { dp[i] = min(dp[i], mn + 1); mn = min(mn, dp[i]); } cout \u0026lt;\u0026lt; \u0026quot;Case #\u0026quot; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026quot;: \u0026quot;; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } }   例2 CF95E Lucky Country 题意\n给定 $n$ 个点，$m$ 条边的无向图。\n每次操作可以加一条边。\n求最少的操作次数，使得其中一个联通块的大小为 $x$，且 $x$ 只包含 $4,7$ 这两个字符。\n其中，$n,m \\leq 10^5$，如果操作不存在输出 $-1$。\n 题解 把联通块大小看作数字，就是每次操作合并两个数字，看怎么样合并出一个 $x$ 只包含 $4,7$ 这两个字符。\n一眼多重背包，但数据范围太大了。\n再次注意到所有数字的和为 $n$（多重背包二进制的经典老套路），所以不同的数字种类最多为 $O(\\sqrt n)$ 个。\n于是拿二进制优化一下多重背包就可以 $O(n \\sqrt n \\log(10^5))$ 跑出来了（实际上复杂度上界很松）。\n• 注意二进制合并物品的时候，也要增加相应的 cost。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; const int maxm = 4e4+55; bool isLukcy(int x) { while (x) { int r = x % 10; x /= 10; if (r != 4 \u0026amp;\u0026amp; r != 7) return 0; } return 1; } int dp[maxn], par[maxn], sz[maxn]; int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u == v) return; if (sz[u] \u0026lt; sz[v]) swap(u,v); sz[u] += sz[v], sz[v] = 0; par[v] = u; } int n, m, cnt[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) par[i] = i, sz[i] = 1; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; unions(u,v); } vector\u0026lt;int\u0026gt; vec; for (int i = 1; i \u0026lt;= n; i++) { if (par[i] == i) vec.push_back(sz[i]); } for (int x : vec) cnt[x]++; vector\u0026lt;pii\u0026gt; res; for (int i = 1; i \u0026lt;= 100000; i++) { if (cnt[i]) { for (int j = 1; j \u0026lt;= cnt[i]; j *= 2) { cnt[i] -= j; res.push_back({j * i, j}); } if (cnt[i]) res.push_back({cnt[i] * i, cnt[i]}); } } memset(dp, 63, sizeof(dp)); dp[0] = 0; for (auto [x, c] : res) { for (int i = 100000; i \u0026gt;= x; i--) { dp[i] = min(dp[i], dp[i-x] + c); } } int ans = 1e9; for (int i = 1; i \u0026lt;= n; i++) { if (isLukcy(i)) { ans = min(ans, dp[i]); } } cout \u0026lt;\u0026lt; ((ans \u0026gt; 1e8) ? -1 : ans - 1) \u0026lt;\u0026lt; endl; }   ","date":"2021-04-11T21:42:06+08:00","permalink":"https://tom0727.github.io/post/039-%E8%83%8C%E5%8C%85/","tags":["DP","背包"],"title":"背包问题"},{"categories":["解题报告"],"contents":"友情出场本次HDU新生赛，题目质量一如既往的优秀。写一下解题报告吧。\n题目 \u0026amp; 题解 题目PDF\n题解PDF\nQ1 选课 题意\n有一些学生档案，每个档案上记录了某一名学生选修的 互不相同的 $3$ 门课 $a,b,c$。学校总共有 $m$ 种选修课。\n给出 $n$ 个询问，格式如下：\n$1 ~ a ~ b ~ c$：代表加入一个学生档案，他选修了 $a,b,c$ 这三门课。\n$2 ~ a ~ b$：询问当前已经加入档案中的学生，选修了 $a,b$ 之中恰好一门 的人数。\n对于每一个询问 $2$，输出一行答案即可。\n其中，$3 \\leq n,m \\leq 5 \\times 10^5, 1 \\leq a,b,c \\leq m$\n 题解 简单容斥。\n选修 $a,b$ 之中恰好一门 $=$ 选修 $a$ $+$ 选修 $b$ $-$ 同时选修 $a,b$\n所以记录一下同时选修 $2$ 门的数量就好。\n• 注意，记录的时候使用 $m$ 个 unordered_map() ，不要把所有的 pair 放在一起，否则容易 $TLE$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; int n, m, cnt[maxn]; unordered_map\u0026lt;int, int\u0026gt; mp[maxn]; int a[3]; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); while (n--) { int op; scanf(\u0026quot;%d\u0026quot;,\u0026amp;op); if (op == 1) { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;a[0],\u0026amp;a[1],\u0026amp;a[2]); sort(a, a+3); for (int i = 0; i \u0026lt; 3; i++) { cnt[a[i]]++; for (int j = i+1; j \u0026lt; 3; j++) { mp[a[i]][a[j]]++; } } } else { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a[0],\u0026amp;a[1]); sort(a, a+2); int ans = cnt[a[0]] + cnt[a[1]] - 2 * mp[a[0]][a[1]]; printf(\u0026quot;%d\\n\u0026quot;, ans); } } }   Q2 善良的出题人 题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\text{lcm}(a_1,a_2,\u0026hellip;,a_n)$。答案对 $10^9+7$ 取模。\n其中，$n \\leq 1.5 \\times 10^6, 1 \\leq a_i \\leq 10^7$\n 题解 很明显的质因数分解。但是复杂度看起来不太对：$n \\sqrt{(a_i)} = 4 \\times 10^9$\n这里，我们要用到 $\\log a_i$ 复杂度的质因数分解！\n主要原理是：在 欧拉筛 过程中，我们可以得到每个数字的 最小质因子，所以我们预处理出 $1$ 到 $10^7$ 的所有数字的最小质因子。在分解 $a_i$ 的时候，不断除掉最小质因子即可。\n复杂度：$n \\log a_i$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; bool p[maxn]; int n, primes[maxn], tail = 0, cnt[maxn], small[maxn]; // small[i] 代表数字 i 的最小质因子 void init() { fill(p, p+maxn, 1); small[1] = 1; for (int i = 2; i \u0026lt; maxn; i++) { if (p[i]) primes[++tail] = i, small[i] = i; for (int j = 1; j \u0026lt;= tail; j++) { int cur = i * primes[j]; if (cur \u0026gt;= maxn) break; p[cur] = 0; small[cur] = primes[j]; // 最小质因子 if (i % primes[j] == 0) break; } } } ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { init(); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { int a; scanf(\u0026quot;%d\u0026quot;, \u0026amp;a); while (a \u0026gt; 1) { int sp = small[a]; int c = 0; while (a % sp == 0) a /= sp, c++; cnt[sp] = max(cnt[sp], c); } } ll ans = 1; for (int i = 2; i \u0026lt; maxn; i++) { ans = (ans * qpow(i, cnt[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   Q3 买路钱 题意\n给定 $N$ 个节点，$M$ 个边的 无向图。图中不存在重复边，也不存在自环。并且，保证图连通。\n初始状态下，所有的edge权值均为 $1$。\n现在给出 $Q$ 次修改，每次修改将 第 $R_j$ 条edge的权值 改为 $2$，保证每次修改的edge互不相同。\n令 $d_x$ 为：在所有修改操作之前，节点 $x$ 距离 节点 $1$ 的最短路径长度。\n进行一次修改后，令 $d_x'$ 为：此时 节点 $x$ 距离 节点 $1$ 的最短路径长度。\n对于每一次修改，我们需要输出本次修改后，$d_x' \u0026gt; d_x$ 的节点数量。\n其中，$2 \\leq N \\leq 10^5, 1 \\leq Q \\leq M \\leq 2 \\times 10^5, 1 \\leq R_j \\leq M$\n 题解 首先发现权值均为 $1$，我们就可以用 bfs() 求出初始的最短路径了。\n对于每次修改，我们需要看一下：本次修改都影响了哪些节点？\n但是，我们很难直接看出每次修改影响的节点，如果在整个图上跑最短路复杂度又太高。\n 注意到，因为原图的最短路来自 BFS，而我们又只关心，$u$ 距离 $1$ 的最短路径 是否比初始状态的大。\n所以我们只要看，对于修改的一条边 $(u,v)$，$u$ 和 $v$ 的最短路径是否必须经过 $(u,v)$ 即可。\n那么，对于修改 $(u,v)$ 的权值为 $2$，我们可以直接等效替换为：将 $(u,v)$ 从图中删除。\n在删除过后，看哪些节点 距离 $1$ 的最短路长度变长了即可（如果不再连通到 $1$，直接令长度为 $inf$）。\n 证明：删除边 $(u,v)$ $=$ 修改权值？\n 分两种情况讨论：\n  $u$ 的最短路径长度 没有改变：这说明 $u$ 当前的最短路径并不需要经过 $(u,v)$，所以无论是删除，还是增加权值，都一样。 而对于其他的节点，因为 $u$ 都没受到影响，所以它们也不会受到影响，即答案不变。   $u$ 的最短路径长度 增加了：说明 $u$ 原先的最短路径必须经过 $(u,v)$，那么删掉 $(u,v)$ 就保证了最短路径一定无法经过 $(u,v)$。而给 $(u,v)$ 增加权值，$u$ 的新最短路径要么不经过 $(u,v)$（和删除一样），要么仍然经过 $(u,v)$（这样的话，在删除操作中，就说明 $u$ 与 $1$ 断开了）。所以删除和增加权值仍然等效。对于其他的节点，同理。\n   等效为删除以后，我们发现本题仍然不好做！\n正难则反，我们不如考虑反过来处理，我们把对应的边删掉，然后从后往前，开始加边。\n我们每次加上一条边 $(u,v)$，都会有如下性质：\n 如果在加上这条边之前， $u$ 已经有 $d_u' = d_u$ 了，则 $u$ 对其他节点不会产生任何影响。 如果 $d_u'$ 变小了，那说明 $d_u' = d_v' + 1$ 如果 $d_u'$ 变小了，那么在变小后，只有 $d_u' = d_u$ 时，$u$ 才会对其他节点产生 有效影响。   证明上述性质：\n 证明性质 $1$：$u$ 对其他节点产生影响的话，说明 $u$ 的最短路径缩短了（说明 $d_u'$ 变小了），如果在加上这条边之前已经有 $d_u' = d_u$，则 $d_u'$ 无法变得更小，所以无法产生影响。\n证明性质 $2$：$d_u'$ 如果变小，说明新的最短路径通过了 $(u,v)$，所以 $d_u' = d_v' + 1$\n证明性质 $3$：有效影响 指的是：在增加 $(u,v)$ 以后，其他的某个节点 $x$ 的 $d_x'$ 变小，且 $d_x' = d_x$。如果 $d_u'$ 变小，但是仍然有 $d_u' \u0026gt; d_u$，则其他节点 $x$ 不可能通过 $u$ 来获取原先的最短路径 $d_x$，所以 $u$ 无法对其他节点产生有效影响。\n 由上，我们的算法就有了：\n 先建好完整的图，跑一次 BFS 得到所有节点距离 $1$ 的最短距离。 清空图，将所有 未修改 的边加到图中。 从后向前的顺序，进行 加边 操作，当加上 $(u,v)$ 时，看一下是否存在 $u$ 使得 $d_u'$ 减小，且 $d_u' = d_u$，如果有，更新 $u$ 所有 neighbor 的 $d_x'$ 值，再继续判断上述条件（这是一个递归的操作）。  复杂度：因为每个节点 $u$ 最多只需要更新一次 $d_u'$，每次更新会判断它的所有neighbor，所以复杂度为 $O(n+m)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int maxm = 2e5+5; int n,m,Q, head[maxn], ecnt = 1, ans[maxn], d[maxn]; bool vis_plan[maxm]; struct Edge { int to, nxt; } edges[maxm\u0026lt;\u0026lt;1]; struct Query { int u,v; } query[maxm]; int plan[maxm]; // plan[i] 代表第i年要提升的query编号 void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void clear() { fill(head, head+maxn, 0); ecnt = 1; } int curans; //一开始有n-1个村庄不满 // 村庄u满意了，更新它的所有neighbor void update(int u) { d[u] = ans[u]; curans--; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (d[to] != ans[to] \u0026amp;\u0026amp; d[u] + 1 == ans[to]) { update(to); // 递归更新 } } } // 加上第c条边，并且更新d[] void add(int c) { int u = query[c].u, v = query[c].v; addEdge(u, v); addEdge(v, u); if (d[u] != ans[u] \u0026amp;\u0026amp; d[v] + 1 == ans[u]) { // 更新后，u得到了最短路 update(u); } if (d[v] != ans[v] \u0026amp;\u0026amp; d[u] + 1 == ans[v]) { update(v); } } int q[maxn], hd = 0, tail = -1; void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; fill(ans, ans+maxn, 1e9); fill(d, d+maxn, 1e9); ans[1] = 0; d[1] = 0; curans = n-1; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); query[i] = {u,v}; } q[++tail] = 1; while (hd \u0026lt;= tail) { //bfs int cur = q[hd++]; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (ans[to] == 1e9) { ans[to] = ans[cur] + 1; q[++tail] = to; } } } clear(); // 去掉所有的边 for (int i = 1; i \u0026lt;= Q; i++) { int a; cin \u0026gt;\u0026gt; a; plan[i] = a; vis_plan[a] = 1; // 这条边暂时被删去，之后才加上 } for (int i = 1; i \u0026lt;= m; i++) { if (!vis_plan[i]) { add(i); } } } int ask_ans[maxm]; // 第i个询问的答案 int main() { init(); for (int i = Q; i \u0026gt;= 1; i--) { ask_ans[i] = curans; add(plan[i]); } for (int i = 1; i \u0026lt;= Q; i++) { cout \u0026lt;\u0026lt; ask_ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   Q4 cake 题意\n给定一个 $n \\times m$ 的矩形，左上角为 $(0,0)$，右下角为 $(n,m)$。\n现有 $k$ 个修改操作，有两种类型：\n$line ~ x$：在 $[0,m]$ 的轴上切一条直线 $x$。\n$row ~ y$：在 $[0,n]$ 的轴上切一条直线 $y$。\n每次修改操作后，求最大的子矩形？\n数据保证所有修改互不相同。\n其中，$0 \\leq n,m \\leq 10^6, 0 \\leq k \\leq n+m-2, 1 \\leq x \u0026lt; m, 1 \\leq y \u0026lt; n$\n 题解 问题转化一下，我们可以维护两个有序数组 $a, b$，初始状态下 $a = [0,m], b = [0,n]$\n$line ~ x$ 代表给数组 $a$ 添加一个元素 $x$，而 $row ~ x$ 代表给 $b$ 添加元素 $x$。\n每次添加元素后，我们要找到 $a$ 中相邻元素的最大差值 $d_a$，还有 $b$ 中相邻元素的最大差值 $d_b$。\n则，本次修改操作后的答案为 $d_a \\times d_b$。\n 所以一个非常简单的思路是 维护 $2$ 个 map\u0026lt;int,int\u0026gt; 来代表有序数组 $a,b$。然后再用 $2$ 个 map\u0026lt;int, int\u0026gt; 来维护 $a,b$ 中的差值。每次添加元素，都更新一下 差值 map。\n复杂度：$O(n\\log n)$，会 $TLE$。\n 正难则反 的思想第二次出现了。我们可以把询问反过来做。\n相当于我们先把所有的数字放进 $a,b$ 之中，然后从后往前处理询问，相当于每次从数组中拿走一个元素。\n$a,b$ 可以用 链表思想 进行维护，这样删除一个元素和计算新差值的时间就是 $O(1)$ 了。\n但是 $a,b$ 内是有序的，排序仍然需要 $O(n \\log n)$ 的时间。\n注意到 $a,b$ 内所有的元素都 $\\leq 10^6$，所以直接使用 桶排序（bucket sort) 即可在 $O(n)$ 完成排序。\n复杂度：$O(n+m+k)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+2; // 桶排序：将所有元素放进一个 cnt[] 数组内，然后从小到大遍历 cnt[] 数组即可 void bucket_sort(int* arr, int len) { static int cnt[maxn]; for (int i = 1; i \u0026lt;= len; i++) cnt[arr[i]]++; int ptr = 0; for (int i = 0; i \u0026lt;= 1e6; i++) { while (cnt[i] \u0026gt; 0) { cnt[i]--; arr[++ptr] = i; } } } int n,m,k; char op[5]; int arr[2][maxn], pos[2][maxn], pre[2][maxn], nxt[2][maxn], tail[2]; ll ans[maxn\u0026lt;\u0026lt;1], maxd[2]; // max diff // pos[id][val]: val 所在 arr[id] 中的位置 // pre[id][j]: index j的前一个数字的index // nxt[id][j]: index j的后一个数字的index struct Query { int id, val; } q[maxn\u0026lt;\u0026lt;1]; int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;k); arr[0][1] = arr[1][1] = 0; arr[0][2] = m, arr[1][2] = n; tail[0] = tail[1] = 2; for (int i = 1; i \u0026lt;= k; i++) { scanf(\u0026quot;%s\u0026quot;, op); int a, id; scanf(\u0026quot;%d\u0026quot;, \u0026amp;a); if (op[0] == 'l') id = 0; else id = 1; q[i] = {id, a}; arr[id][++tail[id]] = a; } for (int id = 0; id \u0026lt;= 1; id++) { bucket_sort(arr[id], tail[id]); for (int i = 1; i \u0026lt;= tail[id]; i++) { pos[id][arr[id][i]] = i; pre[id][i] = i-1, nxt[id][i] = i+1; maxd[id] = max(maxd[id], arr[id][i+1] - arr[id][i]); } } for (int i = k; i \u0026gt;= 1; i--) { ans[i] = maxd[0] * maxd[1]; int id = q[i].id, val = q[i].val; int p = pos[id][val]; int pr = pre[id][p], ne = nxt[id][p]; maxd[id] = max(maxd[id], arr[id][ne] - arr[id][pr]); nxt[id][pr] = ne, pre[id][ne] = pr; // 链表删除元素的更新 } for (int i = 1; i \u0026lt;= k; i++) printf(\u0026quot;%lld\\n\u0026quot;, ans[i]); }   Q5 半精灵数 题意\n给定 $L,R,p$，求 $[L,R]$ 之间，恰好满足以下条件之一 的数字数量：\n 能被 $p$ 整除 数字中含有 $p$  其中，$1 \\leq L \\leq R \\leq 10^{18}, 1 \\leq p \\leq 9$，有 $T \\leq 10^5$ 个 testcase。\n 题解 数位dp比较模版的题目。\n令 $dp[i][j][k]$ 为：我们当前到了第 $i$ 位，数字 $mod ~ p = j$，数字内含有 $p$ 与否（含有：$k=1$）。\n然后，我们离线化处理一下所有的询问，按照 $p$ 的值进行分类，这样可以只 memset() $9$ 次。\n 注：也可以在 dp[] 数组里面，额外加一个维度，表示 p 的值，这样就不用离线处理询问了。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[20][9][2]; // dp[i][j][k]: 到第i位，mod p = j, 含有p与否 (k = 1/0) 的数量 int arr[20], n, p; ll dfs(int i, int j, int k, bool limit) { if (i \u0026lt;= 0) { if (j == 0 \u0026amp;\u0026amp; !k) return 1; if (j != 0 \u0026amp;\u0026amp; k) return 1; return 0; } if (!limit \u0026amp;\u0026amp; dp[i][j][k] != -1) return dp[i][j][k]; int ed = 9; if (limit) ed = arr[i]; ll res = 0; for (int c = 0; c \u0026lt;= ed; c++) { res += dfs(i-1, (j*10+c)%p, k||(c == p), limit \u0026amp;\u0026amp; (c == ed)); } if (!limit) dp[i][j][k] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } struct Query { int id; ll L,R; }; vector\u0026lt;Query\u0026gt; q[10]; ll ans[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= T; i++) { ll L, R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; p; q[p].push_back({i, L, R}); } for (p = 1; p \u0026lt;= 9; p++) { memset(dp, -1, sizeof(dp)); for (auto que : q[p]) { ll L = que.L, R = que.R; ans[que.id] = solve(R) - solve(L-1); } } for (int i = 1; i \u0026lt;= T; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   Q6 Mess 题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，每次可以选择一个元素 $a_i$，进行以下操作之一：\n $a_i = a_i \\times 2$ $a_i = \\lfloor \\frac{a_i}{2} \\rfloor$  求最少操作次数，使得所有元素相同？\n其中，$1 \\leq n, a_i \\leq 10^6$\n 题解 我们发现，这两种操作，分别是二进制 左移 和 右移。\n并且我们发现，无论是左移还是右移，一个数字二进制中， $1$ 的数量都只能减少，而不能增加。\n我们设最终的答案为 $x$（最后所有元素等于 $x$），那么 $x$ 的二进制中 $1$ 的数量，必须 $\\leq \\min\\limits_i \\{ count(a_i) \\}$\n我们随便选一个 二进制中 $1$ 的数量最少的数，令其为 $a_k$。\n因为 $x$ 必然由 $a_k$ 移动而来，所以我们只要移动 $a_k$，就可以枚举答案 $x$。\n 问题转化为：已知最终答案为 $x$，如何求出操作次数？\n我们再次利用了 $1$ 的数量只减不增的特点，对于每一个 $a_i$，我们都观察一下 $a_i$ 中 $1$ 的数量，分两种情况：\n $count(a_i) \u0026gt; count(x)$：那么我们右移 $a_i$，直到 $count(a_i) = count(x)$。 $count(a_i) = count(x)$：看一下是否可以通过移动 $a_i$ 得到 $x$。（即，它们其中一个是否为另外一个的 $2^j$ 次方）。如果不能通过移动得到，就说明这个 $x$ 是非法的。  对于情况 $2$，我们可以预处理出所有 $2^j$ 对应的 $j$。\n• 注意，无论什么情况下，都必然有解。因为 $x = 1$ 一定有解！\n复杂度：$O(nlog^2n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n; struct node { int cnt, val; } arr[maxn]; int count_bit(int x) { int res = 0; while (x) { if (x\u0026amp;1) res++; x \u0026gt;\u0026gt;= 1; } return res; } int ans = 2e9; map\u0026lt;int, int\u0026gt; mp; void solve(int x, int t) { int res = 0; for (int i = 1; i \u0026lt;= n; i++) { int v = arr[i].val; int c = arr[i].cnt; while (c \u0026gt; t) { // Case1 if (v \u0026amp; 1) c--; v \u0026gt;\u0026gt;= 1; res++; } // Case2 if (v \u0026lt; x) { if (x % v) return; if (!mp.count(x/v)) return; res += mp[x/v]; } else { if (v % x) return; if (!mp.count(v/x)) return; res += mp[v/x]; } } ans = min(ans, res); } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int mincnt = 1e9, mini; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i].val); arr[i].cnt = count_bit(arr[i].val); if (arr[i].cnt \u0026lt; mincnt) { mincnt = arr[i].cnt; mini = i; } } for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= 2e6; j++) { mp[(1\u0026lt;\u0026lt;j)] = j; } for (int v = arr[mini].val; v \u0026lt;= 2e6; v \u0026lt;\u0026lt;= 1) { solve(v, count_bit(v)); } for (int v = arr[mini].val \u0026gt;\u0026gt; 1; v \u0026gt;= 1; v \u0026gt;\u0026gt;= 1) { solve(v, count_bit(v)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   总结 $Q2$ 善良的出题人\n利用欧拉筛，预处理出所有数字的最小质因子，达到 $O(n \\log n)$ 的质因数分解。\n$Q3$ 买路钱\n 将增加边的权值，转化为删边。 删边不好处理，将 询问反过来，变成加边。  $Q4$ Cake\n 将 询问反过来，添加元素变成删除元素。 删除元素利用 链表思想，$O(1)$ 时间维护新差值。 排序使用 bucket sort 可以达到 $O(n)$。  $Q5$ 半精灵数\n在数位DP中，离线根据 $p$ 的值处理询问，能大幅减少 memset() 的次数。\n$Q6$ Mess\n对于 枚举最终答案 的题目，一般常见的套路有：\n 二分/三分 搜索 根据题目性质，缩小答案可能的范围。（本题就是这个思想）  ","date":"2021-04-07T21:24:21+08:00","permalink":"https://tom0727.github.io/post/038-hdu-contest1/","tags":[""],"title":"HDU Contest 1 解题报告"},{"categories":["算法"],"contents":"介绍 树上差分就是将数组上的差分思想，转化到树上。\n树上差分是一种思想，很多时候树链剖分可以代替树上差分，如果询问不复杂的时候，就可以用树上差分来减少代码难度。\n经典模型 模型1 边权求和 题意\n给定一个 $N$ 个节点的树，每个边 edge上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u,v$ 之间的路径的 edge权值 加上 $d$。\n所有操作结束后，求所有边上的权值？\n 首先将树变成有根树（设 $root = 1$），我们令 dp[u] 为：从 $root$ 开始，一直到 $u$ 的路径上的所有边权，都被加上了 dp[u]。\n那么每次修改操作 $u,v,d$，令 $x = LCA(u,v)$，则修改操作是：\ndp[u] += d, dp[v] += d, dp[x] -= 2 * d\n所有修改操作结束后，我们将 dp[] 的值 从下往上 进行传递（用 dfs() 实现即可）。就可以得到所有的边权了。\n• 在 dfs(u, p) 的过程中，$(u, to)$ 这个edge的权值就是 dp[to]。\nint dp[maxn]; void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); // 注意是先 dfs, 再 dp[u] += dp[to]（从下到上） dp[u] += dp[to]; // dp[to] 就是 (u,to) 这个边的权值 } }  模型2 点权求和 题意\n给定一个 $N$ 个节点的树，每个点 vertex上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u,v$ 之间的路径的 vertex权值 加上 $d$。\n所有操作结束后，求所有点上的权值？\n 同理，令 dp[u] 为：从 $root$ 开始，一直到 $u$ 的路径上的所有点权（inclusive)，都被加上了 dp[u]。\n那么每次修改操作 $u,v,d$，令 $x = LCA(u,v)$，则修改操作是：\ndp[u] += d, dp[v] += d, dp[x] -= d, dp[par[x]] -= d\n所有修改操作结束后，我们将 dp[] 的值 从下往上 进行传递。\n• 代码同上。\n模型3 子树求和 题意\n给定一个 $N$ 个节点的树，每个点 vertex上都有权值（初始为0）。\n给定 $M$ 次操作，每次将 $u$ 的子树的 vertex权值 加上 $d$。\n所有操作结束后，求所有点上的权值？\n 令 dp[u] 为：$u$ 的子树中的 vertex 权值都被加上了 dp[u]。\n那么每次修改操作 $u, d$，有：\ndp[u] += d\n所有修改操作结束后，我们将 dp[] 的值 从上往下 进行传递。（注意这里的顺序是从上往下）\nint dp[maxn]; void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; // 注意是先 dp[to] += dp[u] (从上到下)，再 dfs dfs(to, u); } }  例题 例1 AcWing 352 暗之连锁 题意\n给定一棵包含 $N$ 个节点的树，树中原先存在的边叫做主要边。\n现在给定 $M$ 个附加边。\n我们需要采取以下操作（仅能进行一次，并且步骤1，2都必须进行）：\n 选定一个主要边，删掉它。 然后选定一个附加边，删掉它。  求有多少种这样的操作，使得树断开？\n其中，$N \\leq 10^5, M \\leq 2 \\times 10^5$\n 题解 因为我们是先删除主要边，再删除附加边。在删除一个主要边 $(u,v)$ 的时候，我们只要关心删除附加边后，能否让 $(u,v)$ 断开。\n我们可以只考虑 主要边，对于附加边，我们把它们转化为 主要边。\n也就是说，对于每个附加边 $(u,v)$，我们都把 $(u,v)$ 在原来树中的路径上，所有 edge（主要边）的权值都加 $1$。\n所以，在进行删除操作的第一步（删除主要边）时，我们可以看一下这个边 $(u,v)$ 的权值。有以下三种情况：\n 权值等于 $0$：树已经断开了，附加边随便删一条即可，所以 ans += M。 权值等于 $1$：存在，且仅存在一个附加边，使得 $u,v$ 仍然连通，所以 ans++。 权值大于等于 $2$：存在多个附加边使得 $u,v$ 仍然连通，所以不可能使得树断开。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int par[maxn][19], head[maxn], ecnt = 1, n, m, dep[maxn], dp[maxn]; ll ans = 0; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u, int p) { par[u][0] = p; dep[u] = dep[p] + 1; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 18; j++) if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int diff = dep[u] - dep[v]; u = jump(u, diff); if (u == v) return u; for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs2(to, u); dp[u] += dp[to]; if (dp[to] == 0) ans += (ll)(m); if (dp[to] == 1) ans++; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); } dfs(1, 0); for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int p = LCA(u,v); dp[u]++, dp[v]++, dp[p] -= 2; } dfs2(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF1076E Vasya and a Tree 题意\n给定 $n$ 个节点的有根树（$1$ 为根）。每个vertex上都有一个权值，初始为 $0$。\n有 $m$ 个询问，每次询问：\n$u ~ d ~ x$：将 $u$ 的子树中，离 $u$ 的距离 $\\leq d$ 的所有 vertex，权值都加上 $x$。\n求所有询问结束后，每个节点上的权值？\n 法一（树上差分） 首先看一下我们怎么进行差分：\n 将 $u$ 的子树中，离 $u$ 的距离 $\\leq d$ 的所有 vertex，权值都加上 $x$。\n 我们可以将上面转化为：\n 将 $u$ 的子树权值都加上 $x$ 然后将 $u$ 距离 $= (d+1)$ 的所有 $v$ 的子树，权值都减去 $x$。   注意到，每次询问，加的都是 子树。\n那么我们可以利用 dfs() 的特点，不需要考虑每次询问加的是哪个节点，而是将询问根据 每个节点的 dep[] 来进行修改，在递归的时候自然就完成了差分，在 dfs() 回溯的时候，再把修改 revert 掉。\n具体操作如下：\n 离线处理所有的询问，记录每一个节点上，都有哪些询问。 dfs(u) 的时候，将 sum[dep[u]] += x，然后 sum[dep[u]+d+1] -= x 回溯的时候，将修改 revert，即：sum[dep[u]] -= x，然后 sum[dep[u]+d+1] += x  记得下传 dp[] 数组的值。\n 法一 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n, m, head[maxn], ecnt = 1, dep[maxn]; ll sum[maxn], ans[maxn], dp[maxn]; // dp[u] 代表u的subtree加上了多少 vector\u0026lt;pii\u0026gt; q[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void dfs(int u, int p) { dep[u] = dep[p] + 1; for (auto pa : q[u]) { int d = pa.first; ll x = pa.second; sum[dep[u]] += x; d = min(3e5, d + dep[u] + 1); sum[d] -= x; } dp[u] += sum[dep[u]]; ans[u] = dp[u]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; dfs(to, u); } for (auto pa : q[u]) { int d = pa.first; ll x = pa.second; sum[dep[u]] -= x; d = min(3e5, d + dep[u] + 1); sum[d] += x; } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } cin \u0026gt;\u0026gt; m; while (m--) { int u,d,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x; q[u].push_back({d, x}); } dfs(1,0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   法二（BFS序 \u0026#43; 二分 \u0026#43; 差分数组） BFS序就是从上到下，从左到右，一层层的进行编号。\n求 BFS 序用一个普通的 BFS 就可以解决：\nint q[maxn], hd = -1, tail = 0, idcnt = 0, id[maxn]; void bfs() { q[++tail] = 1; while (hd \u0026lt;= tail) { int cur = q[hd++]; id[cur] = ++idcnt; mp[idcnt] = cur; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur][0]) continue; q[++tail] = to; } } }   有了 BFS 序以后，我们可以发现：\n$u$ 的子树中，离 $u$ 的距离 $= d+1$ 的所有 vertex 实际上就是 BFS 序上，一段连续的编号。\n所以，我们只要找到这一段编号即可。\n我们可以利用 二分搜索 来查找这一段编号的 左端点和右端点。\n查找端点的时候，我们看一下当前端点编号为 $mid$，往上跳 $d+1$ 格的端点编号即可。\n令 $mid$ 往上跳 $d+1$ 格的端点为 $p$：\n $id[p] \u0026lt; id[u]$：说明端点在 $x$ 的右侧，l = mid+1 $id[p] \u0026gt; id[u]$：说明端点在 $x$ 的左侧，r = mid-1 $id[p] = id[u]$：如果是在查找左端点，那么左端点在左侧，则 r = mid-1；否则右端点在右侧，则 l = mid+1。  由此可以找到左右端点，然后维护一个差分数组，进行一下区间修改即可。\n 法二 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; const int maxm = 2e5+2; int n, m, q[maxn], head[maxn], hd = 0, tail = -1, ecnt = 1, id[maxn], mp[maxn], idcnt = 0; // id[u]: vertex u的id, mp[id]: id对应的vertex u int par[maxn][20], dep[maxn]; ll sum[maxn], dp[maxn]; // sum 为差分数组, dp[u] 代表u的subtree加上了多少 struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 19; j++) { if (d \u0026amp; (1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } void dfs(int u, int p) { dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } void bfs() { q[++tail] = 1; while (hd \u0026lt;= tail) { int cur = q[hd++]; id[cur] = ++idcnt; mp[idcnt] = cur; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur][0]) continue; q[++tail] = to; } } } inline void add(int l, int r, ll val) { if (l == -1) return; // 不存在这样的点 sum[l] += val, sum[r+1] -= val; } void update(int u, int d, ll x) { int L = -1, R = -1; int l = id[u], r = n; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; int p = jump(mp[mid], d+1); if (id[p] \u0026lt; id[u]) l = mid+1; if (id[p] \u0026gt; id[u]) r = mid-1; if (id[p] == id[u]) { L = mid; r = mid-1; } } l = id[u], r = n; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; int p = jump(mp[mid], d+1); if (id[p] \u0026lt; id[u]) l = mid+1; if (id[p] \u0026gt; id[u]) r = mid-1; if (id[p] == id[u]) { R = mid; l = mid+1; } } add(L, R, -x); add(id[u], id[u], x); } void dfs2(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; dfs2(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1,0); bfs(); cin \u0026gt;\u0026gt; m; while (m--) { int u,d,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x; update(u, d, x); } for (int i = 1; i \u0026lt;= n; i++) sum[i] += sum[i-1], dp[mp[i]] = sum[i]; dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 CF1467E Distinctive Roots in a Tree 题意\n给定 $n$ 个节点的树，每个节点 $i$ 上有一个值 $a_i$。\n定义一个节点 $u$ 为 distinctive root，如果：\n从 $u$ 出发，连向任意一个节点 $v$ 的路径上，不存在相同的值。\n输出整个树内，distinctive root 的数量。\n其中，$1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i \\leq 10^9$\n 题解 首先转化成有根树（以 $1$ 为根）。然后我们看，对于任意的两个具有相同权值的节点 $u,v$（$a_u = a_v$），可以分为两种情况：\n令 $x = LCA(u,v)$\n $x \\neq u, x \\neq v$ $x = u$ 或者 $x = v$   以下，用蓝色圈起来的节点，代表权值相同\n Case 1: $x \\neq u, x \\neq v$\n 可以发现，在本图中，所有 不可能为 distinctive root 的节点，为 $4$ 的子树 和 $6$ 的子树。\n  Case 2: $x = u$ 或者 $x = v$\n 在本图中，除了 节点 $6,7,14$ 以外，全都 不可能为 distinctive root。\n 由上，我们可以总结出以下结论：\n情况1：$x \\neq u, x \\neq v$，那么\n $u$ 的子树 $R_u$ $v$ 的子树 $R_v$  均不可能为 distinctive root。\n情况2：$x = u$ 或者 $x = v$，我们假设 $v$ 包含在 $u$ 的子树内。则\n $v$ 的子树 $R_v$ $u$ 外面的所有节点 $u$ 的所有child的子树（除了 $v$ 所在的那个子树以外）  均不可能为 distinctive root。\n例子：如上图中，$u = 3, v = 8$，那么 $u=3$ 有三个子树 $R_{10}, R_6, R_{16}$，因为 $v=8 \\in R_6$，所以 $R_6$ 不受影响。\n 有了上述结论，我们需要思考如何高效的处理。首先我们不可能直接枚举所有权值相同的点对 $(u,v)$。\n对于这一类问题，一个比较常见的套路是：\n维护一个 cnt[] 的桶，在 dfs() 过程中，对当前节点进行统计。\n将上述情况做一个转化：\n对于情况 $1$，我们可以转化为：当我们 dfs(u) 时，看一下 $u$ 的外面是否存在 $v$ 使得 $a_u = a_v$。如果存在，将 $u$ 的所有子树进行标记。\n对于情况 $2$，我们可以转化为：当我们 dfs(u) 时，看一下 $u$ 的某一个子树 $R_j$ 内，是否存在 $v$ 使得 $a_u = a_v$。如果存在，将 除了该子树 $R_j$ 以外 的所有子树都进行标记，然后将 $v$ 的子树 $R_v$ 也进行标记。\n 现在问题转化为：\n对于每个节点 $u$，如何知道：\n $u$ 的外面是否存在 $v$ 使得 $a_u = a_v$ ？ $u$ 的所有child $j$ 的子树 $R_j$ 内，是否存在 $v$ 使得 $a_u = a_v$ ？  这里，就要用到 桶思想。\n先预处理出整棵树的信息 all[]，其中 all[v] 代表 整棵树内 权值为 $v$ 的节点数量。\n维护一个 cnt[]，其中 cnt[v] 代表 当前遇到的 权值为 $v$ 的节点数量。\n在我们 dfs(u) 前，我们看一下 cnt[a[u]] 的值。\n在我们 dfs(u) 结束后，再看一下 cnt[a[u]] 的值。\n  如果在 dfs(u) 之前，cnt[a[u]] = 0。在 dfs(u) 结束后，cnt[a[u]] = all[a[u]]，说明 $u$ 外面不存在 $v$ 使得 $a_u = a_v$。否则，存在。\n  如果在 dfs(to) 之前（$to$ 为 $u$ 的child）和之后，cnt[a[u]] 增加了，说明 $to$ 这个child的子树内，存存在 $v$ 使得 $a_u = a_v$。\n   标记子树就是套路的树上差分了。不再赘述。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; int n; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; map\u0026lt;int,int\u0026gt; all, cnt; int dp[maxn], f[maxn]; // dp代表标记，f代表处理完以后的值，大于0就说明不行 int val[maxn], head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { all[val[u]]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); } } void dfs2(int u, int p) { int v = val[u]; int pcnt = cnt[v]; cnt[v]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; int pre = cnt[v]; dfs2(to, u); if (cnt[v] - pre \u0026gt; 0) { // 里面存在 cur dp[to]--; dp[1]++; } } if (cnt[v] - pcnt \u0026lt; all[v]) { // 外面存在 cur dp[u]++; } } int ans = 0; void dfs3(int u, int p) { f[u] += dp[u]; if (f[u] == 0) ans++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dp[to] += dp[u]; // 标记下传 dfs3(to, u); } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; val[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v), addEdge(v,u); } dfs1(1, 0); dfs2(1, 0); dfs3(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例4 洛谷P1600 [NOIP2016 提高组] 天天爱跑步 题意\n给定一棵 $n$ 个节点的树。有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。所有玩家从第 $0$ 秒开始，以每秒跑 $1$ 条边的速度，沿着最短路径从 $s_i$ 跑到 $t_i$。\n现在给出 $n$ 个数字 $w_i$，对于每个数字 $i$，我们需要回答在 第 $w_i$ 秒时，有多少个玩家恰好站在节点 $i$ 上。\n• 当玩家 $i$ 跑到终点 $t_i$ 后，他会退出游戏。如果他刚好在第 $w_{t_i}$ 秒跑到了节点 $t_i$，那么他会被算入答案中。否则不会被算入。\n其中，$n,m \\leq 3 \\times 10^5, 1 \\leq s_i,t_i \\leq n, 0 \\leq w_i \\leq n$\n 题解 先考虑一下，我们能否对于每一个玩家，考虑他的贡献？\n似乎不行。因为每个节点的 $w_i$ 各不相同，我们没法将一条路径 $(s_i,t_i)$ 上的贡献直接算出来。\n 既然每个节点的 $w_i$ 不同，不妨考虑对于每个节点 $i$，我们看有多少个玩家满足条件。\n同上题一样，一个常规的套路是\n维护一个 cnt[] 的桶，在 dfs() 过程中，对当前节点进行统计。\n那么，这个桶里面需要维护什么信息？\n 首先将树变成有根树（根节点为 $1$），这样每个节点最多只有一个 parent（如果一个节点 $u$ 具有两个 parent $p_1,p_2$，则 $1,p_1,p_2,u$ 成环）。\n所以我们会发现，如果一个玩家 $(s_i,t_i)$ 可能对 $u$ 产生贡献的话，$s_i, t_i$ 的其中至少有一个在 $u$ 的子树内！\n但是，如果只是用一个 cnt[] 来记录，我们无法区分哪个是 $s_i$，哪个是 $t_i$，我们不如分开讨论。\n令 $x_i = LCA(s_i, t_i)$，则路径可以分成两段：$s_i \\rightarrow x_i$（路径上行） 和 $x_i \\rightarrow t_i$ （路径下行）。由于区分了上下行路线，也可以很方便的用 cnt[] 记录深度信息。\n 对于上行路线，只考虑 $s_i$ 的影响。如果 $u$ 在 $s_i \\rightarrow x_i$ 的上行路径上，就可以考虑 $s_i$ 带给 $u$ 的贡献。\n对于这个 $s$，只要满足 $dep[s] - dep[u] = w_u$，即：\n$$dep[u] + w_u = dep[s]$$\n所以在 dfs(u) 的过程中，第 $1$ 个需要维护的桶 ds[]，可以用来维护 dep[s] 的数量，即：\nds[d] 的值为：在 $u$ 的子树内，有多少个节点的 dep = d。\n 对于下行路线，只考虑 $t_i$ 的影响。如果 $u$ 在 $x_i \\rightarrow t_i$ 的下行路径上，就可以考虑 $t_i$ 带给 $u$ 的贡献。\n但是，我们不能单独考虑 $t_i$，因为是否产生贡献，主要是根据 $s_i$ 决定的。我们在考虑 $t_i$ 的时候无法忽略 $s_i$ 的影响。这时候我们要将 $s_i$ 和 $t_i$ 结合起来，变成一个信息，使得我们可以直接用桶来维护。\n带 $s_i$ 的信息不好维护，我们可以预先处理出 $d$，代表 $s_i,t_i$ 这两个节点之间的距离。然后从 $u \\rightarrow t$ 的距离是 $dep[t] - dep[u]$。所以只要满足 $d - (dep[t] - dep[u]) = w_u$，也就是：\n$$w_u - dep[u] = d - dep[t]$$\n所以在 dfs(u) 的过程中，第 $2$ 个需要维护的桶 dt[]，可以用来维护 d - dep[t] 的数量，即：\ndt[a] 的值为：在 $u$ 的子树内，有多少个玩家 $i$ 满足 d - dep[t] = a。\n 有了以上两个桶，就可以在 dfs() 过程中计算答案了。\n我们怎么得到仅在 $u$ 的子树 $R_u$ 内的桶信息？\n还是和上一题一样，在 dfs(u) 之前，和 dfs(u) 结束后，将桶内的值 做一个减法 就可以了！\n 但是我们还有一个问题没解决：\n我们并没有保证 $u$ 在 $s \\rightarrow x \\rightarrow t$ 的路径上！\n这样我们多算了很多答案。为了解决这个问题，我们会发现，当我们的 dfs(u) 只要离开了 $LCA(s,t) = x$ 的子树，$x$ 节点上的信息都没用了。\n所以，我们提前记录每一个节点 $u$ 作为 $LCA$ 时，$s,t$ 在桶内的信息。\n可以在 dfs(u) 离开 $u$ 的时候，减去所有满足 $LCA(s,t) = u$ 的路径 $(s,t)$ 的信息。对应下面的代码是：\nvoid dfs2(int u, int p) { /// Other logics //// // 从两个桶内减去 以u为LCA，(s,t)的桶信息 for (pii a : con[u]) { ds[a.first]--; dt[a.second]--; } } ... // 其他代码 int main() { for (int i = 1; i \u0026lt;= m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int x = LCA(s,t); //// Other logics // 预处理出 以 x为LCA, s和t的桶信息 con[x].push_back({dep[s], d - dep[t]}); } }   我们还剩最后一个问题。如果 $u$ 刚好等于 $LCA(s,t)$，且 $dep[s] - dep[u] = w_u$。\n那么 $s$ 会对 $u$ 产生一次贡献，$t$ 也会产生一次贡献。多产生了一次贡献。\n所以，我们预先看一下每一个玩家 $(s_i, t_i)$，它们的 $LCA$ 是否满足这个条件，如果满足，就事先将 ans[x]--;\n 总结一下本题：\n 将路径分为上行，下行两种。维护两个桶。 dfs() 时，对于 dfs() 前后的信息，相减来获得子树信息。 预处理 $LCA$ 为 $u$ 的所有贡献，在 dfs() 离开 $u$ 时，从桶中减去这些贡献。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,m,head[maxn],ecnt = 1, w[maxn], dep[maxn], par[maxn][20], ans[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int jump(int u, int d) { for (int j = 0; j \u0026lt;= 19; j++) { if (d\u0026amp;(1\u0026lt;\u0026lt;j)) u = par[u][j]; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); u = jump(u, dep[u]-dep[v]); if (u == v) return u; for (int j = 19; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } void dfs(int u, int p) { par[u][0] = p; for (int j = 1; j \u0026lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1]; dep[u] = dep[p] + 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int ds[maxn]; // 第一个桶 map\u0026lt;int,int\u0026gt; dt; // 第二个桶 int st[maxn]; // 记录 start 的数量（st[u] 代表以u为起点的路径数量） vector\u0026lt;int\u0026gt; ed[maxn]; // ed[t] 代表以 t 为终点的所有路径的 d - dep[t] 信息 vector\u0026lt;pii\u0026gt; con[maxn]; void dfs2(int u, int p) { int pds; if (dep[u] + w[u] \u0026lt; maxn) pds = ds[dep[u] + w[u]]; // dfs前，桶1的值 else pds = 0; int pdt = dt[-dep[u] + w[u]]; // dfs前，桶2的值 ds[dep[u]] += st[u]; for (int a : ed[u]) dt[a]++; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs2(to, u); } if (dep[u] + w[u] \u0026lt; maxn) { ans[u] += ds[dep[u] + w[u]] - pds; // dfs后，桶1的值 } ans[u] += dt[-dep[u] + w[u]] - pdt; // dfs后，桶2的值 for (pii a : con[u]) { // 从两个桶内减去所有 以u为LCA，(s,t)的桶信息 ds[a.first]--; dt[a.second]--; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; dfs(1, 0); for (int i = 1; i \u0026lt;= m; i++) { int s,t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int x = LCA(s,t); int d = dep[s] + dep[t] - 2 * dep[x]; if (dep[s] - dep[x] == w[x]) ans[x]--; // 去重 st[s]++; ed[t].push_back(d - dep[t]); con[x].push_back({dep[s], d - dep[t]}); // 预处理出 以 x为LCA, s和t的桶信息 } dfs2(1, 0); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例5 LOJ146 DFS序3 树上差分1 题意\n给定有 $N$ 个节点的树，根节点为 $R$。每个节点 $i$ 具有初始权值 $V_i$。\n给定 $M$ 个操作，有三种：\n$1 ~ a ~ b ~ x$：将 $a,b$ 之间的路径上所有节点权值加上 $x$。（链修改）\n$2 ~ a$：求节点 $a$ 的权值。（点查询）\n$3 ~ a$：求节点 $a$ 子树的权值和。（子树查询）\n其中，$1 \\leq N,M \\leq 10^6$。\n 题解 看起来是树链剖分的模版题，但是 $O(n\\log^2n)$ 是过不了的。\n本题可以利用 DFS序 + 树上差分 达到 $O(n\\log n)$ 的复杂度！\n首先，对于一个链 $(u,v)$，常见套路就是树上差分：\n令 $x = LCA(u,v)$。\n令 $f_u$ 为 从 $root$ 到 $u$ 的路径上，被加上了多少。\n令 $val$ 为本次修改的值。\n然后链修改就被转化为 $f_u+val, f_v + val, f_x - val, f_{par(x)} - val$ 了。\n 现在问题是，有了 $f_u$ 的值，怎么查询？\n在树上差分中，一个很常见的套路是 贡献 思想。\n对于每一个修改，我们都考虑，它对哪些节点的查询具有贡献？\n注意到 $f_u$ 是从 $root$ 到 $u$ 的路径上，被修改的值。\n 对于单点查询 $a$，我们可以发现：\n只要 $u$ 在 $a$ 的子树内，那么 $f_u$ 就可以被加到 $a$ 上，作为 $u$ 对 $a$ 的贡献。\n所以，单点查询 $a$ 就变成了：\n求 $a$ 的子树中的所有节点 $u$ 的 $f_u$ 之和。\n$$ans = \\sum\\limits_u f_u$$\n拿线段树维护一下子树中，$f_u$ 的 sum 即可。\n 对于子树查询 $a$，可以发现：\n当我们修改 $f_u$ 的时候，如果 $u$ 在 $a$ 的子树内，那么从 $a$ 到 $u$ 的这一条链上所有的节点，都应该被算入贡献当中。\n而这个贡献，刚好就是 $(d_u - d_a + 1) \\times f_u$。（$d_u$ 为 $u$ 的depth）\n但是，我们不能直接把 $(d_u - d_a + 1) \\times f_u$ 加到 $a$ 上面，因为 $a$ 的子树中，每个节点的depth不相同。\n$$ans = \\sum\\limits_u (d_u - d_a + 1) \\times f_u = \\sum\\limits_u d_uf_u + (1-d_a)\\sum\\limits_u f_u$$\n所以，线段树还需要再维护一下子树中，$d_uf_u$ 的 sum。\n 最后注意一下，每个节点有个初始的权值 $V_i$，这个拿一个 sum[] 数组单独维护一下就行，每次查询的时候记得加上。\n 本题卡常，一些卡常小技巧：\n 使用树链剖分来求 $LCA$，复杂度仍然是 $O(\\log n)$，但是常数小。 线段树query的时候，使用传入sum的reference，来进行查询。这样就不用返回查询值了。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, m, root, in[maxn], out[maxn], par[maxn], idcnt = 0, ecnt = 1, head[maxn], V[maxn]; ll sum[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int top[maxn], son[maxn], dep[maxn]; void dfs(int u, int p) { sum[u] += (ll)(V[u]); in[u] = ++idcnt; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); int sz = out[to] - in[to] + 1; if (sz \u0026gt; maxsz) { maxsz = sz; son[u] = to; } sum[u] += sum[to]; } out[u] = idcnt; } void dfs2(int u, int p, int topf) { top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); u = par[top[u]]; } if (dep[u] \u0026lt; dep[v]) return u; return v; } struct tree_node { ll fsum, dfsum; } tr[maxn\u0026lt;\u0026lt;2]; void update(int cur, int l, int r, int p, int val1, ll val2) { tr[cur].fsum += (ll)val1; tr[cur].dfsum += val2; if (l == r) return; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, val1, val2); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, val1, val2); } void query(int cur, int l, int r, int L, int R, ll\u0026amp; fsum, ll\u0026amp; dfsum) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { fsum += (ll)(tr[cur].fsum); dfsum += (ll)(tr[cur].dfsum); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(cur\u0026lt;\u0026lt;1, l, mid, L, R, fsum, dfsum); if (R \u0026gt; mid) query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, fsum, dfsum); } int main() { read(n); read(m); read(root); for (int i = 1; i \u0026lt;= n; i++) read(V[i]); for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; read(u); read(v); addEdge(u, v); addEdge(v, u); } dfs(root, 0); dfs2(root, 0, root); while (m--) { int op; read(op); if (op == 1) { int a,b,x; read(a); read(b); read(x); int lca = LCA(a,b), p = par[lca]; update(1, 1, n, in[a], x, (ll)(dep[a]) * (ll)(x)); update(1, 1, n, in[b], x, (ll)(dep[b]) * (ll)(x)); update(1, 1, n, in[lca], -x, -(ll)(dep[lca]) * (ll)(x)); update(1, 1, n, in[p], -x, -(ll)(dep[p]) * (ll)(x)); } else if (op == 2) { int a; read(a); int L = in[a], R = out[a]; ll fsum = 0, dfsum = 0; query(1, 1, n, L, R, fsum, dfsum); fsum += (ll)(V[a]); write(fsum); } else { int a; read(a); ll fsum = 0, dfsum = 0; int L = in[a], R = out[a]; query(1, 1, n, L, R, fsum, dfsum); ll res = dfsum; ll d = dep[a]; res += (1LL - d) * fsum; res += sum[a]; write(res); } } }   例6 LOJ147 DFS序4 题意\n给定有 $N$ 个节点的树，根节点为 $R$。每个节点 $i$ 具有初始权值 $V_i$。\n给定 $M$ 个操作，有三种：\n$1 ~ a ~ x$：将节点 $a$ 的权值加上 $x$。（点修改）\n$2 ~ a ~ x$：将节点 $a$ 的子树中，所有节点权值加上 $x$。（子树修改）\n$3 ~ a ~ b$：求 $a,b$ 之间的路径上所有节点权值和。（链查询）\n其中，$1 \\leq N,M \\leq 10^6$。\n 题解 和上一题思路几乎一致，仍然是考虑每个修改，对于查询的贡献。\n主要的原因在于 链 是只能通过 $f_u$ 来维护的。\n 考虑 单点修改 $a$ 对于 $f_u$ 的贡献？\n如果 $u$ 在 $a$ 的子树内，则 单点修改 $a$ 对于 $f_u$ 具有贡献 $val$。\n所以单点修改 $a$，就变成了：\n将 $a$ 的子树内，所有的 $f_u$ 加上 $val$。\n 考虑 修改 $a$ 的子树 对于 $f_u$ 的贡献？\n如果 $u$ 在 $a$ 的子树内，则修改 $a$ 的子树 对于 $f_u$ 具有贡献 $(d_u - d_a + 1) \\times val$\n所以单点修改 $a$，就变成了：\n将 $a$ 的子树内，所有的 $f_u$ 加上 $(d_u - d_a + 1) \\times val$。\n然而由于 $d_u$ 对于每个 $u$ 均不同，拆开的话就是：\n$$d_u \\times val + (1-d_a) \\times val$$\n对于 $d_u \\times val$，我们直接维护 $val$ 的 sum，在询问的时候再把 $d_u$ 乘上去。\n对于 $(1-d_a) \\times val$，我们直接加到 $f_u$ 上即可。\n 所以，在线段树中，我们维护两个值，$f_u$ 和 $g_u$。\n单点修改 $a$ 的时候，将 $a$ 的子树内，所有的 $f_u$ 加上 $val$。\n修改 $a$ 的子树时，将 $a$ 的子树内，所有的 $f_u$ 加上 $(1-d_a) \\times val$，所有的 $g_u$ 加上 $val$。\n查询 $f_u$ 的真正值 $ans$ 时，有：\n$$ans = f_u + d_u g_u$$\n 对于每个节点的初始值 $V_i$，仍然用一个 sum[] 数组单独维护一下，查询的时候记得加上。\n 注：线段树在 push_down() 和 update(L,R) 的时候，记得要考虑到当前节点的区间长度 len = (r-l+1)。\n 总结：\n例5和例6是 DFS序+树上差分+贡献思想 的优秀应用。\n但是这样的做法局限性比较强，仅适用于一些特殊情况。\n 链修改 + 点/子树查询 链查询 + 点/子树修改  上面这两种可以这样做。但是如果有 链修改 + 链查询 就必须用树链剖分来做了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; int n, m, root, in[maxn], out[maxn], par[maxn], idcnt = 0, ecnt = 1, head[maxn], V[maxn]; ll sum[maxn]; // sum[u] 代表 root -\u0026gt; u 的链sum struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int top[maxn], son[maxn], dep[maxn]; void dfs(int u, int p) { sum[u] += (ll)(V[u]); in[u] = ++idcnt; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; sum[to] += sum[u]; dfs(to, u); int sz = out[to] - in[to] + 1; if (sz \u0026gt; maxsz) { maxsz = sz; son[u] = to; } } out[u] = idcnt; } void dfs2(int u, int p, int topf) { top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); u = par[top[u]]; } if (dep[u] \u0026lt; dep[v]) return u; return v; } struct tree_node { ll fsum, dfsum; bool lazy = 0; ll lazy_fsum, lazy_dfsum; } tr[maxn\u0026lt;\u0026lt;2]; void push_down(int cur, int L, int R) { if (!tr[cur].lazy) return; ll lazy_fsum = tr[cur].lazy_fsum, lazy_dfsum = tr[cur].lazy_dfsum; tr[cur].lazy = 0; tr[cur].lazy_fsum = tr[cur].lazy_dfsum = 0; int l = cur\u0026lt;\u0026lt;1, r = l|1; tr[l].lazy = 1, tr[r].lazy = 1; tr[l].lazy_fsum += lazy_fsum; tr[r].lazy_fsum += lazy_fsum; tr[l].lazy_dfsum += lazy_dfsum; tr[r].lazy_dfsum += lazy_dfsum; int mid = (L+R) \u0026gt;\u0026gt; 1; ll llen = (mid-L+1), rlen = (R-mid); // 记得这里有 len tr[l].fsum += llen * lazy_fsum, tr[r].fsum += rlen * lazy_fsum; tr[l].dfsum += llen * lazy_dfsum, tr[r].dfsum += rlen * lazy_dfsum; } void push_up(int cur) { tr[cur].fsum = tr[cur\u0026lt;\u0026lt;1].fsum + tr[cur\u0026lt;\u0026lt;1|1].fsum; tr[cur].dfsum = tr[cur\u0026lt;\u0026lt;1].dfsum + tr[cur\u0026lt;\u0026lt;1|1].dfsum; } void update(int cur, int l, int r, int L, int R, ll val1, ll val2) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { ll len = (r-l+1); // 记得这里有 len tr[cur].fsum += len * val1; tr[cur].dfsum += len * val2; tr[cur].lazy_fsum += val1; tr[cur].lazy_dfsum += val2; tr[cur].lazy = 1; return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, val1, val2); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, val1, val2); push_up(cur); } void query(int cur, int l, int r, int L, int R, ll\u0026amp; fsum, ll\u0026amp; dfsum) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { fsum += (ll)(tr[cur].fsum); dfsum += (ll)(tr[cur].dfsum); return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(cur\u0026lt;\u0026lt;1, l, mid, L, R, fsum, dfsum); if (R \u0026gt; mid) query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, fsum, dfsum); } // get the result of vertex u ll get_res(int u) { if (!u) return 0; ll fsum = 0, dfsum = 0; query(1, 1, n, in[u], in[u], fsum, dfsum); ll res = fsum + (ll)(dep[u]) * dfsum + sum[u]; return res; } int main() { read(n); read(m); read(root); for (int i = 1; i \u0026lt;= n; i++) read(V[i]); for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; read(u); read(v); addEdge(u, v); addEdge(v, u); } dfs(root, 0); dfs2(root, 0, root); while (m--) { int op; read(op); if (op == 1) { int a,x; read(a); read(x); update(1, 1, n, in[a], out[a], x, 0); } else if (op == 2) { int a,x; read(a); read(x); ll fsum = (ll)(1-dep[a]) * (ll)(x); update(1, 1, n, in[a], out[a], fsum, x); } else { int a,b; read(a); read(b); int lca = LCA(a,b), p = par[lca]; ll r1 = get_res(a), r2 = get_res(b), r3 = get_res(lca), r4 = get_res(p); ll res = r1+r2-r3-r4; write(res); } } }   参考链接  https://www.acwing.com/blog/content/324/ https://loj.ac/d/1698  ","date":"2021-04-05T15:02:19+08:00","permalink":"https://tom0727.github.io/post/037-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/","tags":["树上差分","树"],"title":"树上差分"},{"categories":["算法"],"contents":"介绍 主席树全名叫做 可持久化权值线段树，一般用于一个数组上，有以下的功能：\n 对于每一个区间 都能 开一个权值线段树。 能够维护数组的 历史版本。（仅用于单点插入/修改）  时间复杂度：$O(n\\log n)$，空间复杂度：$O(n \\log n)$。\n思想 节点的复制 主席树的主要思想在于，对于在线段树上的单点修改，如果要维护多个版本（修改前和修改后），我们可以复制出新的节点，来维护新版本的信息。\n由于单点修改仅会影响一条链（从叶子节点，一直到根节点），所以每个版本最多会复制出 $O(\\log n)$ 个新节点。\n如上图，橙色部分就是一个新版本，复制出来了一条链。\n• 因为复制节点，所以也需要 动态开点。\n来一道例题：\n例1 洛谷 P3919 【模板】可持久化线段树 1（可持久化数组）\n题意\n维护一个长度为 $N$ 的数组，共有 $M$ 次询问。询问格式如下：\n$v ~ 1 ~ p ~ x$：在版本 $v$ 的基础上，将 $a_p$ 修改为 $x$\n$v ~ 2 ~ p$：在版本 $v$ 的基础上，询问 $a_p$ 的值\n每次询问后，都生成一个新版本。（所以共有 $M+1$ 个版本）\n 题解 可持久化的操作在上面说过了。对于每一次修改，都 复制一条链。如果是操作 $2$，复制根节点就可以了。\n可持久化的复制节点方式和普通的动态开点略有不同，主要体现在：\n 不需要看 cur == 0 与否，直接复制即可，并且将复制后的编号返回。 需要记录 上一个版本 的 同位置 节点的标号 pre 需要 build 操作 root[0] = build(1,n)，因为初始状态无论是否为空，都需要把线段树开好，否则后面无法复制（也无法进行相减操作）。  访问不同版本的线段树时，就访问它们的 root 即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = 3e7; int n,m,root[maxn],id, arr[maxn]; struct node { int lc,rc,val; } tr[maxm]; int build(int l, int r) { // 参数中没有 cur int cur = ++id; // 直接添加 if (l == r) { tr[cur].val = arr[l]; return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } // 将位置p 的值修改为 x // pre 是前一个版本的 同位置节点 int insert(int pre, int l, int r, int p, int x) { int cur = ++id; tr[cur] = tr[pre]; if (l == r) { tr[cur].val = x; return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p, x); if (p \u0026gt; mid) tr[cur].rc = insert(tr[pre].rc, mid+1, r, p, x); return cur; } int query(int cur, int l, int r, int p) { if (l == r) return tr[cur].val; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query(tr[cur].lc, l, mid, p); else return query(tr[cur].rc, mid+1, r, p); } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; root[0] = build(1,n); // 注意需要 build(1,n)，这是版本 0 } int main() { init(); for (int i = 1; i \u0026lt;= m; i++) { int v, op, p; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; op \u0026gt;\u0026gt; p; if (op == 1) { int x; cin \u0026gt;\u0026gt; x; root[i] = insert(root[v], 1, n, p, x); } else { int res = query(root[v], 1, n, p); // 版本 v 的根 cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; root[i] = root[v]; } } }   区间询问（两个线段树相减） 区间问题常用的一个思想是 前缀和。\n那么对于一个数组 $a_1,a_2,\u0026hellip;,a_n$，我们可以维护 $n+1$ 个版本的权值线段树。分别维护了 $sum_0, sum_1, sum_2, \u0026hellip;, sum_n$ 的信息。\n例如，$sum_0$ 是一个空的权值线段树（已经 build() 过的），$sum_3$ 这个权值线段树维护的就是 $a_1,a_2,a_3$ 这个数组的信息。\n要求 $sum_3$，我们在 $sum_2$ 的基础上，将 $a_3$ 的信息加进 $sum_2$（单点修改），形成一个新版本的权值线段树即可。\n那么，如果我们要求 $[L,R]$ 这个区间对应的权值线段树，只要求出 $sum_r - sum_{l-1}$ 对应的权值线段树就可以了！\n线段树之间怎么相减？把对应节点维护的值相减一下即可！\n 以上就是主席树的全部内容了，本质上是 节点复制 + 线段树相减。\n这样，对于每一个区间，都可以获得一个权值线段树。\n例题 例2 洛谷P3834 【模板】可持久化线段树 2（主席树） 题意\n给定 $N$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，和 $m$ 个询问，每次询问 $[L,R]$ 之间的第 $k$ 小值。保证询问合法。\n其中，$1 \\leq n,m \\leq 2 \\times 10^5, |a_i| \\leq 10^9$\n 题解 思考一个问题能否用主席树，我们可以先思考，对于整个数组，我们能否用权值线段树解决？\n答案是可以的！如果我们要求整个数组的第 $k$ 小，可以将所有数字先离散化成排名，然后用权值线段树来维护各个排名的数量。求可以求出第 $k$ 小了！\n所以主席树可以解决，步骤如下：\n 对整个数组进行离散化 维护主席树，对于每一个 $[L,R]$ 都可以获得一个权值线段树，然后可以求得第 $k$ 小。   注：离散化的一个很方便的写法是 struct + sort()，然后遍历 sort 后的数组：\nint arr[maxn]; int N = 0, rk[maxn], val[maxn]; // N: 排名数，rk[i]: arr[i]的排名，val[i]: 排名为i的数字的值 void init() { for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i].val, arr[i].id = i; sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026lt; b.val; }); rk[arr[1].id] = ++N; val[1] = arr[1].val; for (int i = 2; i \u0026lt;= n; i++) { if (arr[i].val \u0026gt; arr[i-1].val) N++; rk[arr[i].id] = N; val[N] = arr[i].val; } }   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+5; const int maxm = 1e7; int n,m; struct Num { int val, id; } arr[maxn]; int rk[maxn], val[maxn]; // rk[1] 代表 arr[1] 离散化后的值（排名）, val[1] 代表整个array中第1小的值 int N = 0; struct node { int lc, rc, cnt; } tr[maxm]; int root[maxn], id = 0; int build(int l, int r) { int cur = ++id; if (l == r) { return cur; } int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } // pre 是上个版本的节点 // 令 p 位置的 cnt += 1 int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; // 复制一份上个版本 tr[cur].cnt++; // 添加了一个节点 if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) tr[cur].rc = insert(tr[cur].rc, mid+1, r, p); return cur; } // 查询 tr[pre,cur] 之间的第k小，返回具体的值 int query(int pre, int cur, int l, int r, int k) { if (l == r) return val[l]; int prelc = tr[pre].lc, lc = tr[cur].lc; int prerc = tr[pre].rc, rc = tr[cur].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc].cnt - tr[prelc].cnt; if (lcnt \u0026gt;= k) return query(prelc, lc, l, mid, k); // 如果左边有 \u0026gt;= k 个数 else return query(prerc, rc, mid+1, r, k-lcnt); // 否则只看右边 } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i].val, arr[i].id = i; sort(arr+1, arr+n+1, [](auto a, auto b) { return a.val \u0026lt; b.val; }); rk[arr[1].id] = ++N; val[1] = arr[1].val; for (int i = 2; i \u0026lt;= n; i++) { if (arr[i].val \u0026gt; arr[i-1].val) N++; rk[arr[i].id] = N; val[N] = arr[i].val; } root[0] = build(1, N); for (int i = 1; i \u0026lt;= n; i++) { root[i] = insert(root[i-1], 1, N, rk[i]); } } int main() { init(); for (int i = 1; i \u0026lt;= m; i++) { int l,r,k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; int ans = query(root[l-1], root[r], 1, N, k); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例3 CF1422F Boring Queries 题意\n给定 $n$ 个正整数 $a_1, a_2, \u0026hellip; , a_n$，$q$ 次询问。\n每次询问 $[x,y]$，为了保证询问在线，记上一次询问的答案为 $last$，然后令 $L = ((x+last) \\text{ mod } n) + 1$，$R = ((y+last) \\text{ mod } n) + 1$，如果 $L \u0026gt; R$，则交换 $L,R$。\n每次询问，回答 $[L,R]$ 之间所有数的 LCM，答案对 $10^9+7$ 取模。\n其中，$1 \\leq n,q \\leq 10^5, 1 \\leq a_i \\leq 2 \\times 10^5, 1 \\leq x,y \\leq 10^5$\n 题解 本题主要有两个难点：\n 所有询问在线。 $LCM$ 数字极大，且需要取模，无法正常维护。  因为 $LCM$ 的值极大，且取模，可以考虑 质因数分解。\n但是，$a_i \\leq 2 \\times 10^5$，我们无法直接维护每一个质因子。\n这时候可以考虑 根号分治，将质因子分为两部分：\n一部分是 $\\leq \\sqrt {(2 \\times 10^5)}$ 的质因子。\n还有一部分是 $\u0026gt; \\sqrt {(2 \\times 10^5)}$ 的质因子。\n 对于 $\\leq \\sqrt {(2 \\times 10^5)}$ 的质因子，我们会发现这种小因子只有 $87$ 个。所以我们只要维护 $87$ 个 ST表 来维护每个小因子在区间内的最大次数即可。\n 对于 $\u0026gt; \\sqrt {(2 \\times 10^5)}$ 的质因子，我们会发现它们的出现次数最多为 $1$，并且对于任意一个 $a_i$，它最多只能包含一个这样的大因子。\n所以对于大因子而言，求 $LCM$ 就转化为：\n求一个区间内，有哪些不同的大因子出现过，将这些 unique 的大因子乘起来就可以了！\n 那么，如何解决如下的问题？\n 给定一个数组，询问一个区间，求该区间内 所有不同的数的乘积。\n 这个问题，我们在 HH的项链 中见到过。\n但是这个题 强制在线，没法用上面的离线方法来解决。\n所以，我们维护一个 pr[] 数组，其中 pr[i] 代表：对于 i，上一个值等于 arr[i] 的 index 的值。\n（即：pr[i] = j，其中 arr[j] = arr[i], j \u0026lt; i）\n在询问 $[L,R]$ 时，我们将问题转化为：\n 求区间内所有 arr[i] 的乘积，使得：\n  $i \\in [L,R]$\n  pr[i] \u0026lt; L\n   这个问题可以用 主席树 解决。我们根据 pr[i] 的值来建主席树，树上节点的值就维护乘积。线段树相减 就用 乘积的逆元 来实现。\n 最后总结一下本题的步骤：\n 欧拉筛求出所有质数。 维护 $87$ 个小于等于 $450$ 的小质因子，建立 $87$ 个ST表。 建好大因子的主席树。   本题空间卡的非常紧，我们将 ST表 的数组改为了 short 类型，可以避免 MLE。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 1e5+2; const int maxm = 2e5+2; vector\u0026lt;int\u0026gt; primes; bool is_prime[maxm]; int n, arr[maxn]; void euler() { fill(is_prime, is_prime+maxm, 1); for (int cur = 2; cur \u0026lt; maxm; cur++) { if (is_prime[cur]) primes.push_back(cur); for (auto p : primes) { if (p * cur \u0026gt;= maxm) break; is_prime[p*cur] = 0; if (cur % p == 0) break; } } } short st[87][maxn][18]; short bin[maxn]; int ask_st(int i, int l, int r) { int len = (r-l+1); int k = bin[len]; return max(st[i][l][k], st[i][r-(1\u0026lt;\u0026lt;k)+1][k]); } void build_st() { bin[1] = 0; bin[2] = 1; for (int i = 3; i \u0026lt; maxn; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 0; i \u0026lt;= 86; i++) { int p = primes[i]; for (int j = 1; j \u0026lt;= n; j++) { int cnt = 0; while (arr[j] % p == 0) { arr[j] /= p, cnt++; } st[i][j][0] = cnt; } for (int k = 1; k \u0026lt; 18; k++) { for (int j = 1; j+(1\u0026lt;\u0026lt;k)-1 \u0026lt;= n; j++) { st[i][j][k] = max(st[i][j][k-1], st[i][j+(1\u0026lt;\u0026lt;(k-1))][k-1]); } } } } struct node { int lc,rc; ll val = 1; } tr[maxn\u0026lt;\u0026lt;5]; int id, root[maxn], pr[maxn]; inline ll qpow(ll a, ll b) { if (!b) return 1; ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } inline ll inv(ll a) { return qpow(a, mod-2); } int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l,mid); tr[cur].rc = build(mid+1, r); return cur; } void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].val = (tr[lc].val * tr[rc].val) % mod; } int insert(int pre, int l, int r, int p, ll x) { int cur = ++id; tr[cur] = tr[pre]; (tr[cur].val *= x) %= mod; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p, x); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p, x); push_up(cur); return cur; } // 询问 [pre, cur] 之间的大质数之积, 且保证 pr[i] \u0026lt; p ll query(int pre, int cur, int l, int r, int p) { if (r \u0026lt; p) return (tr[cur].val * inv(tr[pre].val)) % mod; if (l \u0026gt;= p) return 1; int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 1; (res *= query(tr[pre].lc, tr[cur].lc, l, mid, p)) %= mod; (res *= query(tr[pre].rc, tr[cur].rc, mid+1, r, p)) %= mod; return res; } int pos[maxm]; void init() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; euler(); build_st(); root[0] = build(0,n); for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; pr[i] = pos[val]; pos[val] = i; } for (int i = 1; i \u0026lt;= n; i++) { root[i] = insert(root[i-1], 0, n, pr[i], arr[i]); } } ll last = 0; ll Query(ll L, ll R) { L += last, R += last; L %= n, R %= n; L++, R++; if (L \u0026gt; R) swap(L,R); ll big = query(root[L-1], root[R], 0, n, L); ll small = 1; for (int i = 0; i \u0026lt;= 86; i++) { ll p = primes[i]; int c = ask_st(i,L,R); (small *= qpow(p,c)) %= mod; } last = (small * big) % mod; return last; } int main() { init(); int q; cin \u0026gt;\u0026gt; q; while (q--) { ll L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; cout \u0026lt;\u0026lt; Query(L,R) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例4 洛谷P2468 [SDOI2010]粟粟的书架 题意\n给定一个 $R \\times C$ 的矩阵，矩阵中所有元素均为正整数，有 $M$ 个询问，每次询问：\n$x_1 ~ y_1 ~ x_2 ~ y_2 ~ H$：求 $(x_1,y_1)$ 和 $(x_2,y_2)$ 之间的矩形中，最少取多少个数字可以让数字之和 $\\geq H$？\n数据范围：\n对于 $50$ % 的数据，有 $R,C \\leq 200, M \\leq 2 \\times 10^5$\n对于另外 $50$ % 的数据，有 $R = 1, C \\leq 5 \\times 10^5, M \\leq 2 \\times 10^4$\n矩阵中所有元素满足值在 $[1, 1000]$ 之间，$H \\leq 2 \\times 10^9$\n 题解 我们需要让数字之和尽量大，那么每次询问就选择最大的那些数。\n可以维护主席树，以元素的值作为权值，节点之中维护 $cnt$ 和 $sum$。\n对于 $R = 1$ 的情况很好解决。那么对于 $R \\leq 200$ 呢？\n有两种方法，\n法一：维护 $200$ 棵主席树\n询问的过程中，把每一行的线段树都进行 相加 （具体实现通过维护 vector\u0026lt;int\u0026gt; pre, vector\u0026lt;int\u0026gt; cur）。\n 法二：维护二维前缀和\nsum[i][j][k] 代表 $(1,1)$ 和 $(i,j)$ 之间矩阵之中，数值 $\\geq k$ 的数字的和\ncnt[i][j][k] 代表 $(1,1)$ 和 $(i,j)$ 之间矩阵之中，数值 $\\geq k$ 的数字的数量\n询问的时候，二分一下 $k$ 就可以了。\n以下给出主席树代码。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct node { int lc, rc, sum, cnt; } tr[maxn\u0026lt;\u0026lt;5]; int n,m,Q, id = 0; vector\u0026lt;int\u0026gt; sum[201]; vector\u0026lt;int\u0026gt; arr[201]; vector\u0026lt;int\u0026gt; root[201]; int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].sum += p; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } pii query(vector\u0026lt;int\u0026gt;\u0026amp; pre, vector\u0026lt;int\u0026gt;\u0026amp; cur, int l, int r, int need) { if (need \u0026lt;= 0) return {0,0}; int allsum = 0, allcnt = 0; for (int i = 0; i \u0026lt; pre.size(); i++) { int p = pre[i], c = cur[i]; allsum += tr[c].sum - tr[p].sum; // 200棵线段树相加 allcnt += tr[c].cnt - tr[p].cnt; } if (allsum \u0026lt;= need) return {allcnt, allsum}; if (l == r) return {(need/l + (need % l \u0026gt; 0)), (need/l + (need % l \u0026gt; 0)) * l}; int mid = (l+r) \u0026gt;\u0026gt; 1; vector\u0026lt;int\u0026gt; plc, lc, prc, rc; for (int i = 0; i \u0026lt; pre.size(); i++) { int p = pre[i], c = cur[i]; plc.push_back(tr[p].lc); lc.push_back(tr[c].lc); prc.push_back(tr[p].rc); rc.push_back(tr[c].rc); } int needcnt = 0, needsum = 0; pii res = query(prc, rc, mid+1, r, need); need -= res.second; needcnt += res.first; needsum += res.second; res = query(plc, lc, l, mid, need); needcnt += res.first; needsum += res.second; return {needcnt, needsum}; } bool ok(int x1, int y1, int x2, int y2, int tar) { int res = 0; for (int i = x1; i \u0026lt;= x2; i++) { res += sum[i][y2] - sum[i][y1-1]; } return res \u0026gt;= tar; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= n; i++) { sum[i] = arr[i] = root[i] = vector\u0026lt;int\u0026gt;(m+1,0); root[i][0] = build(1, 1000); for (int j = 1; j \u0026lt;= m; j++) { int val; cin \u0026gt;\u0026gt; val; arr[i][j] = val; sum[i][j] = sum[i][j-1] + val; root[i][j] = insert(root[i][j-1], 1, 1000, val); } } } int main() { init(); while (Q--) { int x1,y1,x2,y2,tar; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; tar; if (!ok(x1,y1,x2,y2,tar)) cout \u0026lt;\u0026lt; \u0026quot;Poor QLW\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; else { vector\u0026lt;int\u0026gt; cur,pre; for (int i = x1; i \u0026lt;= x2; i++) cur.push_back(root[i][y2]), pre.push_back(root[i][y1-1]); pii ans = query(pre, cur, 1, 1000, tar); cout \u0026lt;\u0026lt; ans.first \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例5 洛谷P2633 Count on a tree 题意\n给定一棵 $n$ 个节点的树，每个点 $i$ 具有权值 $a_i$。\n有 $m$ 个询问，每次询问 $u ~ v ~ k$，回答 $u \\text { xor } last$ 和 $v$ 的最短路径中，第 $k$ 小的点权。\n其中，$last$ 为上次询问的答案，且保证每次询问均合法。\n点权值的范围在 $[0, 2^{31}-1]$ 之间。\n 题解 树上主席树。\n与普通主席树不同，我们主席树中的 前缀 代表了从 parent 继承而来的部分。即，我们选定 $1$ 作为根，那么一条从上到下的路径，就形成了一个主席树上的 前缀。\ninsert() 的时候，就有如下的代码：\nint root_id = 0, root[maxn], ver_root[maxn]; // ver_root[u] 的值为 u 对应的版本的 root index void dfs(int u, int p) { root_id++; ver_root[u] = root_id; root[root_id] = insert(root[ver_root[p]], 1, N, rk[u]); // 从parent p那里继承而来 // .... }   那么，怎么将 $u,v$ 之间的路径转化为 前缀之间的加减？（也就是线段树之间的加减）\n回忆一下 树上启发式合并中，一道关于形成回文串路径的题目：CF741D\n我们当时采用的是：\n$$f_{u,v} = (f_u \\text{ xor } f_x) \\text{ xor } (f_v \\text{ xor } f_x) = f_u \\text{ xor } f_v$$\n其中 $x = LCA(u,v)$\n 那么本题的思路也一样，将路径问题转化为 $LCA$ 问题。（实际上，本质就是 树上差分）\n所以，令 $x = LCA(u,v)$，令 $f_u$ 为 $1 \\rightarrow u$ 的路径对应的线段树。\n我们发现在线段树上，$u,v$ 之间的路径 $f_{u,v}$，就是 $$f_u + f_v - f_x - f_{par(x)}$$\n那么剩下的就是经典的主席树模版，区间第 $k$ 小问题了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct Num { int id, v; } nums[maxn]; struct node { int lc, rc, cnt; } tr[maxn\u0026lt;\u0026lt;5]; int n, m, arr[maxn], rk[maxn], val[maxn], N = 0, id = 0; int root[maxn]; int ecnt = 1, head[maxn], par[maxn][19], dep[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } int query(int pre1, int pre2, int cur1, int cur2, int l, int r, int k) { if (l == r) return l; int plc1 = tr[pre1].lc, prc1 = tr[pre1].rc; int plc2 = tr[pre2].lc, prc2 = tr[pre2].rc; int lc1 = tr[cur1].lc, rc1 = tr[cur1].rc; int lc2 = tr[cur2].lc, rc2 = tr[cur2].rc; int mid = (l+r) \u0026gt;\u0026gt; 1; int lcnt = tr[lc1].cnt + tr[lc2].cnt - tr[plc1].cnt - tr[plc2].cnt; // 线段树加减 if (k \u0026lt;= lcnt) return query(plc1, plc2, lc1, lc2, l, mid, k); else return query(prc1, prc2, rc1, rc2, mid+1, r, k-lcnt); } int jump(int u, int d) { int c = 0; while (d) { if (d\u0026amp;1) u = par[u][c]; d \u0026gt;\u0026gt;= 1, c++; } return u; } int LCA(int u, int v) { if (dep[u] \u0026lt; dep[v]) swap(u,v); int d = dep[u] - dep[v]; u = jump(u, d); if (u == v) return u; for (int j = 18; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j]; } return par[u][0]; } int root_id = 0, ver_root[maxn]; // ver_root[u] 的值为 u 对应的版本的 root index void dfs(int u, int p) { root_id++; ver_root[u] = root_id; root[root_id] = insert(root[ver_root[p]], 1, N, rk[u]); dep[u] = dep[p] + 1; par[u][0] = p; for (int j = 1; j \u0026lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1]; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); } } int Query(int u, int v, int k) { int lca = LCA(u,v); int res = query(root[ver_root[lca]], root[ver_root[par[lca][0]]], root[ver_root[u]], root[ver_root[v]], 1, N, k); return val[res]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], nums[i] = {i, arr[i]}; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u, v); addEdge(v, u); } // 离散化 sort(nums + 1, nums + 1 + n, [](auto a, auto b) { return a.v \u0026lt; b.v; }); rk[nums[1].id] = ++N; val[1] = nums[1].v; for (int i = 2; i \u0026lt;= n; i++) { if (nums[i].v \u0026gt; nums[i-1].v) { N++; } rk[nums[i].id] = N; val[N] = nums[i].v; } root[0] = build(1, N); dfs(1, 0); } int last = 0; int main() { fastio; init(); while (m--) { int u,v,k; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; k; u ^= last; last = Query(u,v,k); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例6 CF813E Army Creation 题意\n给定 $n$ 个数字 $a_1,a_2,\u0026hellip;,a_n$，给定一个数字 $k$，有 $q$ 次询问，每次询问：\n$x ~ y$：令 $L = ((x+last) \\text { mod } n) + 1, R = ((y+last) \\text { mod } n) + 1$，回答 $[L,R]$ 中，最多可以选多少个数，使得任何一个数字选择的数字次数 $\\leq k$？\n 题解 仍然是 强制在线，还是和例4的做法一样，维护 pr[] 数组：只不过维护的值改了一下：\n$pr[i] = j$，满足 $arr[i] = arr[j]$，且 $i$ 往前走 $k$ 个位置，就得到 $j$ 。\n然后每次询问就回答 $[L,R]$ 之中，有多少个 $i \\in [L,R]$ 满足 $pr[i] \u0026lt; L$。\n 预处理这个 pr[] 数组，可以通过倍增的方式（类似于 LCA）来做。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int n,k; int par[maxn][19], pr[maxn], id = 0, root[maxn], last = 0, arr[maxn], pos[maxn]; struct node { int lc,rc,cnt; } tr[maxn\u0026lt;\u0026lt;5]; int build(int l, int r) { int cur = ++id; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; tr[cur].lc = build(l, mid); tr[cur].rc = build(mid+1, r); return cur; } int insert(int pre, int l, int r, int p) { int cur = ++id; tr[cur] = tr[pre]; tr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) tr[cur].lc = insert(tr[pre].lc, l, mid, p); else tr[cur].rc = insert(tr[pre].rc, mid+1, r, p); return cur; } int query(int pre, int cur, int l, int r, int L) { if (r \u0026lt; L) return tr[cur].cnt - tr[pre].cnt; if (l \u0026gt;= L) return 0; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; res += query(tr[pre].lc, tr[cur].lc, l, mid, L); res += query(tr[pre].rc, tr[cur].rc, mid+1, r, L); return res; } int jump(int u, int d) { int c = 0; while (d) { if (d\u0026amp;1) u = par[u][c]; c++; d \u0026gt;\u0026gt;= 1; } return u; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { int val; cin \u0026gt;\u0026gt; val; arr[i] = val; par[i][0] = pos[val]; pos[val] = i; } root[0] = build(0, n); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= 18; j++) { par[i][j] = par[par[i][j-1]][j-1]; } pr[i] = jump(i, k); root[i] = insert(root[i-1], 0, n, pr[i]); } } int main() { init(); int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l = (l + last) % n + 1; r = (r + last) % n + 1; if (l \u0026gt; r) swap(l,r); last = query(root[l-1], root[r], 0, n, l); cout \u0026lt;\u0026lt; last \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   例7 CF1404C Fixed Point Removal 题意\n给定长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n我们每次可以选择 $i$ 使得 $a_i = i$，然后将它删掉。删掉后，剩下的部分会合并在一起。\n现在有 $q$ 个询问，每次询问 $(x,y)$，回答：\n如果将 $a_1,a_2,\u0026hellip;,a_x$ 赋值为 $n+1$，$a_n,a_{n-1},\u0026hellip;,a_{n-y+1}$ 赋值为 $n+1$ （实际上，就是让 $a$ 的前 $x$ 个元素 和 后 $y$ 个元素变得无法删除。），我们能最多删除多少个元素？\n询问之间完全独立，互不影响。\n其中，$1 \\leq n,q \\leq 3 \\times 10^5, a_i \\in [1,n], x,y \\geq 0, x+y \u0026lt; n$\n 题解 首先，我们先不考虑询问的问题。\n对于原数组，如何求出最多删除的元素个数？\n我们会发现，当我们删除一个元素时，它右边的所有元素的 index 都会减少 $1$，这可能导致右边的元素又出现了可删除的。\n同时我们发现，如果对于 $i$，有 $a_i \u0026gt; i$，则无论怎么删除，$i$ 只减不增，这样 $a_i = i$ 永远不可能成立。\n这意味着，当出现 $a_i = i$ 时，就要立刻删除，如果它左边的元素被删了，它就再也删不掉了。\n所以对于原数组，最优的删除方法是：\n从右侧开始删，删完一个数字后，判断右边有没有出现新的可删数字，如果有的话继续从右开始。\n 有了贪心的删除策略，我们不能简单的模拟删除过程，因为这是 $O(n^2)$ 的。\n每次删除操作，我们需要对右边的元素的index 进行区间减 $1$，很明显可以用线段树来维护。\n不妨将问题转化一下，令 $b_i = i - a_i$：\n 当 $b_i = 0$ 时，可以删除，删除时，将 $[i+1,n]$ 的所有 $b_i$ 都减去 $1$。 当 $b_i \u0026lt; 0$ 时，永远都不可能删除。 当 $b_i \u0026gt; 0$ 时，如果它未来的某时刻被减为 $0$ 了，则可以被删掉。  那我们在线段树里面维护一个 $min$，代表区间最小值。\n如果一个元素 $\u0026lt; 0$，则直接把它赋值为 $10^9$，无论怎么减，它都不可能等于 $0$，代表着它是一个无效元素（永远不可能被删除，或者已经被删除）。\n每次询问一下区间最小值的位置，如果最小值为 $0$，就把这个位置 $i$ 的元素删掉，然后将 $[i+1,n]$ 都减去 $1$，然后将 $b_i$ 设为 $10^9$（代表已删除）。\n 现在有了 无询问 情况下的解，有询问怎么办？\n我们观察一下样例数组（长度为 $13$）\n$[2,2,3 ,9 ,5 ,4 ,6 ,5 ,7, 8, 3, 11, 13]$\n我们删除的 index 顺序（指原数组的index）是：$13,5,12,7,10,9,3,8,6,2,11$。\n假设我们询问了 $x=3, y=1$，这意味着 $1,2,3$ 和 $13$ 都不能出现在这个删除序列中了（我们给它们 打上标记），并且它后面的 所有 比它大 的数字也被打上标记了（因为它实际上依赖前面的数字，但是前面的这些数字无法被删了）！如下：\n找 $1$，$1$ 不在删除序列中，忽略。\n找 $2$，$2$ 在删除序列中，后面比它大的数字有 $11$，所以 $2,11$ 打上标记。\n找 $3$，$3$ 在删除序列中，后面比它大的数字有 $8,6,2,11$，所以 $3,8,6,2,11$ 打上标记。\n找 $13$，$13$ 在删除序列中，后面不存在比它大的数字。所以 $13$ 打上标记。\n以上，剩下没有被标记的，只有 $5,12,7,10,9$，共 $5$ 个数字，所以答案为 $5$。\n 将上述的模拟过程，总结一下就是：\n设删除序列（就是上面的 $13,5,12,7,10,9,3,8,6,2,11$）为 $c$。\n那么，每次询问 $(x,y)$，所有 未被标记 的index $i$，必须得满足以下的所有条件：\n $c_i \\in [x+1, n-y]$ $pre_i \\geq x+1$  其中，$pre_i$ 代表 $\\min \\{ c_1,c_2,\u0026hellip;,c_{i-1}\\}$。这是因为，如果 $pre_i \\leq x$，则 $i$ 前面必然存在一个数字被标记了，所以 $i$ 也要被标记。\n 现在问题就转化为：\n给定一个长度为 $n$ 的数组，每个元素是 $(c, pre)$ 的形式。\n每次询问 $(x,y)$，求有多少个 $i \\in [1,n]$ 满足以下所有条件：\n $c_i \\in [x+1, n-y]$ $pre_i \\geq x+1$  有离线和在线两种方法。\n 在线做法：\n将数组根据 $c$ 的值，sort一下。\n每次询问的时候，先用二分找到左边界 $l$，满足 $c_l \\geq x+1$，且 $l$ 尽可能小。\n再二分找到右边界 $r$，满足 $c_r \\leq n-y$，且 $r$ 尽可能大。\n然后问题就转化为，求 $[l,r]$ 之间，有多少个元素 $i$，满足：\n $i \\in [l,r]$ $pre_i \\geq x+1$  那这就是一个标准的主席树问题了。\n复杂度：$O(n\\log^2n)$\n 离线做法：\n将所有的询问，根据 $x$ 的值，从大到小 进行sort。\n然后，将数组根据 $pre$ 的值，从大到小 进行sort。\n所以，我们在回答每个询问 $(x,y)$ 的时候，我们只需要考虑 $pre_i \\geq x+1$ 的部分。\n也就是说我们可以开一个线段树，维护 $c_i$ 的值。\n假如我们当前处理到了 询问 $(x,y)$，我们只在线段树内维护所有满足 $pre_i \\geq x+1$ 的 $c_i$ 即可。\n• 这本质上是一个，将数组内的元素，根据 $pre_i$ 的值，逐一插入到线段树中的过程。\n复杂度：$O(n\\log n)$\n 总结：\n本题的思考流程分为以下几个步骤：\n 找到最优的删除策略。 对于无询问状态下，如何模拟删除过程。 对于有询问状态下，如何模拟删除过程。 如何处理一个 类似二维数点 的问题。   在线做法（主席树） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,q; struct node { int idx, val; } arr[maxn]; struct tree_node { int minval, idx; int lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].minval = min(tr[cur\u0026lt;\u0026lt;1].minval, tr[cur\u0026lt;\u0026lt;1|1].minval); } void push_down(int cur) { if (tr[cur].lazy == 0) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].minval += lazy, tr[r].minval += lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].minval = arr[l].val; tr[cur].idx = arr[l].idx; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026gt; R) return; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].minval += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // query if [1,n] has minval = 0, (query right first), if yes, return the idx (original) int query(int cur, int l, int r) { if (tr[cur].minval != 0) return -1; if (l == r) { return tr[cur].idx; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (tr[cur\u0026lt;\u0026lt;1|1].minval == 0) return query(cur\u0026lt;\u0026lt;1|1, mid+1, r); return query(cur\u0026lt;\u0026lt;1, l, mid); } // delete the element in p void del(int cur, int l, int r, int p) { if (l == r) { tr[cur].minval = 1e9; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (p \u0026lt;= mid) del(cur\u0026lt;\u0026lt;1, l, mid, p); if (p \u0026gt; mid) del(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); push_up(cur); } struct Num { int val, pre; } seq[maxn]; int tail = 0; void init() { build(1, 1, n); while (1) { int p = query(1, 1, n); if (p == -1) break; del(1, 1, n, p); seq[++tail] = {p, (int)1e9}; update(1, 1, n, p+1, n, -1); } if (!tail) return; for (int i = 2; i \u0026lt;= tail; i++) { seq[i].pre = min(seq[i-1].pre, seq[i-1].val); } sort(seq+1, seq+tail+1, [](auto a, auto b) { return a.val \u0026lt; b.val; // 根据 c 的值先进行sort }); } void debug() { printf(\u0026quot;tail = %d\\n\u0026quot;,tail); for (int i = 1; i \u0026lt;= tail; i++) { printf(\u0026quot;%d \u0026quot;, seq[i].val); } printf(\u0026quot;\\n\u0026quot;); } struct persistent_tree_node { int lc, rc, cnt; } ptr[maxn\u0026lt;\u0026lt;5]; int root[maxn], id = 0; int insert(int pre, int l, int r, int p) { int cur = ++id; ptr[cur] = ptr[pre]; ptr[cur].cnt++; if (l == r) return cur; int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) ptr[cur].lc = insert(ptr[pre].lc, l, mid, p); if (p \u0026gt; mid) ptr[cur].rc = insert(ptr[pre].rc, mid+1, r, p); return cur; } int query(int cur, int pre, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return ptr[cur].cnt - ptr[pre].cnt; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(ptr[cur].lc, ptr[pre].lc, l, mid, L, R); if (R \u0026gt; mid) res += query(ptr[cur].rc, ptr[pre].rc, mid+1, r, L, R); return res; } // return the smallest index, where seq[i].val \u0026gt;= x int search_down(int x) { int l = 1, r = tail; int ans = tail+1; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (seq[mid].val \u0026gt;= x) { ans = mid; r = mid-1; } else l = mid+1; } return ans; } // return the largest index, where seq[i].val \u0026lt;= x int search_up(int x) { int l = 1, r = tail; int ans = 0; while (l \u0026lt;= r) { int mid = (l+r) \u0026gt;\u0026gt; 1; if (seq[mid].val \u0026lt;= x) { ans = mid; l = mid+1; } else r = mid-1; } return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].val; arr[i].idx = i; int val = arr[i].val, idx = i; if (val \u0026gt; idx) arr[i].val = 1e9; else arr[i].val = i - val; } init(); for (int i = 1; i \u0026lt;= tail; i++) { root[i] = insert(root[i-1], 1, n, seq[i].pre); } while (q--) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int ans = 0; int l = search_down(x+1); int r = search_up(n-y); if (l \u0026gt; r) ans = 0; else { ans = query(root[r], root[l-1], 1, n, x+1, n); } // 以下是暴力的做法： // for (int i = 1; i \u0026lt;= tail; i++) { // if (seq[i].val \u0026gt;= x+1 \u0026amp;\u0026amp; seq[i].val \u0026lt;= n-y \u0026amp;\u0026amp; seq[i].pre \u0026gt;= x+1) ans++; // } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   离线做法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 3e5+5; int n,q; struct node { int idx, val; } arr[maxn]; struct tree_node { int minval, idx; int lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].minval = min(tr[cur\u0026lt;\u0026lt;1].minval, tr[cur\u0026lt;\u0026lt;1|1].minval); } void push_down(int cur) { if (tr[cur].lazy == 0) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[l].lazy += lazy, tr[r].lazy += lazy; tr[l].minval += lazy, tr[r].minval += lazy; } void build(int cur, int l, int r) { if (l == r) { tr[cur].minval = arr[l].val; tr[cur].idx = arr[l].idx; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026gt; R) return; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy += x; tr[cur].minval += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // query if [1,n] has minval = 0, (query right first), if yes, return the idx (original) int query(int cur, int l, int r) { if (tr[cur].minval != 0) return -1; if (l == r) { return tr[cur].idx; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (tr[cur\u0026lt;\u0026lt;1|1].minval == 0) return query(cur\u0026lt;\u0026lt;1|1, mid+1, r); return query(cur\u0026lt;\u0026lt;1, l, mid); } // delete the element in p void del(int cur, int l, int r, int p) { if (l == r) { tr[cur].minval = 1e9; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (p \u0026lt;= mid) del(cur\u0026lt;\u0026lt;1, l, mid, p); if (p \u0026gt; mid) del(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); push_up(cur); } struct Num { int val, pre; } seq[maxn]; int tail = 0; void init() { build(1, 1, n); while (1) { int p = query(1, 1, n); if (p == -1) break; del(1, 1, n, p); seq[++tail] = {p, (int)1e9}; update(1, 1, n, p+1, n, -1); } if (!tail) return; for (int i = 2; i \u0026lt;= tail; i++) { seq[i].pre = min(seq[i-1].pre, seq[i-1].val); } sort(seq+1, seq+tail+1, [](auto a, auto b) { return a.pre \u0026gt; b.pre; // 根据 pre 进行 sort }); } struct Query_node { int x,y,id; } que[maxn]; int ans[maxn]; struct tree_node2 { int cnt; } tr2[maxn\u0026lt;\u0026lt;2]; void insert(int cur, int l, int r, int p) { tr2[cur].cnt++; if (l == r) { return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) insert(cur\u0026lt;\u0026lt;1, l, mid, p); else insert(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } int Query(int cur, int l, int r, int L, int R) { if (L \u0026gt; R) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr2[cur].cnt; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += Query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += Query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; arr[i].val; arr[i].idx = i; int val = arr[i].val, idx = i; if (val \u0026gt; idx) arr[i].val = 1e9; else arr[i].val = i - val; } init(); for (int i = 1; i \u0026lt;= q; i++) { cin \u0026gt;\u0026gt; que[i].x \u0026gt;\u0026gt; que[i].y; que[i].id = i; } sort(que+1, que+q+1, [](auto a, auto b){ return a.x \u0026gt; b.x; }); int p = 0; for (int i = 1; i \u0026lt;= q; i++) { int x = que[i].x, y = que[i].y, id = que[i].id; while (p+1 \u0026lt;= tail \u0026amp;\u0026amp; seq[p+1].pre \u0026gt;= x+1) { // 满足 pre \u0026gt;= x+1 就插入 p++; insert(1, 1, n, seq[p].val); // 逐一插入进线段树 } ans[id] = Query(1, 1, n, x+1, n-y); } for (int i = 1; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://www.luogu.com.cn/blog/Fighting-Naruto/solution-p3834  ","date":"2021-03-31T10:42:02+08:00","permalink":"https://tom0727.github.io/post/036-%E4%B8%BB%E5%B8%AD%E6%A0%91/","tags":["主席树","可持久化"],"title":"主席树"},{"categories":["算法"],"contents":"介绍 权值线段树 权值线段树用于维护一定值域内，各个元素出现的次数，结合动态开点可以 避免离散化的处理。\n举个例子，我们现在有一个长度为 $10$ 的数组 $[1,5,2,3,4,1,3,4,4,4]$\n$1$ 出现了 $2$ 次，$2$ 出现了 $1$ 次，$3$ 出现了 $2$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $1$ 次。\n则这个线段树长这样：\n每个叶子节点的值： 代表 这个值的出现次数。\n非叶子节点的值：代表了某一个值域内，所有值出现次数的和。\n 动态开点 我们会发现，在上面的线段树中，$6,7,8$ 都没有出现过，所以值为 $0$。\n$7,8$ 对应节点的 parent 的值也为 $0$，这样很浪费空间。而且在值域较大的时候（如维护 $[1,10^{18}]$ 的权值线段树）时，这样开点是不可行的。\n所以我们可以用 动态开点 来解决空间问题。\n动态开点与普通线段树的区别，主要在于以下几个方面：\n 一个节点的左右 child 不一定为 cur\u0026lt;\u0026lt;1, cur\u0026lt;\u0026lt;1|1，而是以 lc, rc 的形式储存在 struct 中。 更改某一个节点的值，或者 push_down() 时，如果节点不存在，则创建一个。 询问某一个节点的值时，如果节点不存在，直接返回 $0$。 不需要 build() 线段树，因为在一开始，整个线段树没有任何节点。  这样做有什么好处呢？\n 大幅度节省空间，尤其对于值域较大的权值线段树。 如果一个数组初始状态均为 $0$，就避免了普通线段树需要 build() 的过程。如果需要初始化，则一个个 insert() 进去也可以。 在需要维护多棵线段树时（比如 $HDU ~6183$ 需要开 $51$ 棵动态开点线段树），可以将它们维护在同一个数组上，大幅度节省空间。  例题 例1 洛谷P1908 逆序对 题解 求逆序对，我们可以从左往右遍历数组，遍历到 $i$ 时，检查一下已经遍历的值中，有多少比它大的即可。\n这可以用权值线段树来实现。\n因为每个数字的范围是 $[1,10^9]$，所以需要动态开点。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; struct node { int lc, rc, cnt; // 记录左右child的编号，如果不存在，则为 0 } tr[maxn]; int id = 0; // 动态开点用的pointer int root = 0; // 根节点编号 void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].cnt = tr[lc].cnt + tr[rc].cnt; } // 插入一个值为 p 的元素 void insert(int\u0026amp; cur, int l, int r, int p) { if (!cur) cur = ++id; // 动态开点 if (l == r) { tr[cur].cnt++; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) insert(tr[cur].lc, l, mid, p); if (p \u0026gt; mid) insert(tr[cur].rc, mid+1, r, p); push_up(cur); } // 询问 值在 [L,R] 之间的元素有多少个 ll query(int cur, int l, int r, int L, int R) { if (!cur) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return (ll)tr[cur].cnt; } int mid = (l+r) \u0026gt;\u0026gt; 1; ll res = 0; if (L \u0026lt;= mid) res += query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) res += query(tr[cur].rc, mid+1, r, L, R); return res; } int main() { int n; cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; insert(root, 1, 1e9+1, x); ans += query(1, 1, 1e9+1, x+1, 1e9+1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例2 CF69E Subsegments 题意\n给定正整数 $n,k$，给定一个长度为 $n$ 的数组 $a_1,a_2,\u0026hellip;,a_n$。\n输出 $n-k+1$ 个数，每个数字代表 $[a_{i},\u0026hellip;, a_{i+k-1}]$ 中，仅出现一次的元素的最大值。\n如果不存在仅出现一次的元素，输出 $-1$。\n其中，$n \\leq 10^5, 1 \\leq k \\leq n, |a_i| \\leq 10^9$\n 题解 在线段树节点里面额外维护一个信息 bool one，代表这个值域内，是否存在仅出现一次的元素。然后询问时，优先询问右边（值域较大的部分）。\n还有一个问题，$a_i$ 的值可以为负数，怎么维护？\n我们可以将 $a_i$ 都加上一个 delta = 1e9，这样让每一个 $a_i \\geq 0$，然后就可以用权值线段树来维护了。记得在 insert(), query() 时，也要加上这个 delta = 1e9。\n 注：我们用 int mid = (r-l) / 2 + l 来代替 int mid = (l+r) \u0026gt;\u0026gt; 1，防止 overflow。\n证明它们两个的等效性：因为 (r-l) 和 (l+r) 的奇偶性一样，且均为非负数，所以它们等效。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; const int maxm = 1e5+10; int n,k,id = 0, root = 0; struct node { int lc,rc,cnt; bool one; // 这个值域内，是否存在unique的元素 } tr[maxn]; int arr[maxm]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].one = tr[lc].one | tr[rc].one; tr[cur].cnt = tr[lc].cnt + tr[rc].cnt; } void insert(int\u0026amp; cur, int l, int r, int p, int f) { if (!cur) cur = ++id; if (l == r) { tr[cur].cnt += f; if (tr[cur].cnt == 1) tr[cur].one = 1; else tr[cur].one = 0; return; } int mid = (r - l) / 2 + l; if (p \u0026lt;= mid) insert(tr[cur].lc, l, mid, p, f); if (p \u0026gt; mid) insert(tr[cur].rc, mid+1, r, p, f); push_up(cur); } int query(int cur, int l, int r) { if (!tr[cur].one) return -1; if (l == r) return l; int lc = tr[cur].lc, rc = tr[cur].rc; int mid = (r - l) / 2 + l; if (tr[rc].one) return query(rc, mid+1, r); else return query(lc, l, mid); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= k-1; i++) { insert(root, 0, 2e9, arr[i]+1e9, 1); } for (int i = k; i \u0026lt;= n; i++) { insert(root, 0, 2e9, arr[i]+1e9, 1); int a = query(root, 0, 2e9); if (a == -1) { cout \u0026lt;\u0026lt; \u0026quot;Nothing\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else { cout \u0026lt;\u0026lt; (a - (int)1e9) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } insert(root, 0, 2e9, arr[i-k+1]+1e9, -1); } }   例3 CF474E Pillars 题意\n给定正整数 $n,d$，还有长度为 $n$ 的数组 $h_1,h_2,\u0026hellip;,h_n$。\n求数组中 最长的 subsequence $b$（不一定连续），使得 $\\forall i, |b_{i+1} - b_i| \\geq d$。\n其中，$n \\leq 10^5, 0 \\leq d \\leq 10^9, 1 \\leq h_i \\leq 10^{15}$\n 题解 一个很明显的 dp 思路：\n当我们遍历到 $i$ 时，令 $dp[j]$ 为：目前为止，结尾的值为 $j$ 的 subsequence 的最大长度。\n那么 $dp[h_i] = \\max\\limits_j \\{ dp[j]+1 \\}$，其中 $|h_i - j| \\geq d$\n那么，这个 dp 数组就可以用权值线段树来维护。\n查询的时候，分别查询 $j \\geq h_i + d$ 和 $j \\leq h_i - d$ 的部分即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 8e6; const int maxm = 1e5+10; int n, pre[maxm], dp[maxm]; ll arr[maxm], d; int root,id; struct node { int lc,rc,m,idx; // m: dp数组的值，idx: 该值域内，具有最大的 m 对应的原来array中的index } tr[maxn]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; if (tr[lc].m \u0026gt; tr[rc].m) tr[cur].m = tr[lc].m, tr[cur].idx = tr[lc].idx; else tr[cur].m = tr[rc].m, tr[cur].idx = tr[rc].idx; } void insert(int\u0026amp; cur, ll l, ll r, ll h, ll m, int idx) { if (!cur) cur = ++id; if (l == r) { if (m \u0026gt; tr[cur].m) { tr[cur].m = m; tr[cur].idx = idx; } return; } ll mid = (l+r) \u0026gt;\u0026gt; 1; if (h \u0026lt;= mid) insert(tr[cur].lc, l, mid, h, m, idx); if (h \u0026gt; mid) insert(tr[cur].rc, mid+1, r, h, m, idx); push_up(cur); } // return the index with maximum m value pll query(int cur, ll l, ll r, ll L, ll R) { if (!cur) return {0,0}; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return {tr[cur].m, tr[cur].idx}; } ll mid = (l+r) \u0026gt;\u0026gt; 1; pll r1, r2; if (L \u0026lt;= mid) r1 = query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) r2 = query(tr[cur].rc, mid+1, r, L, R); if (r1.first \u0026gt; r2.first) return r1; return r2; } const ll up = 1e15 + 2e9 - 1LL; const ll delta = 1e9-1; int ans = 0, maxi = 0; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { ll h = arr[i]; pll r1 = query(root, 0, up, 0, h-d+delta); pll r2 = query(root, 0, up, h+d+delta, up); pll r; if (r1.first \u0026gt; r2.first) r = r1; else r = r2; dp[i] = dp[r.second] + 1; pre[i] = r.second; insert(root, 0, up, h+delta, dp[i], i); if (ans \u0026lt; dp[i]) ans = dp[i], maxi = i; } vector\u0026lt;int\u0026gt; vec; while (maxi) { vec.push_back(maxi); maxi = pre[maxi]; } cout \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; for (int i = vec.size()-1; i \u0026gt;= 0; i--) { cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例4 HDU6183 Color it 题意\n给定一个二维平面，初始状态下，整个平面为空，现在有以下 3 种操作：\n$0$： 清空平面\n$1 ~ x ~ y ~ c$：在 $(x,y)$ 添加一种颜色 $c$\n$2 ~x~ y_1~ y_2$：查询所有 $(a,b)$ 的不同颜色数量，其中 $1 \\leq a \\leq x, y_1 \\leq b \\leq y_2$\n其中，$1\\leq x,y \\leq 10^6, 0 \\leq c \\leq 50$\n数据保证，最多有 $150000$ 个连续的询问 $1$，最多有 $10$ 个询问 $0$。\n 题解 首先，发现 颜色 $c$ 只有 $51$ 种，所以我们可以分开维护每一种颜色，统计的时候加起来就可以了。\n其次，发现本题询问 $2 ~x~ y_1~ y_2$ 时，我们只关心 $1 \\leq a \\leq x$ 的部分，也就是说，对于同一种颜色和同一个 $y$ 坐标而言，我们只关心 最小的那个 $x$ 坐标。\n所以，我们可以根据 $y$ 轴开一棵线段树，维护 $y$ 坐标对应的最小 $x$ 值。\n有 $51$ 种颜色，所以我们开 $51$ 棵线段树即可。\n 注：如果开51棵普通的线段树会 $MLE$，所以用动态开点，把它们开在同一个数组上，使用 int root[51] 来维护 $51$ 棵线段树的 root 即可。\n  注：如果询问是 $1 ~ x_1 ~ x_2 ~ y_1 ~ y_2$ 的这种形式，似乎要用 线段树套线段树 （还没学）。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 8e6; int id = 0; int root[51]; struct node { int lc,rc,x = 1e9; } tr[maxn]; void push_up(int cur) { int lc = tr[cur].lc, rc = tr[cur].rc; tr[cur].x = min(tr[lc].x, tr[rc].x); } void insert(int\u0026amp; cur, int l, int r, int c, int x, int y) { if (!cur) cur = ++id; if (l == r) { tr[cur].x = min(tr[cur].x, x); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (y \u0026lt;= mid) insert(tr[cur].lc, l, mid, c, x, y); else insert(tr[cur].rc, mid+1, r, c, x, y); push_up(cur); } bool query(int cur, int l, int r, int c, int x, int L, int R) { if (!cur) return 0; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].x \u0026lt;= x; } int mid = (l+r) \u0026gt;\u0026gt; 1; bool res = 0; if (L \u0026lt;= mid) res |= query(tr[cur].lc, l, mid, c, x, L, R); if (res) return 1; if (R \u0026gt; mid) res |= query(tr[cur].rc, mid+1, r, c, x, L, R); return res; } void init(int i) { tr[i].lc = tr[i].rc = 0; tr[i].x = (int)1e9; } void clearall() { for (int i = 0; i \u0026lt;= 50; i++) { root[i] = 0; } for (int i = 1; i \u0026lt;= id; i++) init(i); id = 0; } int main() { int op; while (1) { cin \u0026gt;\u0026gt; op; if (op == 0) clearall(); if (op == 1) { int x,y,c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; c; insert(root[c], 1, 1e6, c, x, y); } if (op == 2) { int ans = 0; int x,y1,y2; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; y2; if (y1 \u0026gt; y2) swap(y1,y2); for (int c = 0; c \u0026lt;= 50; c++) { ans += query(root[c], 1, 1e6, c, x, y1, y2); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } if (op == 3) { return 0; } } }   ","date":"2021-03-27T20:13:23+08:00","permalink":"https://tom0727.github.io/post/035-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":["线段树"],"title":"权值线段树（动态开点）"},{"categories":["题解"],"contents":"题目链接 题意\n给定正整数 $c,d,x$，求正整数pair $(a,b)$ 的数量使得 $$c \\times lcm(a,b) - d \\times gcd(a,b) = x$$\n其中，共 $T \\leq 10^4$ 个testcase，$1 \\leq c,d,x \\leq 10^7$\n• $(a,b)$ 和 $(b,a)$ 不同，例如 $(1,6), (6,1)$ 算两个，但是 $(3,3),(3,3)$ 算一个。\n 题解 对于任意一个$(a,b)，$令 $l = lcm(a,b), ~g = gcd(a,b)$，则必然有 $g|l$。\n那么两边同除 $g$，我们有\n$$c \\times \\frac{l}{g} - d = \\frac{x}{g}$$\n这说明： $g|x$\n所以我们可以枚举 $x$的所有因子 $g$ （例如 $x = 12$，因子有 $g=1,2,3,4,6,12$），当我们已知 $g = gcd(a,b)$ 时，$l = lcm(a,b)$ 也可以计算出来。\n  怎么枚举 $x$ 的所有因子 $g$？\n for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } }    问题转化为：已知 $gcd(a,b), ~ lcm(a,b)$，如何求满足条件的 $(a,b)$ 数量？\n 发现 $gcd$ 为所有质因子的 $\\min$，而 $lcm$ 为所有质因子的 $\\max$。\n所以对于 $lcm(a,b)$ 的每一个质因子 $p_i$，看一下 $p_i$ 在 $lcm(a,b)$ 中出现的次数是否大于它在 $gcd(a,b)$ 中出现的次数即可。\n如果大于，我们可以将这个质因子 出现次数较小的分配给 $a$，或者给 $b$，所以答案乘上 $2$。\n如果等于，则这个质因子没有贡献，答案不变。\n实现过程中，直接令 $r = \\frac{lcm(a,b)}{gcd(a,b)}$，然后看一下 $r$ 有多少个质因子就可以了。\n设 $r$ 的质因子数量为 $m$，则 $ans = 2^m$\n  快速求 $r$ 的质因子数量，我们可以预处理出 每一个数的质因子数量，但是数组的上限 maxn 是多少？\n 注意到 $c\\times r - d = \\frac{x}{g}$，所以 $r = \\frac{x}{gc} + \\frac{d}{c}$，分母最小的情况下，$g = c = 1$，所以 $r = (x + d) \\leq 2\\times10^7$，只要预处理 maxn \u0026lt;= 2e7 的部分即可。\n  怎么预处理出每一个数的质因子数量？\n 有两种方法，比较简单的是直接用 Eratosthenes 筛法，还有一种是欧拉筛 + dp。\n法一：Eratosthenes 筛法\nint sum[maxn]; // 每个数的质因子出现个数 void init() { for (int i = 2; i \u0026lt;= maxn-5; i++) { if (sum[i] == 0) { // i为质数 for (int j = i; j \u0026lt;= maxn-5; j += i) sum[j]++; } } }  因为 $j$ 是从 $i$ 开始的，所以复杂度为 $O(n\\log n)$\n• 注: 如果无需计算质因子数量，只需要筛质数的话，直接从 int j = i * i 开始即可，这样的复杂度为 $O(n \\log \\log n)$\n法二：欧拉筛 + dp\nbool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; // dp，继承之前的质数数量 if (i % cur) sum[tar]++; // 如果 i 和 cur互质，说明 cur 是一个没用过的质数 if (i % cur == 0) break; } } }  复杂度：$O(n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e7+5; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int sum[maxn]; ll a,b,x,ans = 0; void cal(ll g) { ll l = (b*g + x); if (l % (a * g)) return; ans += (1LL \u0026lt;\u0026lt; (sum[l/(a*g)])); } bool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; if (i % cur) sum[tar]++; if (i % cur == 0) break; } } } int main() { int T; cin \u0026gt;\u0026gt; T; init(); while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; x; ans = 0; for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-22T23:47:16+08:00","permalink":"https://tom0727.github.io/post/034-cf-1499d/","tags":["数学"],"title":"CF 1499D（数学，筛法）"},{"categories":["算法"],"contents":"介绍 数位DP是指这样一类题型：\n给定一些限定条件，求 $[L,R]$ 内满足这些条件的数字数量，一般 $L,R$ 可能非常大（例如$10^{18}, 10^{1000}$）\n限定条件的一些例子：\n例1. 不含前导0，相邻两个数字差至少为2\n例2. 不包含4，不包含62\n例3. 存在长度至少为2的回文子串\n算法 首先，求 $[L,R]$ 内满足条件的数字数量，可以转化为 先求 $[1,R]$，再减去 $[1,L-1]$ 的部分。\n然后，因为数字很大，所以把它拆成每一位数来看，就可以进行 DP 或者 记忆化搜索 了。\n记忆化搜索 经典的搜索状态有：\n 当前在第几位数：int pos 是否含有前导0：bool zero 当前数字的前面部分，是否受到最大值限制：bool limit 前一位使用的数字 int pre  • 上述部分状态，有可能用不到。\n• 可能有额外状态，根据题目具体来定。\n• 一般来说，记忆化用到的 dp 数组，不需要记录 zero 和 limit。\n• 记忆化搜索的代码难度远远小于递推。\n 记忆化搜索时，有以下需要注意的点：\n 将数位 从低到高 进行排列（因为也许可以重复利用），从高位开始，往低位搜。 有前缀 $0$ 时（zero = 1），注意其他的搜索状态全部清零。（因为有前缀 $0$ 就相当于我们刚刚开始搜索） dp 数组初始化为 -1，一般每次搜索都要重新 memset(dp, -1, sizeof(dp)) dp 数组记录的状态是 (!limit \u0026amp;\u0026amp; !zero) 的状态（即，无任何限制的情况），这样才可以利用。当 (limit || zero) 时，我们需要继续搜索。  DP DP • 因为不推荐这么写，所以折叠了。\n本质和记忆化搜索相同，DP速度可能较快，但是一般很难写，一般有两种写法：\n 写法一：\n令 dp 数组记录 严格小于数字 $x$ 的满足条件的数量。\n将数位按照 高位到低位 排好，然后对于前缀等于 $x$ 的那些数，进行单独处理。\n这种写法可以见 ABC194F的题解\n 写法二：\n将数位按照 低位到高位 排好。（注意，和上面相反）\n预处理出 dp 数组（不带任何限制）。\n预处理以后，对于每一个询问，都直接进行处理，有3种情况：\n(以下的 $n$ 指的是当前询问数字 $x$ 的数位个数)\n 数字使用的位数 $\u0026lt; n$，则没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $\u0026lt; arr[n]$，也没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $= arr[n]$，则我们需要从最高位的前一位 n-1 开始，对于每一位 i，都枚举当前使用的数字 j = 0,1,...,arr[i]-1，然后再到前一位 i-1。   为什么不枚举 j = arr[i] 的情况？\n 注意到 dp 数组里表示的是不带任何限制的数量，当 j = arr[i] 时，更高位的数字都被固定为 $x$ 的高位部分了，所以是有限制的，不能算进去。\n以下给出 SCOI2009 windy 数 的写法：\nll dp[12][12]; int arr[12]; void init() { // 处理无限制的部分 for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数 = p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数 = p，最高位 == arr[p] for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果高位固定的部分已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; // 检查一下这个数字 arr[] 本身是否满足条件 return ans; }  注：在DP处理高位 等于 $x$的高位 时，一定要注意 高位的数字都已经被固定了，所以需要算进答案里，或者需要检查一下被固定的数是否满足条件了。\n注：最后要单独检查一下 这个数字 $x$ 本身是否满足条件。\n 例题 例1 洛谷P2657 Windy数 题意\n给定 $a,b \\leq 2 \\times 10^9$，求 $[a,b]$ 内满足以下条件的数字数量：\n 不含前导 $0$ 两个数字之差至少为 $2$   代码-DP法二 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[12][12]; int arr[12]; void init() { for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } int p; bool check() { for (int i = 2; i \u0026lt;= p; i++) { if (abs(arr[i] - arr[i-1]) \u0026lt; 2) return 0; } return 1; } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数=p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数=p，最高位=p for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果前缀已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; return ans; } int main() { init(); int a,b; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; a; int r = solve(a) - solve(b-1); cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; }   例2 洛谷P2602 数字计数 题意\n给定两个正整数 $a \\leq b \\leq 10^{12}$，求 $[a,b]$ 内的所有整数中，每个 digit 出现的次数。\n 题解 我们枚举每一个digit，然后进行记忆化搜索即可。\n记忆化搜索一般比较模版化，其中 zero, limit 的套路是可以背下来的。\n对于本题，枚举每一个digit $cur$，令 $dp[i][j]$ 表示到了 第 $i$ 位，包含 $j$ 个 $cur$的数字数量。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll a,b; ll dp[14][14]; // dp[i][j]: 到第i位，包含j个cur的数的数量 int arr[14]; // 数字x的各个数位 （从低位到高位） int n; // 数字x的长度 int cur; // 当前枚举的数字 (0...9) // pos: 当前到了第几位 // cnt: 当前数字包含了 cnt 个 cur // zero: 是否有前缀 0 // limit: 前面部分是否完全等于高位 ll dfs(int pos, int cnt, bool zero, bool limit) { if (pos \u0026lt;= 0) { return cnt; } if (!zero \u0026amp;\u0026amp; !limit \u0026amp;\u0026amp; dp[pos][cnt] != -1) // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时获得dp值，否则继续往下搜索 return dp[pos][cnt]; int ed = 9; if (limit) ed = arr[pos]; // 如果前面完全等于高位，那么这一位不能超过当前位 ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) res += dfs(pos-1, 0, 1, 0); // 如果仍然保持前缀 0，那么记得将 cnt 清零，limit也要清零。 else { res += dfs(pos-1, cnt + (j == cur), 0, limit \u0026amp;\u0026amp; (j == arr[pos])); } } if (!zero \u0026amp;\u0026amp; !limit) dp[pos][cnt] = res; // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时记录dp值 return res; } ll solve(ll x) { n = 0; memset(dp, -1, sizeof(dp)); while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 1, 1); // 从高位开始 } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (cur = 0; cur \u0026lt;= 9; cur++) { cout \u0026lt;\u0026lt; solve(b) - solve(a-1) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例3 洛谷P3413 萌数 题意\n给定两个正整数 $L \\leq R \\leq 10^{1000}$，求满足以下条件的数字数量：\n $x \\in [L,R]$ $x$ 包含长度至少为2的回文子串 $x$ 没有前缀 $0$   题解 我们只需要考虑长度为 $2$ 或者 $3$ 的回文子串即可（因为 $\u0026gt;3$ 的情况已经被它们两个包含了）。\n那么我们可以设定 dp 数组为：\n$dp[i][j][k][0/1]$：我们当前在第 $i$ 位，往前 $2$ 位的数字为 $j$，往前 $1$ 位的数字为 $k$，且 不包含（0）/ 包含（1） 回文子串 的数字数量。\n注意到，最后一维度判断了是否包含回文子串。因为一个数有可能 前面几位没有回文子串，但是 后来又有了。如果我们只记录 包含 的情况，会漏掉很多答案。\n而 dfs() 函数的意思是：我们从当前这个状态出发，能获得多少符合条件的数字。\n 注：有的时候，前 $1$ 位，前 $2$ 位上可能没有数字，我们可以设定这些空着的位为 $10$。\n  注：因为本题数字过大，所以不采用减去 $dfs(L-1)$ 的形式，而是 减去 $dfs(L)$，然后特判一下 $L$ 本身是否满足。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[1002][11][11][2]; string s; int n; ll dfs(int pos, int pre2, int pre1, bool zero, bool limit, bool moe) { if (pos \u0026gt;= n) { return moe; } int ed = 9; if (limit) ed = s[pos] - '0'; if (!limit \u0026amp;\u0026amp; !zero \u0026amp;\u0026amp; dp[pos][pre2][pre1][moe] != -1) return dp[pos][pre2][pre1][moe]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) (res += dfs(pos+1, 10, 10, 1, 0, 0)) %= mod; else { (res += dfs(pos+1, pre1, j, 0, limit \u0026amp;\u0026amp; (j == ed), moe || (j == pre1 || j == pre2))) %= mod; } } if (!limit \u0026amp;\u0026amp; !zero) dp[pos][pre2][pre1][moe] = res; return res; } ll solve(string a) { n = a.size(); if (n \u0026lt;= 1) return 0; memset(dp, -1, sizeof(dp)); s = a; return dfs(0, 10, 10, 1, 1, 0); } bool check(string s) { int n = s.size(); for (int i = 0; i \u0026lt; n-1; i++) { if (s[i] == s[i+1]) return 1; if (i+2 \u0026lt; n \u0026amp;\u0026amp; s[i] == s[i+2]) return 1; } return 0; } int main() { string a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll r = solve(b) - solve(a); r += check(a); cout \u0026lt;\u0026lt; (r % mod + mod) % mod \u0026lt;\u0026lt; endl; }   例4 洛谷P4127 同类分布 题意\n给定两个正整数 $a,b \\leq 10^{18}$，求 $[a,b]$ 中，各位置上数字之和 能够整除该数字 的数字个数。\n 题解 可以发现最大的数字只有 $18$ 个 $9$，所以最大的数位和就是 $18 \\times 9 = 162$。\n所以我们可以枚举数位和 $cur$，然后找到符合以下条件的数字 $x$ 的数量：\n $x \\in [a,b]$ $x$ 各位置上数位和 等于 $cur$ $x \\text{ mod } cur = 0$  令 dp 数组为：\n$dp[i][j][k]$：当前到了第 $i$ 位，数位和为 $j$，数字本身 $\\text{mod } cur = k$ 的数字数量。\n 注意到本题不关心前缀 $0$，因为就算有前缀 $0$，也不会对 dfs() 内的其他参数 $sum, v$ 产生任何影响，也不会对枚举当前位使用的数字 $j$ 产生影响，所以可以舍去了。\n 有一个很重要的优化（在多testcase的情况下，优化程度极大）：\n注意到代码里面：\nfor (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); }  我们在 solve(b) 结束后，并没有 memset(dp, -1, sizeof(dp));\n这是因为我们的 dfs() 是从高位开始，枚举到低位。因为 dp[] 数组里保存的都是 !limit 的无限制情况，所以这里面的内容是可以重复利用的！\n但是对于 不同的 cur 就不能重复利用了，因为数组本身的意义已经不同了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[19][163][163]; int arr[19]; int n; int cur; ll dfs(int pos, int sum, int v, bool limit) { // sum为数位和，v为 x % cur 的值 if (!pos) { return (sum == cur) \u0026amp;\u0026amp; (!v); } if (!limit \u0026amp;\u0026amp; dp[pos][sum][v] != -1) return dp[pos][sum][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { res += dfs(pos-1, sum + j, (v * 10 + j) % cur, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][sum][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } int main() { memset(dp, -1, sizeof(dp)); ll a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll ans = 0; for (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 CF55D Beautiful numbers 题意\n给定正整数 $L \\leq R \\leq 9 \\times 10^{18}$，求满足以下条件的数字 $x$ 的数量：\n $x \\in [L,R]$ $x$ 能够被它每一位上的数字整除  共有 $T \\leq 10$ 个 testcase\n 题解 $x$ 可以被每一位上的数字整除 $\\iff$ $x \\text { mod } lcm = 0$\n其中 $lcm$ 是 $x$ 每一位上的数字的 $lcm$。\n发现 $lcm(1,2,\u0026hellip;,9) = 2520$，所以我们可以大致得出以下的状态：\n$dp[i][j][k]$：我们来到了第 $i$ 位，$j$ 表示我们使用了哪些数字，$k$ 代表当前数字 $x \\text { mod } 2520$ 的值。\n这样最后在 pos == 0 时，判断一下 $j$ 对应的 $lcm$，然后判断 $k \\text { mod } lcm_j = 0$ 是否成立即可。\n 现在问题是，这个 $j$ 怎么表示？（$j$ 代表 $x$ 用了 $0,1,2,\u0026hellip;9$ 中的哪些数字）\n可以用状压来实现，其中忽略掉 $0,1$，只记录是否包含 $2,3,\u0026hellip;,9$。大概有 $2^8 - 1$ 种状态，但是这样仍然会 $TLE$，怎么办？\n我们发现，记录使用了哪些数字，只是为了求出这些数字的 $lcm$，那我们直接记录 $lcm$ 作为状态即可！\n但是好像维度反而变大了，因为 $lcm$ 最大可以达到 $2520$，比之前状压的 $2^8 - 1$ 还大。\n 再观察一下，发现我们只关心有效的 $lcm$ 值，$2520$ 内的绝大多数值是无效的，所以我们可以枚举出所有 有效的 $lcm$，而这些有效的 $lcm$ 就是 $2520$ 的所有因子。总共只有 $48$ 个。\n所以我们只需要进行一次 离散化 的操作，将这些因子 map 到 $0,1,2,\u0026hellip;,47$，这样 $j$ 就可以只用 $48$ 个数字来表示了。\n 最后就是 memset(dp, -1, sizeof(dp)) 的优化了，因为本题的 dp[] 数组在不同的 case 之间的含义没有任何变化（都是 $\\text {mod } 2520$），所以只在一开始 memset 一次，之后就一直重复利用。\n• 本题的 memset 优化非常重要，因为有 $T = 10$ 个 case ，大概会有 $2 \\times T = 20$ 倍左右的速度差（如果不优化会 $TLE$ 的很惨）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 2520; ll dp[20][49][2520]; int idx[2521]; int n = 0, arr[20]; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int LCM(int a, int b) { return a/gcd(a,b)*b; } vector\u0026lt;int\u0026gt; fac; void init() { for (int i = 1; i \u0026lt;= sqrt(mod); i++) { if (mod % i == 0) { fac.push_back(i); if (i != mod/i) fac.push_back(mod/i); } } sort(fac.begin(), fac.end()); for (int i = 0; i \u0026lt; fac.size(); i++) { idx[fac[i]] = i; // 离散化，例如 idx[1] = 0, idx[2520] = 47 } } // lc 代表当前的 lcm, v 代表 x % 2520 的值 ll dfs(int pos, int lc, int v, bool limit) { if (pos \u0026lt;= 0) { return v % lc == 0; // 注意，只有在 pos == 0时，才判断 % lc，其余情况都是 % 2520 } if (!limit \u0026amp;\u0026amp; dp[pos][idx[lc]][v] != -1) return dp[pos][idx[lc]][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { int newval = (v * 10 + j) % mod; if (j \u0026lt; 2) res += dfs(pos-1, lc, newval, limit \u0026amp;\u0026amp; (j == ed)); else res += dfs(pos-1, lcm(lc, j), newval, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][idx[lc]][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n,1,0,1); } int main() { init(); int T; cin \u0026gt;\u0026gt; T; memset(dp, -1, sizeof(dp)); // 注意，只进行一次 memset while (T--) { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; cout \u0026lt;\u0026lt; solve(r) - solve(l) \u0026lt;\u0026lt; endl; } }   例6 HDU4507 恨7不成妻 题意\n给定两个正整数 $L \\leq R \\leq 10^{18}$，求满足以下条件的数字的平方之和：\n 整数中不含 $7$ 整数中每一位加起来的和 不是 $7$ 的整数倍 这个整数不被 $7$ 整除  输出对 $10^9+7$ 取模的结果，共有 $T \\leq 50$ 个 testcase\n 错误做法 $dp[i][j][k]$：使用到 $i$ 位，每一位的和 $\\text{mod } 7 = j$，数字本身 $\\text{mod } 7 = k$ 的平方和。\n将返回值设定为该数字的平方，然后将 dp 数组的值作为平方之和。\n 为什么是错的？\n 考虑记忆化状态：\n那么，数字 $10,80$ 的状态完全相同，但是因为我们先 dfs 到了 $10$，然后到了 $80$ 的时候就会直接返回，没有计算 $80^2$ 的值，导致答案错误。\n 正确做法 注意这个题和其他例题完全不一样，因为其他题求的都是 数字的数量，而只有这个题求的是 平方之和。\n这直接导致，我们在状态转移的时候 不能简单的相加。\n上面做法的 dp 状态没有问题：\n$dp[i][j][k]$：使用到 $i$ 位，每一位的和 $\\text{mod } 7 = j$，数字本身 $\\text{mod } 7 = k$\n但是 dp[] 数组对应的值，不能简单的设定为平方和。\n  如果这个题求的是满足条件的数字数量，是不是就可以了？\n 是的！比如 $2$ 和 $9$ 对应的状态相同，无论后缀是什么，只要满足条件，它们就完全等价。\n比如后缀是数字 $3$，那么 $23, 93$ 就完全等价，所以我们来到前缀 $9$ 的时候就可以直接利用前缀 $2$ 的信息。\n但是在本题中，$23$ 和 $93$ 并不等价，因为 $23^2 \\neq 93^2$。\n 所以我们要考虑一下组合数学/计数题中的 贡献 套路。\n我们在 dfs 过程中，先算出来了前缀 $2$ 的相关信息。我们假设前缀 $2$ 有着 三个有效的后缀 $2,3,4$，那么数字就是 $22,23,24$。\n此时，我们已经算出了这些后缀的相关信息，怎么把它合并上去？\n$$22^2 + 23 ^ 2 + 24^2 = (20+2)^2 + (20+3)^2 + (20+4)^2$$ $$= 3\\times 20^2 + 2 \\times 20 \\times (2+3+4) + (2^2+3^2+4^2)$$\n如果这里还不太清楚，还可以再举一个例子：\n我们有一个前缀 $1$，后缀是 $21,22$，那么合并的过程就是：\n$$121^2+122^2 = (100+21)^2 + (100+22)^2 $$ $$=2 \\times 100^2 + 2 \\times 100 \\times (21+22) + (21^2+22^2)$$\n 更 General 的写法是，给定一个digit $a$（$a$ 实际上就是 dfs() 过程中，当前使用的数字），然后假设我们有 $n$ 个后缀 $b_1,b_2,\u0026hellip;,b_n$，那么：\n$$(ab_1)^2 + (ab_2)^2 + \u0026hellip; + (ab_n)^2 = (a \\times 10^p + b_1) ^ 2 + (a \\times 10^p + b_2) ^ 2 + \u0026hellip;+(a \\times 10^p + b_n) ^ 2$$\n$$= n \\times a^2 \\times 10^{2p} + 2\\times10^p \\times (b_1+b_2+\u0026hellip;+b_n) + (b_1^2+b_2^2+\u0026hellip;+b_n^2)$$\n$$= \\sum\\limits_{i=1}^n ((a^2\\times 10^{2p}) + (2\\times10^p\\times b_i) + (b_i^2))$$\n• 其中，$p$ 就是 $pos-1$\n但是注意到，$b_i$ 是一个后缀，它代表的是 dp[] 数组里面，pos-1 的部分，所以它本身也是一个贡献（它并不是一个数字）。\n比如上面的第二个例子中，前缀为 $1$，后缀 $b_1$ 实际上是 $2$，这个 $b_1$ 有两个后缀 $2,3$，所以 $c_1 = 2, c_2 = 3$\n 那么，我们单独看一下每一个 $b$ 带来的贡献是多少。\n对于某一个后缀 $b$，我们继续考虑它的后缀 $c_j$，$b$ 带给 前缀 $a$ 的贡献可以这么表示：\n$$\\sum\\limits_{j=1}^m ((a^2\\times 10^{2p}) + (2\\times10^p\\times c_j) + (c_j^2))$$\n$$=m\\times a^2\\times 10^{2p} + (2\\times 10^p \\times \\sum\\limits_{j=1}^mc_j) + (\\sum\\limits_{j=1}^m c_j^2)$$\n其中，$m$ 是 $b$ 的 后缀数量，$\\sum\\limits_{j=1}^mc_j$ 是 $b$ 的后缀的值之和， $\\sum\\limits_{j=1}^m c_j^2$ 是 $b$ 的后缀的平方和。\n 由上，我们可以看出，对于每一个后缀 $b$，我们都要维护它的\n 后缀 数量 $cnt$ 后缀值 之和 $sum_1$ 后缀值的 平方和 $sum_2$  则，这个 $b$ 带给 $a$ 的 平方和 的贡献就是：\n$$\\sum ((a^2\\times 10^{2p}) + (2\\times10^p\\times c_j) + (c_j^2))$$\n$$= (\\sum a^2\\times 10^{2p}) + (2\\times10^p\\times \\sum c_j) + \\sum c_j^2$$\n$$ = cnt \\times (a^2\\times 10^{2p}) + (2\\times10^p\\times sum_1) + (sum_2)$$\n 那么 $b$ 带给 $a$ 的 后缀和 的贡献呢？\n$$a \\times 10^p + b$$\n$$= \\sum (a \\times 10^p) + \\sum c_j$$\n$$= (cnt \\times a \\times 10^p) + sum_1$$\n 那么 $b$ 带给 $a$ 的 后缀数量 的贡献呢？\n$$1= \\sum_j 1 = cnt$$\n 下面会给一个并不严谨，但是比较好理解的公式推导。\n 注：实现过程中，我们用 struct node 来维护这些信息。\n  公式 平方和：\n$$(a \\times 10^p + b)^2$$\n$$= (a^2\\times 10^{2p}) + (2\\times10^p) \\times b + (b^2)$$\n然后对其进行求和操作，有：\n$$\\sum (a^2\\times 10^{2p}) + (2\\times10^p) \\times \\sum b + \\sum b^2$$\n$$= cnt \\times (a^2\\times 10^{2p}) + (2\\times10^p\\times sum_1) + (sum_2)$$\n 值的和：\n$$(a \\times 10^p + b)$$\n对其进行求和操作：\n$$\\sum a\\times10^p + \\sum b$$\n$$=cnt \\times a \\times 10^p + sum_1$$\n 数量之和：\n$$1$$\n对其进行求和：\n$$\\sum 1$$\n$$=cnt$$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct node { ll cnt, sum1, sum2; }; ll pow10[20]; node dp[20][7][7]; bool vis[20][7][7]; int n, arr[20]; node dfs(int pos, int sum, int md, bool limit) { if (!pos) { if (!md) return {0,0,0}; if (!sum) return {0,0,0}; return {1,0,0}; // 注意这里是 {1,0,0}，因为没有选择任何值 } if (!limit \u0026amp;\u0026amp; vis[pos][sum][md]) { return dp[pos][sum][md]; } ll cnt = 0, sum1 = 0, sum2 = 0; int ed = 9; if (limit) ed = arr[pos]; for (ll j = 0; j \u0026lt;= ed; j++) { if (j == 7) continue; node res = dfs(pos-1, (sum+j) % 7, (md*10+j) % 7, limit \u0026amp;\u0026amp; (j==ed)); ll c = res.cnt, s1 = res.sum1, s2 = res.sum2; cnt = (cnt + c) % mod; sum1 = (sum1 + j * pow10[pos-1] % mod * c % mod + s1) % mod; sum2 = (sum2 + j * j * pow10[pos-1] % mod * pow10[pos-1] % mod * c % mod) % mod; sum2 = (sum2 + 2LL * j * pow10[pos-1] % mod * s1 % mod) % mod; sum2 = (sum2 + s2) % mod; } if (!limit) { vis[pos][sum][md] = 1; dp[pos][sum][md] = {cnt, sum1, sum2}; } return {cnt, sum1, sum2}; } node solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } int main() { memset(vis, 0, sizeof(vis)); pow10[0] = 1LL; for (int i = 1; i \u0026lt;= 19; i++) pow10[i] = pow10[i-1] * 10LL % mod; int T; cin \u0026gt;\u0026gt; T; while (T--) { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ll ans = solve(r).sum2 - solve(l-1).sum2; // 如果是求值的和，改成 sum1 即可 ans = (ans + (ll)(mod)) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } }   • 这个代码中，一定要注意到 base case 返回的是 {1, 0, 0}（后面两个 0 是因为 sum1, sum2 是在选择当前digit时才计算）。\n例7 CF1073E Segment Sum 题意\n给定正整数 $L, R, K$，求 $[L,R]$ 之间满足：distinct digit 的数量 $\\leq K$ 的数字之和。\n其中，$1 \\leq L \\leq R \\leq 10^{18}, K \\leq 10$\n 题解 和例6是一样的做法，更简单了一些。\n回顾一下状态转移：\n如果当前 digit 为 $a$，后缀为 $b$，则 $b$ 给 $a_{sum}$ 带来的贡献为：\n$$\\sum_{i=1}^{cnt} (a * 10^p + b_i) = cnt * a * 10^p + b_{sum}$$\n而 $a_{sum}$ 就等于所有后缀 $b$ 的贡献之和。\n 状态比较容易想：\ndp[i][mask] 代表到了第 $i$ 个字符，当前使用的digit组成了 $mask$，dp 的值就是 {cnt, sum}。\n• 这里需要注意，在写 dfs() 函数时要考虑是否有前导 $0$。因为如果有前导 $0$，这个 $mask$ 不应包含前导 $0$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244353; const int maxn = 4e5+5; int K; int a[20], n; struct node { ll cnt, sum; }; node dp[20][(1\u0026lt;\u0026lt;10)+5]; bool vis[20][(1\u0026lt;\u0026lt;10)+5]; inline int popcount(int mask) { int res = 0; while (mask) { res += (mask \u0026amp; 1); mask \u0026gt;\u0026gt;= 1; } return res; } ll ten[20]; node dfs(int i, int mask, bool zero, bool limit) { if (i \u0026lt;= 0) return {1, 0}; if (!limit \u0026amp;\u0026amp; vis[i][mask]) return dp[i][mask]; ll cnt = 0, sum = 0; int ed = (limit ? a[i] : 9); for (ll j = 0; j \u0026lt;= ed; j++) { if (popcount(mask | (1\u0026lt;\u0026lt;j)) \u0026lt;= K) { int newmask = mask | (1\u0026lt;\u0026lt;j); if (zero \u0026amp;\u0026amp; (!j)) newmask = 0; node res = dfs(i-1, newmask, zero \u0026amp;\u0026amp; (!j), limit \u0026amp;\u0026amp; (j == ed)); cnt += res.cnt, cnt %= mod; sum = ((res.sum + (ten[i-1] * res.cnt % mod * j % mod)) % mod + sum) % mod; } } if (!limit) vis[i][mask] = 1, dp[i][mask] = {cnt, sum}; return {cnt, sum}; } ll solve(ll x) { n = 0; memset(a, 0, sizeof(a)); memset(dp, 0, sizeof(dp)); memset(vis, 0, sizeof(vis)); while (x) { a[++n] = x % 10; x /= 10; } return dfs(n, 0, 1, 1).sum; } int main() { fastio; ll L,R; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; K; ten[0] = 1; for (int i = 1; i \u0026lt;= 19; i++) ten[i] = ten[i-1] * 10LL % mod; ll ans = (solve(R) - solve(L-1) + mod) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例8 CFgym104053M. XOR Sum 题意\n对于一个数组 $A = [a_1,a_2,\u0026hellip;,a_k]$，定义\n$$f(A) = \\sum\\limits_{i=1}^k \\sum\\limits_{j=1}^{i-1} a_i \\text{ XOR } a_j$$\n给定 $n,m,k$，求有多少个数组 $A$ 满足以下所有条件：\n $A$ 的长度为 $k$。 $f(A) = n$。 $\\forall i, a_i \\in [0, m]$。  其中，$n \\in [0, 10^{15}], m \\in [0, 10^{12}], k \\in [1,18]$，答案对 $10^9 + 7$ 取模。\n 题解 以前的数位dp都只针对一个数。\n而这次的数位dp需要考虑 $k$ 个数，所以比起一个数的情况，记录一个 bool limit 代表是否碰到上限 $m$，我们这次记录一个 $j$ 代表有 $j$ 个数顶到了 $m$ 的上限。\n如图，每一列代表一个 $a_i$，而每一行就是每一个 $a_i$ 的每一位上的bit。\n注意到我们只关心每一行有几个 $1$ 几个 $0$，这样贡献就可以计算出来。\n我们要求：\n 所有行的贡献之和 $=n$。 每一列不能超过 $m$。  所以我们设计数位dp的状态就是：\ndp[i][j][k]：代表到了第 $i$ 位（从高位到低位），有 $j$ 个数顶到了 $m$ 的上限。\n而 $k$ 就代表到当前位的贡献和。但 $k$ 可能会非常大，所以我们需要剪枝。\n注意到我们可以令 $k$ 等于 $\\frac{n-sum}{2^i}$，其中 $sum$ 为之前的贡献之和，这样我们规定 $k \\leq 81$ 即可，因为如果 $k \u0026gt; 81$ 那么后面每一行就算贡献最大也不可能使得 $f(A) = n$ 了。\n• 实际操作的时候保险一点设定 $k \\leq 200$。\n• 注意到在数位 dp 中，我们不一定要找出这个数 $m$ 有多少位，直接假设它位数最大（本题中为 $40$）开始处理也可以的。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 70; const int M = 200; int sm[maxn], sn[maxn]; Z dp[43][20][M+5]; Z C[105][105]; ll n, m, len; // len: length // i: 从高到低第几位 // j: 有几个数来到了m的上限 // k: (n - 前面贡献的和) / 2^(40-i), 如果 k \u0026gt; M 则不行 Z dfs(int i, int j, int k) { if (i \u0026lt;= 0) { return k == 0; } if (dp[i][j][k].val() != -1) return dp[i][j][k]; Z res = 0; if (sm[i] == 0) { // 这 j 个数只能选 0 for (int a = 0; a \u0026lt;= len - j; a++) { // 剩下 K - j 个数里面，有 a 个选 1 int new_k = k * 2 - a * (len - a) + sn[i]; if (new_k \u0026lt;= M \u0026amp;\u0026amp; new_k \u0026gt;= 0) { res = res + C[len-j][a] * dfs(i-1, j, new_k); } } } else { for (int a = 0; a \u0026lt;= len - j; a++) { // a 个 1 for (int b = 0; b \u0026lt;= j; b++) { // b 个 1 (到了上限) int new_k = k * 2 - (a + b) * (len - a - b) + sn[i]; if (new_k \u0026lt;= M \u0026amp;\u0026amp; new_k \u0026gt;= 0) { res = res + C[len-j][a] * C[j][b] * dfs(i-1, b, new_k); } } } } return dp[i][j][k] = res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; len; memset(dp, -1, sizeof(dp)); C[0][0] = 1; for (int i = 1; i \u0026lt;= 100; i++) { C[i][0] = 1; for (int j = 1; j \u0026lt;= i; j++) { C[i][j] = C[i-1][j-1] + C[i-1][j]; } } if ((n \u0026gt;\u0026gt; 40) \u0026gt; M) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } int id = 0; ll tn = n; while (tn) { sn[++id] = (tn \u0026amp; 1); tn \u0026gt;\u0026gt;= 1; } id = 0; ll tm = m; while (tm) { sm[++id] = (tm \u0026amp; 1); tm \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; dfs(40, len, n \u0026gt;\u0026gt; 40) \u0026lt;\u0026lt; endl; }   ","date":"2021-03-18T10:53:51+08:00","permalink":"https://tom0727.github.io/post/033-%E6%95%B0%E4%BD%8Ddp/","tags":["数位dp","数学","dp"],"title":"数位DP"},{"categories":["题解"],"contents":"主要记录一些遇到的线段树/分块例题。\n例1 CF438D 题意\n给定 $N$ 个正整数和 $M$ 个询问，询问有 3 种：\n$1 ~ l ~ r$：输出 $\\sum\\limits_{i=l}^r a_i$\n$2 ~ l ~ r ~ x$：将 $a_l$ 到 $a_r$ 的所有数取 $\\text{mod } x$\n$3 ~ k ~ x$：将 $a_k = x$\n其中，$1 \\leq N,M \\leq 10^5, 1 \\leq a_i,x \\leq 10^9$\n 题解 本题分块和线段树都可以做，我们这里用 线段树 来做。\n主要是需要考虑 区间取模 怎么办？\n回忆一下分块例题中的 区间开方，我们维护了一个额外的tag表示这个区间是否为 全0/全1，如果不是 全0/全1 就暴力开方。\n取模操作同理，我们发现，如果 $a_i \u0026gt; x$，那么 $a_i \\text{ mod } x \\leq \\frac{a_i}{2}$，所以对于每个 $a_i$，最多只会被 $\\text{mod}$ $\\log (a_i)$ 次！\n所以，我们维护一个 区间最大值，取模时，检查一下 区间最大值是否大于 $x$：\n 如果大于 $x$，就继续往下递归。 如果小于 $x$，就直接返回。  base case 就是区间长度为 $1$ 时，直接对这个元素开方即可。\n 例2 CF558E 题意\n给定一个长度为 $n$ 的string，仅包含小写字母。给 $q$ 个询问：\n$l,r,k$：将string的 $[l,r]$ 进行sort，如果 $k=1$ 就升序，$k=0$ 降序。\n输出所有询问结束后的string。\n其中，$1\\leq n \\leq 10^5, 1 \\leq q\\leq 50000$\n 题解 线段树来处理。\n首先，string只包含小写字母。所以每个 node 可以维护一个 cnt[26] 代表这个node里的每个字母出现的次数。\n其次，对于排序，我们在每个 node 中维护一个标记 $k$ 来代表该区间是否排序好了。若 $k=0$ 代表降序，$k=1$ 代表升序，$k = -1$ 代表乱序。\n最后，维护一个 $lazy$ 标记，我们会注意到对于一个node而言，若 $lazy = 1$，那么这个 node 必然是排序好了的！（要么 $k=0$ ，要么 $k=1$）。\n有了以上信息，我们就可以进行 sort 操作了！\n sort $[L,R]$ 的时候，步骤如下：\n 提取出 $[L,R]$ 内每个字母出现的次数。 求出 $[L,R]$ 与 $[l,mid]$（当前node 左child的范围）的区间交集 $[l_1,r_1]$ 求出 $[L,R]$ 与 $[mid+1, r]$（当前node 右child的范围）的区间交集 $[l_2,r_2]$ 用指针遍历 $a-z$（或者 $z-a$），根据升序/降序 将 字母出现的次数分别填充 到 左child和右child的 cnt[] 中。（注意，这里的填充是指：先填充进一个 int* buf = new int[26]; 的动态数组，然后将 buf[] 作为参数，再往下传递，直到区间完全覆盖，再将 buf[] 的内容复制进 cnt[] 里）。   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+10; int n,q; char arr[maxn]; struct Node { int l,r,k,cnt[26]; bool lazy = 0; } tr[4*maxn]; int tmp[26]; inline int len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; for (int i = 0; i \u0026lt; 26; i++) { tr[cur].cnt[i] = tr[lc].cnt[i] + tr[rc].cnt[i]; } if (tr[lc].k != -1 \u0026amp;\u0026amp; tr[lc].k == tr[rc].k) tr[cur].k = tr[lc].k; // k = 1: increasing, k = 0: decreasing else tr[cur].k = -1; } void put(int cur, int k) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; memset(tr[lc].cnt, 0, sizeof(tr[lc].cnt)); memset(tr[rc].cnt, 0, sizeof(tr[rc].cnt)); memcpy(tmp, tr[cur].cnt, sizeof(tmp)); int lsz = len(lc), rsz = len(rc); if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } } assert(lsz == 0); assert(rsz == 0); } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; tr[cur].lazy = 0; tr[lc].lazy = tr[rc].lazy = 1; assert(tr[cur].k != -1); int k = tr[cur].k; tr[lc].k = k; tr[rc].k = k; put(cur,k); } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { memset(tr[cur].cnt, 0, sizeof(tr[cur].cnt)); tr[cur].cnt[arr[L]-'a'] = 1; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } int ress[26]; // 每次query的结果会存到这里 void clear(int* buf) { for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; } int inter(int l1, int r1, int l2, int r2) { // 求区间交集的长度 int l = max(l1,l2), r = min(r1,r2); return max(0,r-l+1); } void update(int cur, int L, int R, int k, int* res) { // 注意参数里有个动态数组 res int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].k = k; tr[cur].lazy = 1; for (int i = 0; i \u0026lt; 26; i++) tr[cur].cnt[i] = res[i]; // 区间完全覆盖，复制到 cnt 中。 clear(res); // 记得清空，之后可能还要用 return; } int mid = (l+r) \u0026gt;\u0026gt; 1; int lsz = inter(l,mid,L,R), rsz = inter(mid+1,r,L,R); int* buf = new int[26]; // 这里采用了动态数组 for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; //注意new出来的需要先清空一下，另外不能使用 memset(因为是指针) if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } delete[] buf; assert(lsz == 0); assert(rsz == 0); push_up(cur); } void query(int cur, int L, int R) { // 求区间内每个字母出现的个数 int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { for (int i = 0; i \u0026lt; 26; i++) ress[i] += tr[cur].cnt[i]; return; } int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(lc, L, R); if (R \u0026gt; mid) query(rc, L, R); push_up(cur); } void printans() { for (int i = 1; i \u0026lt;= n; i++) { memset(ress, 0, sizeof(ress)); query(1,i,i); for (int j = 0; j \u0026lt; 26; j++) { if (ress[j]) { printf(\u0026quot;%c\u0026quot;,(char)('a'+j)); ress[j]--; break; } } } printf(\u0026quot;\\n\u0026quot;); } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;q); scanf(\u0026quot;%s\u0026quot;, arr+1); build(1, 1, n); while (q--) { int l,r,k; scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;l,\u0026amp;r,\u0026amp;k); memset(ress, 0, sizeof(ress)); query(1,l,r); update(1,l,r,k,ress); } printans(); }   例3 洛谷P1972 HH的项链 题意\n给定一个长度为 $N$ 的数组 $a_1,a_2,\u0026hellip;,a_n$，以及 $m$ 个询问，每次询问 $[L,R]$ 之间有多少个不同的数。\n其中，$1 \\leq n,m,a_i \\leq 10^6$\n 题解 我们可以发现，如果我们固定了询问的右端点 $R$，那么无论 $L$ 为多少，在 $R$ 的左侧的所有重复数字中，仅保留最靠右的一个 copy 即可。\n例如 $arr = 1,3,2,1,7,1$，那么我们在遍历到 $i = 4$ 时，我们仅需要保留最后一个 $1$ （也就是 index 为 $4$ 的数字）。\n由上，在处理 区间内不同的数 时，一个常见的套路是：\n 离线处理所有询问，按右端点 $R$ 排序。 从左到右遍历数组，遍历到 $i$ 时，对于所有 $a_i$ 的 copy，仅保留最靠右的那一个（也就是 $i$），之前的所有 copy 全部删除。 回答所有 $[L, i]$ 的询问。  那么对于本题，第一步是离线处理询问，按右端点 $R$ 排序。\n第二步是遍历数组，遍历过程中维护一个 int pos[] 数组，其中 pos[val] 代表：在 $arr[1\u0026hellip;i]$ 中，值为 val 的数 最靠右的 index。\n当我们遍历到 $i$ 时，令 int val = arr[i]，将 pos[val] 处的数字 删掉（更新线段树），然后将 $i$ 处的数字 加入线段树，最后更新一下 pos[val] = i;\n•本题中，删掉就是将 线段树的位置 $i$ 的值 减去$1$，加上就是将 线段树的位置 $i$ 的值 加上$1$。\n然后回答所有 以 $i$ 为右端点的询问（求 $[L,i]$ 的和即可）。\n 注：如果询问 在线 怎么办？可以使用主席树！（对于 pr[i] 建主席树）\n具体做法参考：CF1422F Boring Queries\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 1e9+7; const int maxn = 1e6+5; int n, m, arr[maxn]; struct node { int sum; } tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void update(int cur, int l, int r, int p, int x) { if (l == r) { tr[cur].sum += x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].sum; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } int ans[maxn]; int pos[maxn]; struct Query { int id,l,r; } q[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; q[i] = {i,l,r}; } sort(q+1,q+m+1, [](auto a, auto b) { return a.r \u0026lt; b.r; // 根据右端点离线 }); int ptr = 1; for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; if (pos[val]) update(1, 1, n, pos[val], -1); // 删去 pos[val] update(1, 1, n, i, 1); // 加上 i pos[val] = i; // 更新 pos[val] while (ptr \u0026lt;= m \u0026amp;\u0026amp; q[ptr].r == i) { // 回答所有以 i 作为右端点的询问 int id = q[ptr].id, L = q[ptr].l, R = q[ptr].r; ans[id] = query(1, 1, n, L, R); ptr++; } if (ptr \u0026gt; m) break; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF1000F One Occurrence 题意\n给定一个长度为 $n$ 的数组，$m$ 个询问，每次询问一个区间 $[l,r]$，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出 $0$。\n其中 $n,m \\leq 5 \\times 10^5, 1 \\leq a_i \\leq 5 \\times 10^5$。\n 题解 和例3类似的套路，也是离线处理询问（根据右端点sort），从左往右遍历，仅保留最靠右的复制。\n问题在于怎么删除 和 加入数字？因为本题不再是求数量了，所以不能简单的加 $1$ 或者 减 $1$。\n会发现，我们仅关心一个区间内是否存在 unique 的数字，对于一个询问 $[L,R]$ 内，我们只要看，是否存在 $i$ 使得 $arr[i]$ 的前一个复制 不在 $[L,R]$ 内。（也就是说，pos[val] 是否小于 $L$）\n那么，我们用线段树维护一下 区间最小值 即可，其中 $[L,R]$ 的区间最小值就代表着所有$i \\in [L,R]$ 中，pos[arr[i]] 的最小值。如果一个区间 $[L,R]$ 的最小值 $\\geq L$，那么答案不存在，否则答案存在。\n那么，删除位置 $i$ 就是将它这个位置上的值设为 $inf$。\n加入位置 $i$ 的数，就是将它这个位置上的值设为 pos[arr[i]]。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; struct node { int pre = 1e9, idx = 0; // pre 代表 pos[val] 的值，idx代表这个最小值对应的 index } tr[maxn\u0026lt;\u0026lt;2]; int pos[maxn], n, m, arr[maxn]; struct Query { int id,l,r; } q[maxn]; void push_up(int cur) { int lpre = tr[cur\u0026lt;\u0026lt;1].pre, rpre = tr[cur\u0026lt;\u0026lt;1|1].pre; if (lpre \u0026lt; rpre) tr[cur].pre = lpre, tr[cur].idx = tr[cur\u0026lt;\u0026lt;1].idx; else tr[cur].pre = rpre, tr[cur].idx = tr[cur\u0026lt;\u0026lt;1|1].idx; } void update(int cur, int l, int r, int p, int x) { if (l == r) { tr[cur].pre = x, tr[cur].idx = l; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, p, x); else update(cur\u0026lt;\u0026lt;1|1, mid+1, r, p, x); push_up(cur); } pii query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return {tr[cur].pre, tr[cur].idx}; int mid = (l+r) \u0026gt;\u0026gt; 1; pii r1 = {1e9, 0}, r2 = {1e9, 0}; if (L \u0026lt;= mid) r1 = query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) r2 = query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (r1.first \u0026gt; r2.first) return r2; else return r1; } int ans[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; q[i] = {i,l,r}; } sort(q+1, q+m+1, [](auto a, auto b) { return a.r \u0026lt; b.r; }); int ptr = 1; for (int i = 1; i \u0026lt;= n; i++) { int val = arr[i]; update(1, 1, n, i, pos[val]); // 在i处 加入数字 pos[val] if (pos[val]) update(1, 1, n, pos[val], 1e9); // 在pos[val] 处删除数字（设为 inf） pos[val] = i; while (ptr \u0026lt;= m \u0026amp;\u0026amp; q[ptr].r == i) { int L = q[ptr].l, R = q[ptr].r; pii res = query(1, 1, n, L, R); int id = q[ptr].id; if (res.first \u0026gt;= L) ans[id] = 0; // 如果这个区间内，所有 pos[val] 都 \u0026gt;= L else ans[id] = arr[res.second]; // 否则，答案存在 ptr++; } if (ptr \u0026gt; m) break; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例5 CF803G Periodic RMQ Problem 题意\n给定一个长度为 $n$ 的数组，将这个数组复制为 $k$ 份并且拼接在一起。\n然后回答 $Q$ 个询问，分两种询问：（所有询问都在拼接后的数组上进行）\n$1 ~ l ~ r ~ x$：将 $[l,r]$ 中的所有元素改为 $x$。\n$2 ~ l ~ r$：询问 $[l,r]$ 中的最小值。\n其中，$1 \\leq n \\leq 10^5, 1 \\leq k \\leq 10^4, 1 \\leq Q \\leq 10^5, ~l,r \\in [1,n]$\n 题解 注意到数组的总长度可以达到 $10^9$。但是询问只有 $Q=10^5$，我们于是想到了动态开点线段树。\n但是注意到，这个数组是有初始值的，按理说应该把树建好，不能动态开点。\n所以我们考虑 不建树，而是在开点的时候，把这个点的初始状态处理好（就是在没有任何修改的情况下，这个点的初始状态），然后再对这个点进行操作。\n所以，对于一个点对应的区间 $[l,r]$，怎么处理初始状态？\n注意到，由于数组是一个循环节，所以可以分以下三种情况：\n $[l,r]$ 的长度 $\\geq n$，它的初始最小值就是数组 $[1,n]$ 的最小值。 $[l,r]$ 的长度 $\u0026lt; n$，且属于同一个循环节，那么用 ST表 预处理一下 $[l \\text{ mod } n,r\\text{ mod } n]$ 的最小值即可。 $[l,r]$ 的长度 $\u0026lt; n$，且不属于同一个循环节，那么它的初始最小值就是 $[l \\text{ mod } n, n] \\bigcup [1, r\\text{ mod } n]$  开点的函数是代码里的 build()，注意到只要我们访问到了 cur，并且需要访问它的任意一个 child 时，需要把左右两个子树都开点，这保证了 pushup() 的正确性。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e7+5; const int maxm = 1e5+5; int n,k,Q; int a[maxm]; int belong(int x) { return (x-1) / n + 1; } struct Node { int lc, rc, lazy, val; } tr[maxn]; int id = 0; int st[maxm][18]; int bin[maxm]; void build_st() { bin[1] = 0, bin[2] = 1; for (int i = 3; i \u0026lt; maxm; i++) bin[i] = bin[i\u0026gt;\u0026gt;1] + 1; for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; j \u0026lt; 18; j++) { for (int i = 1; i + (1\u0026lt;\u0026lt;j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j-1], st[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } } } int ask_st(int l, int r) { if (l \u0026gt; r) swap(l,r); int j = bin[r-l+1]; return min(st[l][j], st[r-(1\u0026lt;\u0026lt;j)+1][j]); } void build(int\u0026amp; cur, int l, int r) { if (cur) return; cur = ++id; if (r-l+1 \u0026gt;= n) { tr[cur].val = ask_st(1, n); return; } int bl = belong(l), br = belong(r); l %= n, r %= n; if (!l) l = n; if (!r) r = n; if (bl == br) { tr[cur].val = ask_st(l,r); return; } // bl != br tr[cur].val = min(ask_st(l, n), ask_st(1, r)); } void push_down(int cur) { if (!tr[cur].lazy) return; int lazy = tr[cur].lazy; tr[cur].lazy = 0; int lc = tr[cur].lc, rc = tr[cur].rc; tr[lc].lazy = tr[lc].val = tr[rc].lazy = tr[rc].val = lazy; } void push_up(int cur) { tr[cur].val = min(tr[tr[cur].lc].val, tr[tr[cur].rc].val); } void update(int cur, int l, int r, int L, int R, int x) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = tr[cur].val = x; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(tr[cur].lc, l, mid); build(tr[cur].rc, mid+1, r); push_down(cur); if (L \u0026lt;= mid) update(tr[cur].lc, l, mid, L, R, x); if (R \u0026gt; mid) update(tr[cur].rc, mid+1, r, L, R, x); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) return tr[cur].val; int mid = (l+r) \u0026gt;\u0026gt; 1; build(tr[cur].lc, l, mid); build(tr[cur].rc, mid+1, r); push_down(cur); int lres = 1e9, rres = 1e9; if (L \u0026lt;= mid) lres = query(tr[cur].lc, l, mid, L, R); if (R \u0026gt; mid) rres = query(tr[cur].rc, mid+1, r, L, R); push_up(cur); return min(lres, rres); } int rt = 0; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build_st(); cin \u0026gt;\u0026gt; Q; build(rt, 1, n*k); for (int i = 1; i \u0026lt;= Q; i++) { int op,l,r,x; cin \u0026gt;\u0026gt; op; if (op == 1) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; update(1, 1, n*k, l, r, x); } else { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int res = query(1, 1, n*k, l, r); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }   例6 CF gym103687F. Easy Fix 题意\n给定一个 permutation $p_1, p_2 \u0026hellip; p_n$。\n定义 $A_i$ 为 $i$ 左边比 $p_i$ 小的元素数量，$B_i$ 为 $i$ 右边比 $p_i$ 大的元素数量，$C_i = \\min(A_i, B_i)$。\n给定 $m$ 个询问，每次询问 $L, R$，回答在交换 $p_L, p_R$ 的位置以后，$\\sum\\limits_{i=1}^n C_i$ 的值？\n其中，$n \\leq 10^5, m \\leq 2 \\times 10^5$。\n 题解 先讨论一下交换后有哪些元素受到影响？\n很明显，$L, R$ 位置会受到影响，$i \\in (L,R)$ 且 $p_i \\in (p_L, p_R)$ 的会受到影响，其他的均无影响。\n 我们先讨论 $i \\in (L,R)$ 且 $p_i \\in (p_L, p_R)$ 这种情况：\nCase1: 如果 $a_u \u0026lt; a_v$，那么 $A_i - 1, B_i + 1$。\n Case1.1: 如果 $A_i \\leq B_i$，那么 $C_i - 1$。\n Case1.2: 如果 $A_i \u0026gt; B_i + 1$，那么 $C_i + 1$。\nCase2: 如果 $a_u \u0026gt; a_v$，那么 $A_i + 1, B_i - 1$。\n Case2.1: 如果 $A_i \\geq B_i$，那么 $C_i - 1$。\n Case2.2: 如果 $A_i \u0026lt; B_i - 1$，那么 $C_i + 1$。\n 然后再讨论一下 $L, R$ 受到的影响：\n只要先把 $C_L, C_R$ 的值从询问中减掉，然后重新找一下换了之后的 $C_L, C_R$ 即可。\n• 需要注意当 $p_L \u0026gt; p_R$ 时，换了之后 $R$ 位置上的 $p_L$ 计算 $A_i$ 时会将 $p_R$ 忽略掉，所以要加 $1$。\n 好的，现在该讨论一下怎么获得 $A_i, B_i, C_i$。\n首先，获得 $A_i$ 可以直接用树状数组维护 $p_i$（作为index），树状数组上的值为 0 和 1。遍历一下就可以求出初始状态的 $A_i$ 了。\n然后 $B_i = p_i - 1 - A_i$，很好理解，这样 $C_i$ 也有了。\n 再讨论一下怎么处理询问？\n我们将 Case1, Case2 分开处理：如果我们开一个线段树/树状数组，index 为 $p_i$，值为 $-1, 0, 1$ 来记录 Case1.1, Case1.2 的情况，那么：\n每次询问就是询问一个区间 $(L,R)$ 内，满足 $(p_L, p_R)$ 的值的一些东西的和。\n似乎是 主席树？\n确实，不过本题询问离线，Stupidcdd 教导我：\n 能用主席树做的，离线情况下就能用线段树/树状数组。\n 回忆一下主席树的作用：对于每个区间 $[L,R]$，维护一个权值线段树，原理其实是每个点维护一个线段树，$R$ 上的线段树减去 $L-1$ 位置的线段树而已。\n那么询问离线的时候，我们只有一个树状数组，可以在遍历的过程中，获得前缀 $[1\u0026hellip;i]$ 对应的树状数组，但是我们没有持久化，所以保存不下来。\n因为树状数组的历史版本保存不下来，不妨从询问下手？\n离线的一个常见套路：\n 对于询问的端点 $L,R$，每个端点开一个 vector 储存所有的询问，遍历到这个点时处理所有对应的询问，加到答案上。\n 这个题就是这样，我们想要知道 $(L,R)$ 内满足 $(p_L, p_R)$ 的值的一些东西的和，那么不妨在遍历到 $L$ 的时候询问一下 $(p_L, p_R)$，在遍历到 $R-1$ 的时候询问一下 $(p_L, p_R)$，然后一减，不就是答案了么？\nstruct Query_Info { int pl, pr; // 询问 [pl, pr] 的部分 int f; // 符号 int idx; // 询问的 idx int type; // (pu \u0026lt; pv) : tr1, (pu \u0026gt; pv): tr2, type = 1 代表 tr1 }; int A[maxn], B[maxn], C[maxn]; int a[maxn], b[maxn], c[maxn]; vector\u0026lt;Query_Info\u0026gt; qinfo[maxn]; // qinfo[i] 端点为 i 的需要询问 struct Single_Query { int x; // 询问 \u0026lt; x 有多少个 int idx; // 询问的 idx int diff; // 如果 p[u] \u0026gt; p[v]，那么换出去以后 A[v]需要+1 }; vector\u0026lt;Single_Query\u0026gt; single[maxn]; // 单点询问 \u0026lt; x 有多少个 ll ans[maxn]; ... ... ... // (u,v) 的话需要让 v-1 的部分 (前缀 v-1 询问 (a_u, a_v) 的部分）减去 u 的部分（前缀 u 询问 (a_u, a_v) 的部分） for (int j = 1; j \u0026lt;= m; j++) { auto q = queries[j]; int u = q.first, v = q.second; if (u != v) { int mn = min(p[u], p[v]) + 1, mx = max(p[u], p[v]) - 1; int type = (p[u] \u0026lt; p[v] ? 1 : 2); qinfo[u+1].push_back({mn, mx, -1, j, type}); // 由于处理时，还没加上，所以全部应该 + 1 (u -\u0026gt; u+1, v-1 -\u0026gt; v) qinfo[v].push_back({mn, mx, 1, j, type}); ans[j] -= (C[u] + C[v]); // 先去掉 C[u] + C[v] 的影响，后面直接加上 single[u].push_back({p[v], j, 0}); single[v].push_back({p[u], j, p[u] \u0026gt; p[v]}); } } for (int i = 1; i \u0026lt;= n; i++) { for (auto q : qinfo[i]) { if (q.type == 1) { ans[q.idx] += q.f * (tr1.query(q.pr) - tr1.query(q.pl-1)); } else { ans[q.idx] += q.f * (tr2.query(q.pr) - tr2.query(q.pl-1)); } } for (auto q : single[i]) { int AA = tr3.query(q.x - 1) + q.diff, BB = max(0, q.x - AA - 1); ans[q.idx] += min(AA, BB); } if (A[i] \u0026lt;= B[i]) tr1.update(p[i], -1); if (A[i] \u0026gt; B[i] + 1) tr1.update(p[i], 1); if (A[i] \u0026gt;= B[i]) tr2.update(p[i], -1); if (A[i] \u0026lt; B[i] - 1) tr2.update(p[i], 1); tr3.update(p[i], 1); }  在这个题中：\n $(L,R)$ 我们通过离线询问，答案相减来实现。 $(p_L, p_R)$ 我们通过权值线段树/权值树状数组来实现。 树状数组上面维护了 Case1.1, 1.2 (或者 2.1, 2.2) 的情况。   总结一下思路：\n离线的关键在于从左向右遍历的时候，获得每个前缀对应的树状数组。\n在离线 $(L,R)$ 时，将询问的信息扔给每个端点的 vector，在遍历到的时候再处理，处理时直接对 ans[] 进行操作。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e5+55; const int maxm = 2e5+5; int n, p[maxn], m; pii queries[maxm]; struct BIT { int n, tr[maxn]; inline int lowbit(int x) { return x \u0026amp; -x; } void update(int p, int val) { while (p \u0026lt;= n) { tr[p] += val; p += lowbit(p); } } // return sum[1...p] int query(int p) { int ans = 0; while (p \u0026gt; 0) { ans += tr[p]; p -= lowbit(p); } return ans; } } tr, tr1, tr2, tr3; struct Query_Info { int pl, pr; // 询问 [pl, pr] 的部分 int f; // 符号 int idx; // 询问的 idx int type; // (pu \u0026lt; pv) : tr1, (pu \u0026gt; pv): tr2, type = 1 代表 tr1 }; int A[maxn], B[maxn], C[maxn]; int a[maxn], b[maxn], c[maxn]; vector\u0026lt;Query_Info\u0026gt; qinfo[maxn]; // qinfo[i] 端点为 i 的需要询问 struct Single_Query { int x; // 询问 \u0026lt; x 有多少个 int idx; // 询问的 idx int diff; // 如果 p[u] \u0026gt; p[v]，那么换出去以后 A[v]需要+1 }; vector\u0026lt;Single_Query\u0026gt; single[maxn]; // 单点询问 \u0026lt; x 有多少个 ll ans[maxn]; ll csum = 0; int main() { fastio; cin \u0026gt;\u0026gt; n; tr.n = tr1.n = tr2.n = tr3.n = n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (l \u0026gt;= r) swap(l, r); queries[i] = {l, r}; } for (int i = 1; i \u0026lt;= n; i++) { A[i] = tr.query(p[i] - 1); // 左边比它小 B[i] = p[i] - 1 - A[i]; // 右边比它小 C[i] = min(A[i], B[i]); csum += C[i]; tr.update(p[i], 1); } for (int i = 1; i \u0026lt;= m; i++) ans[i] = csum; // (u,v) 的话需要让 v-1 的部分 (前缀 v-1 询问 (a_u, a_v) 的部分）减去 u 的部分（前缀 u 询问 (a_u, a_v) 的部分） for (int j = 1; j \u0026lt;= m; j++) { auto q = queries[j]; int u = q.first, v = q.second; if (u != v) { int mn = min(p[u], p[v]) + 1, mx = max(p[u], p[v]) - 1; int type = (p[u] \u0026lt; p[v] ? 1 : 2); qinfo[u+1].push_back({mn, mx, -1, j, type}); // 由于处理时，还没加上，所以全部应该 + 1 (u -\u0026gt; u+1, v-1 -\u0026gt; v) qinfo[v].push_back({mn, mx, 1, j, type}); ans[j] -= (C[u] + C[v]); // 先去掉 C[u] + C[v] 的影响，后面直接加上 single[u].push_back({p[v], j, 0}); single[v].push_back({p[u], j, p[u] \u0026gt; p[v]}); } } for (int i = 1; i \u0026lt;= n; i++) { for (auto q : qinfo[i]) { if (q.type == 1) { ans[q.idx] += q.f * (tr1.query(q.pr) - tr1.query(q.pl-1)); } else { ans[q.idx] += q.f * (tr2.query(q.pr) - tr2.query(q.pl-1)); } } for (auto q : single[i]) { int AA = tr3.query(q.x - 1) + q.diff, BB = max(0, q.x - AA - 1); ans[q.idx] += min(AA, BB); } if (A[i] \u0026lt;= B[i]) tr1.update(p[i], -1); if (A[i] \u0026gt; B[i] + 1) tr1.update(p[i], 1); if (A[i] \u0026gt;= B[i]) tr2.update(p[i], -1); if (A[i] \u0026lt; B[i] - 1) tr2.update(p[i], 1); tr3.update(p[i], 1); } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例7 Atcoder ABC237G. Range Sort Query 题意\n给定一个长度为 $n$ 的permutation $p_1,p_2\u0026hellip;,p_n$，和一个正整数 $x$。\n给定 $q$ 个询问，询问有两种：\n$1 ~ L ~ R$：将 $p[L\u0026hellip;R]$ 从小到大排序。\n$2 ~ L ~ R$：将 $p[L\u0026hellip;R]$ 从大到小排序。\n所有询问结束后，回答 $x$ 所在的index。\n其中，$n,q \\leq 2 \\times 10^5, x \\in [1,n]$。\n 题解 经典套路题。一般看见这种每次询问然后排序的，一般来讲只有在整个数组中 distinct 的数非常少的时候才能做。\n这个题注意到我们只关心 $x$，于是我们可以把剩下的数分为比 $x$ 小和比 $x$ 大的。\n而除了 $x$ 以外所有数之间的相对顺序我们并不关心。\n所以我们可以直接开两棵线段树，线段树里只储存 $0$ 或者 $1$，代表这个位置是否存在比 $x$ 大/小 的数。\n而 sort 的时候，我们就相当于把两棵线段树的 $[L,R]$ 中，看一下 $\u0026lt;x$ 和 $\u0026gt;x$ 分别有多少个，然后清空整个线段，然后重新进行区间赋值即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 4e5+5; const int maxm = 1e5+5; struct Tree_Node { int sum = 0; bool flag = 0; int val; // 区间赋的值 }; struct Segment_Tree { Tree_Node tr[maxn\u0026lt;\u0026lt;2]; void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void push_down(int cur, int l, int r) { if (!tr[cur].flag) return; int val = tr[cur].val; tr[cur].flag = 0; int mid = (l+r) \u0026gt;\u0026gt; 1; int lc = cur\u0026lt;\u0026lt;1, rc = cur\u0026lt;\u0026lt;1|1; int llen = (mid - l + 1), rlen = (r - mid); tr[lc].flag = tr[rc].flag = 1; tr[lc].val = tr[rc].val = val; tr[lc].sum = llen * val, tr[rc].sum = rlen * val; } // 区间赋值为 x void update(int cur, int l, int r, int L, int R, int x) { if (L \u0026gt; R) return; if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { tr[cur].flag = 1; tr[cur].val = x; tr[cur].sum = (r-l+1) * x; return; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } // 区间求和 int query(int cur, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; R \u0026gt;= r) { return tr[cur].sum; } push_down(cur, l, r); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); return res; } } tr1, tr2; // 比它小，比它大 int n, q, x, p; int a[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (a[i] == x) p = i; } for (int i = 1; i \u0026lt;= n; i++) { if (a[i] \u0026lt; x) tr1.update(1, 1, n, i, i, 1); if (a[i] \u0026gt; x) tr2.update(1, 1, n, i, i, 1); } while (q--) { int c, L, R; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int sum1 = tr1.query(1, 1, n, L, R); int sum2 = tr2.query(1, 1, n, L, R); tr1.update(1, 1, n, L, R, 0); tr2.update(1, 1, n, L, R, 0); if (c == 1) { tr1.update(1, 1, n, L, L+sum1-1, 1); tr2.update(1, 1, n, R-sum2+1, R, 1); if (p \u0026gt;= L \u0026amp;\u0026amp; p \u0026lt;= R) p = L + sum1; } else { tr2.update(1, 1, n, L, L+sum2-1, 1); tr1.update(1, 1, n, R-sum1+1, R, 1); if (p \u0026gt;= L \u0026amp;\u0026amp; p \u0026lt;= R) p = L + sum2; } } cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; }   ","date":"2021-03-16T22:10:22+08:00","permalink":"https://tom0727.github.io/post/032-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BE%8B%E9%A2%98/","tags":["暴力优化","线段树"],"title":"线段树/树状数组/分块 例题"},{"categories":["算法"],"contents":"介绍 树上启发式合并 一般用于 满足以下条件的问题：\n 所有询问离线，无修改，仅询问子树的信息（不能用于链的询问） $ans[u]$ 可以转化为 $\\sum\\limits_{v}ans[v]$ 的形式（其中，$v$ 是 $u$ 的child） 如果已知 $ans[v]$，可以在 $O(1)$ 的时间（或者无需任何操作）添加到 $ans[u]$ (其中，$v$ 是 $u$ 的child）   先用 CF600E 来举个例子。\n题意\n已知一棵包含 $N$ 个节点的有根树（root为 $1$），每个节点 $i$ 有一个颜色 $c_i$。\n对于每一个节点 $i$，我们都要求出它的 subtree（包含自己）中，出现颜色次数最多的所有颜色编号和（可能不止一种颜色）。\n例：$1$ 的subtree中，共有 5 个节点，颜色分别为 $2,2,5,5,1$，那么出现颜色次数最多的颜色编号为 $2,5$，所求的和为 $2+5 = 7$，所以 $ans_1 = 7$。\n输出对于每一个 $i$ 的 $ans_i$\n其中，$1\\leq n \\leq 10^5, 1 \\leq c_i \\leq n$\n 思想 暴力做法 首先，我们开一个全局的数组 cnt[]，记录每一种颜色出现的次数。再开一个全局数组 sum[]，其中 sum[i] 代表出现次数为 i 的颜色的编号和。\n然后，对于每一个节点 $i$，遍历它 subtree 中的所有节点，统计答案。统计完以后，清空这两个全局数组，再换下一个节点重复此步骤。\n复杂度：$O(n^2)$\n优化思路 • 注：以下 $u$ 均表示parent，$v$ 表示 $u$ 的child。\n我们发现，对于任何一个节点 $u$ ，$cnt[u] = \\sum\\limits_v cnt[v]$ ，$sum[u] = \\sum\\limits_v sum[v]$ （这里不是指真的sum，而是说我们可以通过所有child的信息合并，得到 $u$ 的信息）。\n那么，我们的暴力思路是：\n来到节点 $u$ 时，\n 先统计所有 $v$ 的答案 $ans_v$（代表 $v$ 对应subtree的答案），每统计完一个 $v$ 就清空一次全局数组。 全部的 $v$ 统计完以后，再遍历所有的 $v$ 的subtree，把所有 $v$ 的 cnt[], sum[] 进行合并。 加上 $u$ 本身，就得到了 $u$ 所在subtree的答案 $ans_u$。  这里我们发现了一个可以优化的地方：\n对于最后一个 $v$，我们统计完它以后，不需要清空全局数组，因为我们马上就要进行 Step 2，刚好需要合并所有 $v$ 的信息，所以保留它就可以节省一些时间。\n那么这最后一个 $v$，所对应的subtree 自然是 size 越大越好。所以我们就选择 $u$ 的重儿子作为最后一个 $v$。\n这就是树上启发式合并了，复杂度为 $O(n\\log n)$，证明见下面。\n算法步骤  创建全局数组（一般是 cnt[] 一类的数颜色数组）。 进行第一次 $DFS$（$dfs_1$），获得每个节点的 sz[]（subtree大小），son[]（重儿子）。 进行第二次 $DFS$（$dfs_2$），来到节点 $u$ 后：  先递归 $DFS(v)$，对于每一个 $v$（除了重儿子以外），获得 $ans_v$。然后清空全局数组。 递归 $DFS(x)$，获得 $ans_x$（其中，$x$ 是 $u$ 的重儿子）。不清空全局数组。 遍历所有 $v$ 的subtree（除了重儿子以外），把信息加到全局数组上。（注意，这里的遍历并不是上面的 $DFS(v)$，一般实现过程中，用 add(v, 1) 来表示）。 加上 $u$ 自己的信息，得到 $ans_u$。    模版 vector\u0026lt;int\u0026gt; adj[maxn]; int sz[maxn], son[maxn], par[maxn]; void dfs1(int u, int p) { par[u] = p; sz[u] = 1; int maxsz = -1; for (int v : adj[u]) { if (v == p) continue; dfs1(v, u); sz[u] += sz[v]; if (sz[v] \u0026gt; maxsz) { maxsz = sz[v]; son[u] = v; } } } int cnt[maxn], a[maxn]; // 根据题目而定 // 单点更新 void update(int u, int f) { int c = a[u]; cnt[c] += f; if (f == 1) { if (cnt[c] == 2) mx.insert(c); } else { if (cnt[c] == 1) mx.erase(c); } } // 遍历subtree，加到数组上。f = 1（加上信息）或者 -1（清空信息） void add(int u, int p, int f) { // f = 1: add, f = -1: del update(u, f); // 单点更新 for (int v : adj[u]) { if (v == p) continue; add(v, u, f); } } int ans1[maxn], ans2[maxn]; // keep 代表该节点是否为重儿子（如果keep = 1就不清空数组） // f 代表这个子树对应的是 +1 (加上) 还是 -1 (减去) void dfs2(int u, int p, bool keep, int f) { for (int v : adj[u]) { if (v == p || v == son[u]) continue; dfs2(v, u, 0, f); // Step1: 轻儿子不保留信息，keep = 0表示，在dfs2(v)结束后，全局数组不会有任何变化 } if (son[u]) dfs2(son[u], u, 1, f); // Step2: 重儿子保留信息 for (int v : adj[u]) { if (v == p || v == son[u]) continue; add(v, u, f); // Step3: 遍历所有v（除了重儿子以外），加上信息 } update(u, f); // Step 4: 单点更新 u 的信息 if (f == 1) { if (mx.size()) ans1[u] = *mx.begin(); // Step4: 得到 ans[u] } else { if (mx.size()) ans2[u] = *mx.begin(); } if (!keep) add(u, p, -f); // 如果keep = 0，说明需要清空数组，就把整个subtree(u)的影响再减掉就可以了 } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } dfs1(1, 0); dfs2(1, 0, 0, 1); }  复杂度证明 对于任何一个节点 $u$，如果它被清空了，那么这说明它的某个祖先是轻儿子。而轻儿子的数量 = 重链数量 = $O(\\log n)$，所以每个节点最多被清空 $\\log n$ 次。总复杂度为 $O(n\\log n)$\n例题 例1 CF600E 题意和题解都讲了，就直接放代码了：\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int n, sz[maxn], head[maxn], ecnt = 1, color[maxn], son[maxn]; ll cnt[maxn], sum[maxn], ans[maxn], maxcnt = 0; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { sz[u] = 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void update(int u, int f) { // 单点更新 int c = color[u]; cnt[c] += (ll)f; sum[cnt[c]-f] -= (ll)c; sum[cnt[c]] += (ll)c; while (f \u0026gt; 0 \u0026amp;\u0026amp; sum[maxcnt+1]) maxcnt++; if (f \u0026lt; 0) maxcnt = 0; } void add(int u, int p, int f) { // f = 1: add, f = -1: del update(u, f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } update(u, 1); ans[u] = sum[maxcnt]; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; color[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例2 CF208E 题意\n已知一棵包含 $N$ 个节点的森林（可能有多个root），并且给出 $M$ 个询问。\n$v, p$：输出存在多少个点 $u$，使得 $u$ 和 $v$ 的第 $p$ 个祖先相同。\n其中，$1\\leq n,m \\leq 10^5$\n 法一树上莫队 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n那么，用 DFS序 先把树上问题转化为区间问题，就变成了：\n在区间 $[L,R]$ 内，有多少个 $u \\in [L,R]$ 使得 dep[u] = dep[x] + p ？\n然后用 莫队 来处理每个询问即可。\n 树上莫队代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, tmp[maxn]; int par[maxn][22]; int cnt[maxn], id[maxn], idcnt = 1; struct Edge { int to, nxt; } edges[maxm]; struct Query { int l,r,id,d; } q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; id[u] = idcnt++; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { // 注意这里先处理parent，之后再 dfs(to) par[u][j] = par[par[u][j-1]][j-1]; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; } } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void add(int x) { cnt[dep[x]]++; } void del(int x) { cnt[dep[x]]--; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } memcpy(tmp, dep, sizeof(dep)); for (int i = 1; i \u0026lt;= n; i++) dep[id[i]] = tmp[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int l,r,d; if (!p) l = 0; else l = id[p]; r = l + sz[p] - 1; d = dep[id[u]]; // find number of vertices in subtree of u, which has depth d q[i] = {l,r,i,d}; } int BLOCK = sqrt(n); sort(q+1, q+m+1, [\u0026amp;](auto a, auto b) { int be1 = (a.l-1) / BLOCK, be2 = (b.l-1) / BLOCK; if (be1 == be2) return a.r \u0026lt; b.r; return be1 \u0026lt; be2; }); int l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int L,R,ID,D; L = q[i].l, R = q[i].r, ID = q[i].id, D = q[i].d; if (!L) { ans[ID] = 0; continue; } while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026gt; L) add(--l); while (l \u0026lt; L) del(l++); ans[ID] = cnt[D] - 1; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   法二树上启发式合并 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n可以发现，如果我们求出来了 child $v$ 的 cnt[] 信息（即，在 $v$ 的subtree内，每个 dep 对应的节点数量），则直接把 cnt[] 数组加到 parent $u$ 上即可。所以在继承重儿子 cnt[] 信息时，无需任何操作。\n这样就可以 树上启发式合并了！\n 树上启发式合并代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, son[maxn]; int par[maxn][22]; int cnt[maxn]; struct Edge { int to, nxt; } edges[maxm]; struct Query { int id, d; }; vector\u0026lt;Query\u0026gt; q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { par[u][j] = par[par[u][j-1]][j-1]; } int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void add(int u, int f) { cnt[dep[u]] += f; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; add(to, f); } } void dfs2(int u, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; dfs2(to, 0); } if (son[u]) dfs2(son[u], 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; add(to, 1); } cnt[dep[u]]++; for (Query que : q[u]) { int id = que.id, d = que.d; ans[id] = cnt[d] - 1; } if (!keep) add(u, -1); } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void debug() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 2; j++) { printf(\u0026quot;i = %d, j = %d, par = %d\\n\u0026quot;,i,j,par[i][j]); } } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int d = dep[u]; // find number of vertices in subtree of u, which has depth d if (!p) ans[i] = 0; else { q[p].push_back({i,d}); } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs2(i, 0); } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 CF1009F 题意\n已知一棵包含 $N$ 个节点的有根树。\n设 $d(u,k)$ 为 $u$ 的subtree中，到 $u$ 距离为 $k$ 的节点数量。\n对于每一个点 $u$，输出一个最小的 $k$，使得 $d(u,k)$ 最大。\n其中，$1\\leq N \\leq 10^6$\n 题解  注意对于这一类型的问题，有些信息看起来是 vertex-dependent（和vertex本身有关，例如 到 $u$ 距离为 $k$）。但是我们转化一下，就可以将它变成一个静态的信息，比如：\n到 $u$ 距离为 $k$ $\\iff$ 深度等于 $dep[u] + k$\n这样，这个信息用一个 cnt[] 数组就可以继承了，例二也是同理。\n 用 cnt[] 数组记录每一个深度 $d$ 对应的数量，维护一个 maxcnt 和 cur，分别代表 $\\max\\limits_k \\{d(u,k)\\}$ 和 $k$ 的值。\n剩下就是启发式合并的板子了。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e6+5; const int maxm = 2e6+10; int head[maxn], dep[maxn], sz[maxn], son[maxn], n, ecnt = 1, cnt[maxn], ans[maxn]; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) maxsz = sz[to], son[u] = to; } } int maxcnt = 0, cur = 1e9; void add(int u, int f) { int d = dep[u]; if (f \u0026gt; 0) { cnt[d]++; if (maxcnt \u0026lt; cnt[d]) { maxcnt = cnt[d]; cur = d; } if (maxcnt == cnt[d] \u0026amp;\u0026amp; cur \u0026gt; d) cur = d; } else { cnt[d]--; maxcnt = 0, cur = 1e9; } } void add(int u, int p, int f) { add(u,f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); add(u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } ans[u] = cur; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] - dep[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF741D 题意\n已知一棵包含 $N$ 个节点的有根树，每条边上有一个字符（a-v共22种）。\n定义 Dokhtar-kosh 路径为满足以下条件的路径：\n 简单路径（无环） 路径上的字符经过重新排序后，可以形成一个回文串  对于每一个节点 $u$，求 $u$ 所在子树中，最长的 Dokhtar-kosh 路径长度。\n其中，$1\\leq N \\leq 5 \\times 10^5$\n 题解 2900分的压轴题，很难。\n首先定义 $f_u$ 为：从 $1$（root）开始，一直到节点 $u$ 的路径所组成的字符序列。\n因为字符只有 a-v 22种，并且我们并不关心字符具体数量，只关心奇偶性，所以可以用 状压 来表示一个字符序列。\n例如：$1 \\rightarrow u$ 的路径上有 $a,a,b,b,b,c$，则对应的bitmask为：$000\u0026hellip;110$（$a$有偶数个，$b,c$有奇数个）。\n我们可以预处理出所有的 $f_u$，怎么得到 $u,v$ 之间路径对应的 $f$ 值？\n会发现：\n$$f_{u,v} = (f_u \\text{ xor } f_x) \\text{ xor } (f_v \\text{ xor } f_x) = f_u \\text{ xor } f_v$$\n其中，$f_{u,v}$ 代表 $u,v$ 之间路径对应的 $f$ 值，$x = LCA(u,v)$。\n 又发现，一个 Dokhtar-kosh 路径只要满足：$f_{u,v}$ 所包含的 $1$ 的数量 $\\leq 1$ 即可。\n例如 $f_{u,v} = 000\u0026hellip;000$ 或 $000\u0026hellip;001$ 或 $000\u0026hellip;010$ 等等…… 均满足条件。\n 所以，问题转化为：\n对于每一个节点 $x$，求 $x$ 所在子树中，距离最长的 $u,v$，使得 $f_{u,v} = f_u \\text{ xor } f_v$ 包含最多一个 $1$。\n 那么这就是一个比较标准的 树形dp 问题：\n定义 $dp[mask]$ 为，在当前的节点 $x$ 的 已探索子树 中，$f_u = mask$ 的 最深深度。（因为 $x$ 太多了，所以不能定义二维数组，只能用一个全局数组）。\n又发现这是关于深度的信息，可以直接向上传递，所以可以采用 树上启发式合并 进行转移。\n对于每一个节点 $u$，dp的转移方程如下：\n  路径完全存在于某一个child的子树内：从所有的child的子树中取最大值即可！ $$ans_u = \\max\\limits_v \\{ ans_v \\}$$\n  $u$ 本身和某一个 child 的子树中某一个节点 $v$ 组成路径： $$ans_u = \\max\\limits_v \\{dp[f_v] + dep[u]\\} - 2\\times dep[u]$$\n其中 $f_u \\text{ xor } f_v$ 只能包含最多一个 $1$。\n  $u$ 的子树中有两个节点 $a,b$ 跨过了 $u$，组成一条路径： $$ans_u = \\max\\limits_b \\{dp[f_a] + dep[b]\\} - 2 \\times dep[u]$$\n其中 $f_a \\text{ xor } f_b$ 只能包含最多一个 $1$。\n  其中，Case $1,2$ 都比较好处理。对于第三种情况，我们可以在 add() 函数中，遍历子树的时候顺便处理。\n 注意，树形dp中一定要注意更新的先后顺序，以免出现某个节点自己和自己形成路径的情况！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; const int maxm = 1e6+10; int head[maxn], ecnt = 1, dep[maxn], sz[maxn], son[maxn], ans[maxn], f[maxn], dp[(1\u0026lt;\u0026lt;22) + 5], masks[25], n; struct Edge { int to, nxt; char c; } edges[maxm]; void addEdge(int u, int v, char c) { Edge e = {v, head[u], c}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p, int mask) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; f[u] = mask; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; int c = edges[e].c - 'a' + 1; dfs(to, u, mask ^ masks[c]); sz[u] += sz[to]; if (maxsz \u0026lt; sz[to]) { maxsz = sz[to]; son[u] = to; } } } int ori; void add(int u, int p, int sgn) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, sgn); } if (sgn \u0026gt; 0) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[ori] = max(ans[ori], dp[tar] + dep[u]); // 注意这里是 ori，因为更新的是 ans[ancestor] } } if (sgn \u0026lt; 0) dp[f[u]] = -1e9; // 这里清空，必须初始化为负无穷 } void update(int u, int p) { dp[f[u]] = max(dp[f[u]], dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; update(to, u); } } void add(int u) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[u] = max(ans[u], dp[tar] + dep[u]); // Case 2: u 本身和 子树内某个节点 } } void update(int u) { dp[f[u]] = max(dp[f[u]], dep[u]); } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); ori = u; // Case 3: 因为 add过程中，需要更新的是 ans[u]，所以用全局变量 ori 来传递。 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); // 树形dp注意点：先更新ans update(to, u); // 更新ans后，再更新dp数组！ } add(u); // 注意这里单点更新 update(u); // 注意这里单点更新 ans[u] -= 2 * dep[u]; // 这里要减去 2*dep[u] ans[u] = max(ans[u], 0); // 需要大于0，因为有可能是负数 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // Case1: 取每个子树的最大值 ans[u] = max(ans[u], ans[to]); // 注意，是在减去 2*dep[u] 以后，才取的max！ } if (!keep) add(u, p, -1); } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; i++) { int p; char c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; addEdge(i, p, c); addEdge(p, i, c); } for (int i = 1; i \u0026lt;= 22; i++) masks[i] = (1\u0026lt;\u0026lt;(i-1)); fill(dp, dp+(1\u0026lt;\u0026lt;22)+5, -1e9); dfs(1, 0, 0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/pb122401/article/details/84648993 https://codeforces.com/blog/entry/44351  ","date":"2021-03-15T20:53:14+08:00","permalink":"https://tom0727.github.io/post/031-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","tags":["树上启发式合并"],"title":"树上启发式合并（DSU on Tree）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc131/tasks/abc131_f\n题意\n给定 $N$ 个二维平面中的点 $(x_i,y_i)$，我们可以一直重复以下操作：\n选择 4 个整数 $a,b,c,d$，保证 $(a,b),(a,d),(c,b),(c,d)$ 中 有且仅有 3 个点存在，并在剩下的那个位置添加一个点。（即，形成一个长方形）\n我们一直重复此操作，求可以进行多少次？（可以证明，一定是有限次）\n其中，$1 \\leq N,x_i,y_i \\leq 10^5$，每个点互不相同。\n 题解 把每一个 $x$ 坐标当作一个 vertex，每一个 $y$ 坐标也当作一个 vertex。\n每个平面上的点当作一个 edge：例如一个点为 $(x_i,y_i)$，就把 $x_i$ 和 $y_i$ 之间连一个 edge。\n我们会发现：一个包含4个点的长方形，刚好就是 4个vertex + 4个edge。所以有：\n能够加一个点 $\\iff$ 4个点连通，且只有3个edge。\n扩展一下，如果有 $n$ 个 $x$ 坐标和 $m$ 个 $y$ 坐标形成同一个连通块，那么我们最多可以有 $n \\times m$ 个点（edge）（长方形中的每一个点都被填上了）。\n 所以，用并查集维护一下所有点形成的连通块，然后找到每个连通块的 $x,y$ 坐标个数。最终减去所有edge数量，即：\n$$ans = \\sum\\limits_i (n_i \\times m_i) - e$$\n  这题主要是学习一下 以坐标为 vertex，点为 edge 的思想\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 2e5+5; const int maxm = 1e5; int n; int par[maxn]; // [1...1e5] 储存x坐标，[1e5+1...2e5] 储存y坐标 int l[maxn], r[maxn]; //记录每个par对应的块有几个x，y坐标 int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u \u0026gt; v) swap(u,v); par[v] = u; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2*maxm; i++) par[i] = i; for (int i = 1; i \u0026lt;= n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unions(x, y+maxm); // y坐标对应的是 y+1e5 } for (int i = 1; i \u0026lt;= maxm; i++) { int u = finds(i); // x坐标 l[u]++; u = finds(i+maxm); // y坐标 r[u]++; } ll ans = 0; for (int i = 1; i \u0026lt;= 2*maxm; i++) { ans += (ll)(l[i]) * (ll)(r[i]); } ans -= n; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题  https://codeforces.com/contest/1012/problem/B （完全一样的思想）  ","date":"2021-03-12T21:48:23+08:00","permalink":"https://tom0727.github.io/post/030-at-abc131f/","tags":["图论","并查集"],"title":"Atcoder ABC 131F（图论）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/165/problem/E\n题意\n给定 $n$ 个数 $a_1,a_2,\u0026hellip;,a_n$，对于每一个 $a_i$，找出是否存在 $a_j$ 使得 $a_i$ \u0026amp; $a_j = 0$？\n其中 $1 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 4\\times10^6$\n 题解 结论1：如果 $a_i$ \u0026amp; $a_j = 0$，则对于 $a_j$ 的任何一个子集 $b$（$b \\subset a_j$），都有 $a_i$ \u0026amp; $b = 0$\n结论2：$\\forall i, ~a_i$ \u0026amp; $($~$a_i) = 0$\n 由上，对于每一个 $a_i$，我们都知道 ~$a_i$ 必然满足条件。所以只要找是否存在 $a_j$ 使得 $a_j \\subset$ ~$a_i$ 即可。\n换而言之，我们可以从高往低进行 dp，从每一个 ~$a_i$ 开始，枚举 ~$a_i$ 的子集，将满足条件的信息传递到子集中，最后看是否存在 $a_j$ 被传递了即可。\n然而直接枚举子集复杂度太高，我们可以考虑按照 位数 进行dp：\n我们从 $111\u0026hellip;111$ 开始枚举，然后枚举少一个 $1$ 的情况：即 $011\u0026hellip;11, 101\u0026hellip;11, 110\u0026hellip;11$ 等等。然后继续往下传递即可。\n 状态转移方程：\n令 dp[mask] 为：这个mask是否存在 $a_j$ 使得 $mask$ \u0026amp; $a_j = 0$，如果存在，就是 $a_j$ 的值，否则为 $-1$\n转移过程就是上述的，枚举 少一个 $1$ 的子集过程。\n• 实现代码中，是从 多一个 $1$ 转移过来的，本质相同。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = (1\u0026lt;\u0026lt;22); // 1\u0026lt;\u0026lt;22 == 4.1e6 int n; int arr[maxn]; int dp[maxm]; int INF = (1\u0026lt;\u0026lt;22) - 1; // 注意INF \u0026gt; 4e6，我们要根据 位数 取INF，而不是根据数据范围 int inv(int x) { return (~x) \u0026amp; INF; // 注意这里有 \u0026amp; INF 的操作，否则会得到负数 } int main() { fill(dp, dp+maxm, -1); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], dp[inv(arr[i])] = arr[i]; for (int mask = INF; mask \u0026gt;= 1; mask--) { // 注意从 INF开始，而不是从 4e6开始，因为 inv(arr[i]) 有可能 \u0026gt; 4e6 if (dp[mask] != -1) continue; for (int j = 0; j \u0026lt; 22; j++) { int a = mask | (1\u0026lt;\u0026lt;j); // 枚举多一位 if (a == mask) continue; if (dp[a] != -1) { dp[mask] = dp[a]; break; } } } for (int i = 1; i \u0026lt;= n; i++) { int a = arr[i]; cout \u0026lt;\u0026lt; dp[a] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   高维前缀和 本题似乎与高维前缀和有关，这里介绍一下高维前缀和的知识。\n高维前缀和主要用于解决 $dp[S] = \\sum\\limits_{T \\subset S}a[T]$ 的问题。\n在我们求一个多维度的前缀和时，有两种方法：（以下，使用求一个矩阵的前缀和来举例）\n法一：枚举dp数组位置 + 容斥： $O(n2^d)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];  法二：枚举维度，不用容斥： $O(nd)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i][j - 1]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j];  高维前缀和的思想在于枚举每一个维度，然后让这个维度减 $1$，做前缀和。\n• 如上，先枚举了第一维，然后枚举第二维。\n在实现的时候就是根据维度来dp。\n 如果有更多维度的话，也是枚举每一个维度，然后求每个维度的前缀和：\nfor (int i = 0; i \u0026lt; d; i++) { // 枚举每一个维度 for (int mask = 0; mask \u0026lt; (1\u0026lt;\u0026lt;d); mask++) { //求前缀和 if (mask \u0026amp; (1\u0026lt;\u0026lt;i)) dp[mask] += dp[mask ^ (1\u0026lt;\u0026lt;i)]; } }  ","date":"2021-03-11T23:20:32+08:00","permalink":"https://tom0727.github.io/post/029-cf-165e/","tags":["状压dp"],"title":"CF 165E题解（状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1188/problem/B\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，和一个非负整数 $k$，求满足以下条件的 $(i,j)$ 数量：\n $1\\leq i \u0026lt; j \\leq n$ $(a_i+a_j)(a_i^2+a_j^2) \\equiv k \\text{ mod } p$  其中，$2 \\leq n \\leq 3 \\times 10^5, 2 \\leq p \\leq 10^9, 0\\leq k \\leq p-1, p$ 是质数。\n 题解 一般这种求 $(i,j)$ 的数量，一个常规操作是构造出 $f(i) = g(j)$，然后在遍历过程中维护一个 cnt，直接加到 ans 上。\n所以我们想个办法 把 $i,j$ 分到两边：\n$(a_i+a_j)(a_i^2+a_j^2) = k$，两边同乘 $(a_i-a_j)$，有 $a_i^4-a_j^4 = k(a_i-a_j)$，移项得到\n$$a_i^4 - ka_i = a_j^4-ka_j$$\n所以维护一个 cnt 来记录 $a_i^4 - ka_i$ 的值就可以了，代码略。\n","date":"2021-03-11T14:37:13+08:00","permalink":"https://tom0727.github.io/post/028-cf-1188b/","tags":["枚举"],"title":"CF 1188B（枚举优化）"},{"categories":["算法"],"contents":"介绍 数论分块一般用于解决 含有 $\\lfloor \\frac{N}{i} \\rfloor$ 的求和问题。\n数论分块主要利用了 $\\lfloor \\frac{N}{i} \\rfloor$ 的取值范围相当有限的特点，所以有\n$$i \\leq j, ~\\lfloor \\frac{N}{i} \\rfloor = \\lfloor \\frac{N}{j} \\rfloor$$\n这样一些求和问题就可以转化为 $(j-i+1) \\times \\lfloor \\frac{N}{j} \\rfloor$ （或者类似的形式）\n时间复杂度：$O(\\sqrt n)$\n证明 $\\forall i \\leq n,$ $\\exists$ 最大的 $j$ 使得 $~i \\leq j \\leq n$，且 $\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloor$\n则 $$j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$$\n 证明：\n显然 $j \\leq n$，只要证 $j \\geq i$：\n因为 $j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$，又因为 $i = \\lfloor \\frac{n}{\\frac{n}{i}} \\rfloor$ （分母没有下取整）\n因为 $\\lfloor \\frac{n}{i} \\rfloor \\leq \\frac{n}{i}$，所以有 $j \\geq i$\n例题 例1 求 $\\sum\\limits_{i=1}^N \\lfloor \\frac{N}{i} \\rfloor$  以下的代码中，我们令 l,r 代表上文的 i,j\n int r; for (int l = 1; l \u0026lt;= n; l = r + 1) { // 注意这里是 l = r+1 r = n / (n / i); ans += (n / l) * (r - l + 1); }  • 可以发现，数论分块的本质思想是 枚举 $\\lfloor \\frac{N}{i} \\rfloor$ 的值。\n例2 洛谷P2261 余数求和 题意\n给定正整数 $n,k \\leq 10^9$，求 $\\sum\\limits_{i=1}^n k \\text{ mod } i$\n 题解 因为 （以下略去 下取整符号） $$k \\text{ mod } i = k - \\frac{k}{i} \\times i$$\n对于 $n \u0026gt; k$ 的部分，就加上 $(n-k) \\times k$。\n对于 $n \\leq k$ 的部分，有 $$\\sum\\limits_{i=1}^n k \\text{ mod } i = n\\times k - \\sum\\limits_{i=1}^n \\frac{k}{i} \\times i$$\n然后数论分块枚举 $\\lfloor \\frac{k}{i} \\rfloor$ 的值，每个块分别用等差数列求和即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll ans = 0; if (n \u0026gt; k) { ans += (n-k) * k; n = k; } ll r; ans += (n*k); for (ll l = 1; l \u0026lt;= n; l = r+1) { r = min(n, k / (k/l)); // 注意这里取 min，因为 k/(k/l) 有可能超过n ans -= (k/l) * ((l+r) * (r-l+1) / 2LL); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 Atcoder ABC132F Small Products 题意\n给定正整数 $n \\leq 10^9$，$2 \\leq k \\leq 100$，求满足以下条件的序列数量：\n 长度为 $k$ 任意两个相邻元素的乘积 $\\leq n$  答案对 $10^9+7$ 取模。\n 题解 很容易发现 dp 思路：\n设 $dp[i][j]$ 为：当前用到第 $i$ 个元素，结尾的元素的值为 $j$ 的数量。则答案为 $\\sum\\limits_{j=1}^{n}dp[k][j]$\n但是 $n \\leq 10^9$，dp数组开不了这么大。\n我们可以考虑只将 dp[][] 的第二维开到 $\\sqrt n$ 的大小，对于 $j \u0026gt; \\sqrt n$ 的部分用数论分块解决。\n令 $m = \\sqrt n$，且维护前缀和 $sum[i][j] = \\sum\\limits_{k=1}^j dp[i][j]$，转移方程有：\n$$dp[i][1] = \\sum\\limits_{j=1}^n dp[i-1][j] = \\sum\\limits_{j=1}^m dp[i-1][j] + \\sum\\limits_{j=m+1}^n dp[i-1][j]$$\n其中，\n$$\\forall j \u0026gt; m, ~dp[i-1][j] = \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k]$$\n会发现，对于不同的 $j$，$\\lfloor \\frac{n}{j} \\rfloor$ 的取值相当有限，所以可以用数论分块。所以有：\n$$dp[i][1] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n sum[i-2][\\frac{n}{j}]$$\n第二项用数论分块处理即可，注意到随着 $j$ 的增大，$\\frac{n}{j}$ 逐渐减小，所以可以反着枚举 $j$ （即 $j = m~\u0026hellip;~1$）\n最后，答案就是 $dp[k+1][1] = \\sum\\limits_{j=1}^{n}dp[k][j]$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k,m; ll dp[103][31642]; ll sum[103][31642]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; m = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) dp[1][i] = 1, sum[1][i] = sum[1][i-1] + 1; for (int i = 1; i \u0026lt;= m; i++) dp[2][i] = n/i, sum[2][i] = (sum[2][i-1] + dp[2][i]) % mod; for (int i = 3; i \u0026lt;= k+1; i++) { ll cur = 0; ll l = m+1,r; for (int j = m; j \u0026gt;= 1; j--) { //倒序枚举 j dp[i][j] = sum[i-1][m]; if (n/j \u0026lt;= m) { // 注意这里需要特判，否则 n/j \u0026lt;= m 是有可能的，导致RE continue; } r = min(n/j, n / (n/l)); cur = (cur + ((r-l+1) * (sum[i-2][n/l]) % mod)) % mod; l = r + 1; dp[i][j] = (dp[i][j] + cur) % mod; } for (int j = 1; j \u0026lt;= m; j++) sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod; } ll ans = dp[k+1][1]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-10T15:49:46+08:00","permalink":"https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","tags":["数学"],"title":"数论分块"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1243/problem/E\n题意\n给定 $k$ 个 box，每个 box $i$ 里有 $n_i$ 个整数，所有整数均不同。\n现在我们需要执行 Exactly Once 以下操作：\n从每一个box中拿一个数出来，然后以permutation的形式放回每一个box（即每一个box放入且仅放入一个数）。\n判断是否存在这样的操作使得所有box里的sum相同，如果有，输出具体方案。\n其中，$k \\leq 15, n \\leq 5000$\n 题解 首先，所有box的sum必须被 $k$ 整除，否则无解。\n令 $tar$ 为最终每个box的sum。\n我们可以枚举 $box ~1$ 要拿哪个数出来（叫做 $a_1$），这样我们就可以知道它需要被放入哪个数（叫做 $b_1$）。又因为所有数字都不相同，故我们就可以知道 $b_1$ 的来源是哪个box，假设来自 $box_i$，那么我们就可以得到 $a_i = b_1$，于是就可以计算出 $b_i$，一直这么继续下去。\n如果最终形成了一个 完整环（以 $box_1$ 作为起点，并且以 $box_1$ 作为终点）的话，就说明这个方案可行。\n但是，这个环不一定覆盖了所有的点。所以我们需要找到所有的环，我们分别以 $1,2,3,\u0026hellip;,k$ 作为起点，并且对于每个box都枚举一下要拿的数。这样我们可以最多形成 $\\sum\\limits_{i=1}^k n_i \\leq 75000$ 个环。并且每个环一定互不相同。\n 现在的问题就转化为：给定了这些环，我们能否从中挑选出几个环，使得每个 $box$ 被访问，且仅被访问一次？\n用 Bitmask ！\n因为 $k \\leq 15$，我们将每个环表示为一个bitmask，比如某个环是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 1$，那么对应的bitmask就是 $000\u0026hellip;1011$。\n我们会发现，可能会有很多个环对应同一个bitmask，但是没关系，我们只需要输出一个解即可。\n 最后，问题转化为：给定一些bitmask，如何让它们组合成 $2^k-1$，且每个bit仅被覆盖一次？\n用 状压dp！\n定义 bool ori[(1\u0026lt;\u0026lt;16)+2], dp[(1\u0026lt;\u0026lt;16)+2];\n其中 ori[mask] 代表这个mask是否由 单独一个环 所组成，而 dp[mask] 代表这个mask能否由 $1$ 个 或多个环 组成。\n然后就是一个很经典的模版了：\nfor (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { // 枚举mask的子集，使用 (sub-1) \u0026amp; mask来加速枚举 if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { // 使用xor保证同一个bit只被覆盖一次 dp[mask] = 1; break; } } }   最后就是实现了，本题实现起来相当麻烦，找 完整环 用的是 $dfs$ + $bitmask$ + 记录起点（和起点使用的数），每次找到一个环，就把 起点 放在对应的 $bitmask$ 数组 plan[] 里。\n在找完所有的环之后，再根据每个 $bitmask$，再进行一次 $dfs$ 来找到这个环的具体路径。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define pii pair\u0026lt;int,int\u0026gt; int k; int adj[16][5002]; //记录第i个box的第j个数 int sz[16]; //记录第i个box的大小 ll sum[16]; ll diff[16]; // 记录第i个box的sum和target的差 unordered_map\u0026lt;ll, int\u0026gt; belong; // 记录某个数属于第几个box pii plan[(1\u0026lt;\u0026lt;16)+2]; // 储存每个bitmask对应的起点 {start, a} bool ori[(1\u0026lt;\u0026lt;16)+2]; bool dp[(1\u0026lt;\u0026lt;16)+2]; int from[(1\u0026lt;\u0026lt;16)+2]; // 记录每个bitmask在dp过程中由哪个子集转移过来的 pii ans[16]; void dfs(int cur, ll a, int mask, int start, ll oa) { //cur: current vertex, a: the number we are taking OUT from cur, start: the starting vertex, oa: the \u0026quot;a\u0026quot; for starting vertex ll need = a - diff[cur]; if (!belong.count(need)) return; // no vertex to go int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); if (to == start \u0026amp;\u0026amp; need == oa) { ori[mask] = 1; plan[mask] = {start, oa}; return; } if (mask \u0026amp; (1\u0026lt;\u0026lt;(to-1))) return; // form a cycle, but not a cycle start with \u0026quot;start\u0026quot; dfs(to, need, mask, start, oa); } void dfs2(int cur, ll a, int mask, int start) { ll need = a - diff[cur]; int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); ans[to] = {need, cur}; if (to == start) { return; } dfs2(to, need, mask, start); } void findans(int mask) { if (!ori[mask]) { findans(from[mask]); findans(from[mask] ^ mask); return; } int start = plan[mask].first; ll a = plan[mask].second; dfs2(start, a, 0, start); } int main() { cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { int n; cin \u0026gt;\u0026gt; n; sz[i] = n; for (int j = 1; j \u0026lt;= n; j++) { ll a; cin \u0026gt;\u0026gt; a; adj[i][j] = a; sum[i] += a; belong[a] = i; } } ll tar = 0; for (int i = 1; i \u0026lt;= k; i++) tar += sum[i]; if (tar % k) { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl; return 0; } tar = tar/k; for (int i = 1; i \u0026lt;= k; i++) { diff[i] = sum[i] - tar; } for (int start = 1; start \u0026lt;= k; start++) { for (int j = 1; j \u0026lt;= sz[start]; j++) { dfs(start, (ll)adj[start][j], 0, start, adj[start][j]); } } for (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { dp[mask] = 1; from[mask] = sub; break; } } } if (dp[(1\u0026lt;\u0026lt;k)-1]) { cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; findans((1\u0026lt;\u0026lt;k)-1); for (int i = 1; i \u0026lt;= k; i++) printf(\u0026quot;%d %d\\n\u0026quot;, ans[i].first, ans[i].second); } else { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-09T12:34:01+08:00","permalink":"https://tom0727.github.io/post/026-cf-1243e/","tags":["图论","dp"],"title":"CF1243E 题解（图论，状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1154/problem/G\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，求 $i \\neq j$ 使得 $\\text{lcm}(a_i, a_j)$ 最小？\n其中 $2 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 10^7$\n 题解 一般和 $gcd, lcm$ 相关的题，一般就 $2$ 种trick：\n 质因子分解 枚举 $gcd$ 的值  这道题是 枚举 $gcd$ 的值。因为 $lcm(a_i,a_j) = \\frac{a_ia_j}{\\gcd(a_i,a_j)}$，所以我们枚举一下 $gcd(a_i,a_j)$ 的值即可。\n设 $g$ 为可能的 $gcd$ 的值，从 $1$ 枚举到 $10^7$，对于每一个 $g$，只要找出 最小的两个 $a_i,a_j$ 使得 $g|a_i, g|a_j$ 即可。\n时间复杂度：$T(n) = \\frac{10^7}{1} + \\frac{10^7}{2} + \u0026hellip; + \\frac{10^7}{10^7} = 10^7(1+\\frac{1}{2} + \u0026hellip; \\frac{1}{10^7}) = O(10^7 \\log(10^7))$\n 证明正确性：\n无论最终答案是什么，$\\gcd(a_i,a_j)$ 必然会被枚举到。所以不会漏解。\n如果我们枚举到的 $g$ 不一定是真的 $gcd$ 呢？比如 $g = 2$，然后 $a_i$ 中最小的两个倍数为 $4, 8$？\n答：我们总会枚举到真正的 $gcd$，如果 $g$ 不是真实的 $gcd$，它只会比真实的 $gcd$ 更小，所以获得的 $lcm$ 更大，所以不影响答案的正确性。\n  另：枚举 $gcd$ 的trick之前在 Atcoder-ABC-162E 也出现过。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e6+5; const int maxm = 1e7+5; int arr[maxn]; int vis[maxm]; // 不要用 unordered_set, 会TLE int n; ll ans = 1e18; int ai,aj; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); if (vis[arr[i]] \u0026amp;\u0026amp; arr[i] \u0026lt; ans) ans = arr[i], ai = vis[arr[i]], aj = i; vis[arr[i]] = i; } for (int g = 1; g \u0026lt;= 1e7; g++) { int cur = 0; if ((g\u0026lt;\u0026lt;1) \u0026gt; ans) break; // 优化时间 for (int j = g; j \u0026lt;= 1e7; j += g) { if (vis[j]) { if (cur) { int d = j / g; ll r = 1LL * cur * d; if (r \u0026lt; ans) { ai = vis[cur]; aj = vis[j]; ans = r; } break; } else cur = j; } } } if (ai \u0026gt; aj) swap(ai, aj); printf(\u0026quot;%d %d\\n\u0026quot;, ai,aj); }  ","date":"2021-03-08T21:36:22+08:00","permalink":"https://tom0727.github.io/post/025-cf-1154g/","tags":["枚举","数论"],"title":"CF1154G 题解（gcd/lcm的枚举优化）"},{"categories":["算法"],"contents":"介绍 莫队算法是一种基于分块思想的暴力算法，一般应用于同时满足以下条件的区间问题中：\n 已知 $[L,R]$ 之间的答案，能在 $O(1)$ 时间内转移到 $[L+1,R], [L-1,R], [L,R+1], [L,R-1]$ 的答案。 所有询问均离线。 不存在修改。  我们用模版举个例子：\n题意\n给定一个长度为 $N$ 的正整数序列 $a$，给定一个 $k$，满足 $\\forall i, a_i \\in [1,k]$。\n现在有 $M$ 个询问，每个询问给定一个区间 $[l,r]$，求 $\\sum_{i=1}^kc_i^2$\n其中 $c_i$ 为数字 $i$ 在 $[l,r]$ 中的出现次数。\n数据范围：$1 \\leq n,m,k \\leq 5\\times10^4$\n 算法 Part1 O(1)的状态转移 对于上面的例题，我们可以发现从 $[L,R]$ 转移到 $[L,R+1]$ 是 $O(1)$ 的。\n我们维护两个指针 $l,r$，并且维护一个 cnt[] 数组来记录当前区间的 $c_i$，在 $r$ 右移一格的时候，加上对应的 $cnt$，然后要维护的 $\\sum_{i=1}^kc_i^2$ 也很好转移，计算一下，就会得到\n$$s_{l,r+1} = s_{l,r} + 2\\times c_{a_{r+1}} + 1$$\n同理对于其他三种情况，转移都是 $O(1)$ 的。\n所以，假设我们有两个询问 $[L_1, R_1], [L_2, R_2]$，我们在询问完 $[L_1, R_1]$ 后，将左右指针一个个移动到 $[L_2, R_2]$ 似乎就可以节省一点时间了。（如果它们离得比较近的话）\nPart2 莫队思路 既然我们可以通过维护两个指针 $l,r$ 来快速转移，我们又事先知道所有的询问（因为询问离线），那有什么办法将这些询问靠近一些，来节省更多时间呢？\n分块思想！\n我们将区间划分为 $\\sqrt n$ 块，然后对于每个询问 $[L_i,R_i]$，我们根据 $L_i$ 的值，把它放进对应的块中。\n然后，我们将所有的询问首先根据 所在块的编号 来sort，对于同一块内的询问，根据 $R_i$ 从小到大 来sort。\n最后，根据sort的顺序来处理每个询问，询问之间的转移 就按照上面的左右指针移动来处理。这样我们能在 $O(n\\sqrt n)$ 时间内处理好每一个区间。\n算法步骤  预处理所有询问，记录询问的 l,r，记录 be （代表 l 对应是哪个块），记录 id（代表原先是第几个询问）。 根据 be 作为第一关键字，r 作为第二关键字进行sort。 定义global variable int l = 1, r = 0, ans = 0。 按照sort后的顺序进行询问，调整 l,r 指针，并相应更新 ans，然后将 ans 根据 id 放入答案数组中。  需要注意的点  注意在转移过程中，使用的是 --l 还是 l++。r 还有更新 ans 的时候也类似，要根据具体情况来看。 注意初始情况下， l = 1, r = 0。 be 是根据 l 的位置决定的。  复杂度证明 先注意：\n 同一个块内的 $L_i$ 并没有顺序。 同一个块内的 $R_i$ 没有限制，可以横跨整个区间。  左指针在块内移动 的复杂度：注意到，同一个块内的 $L_i$ 并没有顺序，所以每次询问可能有 $O(B)$ 的复杂度（$B$为块的大小）。总复杂度为 $O(mB)$\n右指针在块内移动 的复杂度：因为是 $R_i$ 是有序的，所以在同一个块内移动的总复杂度为 $O(n)$\n左指针在块之间移动 的复杂度：每次移动复杂度为 $O(2B)$。总复杂度为 $O(\\frac{n}{B} * 2B) = O(2n)$\n右指针在块之间移动 的复杂度：总共有 $\\frac{n}{B}$ 个块，每次在块之间移动没有限制，复杂度为 $O(n)$。总复杂度为 $O(\\frac{n^2}{B})$\n综上，复杂度为 $O(mB) + O(n) + O(\\frac{n^2}{B})$\n当我们取 $B = \\sqrt n$ 时，复杂度为 $O(n \\sqrt n)$\n• 实际上最优复杂度应该取 $B = \\frac{n}{\\sqrt m}$，总复杂度为 $O(n \\sqrt m)$\n根据操作次数优化莫队 考虑一个问题：\n题意\n给定一个数组 $a_i$ 和 $q$ 个询问，每次询问 $a_{[L,R]}$ 之间的mex。\n其中，$n \\leq 10^5$。\n 如果我们用莫队来做，怎么维护这个 mex 呢？如果用 set 的话会多加一个log，显然不行。\n注意到，我们有 $O(n \\sqrt n)$ 次修改操作，而只有 $O(n)$ 次询问 mex 的操作。\n所以我们不妨让修改变成 $O(1)$，让询问mex变成 $O(\\sqrt n)$，这样总复杂度就维持在了 $O(n \\sqrt n)$。\n我们可以维护一个 cnt[] 数组，表示元素 $i$ 出现了几次。\n再根据值域分块，代表一个值域内有多少个元素。询问时，我们从小到大枚举块，当一个块的元素数量未满时，就说明mex在这个块内。\n• CF1000F 也可以这么做，虽然那个题的数据范围过不了。\n例题 例1 小B的询问 就是上面的例题，这里直接放代码。\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m,k; int sz; int arr[maxn]; ll cnt[maxn]; ll ans[maxn]; struct query { int l,r,be,id; } q[maxm]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 1,r = 0; ll add(int x) { ll res = 2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]++; return res; } ll del(int x) { ll res = -2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]--; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; q[i].be = (q[i].l-1) / sz; } sort(q+1, q+m+1, cmp); ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r; while (r \u0026lt; qr) res += add(++r); while (r \u0026gt; qr) res += del(r--); while (l \u0026lt; ql) res += del(l++); while (l \u0026gt; ql) res += add(--l); ans[q[i].id] = res; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 小Z的袜子 题意\n有 $N$ 个袜子，每个袜子 $i$ 有一个颜色 $c_i$，给定 $M$ 个询问 $[L,R]$，每次询问回答 $[L,R]$ 区间内随机抽两个袜子，颜色相同的概率？\n其中 $N,M \\leq 50000, c_i \\in [1,N]$\n 题解 维护 分子和分母：\n每次区间长度加 $1$：分母增加 $len$（$len$ 为增加前的区间长度），分子增加 $cnt_{c_i}$ （$cnt_{c_i}$ 为新增的颜色 $c_i$ 原来的数量）。\n每次区间长度减 $1$：分母减少 $len-1$（$len$ 为减少前的区间长度），分子减少 $cnt_{c_i} - 1$ （$cnt_{c_i}$ 为减少的颜色 $c_i$ 原来的数量）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m; struct query { int l,r,be,id; ll nu,de; } q[maxm]; int arr[maxn]; int cnt[maxn]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) { return a.r \u0026lt; b.r; } return a.be \u0026lt; b.be; } ll nu = 0, de = 0; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int sz; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); for (int i = 1; i \u0026lt;= m; i++) { int l,r; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r); q[i].id = i; q[i].be = (l-1)/sz; q[i].l = l, q[i].r = r; } sort(q+1, q+m+1, cmp); ll l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r, id = q[i].id; if (ql == qr) { q[id].nu = 0, q[id].de = 1; continue; } while (r \u0026lt; qr) de += (r-l+1), r++, nu += cnt[arr[r]], cnt[arr[r]]++; while (r \u0026gt; qr) de -= (r-l), nu -= (cnt[arr[r]] - 1), cnt[arr[r]]--, r--; while (l \u0026gt; ql) de += (r-l+1), l--, nu += cnt[arr[l]], cnt[arr[l]]++; while (l \u0026lt; ql) de -= (r-l), nu -= (cnt[arr[l]] - 1), cnt[arr[l]]--, l++; q[id].nu = nu, q[id].de = de; } for (int i = 1; i \u0026lt;= m; i++) { nu = q[i].nu, de = q[i].de; if (nu == 0) { printf(\u0026quot;0/1\\n\u0026quot;); continue; } ll g = gcd(nu,de); nu /= g, de /= g; printf(\u0026quot;%lld/%lld\\n\u0026quot;,nu,de); } }   例3 CF617E 题意\n给定 $n$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，还有一个整数 $k$ ，以及 $m$ 个询问 $[l,r]$，每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $a_i \\text{ xor } a_{i+1} \\text{ xor } \u0026hellip; \\text{ xor } a_j = k$  其中，$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^6, 0 \\leq a_i \\leq 10^6$\n 题解 首先定义一个前缀 $\\text{ xor }$ 数组满足 $s_i = a_1 \\text{ xor } a_2 \\text{ xor } \u0026hellip; \\text{ xor } a_i$，这样问题转化为：\n每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $s_i \\text{ xor } s_j = k$  注意到，$s_j = s_i \\text{ xor } k$，所以我们可以维护一个 cnt[] 数组，记录一下当前区间每个元素出现了多少次。\n然后，比如在区间扩张的过程中，就检查 cnt[] 中当前元素 cur 出现的次数，给 ans 加上，然后 cnt[cur ^ k]++;\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 1e6+5; int n,m,k; struct query { int l,r,id,be; } q[maxn]; bool cmp(query a, query b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 0, r = -1; int cnt[2*maxm]; int s[maxn]; ll b[maxn]; double start; ll ans = 0; void add(int x) { ans += (ll)cnt[s[x]]; cnt[s[x] ^ k]++; } void del(int x) { cnt[s[x] ^ k]--; ans -= (ll)cnt[s[x]]; } void ask(int L, int R) { while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 1; i \u0026lt;= n; i++) s[i] ^= s[i-1]; int sz = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].l--; q[i].id = i; q[i].be = (q[i].l-1)/sz; } sort(q+1, q+m+1, cmp); for (int i = 1; i \u0026lt;= m; i++) { ask(q[i].l, q[i].r); b[q[i].id] = ans; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   带修莫队 常规的莫队的状态是两个指针 $(l,r)$。带修莫队则增加了一个状态的指针 $t$，代表时间，这样就是 $(l,r,t)$ 作为一个状态了。\n转移的时候则可以往 $6$ 个方向转移，每次转移仍然是 $O(1)$ 的。\n为什么要带时间呢？我们利用时间来记录修改。每有一次修改，我们就记录这个修改的时间为 ++t，查询不计入时间轴内，但查询本身需要记录它对应的时间点。\n然后在回答每一次查询的时候，我们希望把时间轴调整到这个查询所在的时间点，在调整时间的时候就进行/回溯修改。\n• 我们记录两种 struct，一种是查询，一种是修改。\n而每个查询sort的时候也是有讲究的，第一优先级是 $l$ 所在的block（和原先一样），第二优先级是 $r$ 所在的 block（注意和原先不一样！），第三优先级是时间。\n• 块的大小取 $n^{\\frac{2}{3}}$，总时间复杂度为 $O(n^{\\frac{5}{3}})$。\n例1 洛谷P1903 [国家集训队] 数颜色 / 维护队列 题意\n给定 $n$ 个元素，每个元素拥有一个颜色 $c_i$。\n现在有两种询问，询问共 $m$ 个。\n $Q~L~R$：询问 $[L,R]$ 之间有几种颜色。 $R~P~C$：将位置 $P$ 的颜色替换为 $C$。  其中，$n,m \\leq 10^5$。\n 题解 上面都说完了，讲一些需要注意的点。\n 查询和修改分开储存，并且 sort 只考虑查询，时间点的增加只考虑修改。 块的大小取 $n^{\\frac{2}{3}}$。 在移动时间点，进行修改的时候，不用区分是修改还是回溯，只要将当前的颜色与询问里的 swap 就行了。因为修改以后，下一次跑到这个时间点肯定是回溯。直接交换就很方便。 在移动时间点修改时，要讨论一下这次修改是否在当前查询范围内，在的话才修改答案。   代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 133333 + 5; int n, m, a[maxn]; struct Query { int l, r, t, id; } q[maxn]; struct Modify { int p, c, t; // p: pos, c: color, t: time } mo[maxn]; int tim = 0; // time for modify int B, cnt[(int)(1e6+5)]; int ans = 0; void add(int x) { int c = a[x]; cnt[c]++; if (cnt[c] == 1) ans++; } void del(int x) { int c = a[x]; cnt[c]--; if (cnt[c] == 0) ans--; } // 当前的询问 (query) 编号是 i, 要执行的修改是第t个（时间为t） void modify(int i, int t) { auto [p,c,_] = mo[t]; auto [L,R,__,id] = q[i]; if (L \u0026lt;= p \u0026amp;\u0026amp; R \u0026gt;= p) { // 当前的 count 要更改 del(p); // 删掉这个颜色 cnt[c]++; if (cnt[c] == 1) ans++; // 加上新颜色 } swap(a[p], mo[t].c); } int res[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; B = pow(n, 0.6666); int qid = 0; for (int i = 1; i \u0026lt;= m; i++) { char c; cin \u0026gt;\u0026gt; c; if (c == 'Q') { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ++qid; q[qid] = {l, r, tim, qid}; } else { int p,c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; ++tim; mo[tim] = {p, c, tim}; } } sort(q+1, q+qid+1, [](auto a, auto b) { if (a.l / B == b.l / B) { if (a.r / B == b.r / B) return a.t \u0026lt; b.t; return a.r / B \u0026lt; b.r / B; } return a.l / B \u0026lt; b.l / B; }); int l = 1, r = 0, now = 0; for (int i = 1; i \u0026lt;= qid; i++) { auto [L, R, t, id] = q[i]; while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); while (r \u0026gt; R) del(r--); while (r \u0026lt; R) add(++r); while (now \u0026lt; t) modify(i, ++now); while (now \u0026gt; t) modify(i, now--); res[id] = ans; } for (int i = 1; i \u0026lt;= qid; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 CF940F. Machine Learning 题意\n给定一个数组 $a_1, a_2, \u0026hellip;, a_n$ 和 $q$ 个询问，询问有两种：\n第一种询问：每次询问一个区间 $[L,R]$，回答：\n令 $c_i$ 为数字 $i$ 在 $[L,R]$ 内出现的次数，求 $\\text{mex} \\{c_0,c_1,\u0026hellip;,c_{10^9}\\}$。\n第二种询问：给定 $p~x$，将 $a_p$ 改为 $x$。\n其中，$1 \\leq n,q \\leq 10^5, a_i \\in [1,10^9]$。\n 题解 很明显首先离散化元素。\n然后就是一个带修莫队的过程。\n找 mex 参照 上面写的 即可，总复杂度 $O(n^{\\frac{5}{3}})$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+55; const int maxm = 4e4+55; int n, m, a[maxn]; struct Query { int l, r, t, id; } q[maxn]; struct Modify { int p, c, t; // p: pos, c: color, t: time } mo[maxn]; int tim = 0; // time for modify int B; const int M = sqrt(1e5); struct Mex { int cnt[maxn]; // cnt[i]: i 出现的次数 int csum[maxn]; // csum[i]: 第i个block里面的元素数量，第0个block: [0, M-1], 第1个block: [M, 2M-1] ... Mex() { cnt[0] = 1e9; csum[0] = 1; } // 加入一个数字 x, x \u0026lt;= 1e5 void add(int x) { if (x \u0026gt; maxn || x \u0026lt; 0) return; // 可能加入了 cnt[0] = 1e9 cnt[x]++; if (cnt[x] == 1) csum[x / M]++; } void del(int x) { if (x \u0026gt; maxn || x \u0026lt; 0) return; cnt[x]--; if (cnt[x] == 0) csum[x / M]--; } int mex() { for (int i = 0; ; i++) { if (csum[i] != M) { for (int j = i * M; j \u0026lt;= i * M + M - 1; j++) { if (!cnt[j]) return j; } } } return -1; } } mex; int cnt[maxn\u0026lt;\u0026lt;1]; void add(int x) { int c = a[x]; cnt[c]++; mex.del(cnt[c] - 1); mex.add(cnt[c]); } void del(int x) { int c = a[x]; cnt[c]--; mex.del(cnt[c] + 1); mex.add(cnt[c]); } // 当前的询问 (query) 编号是 i, 要执行的修改是第t个（时间为t） void modify(int i, int t) { auto [p,c,_] = mo[t]; auto [L,R,__,id] = q[i]; if (L \u0026lt;= p \u0026amp;\u0026amp; R \u0026gt;= p) { // 当前的 count 要更改 del(p); // 删掉这个颜色 cnt[c]++; mex.del(cnt[c] - 1); mex.add(cnt[c]); } swap(a[p], mo[t].c); } map\u0026lt;int, int\u0026gt; mp; int mid = 0; int res[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (!mp.count(a[i])) mp[a[i]] = ++mid; a[i] = mp[a[i]]; } B = pow(n, 0.6666); int qid = 0; for (int i = 1; i \u0026lt;= m; i++) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; ++qid; q[qid] = {l, r, tim, qid}; } else { int p,c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; if (!mp.count(c)) mp[c] = ++mid; c = mp[c]; ++tim; mo[tim] = {p, c, tim}; } } sort(q+1, q+qid+1, [](auto a, auto b) { if (a.l / B == b.l / B) { if (a.r / B == b.r / B) return a.t \u0026lt; b.t; return a.r / B \u0026lt; b.r / B; } return a.l / B \u0026lt; b.l / B; }); int l = 1, r = 0, now = 0; for (int i = 1; i \u0026lt;= qid; i++) { auto [L, R, t, id] = q[i]; while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); while (r \u0026gt; R) del(r--); while (r \u0026lt; R) add(++r); while (now \u0026lt; t) modify(i, ++now); while (now \u0026gt; t) modify(i, now--); res[id] = mex.mex(); } for (int i = 1; i \u0026lt;= qid; i++) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   参考链接  https://ouuan.github.io/post/%E8%8E%AB%E9%98%9F%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/#%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F https://www.cnblogs.com/WAMonster/p/10118934.html  ","date":"2021-03-07T21:50:41+08:00","permalink":"https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/","tags":["莫队"],"title":"莫队"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc194/tasks/abc194_f\n题意\n给定一个数 $1\\leq N \\leq 16^{2\\times10^5}$，求：\n在 16进制 下，满足以下条件的整数 $x$ 数量：\n 拥有 Exactly $K$ 个不同的digit （例如 $x = 1F21$，就有3个不同的digit） $x \\in [1,N]$   题解 我们使用 dp，为了方便处理 $x \\leq N$ 的问题，我们从最高位（Most significant digit）开始处理。\n我们设 dp[i][j] 为，我们处理到了第 i 位，使用了 j 个不同的digit，且满足以下条件的数字 $x$ 的数量：\n $x$ 严格小于 $N$ 的前 i 位 $x \\neq 0$   注意，$x$ 不一定完全有 i 个digit，但是它至少有一个有效的digit。\n 由上，因为第一个条件，我们无论在这一位选择什么digit，都必然会仍然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第一个转移方程：\nfor (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; }   我们发现，这样只考虑到了前 i-1 位至少有一个有效digit的情况，没有考虑全部为前缀0的情况。\n如果前 i-1 位全是前缀0，那么无论在这一位选择任何数，都必然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第二个转移方程：\ndp[i][1] = (dp[i-1][1] + 15) % mod;   注意到，我们的 dp 数组里，并没有包含 $x$ 的前 i-1 位 完全等同于 $N$ 的前 i-1 位的情况。我们需要单独处理它！\n我们在当前这一位（第i位），能够计入 dp 数组的只有 第 i 位小于 $N$ 的第 i 位的情况。\n并且，我们可以很容易得到 $N$ 的前 i-1 位有多少个不同的digit（这样就得到了 dp 数组里的 j）。\n所以，我们只要枚举一下，第 i 位可以选择的所有digit，计算一下不同的digit数量，然后计入 dp 数组即可。\n所以我们得到了第三个转移方程：\nmap\u0026lt;char, int\u0026gt; dict; // 用于将 0123456789ABCDEF map到对应的int set\u0026lt;int\u0026gt; used; // 记录N的前i-1位用了哪些数字 char c = s[i-1]; // N的第i位数字 int cur = dict[c]; int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { //枚举所有可以选择的digit if (!used.count(j)) { // 计算不同digit的数量 dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur);   最后别忘记，看一下 $N$ 自己是否也满足条件（拥有Exactly $K$ 个不同的digit）。\n 小结：\n本题是一个非常不错的dp，主要用了以下几个关键的trick：\n 对于 Exactly $K$ 不同的digit，我们不关心具体是哪几个digit，只需知道不同的digit数量就可以计数了。 通过限制 dp 数组的定义，让 dp 数组仅记录 严格小于 $N$ 的数字，方便计数。 单独处理 $x$ 与 $N$ 的前 i 位相同的情况，并且将符合条件的计数加到 dp 数组当中去。  需要重点关注的是这个 DP并不记录最终答案，而是记录 满足某种条件的部分答案，其余特殊情况单独处理的思想。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll dp[maxn][18]; string s; int k; map\u0026lt;char, int\u0026gt; dict; set\u0026lt;int\u0026gt; used; int main() { fastio; for (int i = 0; i \u0026lt;= 9; i++) dict[(char)(i+'0')] = i; int o = 10; for (char c = 'A'; c \u0026lt;= 'F'; c++) dict[c] = o++; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int n = s.size(); dp[1][1] = dict[s[0]] - 1; used.insert(dict[s[0]]); for (ll i = 2; i \u0026lt;= n; i++) { char c = s[i-1]; dp[i][1] = (dp[i-1][1] + 15) % mod; int cur = dict[c]; for (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; } int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { if (!used.count(j)) { dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur); } if (used.size() == k) dp[n][k]++; ll ans = dp[n][k] % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-03-06T22:16:46+08:00","permalink":"https://tom0727.github.io/post/023-at-abc194f/","tags":["数位dp","进制"],"title":"Atcoder ABC 194F（数位DP，进制处理）"},{"categories":["算法"],"contents":"介绍 树链剖分主要用于将 树上修改/查询 通过 DFS序 变成 区间修改/查询，然后利用 线段树 进行修改/查询。\n我们可以用模版来举个例子：\n题意\n已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n$1\\ x\\ y\\ z$ ：将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n$2\\ x\\ y$ ：求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n$3\\ x\\ z$ ：将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n$4\\ x$ ：求以 $x$ 为根节点的子树内所有节点值之和。\n 主要知识点有三个：DFS序，LCA，线段树\n前置知识回顾 DFS序 DFS序的作用是，根据DFS的顺序将节点编号，就可以得到以下性质：\n 同一个subtree内的编号是连续的，且parent的编号最小。 在从上到下的DFS过程中，一条链上的编号也是连续的，且越靠上，编号越小。   注：记得将原array中的节点权值（或者其他信息） map 到dfs序上的新节点。\n  LCA（最近公共祖先） 在 LCA 中，寻找共同祖先的过程中，要注意不能往上跳过头了，在树链剖分中也一样，只不过没有采用倍增思想。\n 线段树 在树链剖分中，线段树的应用并没有什么变化。\n 概念定义   重儿子：每一个节点的child中，所在subtree（包括它自己）节点数最多的child 叫做该节点的重儿子（每个节点有且仅有一个重儿子）。\n  轻儿子：除了重儿子的所有节点，都是轻儿子。（我们可以把 root 看作一个轻儿子）\n  重边：一个节点连接它的重儿子的edge就是重边。\n  重链：以轻儿子作为起点，向下延伸，连接子树内的所有重儿子，形成的链叫做重链。\n（对于一个leaf，如果它是一个轻儿子，那么它自己形成一条重链）\n  算法 算法步骤如下：\n 进行第一次DFS dfs1() 进行第二次DFS dfs2() 建线段树 将树上操作 对应到 区间上，然后用线段树解决  第一次DFS 第一次DFS，我们需要维护的信息有：\n 记录每个点的 深度： dep[] 记录每个点的 parent： par[] 记录每个点的 subtree大小（包括它自己）：sz[] 记录每个点的 重儿子：son[]  int dep[maxn], par[maxn], sz[maxn], son[maxn]; void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // subtree包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 判断重儿子 maxsz = sz[to]; son[cur] = to; } } }  第二次DFS 第二次DFS，我们需要维护的信息有：\n 记录每个点的 DFS序编号：id[] 记录每个点 所在重链的最顶端：top[] （如果有），将树上的信息通过DFS序编号 转移到 区间上   注意：dfs2() 过程中，我们需要 优先处理重儿子，这是为了保证 同一条重链 对应的必然是 一段连续的区间。\n 这样处理以后，我们能得到如下的DFS序编号：\nint w[maxn]; //weight int arr[maxn]; // array for segment tree to use int top[maxn], id[maxn]; int cnt = 1; //current id void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // 这个节点是leaf dfs2(son[cur], t); // 优先处理重儿子 for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; //重儿子处理过了 dfs2(to, to); // 轻儿子是重链的开始 } }  建线段树 常规操作，并没有什么不同。\n将树上操作对应到区间上 操作 $3,4$ （更新/查询一个子树内的值）：\n在DFS序中，同一个子树内的DFS序编号是连续的，我们有了 parent 对应的编号，就有了区间上的左端点，利用 sz[] 来找到 右端点，左右端点都有了，就用线段树处理即可。\nvoid update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); }   操作 $1,2$ （更新/查询两个点之间最短路径的值）：\n给定两个点 u,v：\n  如果 u,v 在同一条重链上，那么对应的是区间上的一段连续区间（dep 较小的那个对应左端点，dep较深的那个对应右端点），直接用线段树即可。\n  否则，比较 top[u] 和 top[v]，如果 dep[top[u]] \u0026gt; dep[top[v]] （top[u] 比 top[v] 更深），就将 u 往上跳，在线段树上操作 u 到 top[u] 的这一段操作，然后跳到 par[top[u]] 上（即，重链顶端再往上一格），然后重新执行上述判断。\n   为什么要让 top 更深的来跳？为了保证不会跳过头！\n 证明：无论怎么跳，我们都不能超过 u,v 的LCA。设 LCA(u,v) = x，因为它们不在同一条链上，那么 u,v 必然在 x 的两边（或者，其中之一刚好等于 x，另外一个被一个轻儿子挡住了）。无论是哪种情况，因为重链有可能直接从 root 一直延伸下来，所以肯定不能选 top 更靠上层的那个。\n而选择 top 更深的那个，能够保证我们 最远只能刚好跳到x处（因为 x 有且仅有一个重儿子，如果不跳这个重儿子，必然不会跳出 x 的范围）。\n• 由上分析，我们还能发现：在往上跳的过程中，如果发现 u,v 在同一条重链上，那么 dep 较小的那个节点，就是 u,v 的LCA！\nvoid update_path(int u, int v, ll x) { while (top[u] != top[v]) { // u,v 还不是同一个重链上 if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; // 往上跳 } if (dep[u] \u0026gt; dep[v]) swap(u,v); // dep较小的是左端点 update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; }  树链剖分变种（询问边） 如果我们把问题稍微改一下：\n假如现在不再是点上有权值，而是 边上有权值，修改/询问 $(u,v)$ 之间路径上所有边的权值，怎么处理？\n注意到树有一个特别的性质：\n每个节点只有 $1$ 个parent。\n所以我们可以将 边 转化为 点。\n对于一个节点 $u$，如果它有一个parent $p$，那么我们就可以将 $(u,p)$ 这条边，转化为 $u$ 这个点。\n对于每次修改/询问 $(u,v)$，先找到 $LCA(u,v) = x$，然后正常更新，最后将 $x$ 的修改/询问全部撤销掉即可。\n• 或者，注意到在树链剖分每次 query(u,v) 的最后一个阶段，$u,v$ 中深度较浅的那个是 $LCA(u,v)=x$，所以如果要忽略 $x$ 的影响，我们最后一次 query 的时候可以把线段树上的 index + 1 即可。\n例如这样：\nvoid update_path(int u, int v, int x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, 1, n, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); if (id[u] + 1 \u0026lt;= id[v]) update(1, 1, n, id[u]+1, id[v], x); // 给它 + 1 }   如上图，$(6,2)$ 这个边，就可以用 $6$ 这个点来表示。\n修改 $6,5$ 之间的路径，就相当于修改 $[6,2]$ 和 修改 $[5,3]$。\n时间复杂度 性质1 如果 $v$ 是 $u$ 的轻儿子，那么 $size(v) \\leq \\frac{size(u)}{2}$\n证明：根据定义即可。\n 性质2 树中任意两条节点之间，重链的数量 $\\leq \\log_2(n)$\n证明：因为每出现一个重链，意味着出现了一个轻儿子，根据性质1，size减少一半，所以\n#重链 $=$ #轻儿子 $= log_2(n)$\n 由性质1，2，我们可知：\n  路径修改/查询：每个重链进行一次线段树操作，有 $log_2(n)$ 个重链，每次线段树操作复杂度为 $log_2(n)$，所以每次路径操作的总复杂度为 $(log_2(n))^2$\n  子树修改/查询：只有一次线段树操作，所以复杂度为 $log_2(n)$\n  代码 #define ll long long const int maxn = 1e5+5; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int n,m,root; int w[maxn]; //weight int dep[maxn], par[maxn], sz[maxn], son[maxn]; int top[maxn], id[maxn]; int arr[maxn]; // array for segment tree to use int cnt = 1; //current id void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // 包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 更新重儿子 maxsz = sz[to]; son[cur] = to; } } } void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // leaf dfs2(son[cur], t); for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; dfs2(to, to); // 轻儿子是重链的开始 } } struct node { ll sum = 0; ll lazy = 0; } tr[4*maxn]; inline ll len(int cur, int l, int r) { return r - l + 1; } void push_up(int cur) { tr[cur].sum = tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum; } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc|1; tr[lc].lazy = tr[lc].lazy + tr[cur].lazy; tr[rc].lazy = tr[rc].lazy + tr[cur].lazy); tr[lc].sum = tr[lc].sum + len(lc) * tr[cur].lazy; tr[rc].sum = tr[rc].sum + len(rc) * tr[cur].lazy; tr[cur].lazy = 0; } void build(int cur, int l, int r) { if (l == r) { tr[cur].sum = arr[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, ll x) { if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = tr[cur].lazy + x; tr[cur].sum = tr[cur].sum + x * len(cur); return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, x); push_up(cur); } ll query(int cur, int l, int r, int L, int R) { ll res = 0; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].sum; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); push_up(cur); return res; } void update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); } void update_path(int u, int v, ll x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, 1, n, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = res + query(1, 1, n, id[u], id[v]); return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int u,v,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; x; update_path(u,v,x); } else if (op == 2) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; ll res = query_path(u,v); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 3) { int u,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; x; update_tree(u, x); } else { int u; cin \u0026gt;\u0026gt; u; ll res = query_tree(u); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }  例题 例1 洛谷P2486 [SDOI2011]染色 题意\n给定 $n$ 个节点的树，每个节点都有一个初始的颜色 $c_i$。\n有 $m$ 个操作，操作共两种：\n$C ~ a ~ b ~ c$：将 $a$ 到 $b$ 的路径上的所有节点染色为 $c$。\n$Q ~ a ~ b$：输出 $a$ 到 $b$ 的路径上的颜色段数量。\n• 颜色段的定义：每个最长的同颜色的连续子序列，叫做一个颜色段。例如 $[2,1,1,2,2,1]$ 具有 $4$ 个颜色段。\n 题解 比较明显的树剖思路。问题在于如何维护颜色段的数量？\n先思考一下在一个 数组 上，如何维护？\n 如果两个相邻的区间，相邻的部分的颜色相同，那么它们将合并为一个颜色段。\n 所以，对于每一个区间，我们维护它 左端点的颜色 和 右端点的颜色，并且维护 区间内颜色段的数量。\n在 push_up() 的时候，记得检查一下左区间的右端点 和 右区间的左端点颜色是否相同即可。\n 那么如何在树上进行查询？\n需要注意的是 在树剖中，查询的不一定是数组上的连续区间，但是在树上是连续的。\n所以每次查询完一段区间 $[top[u], u]$，要记录这段区间的左端点 $top[u]$ 的颜色。\n继续往上跳的时候，下一段区间的右端点是 $par[top[u]]$。\n所以要比较一下 $top[u]$ 和 $par[top[u]]$ 的颜色是否相同。相同的话，把答案减 $1$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; struct node { int l,r; int lc, rc, cnt; //left color, right color bool lazy = 0; } tr[maxn\u0026lt;\u0026lt;2]; int color[maxn], last, ori[maxn], par[maxn]; // ori[u] 代表u的颜色 int n,m; void push_up(int cur) { int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[cur].cnt = tr[l].cnt + tr[r].cnt; tr[cur].lc = tr[l].lc, tr[cur].rc = tr[r].rc; if (tr[l].rc == tr[r].lc) tr[cur].cnt--; // 合并颜色段 } void push_down(int cur) { if (!tr[cur].lazy) return; int l = cur\u0026lt;\u0026lt;1, r = cur\u0026lt;\u0026lt;1|1; tr[cur].lazy = 0; tr[l].cnt = tr[r].cnt = 1; tr[l].lazy = tr[r].lazy = 1; int c = tr[cur].lc; tr[l].lc = tr[r].lc = tr[l].rc = tr[r].rc = c; } void build(int cur, int l, int r) { tr[cur].l = l, tr[cur].r = r; if (l == r) { tr[cur].cnt = 1; tr[cur].lc = tr[cur].rc = color[l]; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, l, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, r); push_up(cur); } void update(int cur, int l, int r, int L, int R, int c) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].cnt = 1; tr[cur].lc = tr[cur].rc = c; tr[cur].lazy = 1; return; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, l, mid, L, R, c); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R, c); push_up(cur); } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].cnt; } push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; int res = 0; if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, l, mid, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, mid+1, r, L, R); if (L \u0026lt;= mid \u0026amp;\u0026amp; R \u0026gt; mid \u0026amp;\u0026amp; tr[cur\u0026lt;\u0026lt;1].rc == tr[cur\u0026lt;\u0026lt;1|1].lc) res--; // 合并颜色段 return res; } int head[maxn], ecnt = 1, son[maxn], id[maxn], idcnt = 0, top[maxn], sz[maxn], dep[maxn]; struct Edge { int to,nxt; } edges[maxn\u0026lt;\u0026lt;1]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { sz[u] = 1; par[u] = p; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) son[u] = to, maxsz = sz[to]; } } void dfs2(int u, int p, int topf) { id[u] = ++idcnt; color[idcnt] = ori[u]; top[u] = topf; if (son[u]) dfs2(son[u], u, topf); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, to); } } void update(int u, int v, int c) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); int p = top[u]; int L = id[p], R = id[u]; update(1, 1, n, L, R, c); u = par[p]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, 1, n, id[u], id[v], c); } int query_color(int cur, int l, int r, int p) { if (l == r) return tr[cur].lc; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= mid) return query_color(cur\u0026lt;\u0026lt;1, l, mid, p); else return query_color(cur\u0026lt;\u0026lt;1|1, mid+1, r, p); } void query(int u, int v) { int ans = 0; int lastu = -1, lastv = -1; // u和v 的上一次查询的左端点 while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v), swap(lastu, lastv); int p = top[u]; int L = id[p], R = id[u]; ans += query(1, 1, n, L, R); if (lastu == query_color(1, 1, n, R)) { // 如果上一次查询的左端点，等于这次查询的右端点 ans--; } lastu = query_color(1, 1, n, L); // u和v 的上一次查询的左端点 u = par[p]; } if (dep[u] \u0026gt; dep[v]) swap(u,v), swap(lastu, lastv); ans += query(1, 1, n, id[u], id[v]); if (lastv == query_color(1, 1, n, id[v])) ans--; if (lastu == query_color(1, 1, n, id[u])) ans--; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; ori[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); dfs2(1, 0, 1); build(1, 1, n); while (m--) { char op; int u,v; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (op == 'Q') { query(u,v); } else { int c; cin \u0026gt;\u0026gt; c; update(u,v,c); } } }   其他例题  https://codeforces.com/problemset/problem/343/D  参考链接  https://www.luogu.com.cn/problem/P3384 （模版题，上面的AC代码） https://www.cnblogs.com/chinhhh/p/7965433.html （强烈推荐） https://www.cnblogs.com/zwfymqz/p/8094500.html  ","date":"2021-03-06T15:58:27+08:00","permalink":"https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","tags":["树链剖分"],"title":"树链剖分"},{"categories":["算法"],"contents":"介绍 给定一棵有根树（不一定为binary tree），求两个节点的最近公共祖先？\n算法 LCA的思路和ST表比较相似，都是利用了倍增思想，大概流程如下：\n预处理：   用dfs预处理出每一个节点 $u$ 的第$1,2,4,8,\u0026hellip;,$ 个parent（即，如果从$u$ 开始，往上跳 $1,2,4,8,\u0026hellip;,$ 格，是哪个节点）\n  记录每一个节点的深度(depth)\n  预处理parent的时候，利用了倍增的思想：\nfor (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1];   询问 $u,v$ 的LCA：   先比较 $u,v$ 的深度，将深的那个往上跳（使用倍增来跳），跳到同一深度。\n  比较一下当前 $u,v$ 是否相等，如果已经相等了就直接返回 $u$。\n  否则，尝试同时将 $u,v$ 往上跳，从 步幅最大 的开始尝试，如果发现 步幅过大（即 $u,v$ 的第 $j$ 个parent相同），就不跳（防止跳过头了），否则就两者同时往上跳。\n  最后，$u,v$ 必然不相同，此时再让它们同时往上跳 $1$ 格就是LCA了。\n  代码 Luogu-P3379-代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 5e5+5; const int maxm = 1e6+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][33]; //记录parent int d[maxn]; //深度 int n,m,s; int lg[maxn]; //log2预处理 void dfs(int cur, int p) { par[cur][0] = p; d[cur] = d[p] + 1; for (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1]; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, cur); } } int query(int u, int v) { if (d[u] \u0026lt; d[v]) swap(u,v); int diff = d[u] - d[v]; for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= diff; j++) { if (diff \u0026amp; (1\u0026lt;\u0026lt;j)) { u = par[u][j]; } } if (u == v) return u; for (int j = lg[d[u]]; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { // 不相同就往上跳 u = par[u][j], v = par[v][j]; } } return par[u][0]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // s是树的root for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } lg[1] = 0, lg[2] = 1; for (int i = 3; i \u0026lt;= 5e5; i++) lg[i] = lg[i\u0026gt;\u0026gt;1] + 1; } int main() { init(); dfs(s, 0); while (m--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int a = query(u,v); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","date":"2021-03-06T11:57:25+08:00","permalink":"https://tom0727.github.io/post/021-lca/","tags":["LCA","最近公共祖先"],"title":"最近公共祖先 LCA"},{"categories":["算法"],"contents":"介绍 三分法 (tenary search) 和 二分法(binary search) 类似，只不过三分法可以用于搜索一个 二次函数 的最值。\n以搜索二次函数最值为例，假如有一个二次函数存在最大值。\n要搜索这个最大值，可以令 $mid = \\frac{l+r}{2}$，然后令 $lmid = mid - eps$，$rmid = mid + eps$，然后比较一下 $f(lmid)$ 和 $f(rmid)$ 的大小。\n $f(lmid) \u0026lt; f(rmid)$：最大值一定在 $[lmid, r]$ 之间。 $f(lmid) \u0026gt; f(rmid)$：最大值一定在 $[l, rmid]$ 之间。   证明：假如 $f(lmid) \u0026lt; f(rmid)$，那么如果最大值在 $lmid$ 的左边则必然不可能，因为 $rmid$ 离最大值比 $lmid$ 更远。另外一种情况亦然。\n 例题 例1 洛谷P3382 题意\n给定一个 $N$ 次函数，保证 $[l,r]$ 内存在一个点 $x$，使得 $[l,x]$ 单调增，$[x,r]$ 单调减，求 $x$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-7; int n; double l,r; double arr[16]; double get(double x) { double res = 0; double cur = 1.0; for (int i = 1; i \u0026lt;= n+1; i++) { res += cur * arr[i]; cur *= x; } return res; } int main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = n+1; i \u0026gt;= 1; i--) cin \u0026gt;\u0026gt; arr[i]; double low = l, high = r; while (high - low \u0026gt; 5e-7) { double mid = (low + high) * 0.5; double lmid = mid - eps, rmid = mid + eps; if (get(lmid) \u0026lt; get(rmid)) low = lmid; else high = rmid; } printf(\u0026quot;%.7f\\n\u0026quot;, low); }   例2 CF1355E 题意\n有 $N$ 个柱子，高度分别为 $h_1, h_2, \u0026hellip; h_N$。现在有3种操作：\n 令一个柱子的高度+1，cost为 $A$ 令一个柱子的高度-1，cost为 $R$ 令一个柱子的高度+1，且令另外一个柱子的高度-1，cost为 $M$  求最小的cost使得所有柱子高度相等？\n其中 $1 \\leq N \\leq 10^5, 0 \\leq h_i \\leq 10^9$\n 题解 如果我们枚举最终的高度 $h$，对于每一个 $h$ 都可以在 $\\log(N)$ 的时间内计算出来对应的 $cost$。\n然后我们会发现，随着 $h$ 的增加，$cost$ 是一个二次函数，具有一个最小值。（证明略）\n所以就可以使用三分搜索了！\n 因为三分搜索的边界不太好处理，所以可以限定一个范围，在范围之内就停止搜索开始暴力枚举。\n 搜索的部分代码：\nll low = 1, high = 1e9; while (high - low \u0026gt;= 10) { ll mid = (low + high) \u0026gt;\u0026gt; 1; ll lmid = mid-1, rmid = mid+1; ll lv = solve(lmid), rv = solve(rmid); if (lv \u0026gt; rv) low = lmid; else high = rmid; } for (ll p = low; p \u0026lt;= high; p++) { ll r = solve(p); ans = min(ans, r); }  ","date":"2021-03-05T22:20:54+08:00","permalink":"https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/","tags":["三分搜索"],"title":"三分法"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P5664\n题意\n有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的菜。所以总共有 $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m a_{ij}$ 道不同的菜。\n现在需要求做菜方案 （设总共有 $k$ 道菜，$k$ 可以取任何数），满足：\n $k \\geq 1$ 每道菜的烹饪方法 $i$ 各不相同 每种主要食材 $j$ 最多在一半（$\\lfloor \\frac{k}{2} \\rfloor$）的菜中出现  求满足上述条件的做菜方案个数？\n$1 \\leq n \\leq 100, 1 \\leq m \\leq 2000, 0 \\leq a_{ij} \u0026lt; 998244353$\n 题解 首先考虑条件1和2，满足这些条件的总方案数有 $((s_1+1) * (s_2+1) * (s_3+1) * \u0026hellip; * (s_n+1) - 1)$ 种，其中 $s_i = \\sum\\limits_{j=1}^m a_{ij}$\n（因为对于每种烹饪方法 $i$，还可以 不选，所以是 $(s_i+1)$，最后减去 全部不选 的情况）\n这样，我们减去 不满足条件3 的方案数即可！\n我们枚举超过限制的主要食材 $j$，然后设 $dp[i][k]$ 为：当前到了第 $i$ 种烹饪方法，使用了 $k$ 种主要食材 $j$ 的方案数。\n那么问题关键在于，对于某一种烹饪方法 $i$，我们可以不选任何菜，这怎么办？\n我们假设有 $t$ 个不选的，那么总共就选了 $n-t$ 个菜，要保证 $k \u0026gt; \\lfloor \\frac{n-t}{2} \\rfloor$，即 $2k + t \u0026gt; n$。\n所以，我们可以改变一下状态的定义，我们可以将 不选 变成 选了一种主要食材 $j$，而 选择主要食材 $j$ 就变成 选择了两个主要食材 $j$。这样，只要满足 2 * 选择主要食材 + 不选的数量 = 2k + t \u0026gt; n，就不满足条件3了！\n转移方程就很好写了，对于每一种烹饪方法 $i$，有 $3$ 种决策方案：\n 选择主要食材 $j$：dp[i][k] += dp[i-1][k-2] * a[i][j]; 不选任何菜： dp[i][k] += dp[i-1][k-1]; 选择非主要食材：dp[i][k] += (dp[i-1][k] * (sum[i] - a[i][j]));   注意，不能将 dp 数组变成一维然后倒序转移！\n比如，在第三种转移时，(sum[i] - a[i][j]) == 0，那么如果是二维的，此时 dp[i][k] = 0，而如果是一维的，就会变成 dp[i][k] = dp[i-1][k]。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 998244353; const int maxn = 1e5+5; ll dp[103][205]; ll sum[105]; ll a[103][2003]; int n,m; int main() { fastio; ll ans = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; sum[i] = (sum[i] + a[i][j]) % mod; } ans = (ans * (sum[i]+1LL)) % mod; } ll delta = 1LL; for (int j = 1; j \u0026lt;= m; j++) { memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 2*n; k++) { dp[i][k] = (dp[i][k] + dp[i-1][k] * (sum[i] - a[i][j]) % mod) % mod; if (k \u0026gt;= 1) { (dp[i][k] += dp[i-1][k-1]) %= mod; } if (k \u0026gt;= 2) { dp[i][k] = (dp[i][k] + dp[i-1][k-2] * a[i][j] % mod) % mod; } } } for (int k = n+1; k \u0026lt;= 2*n; k++) (delta += dp[n][k]) %= mod; } ans -= delta; (ans %= mod) += mod; ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-05T14:58:19+08:00","permalink":"https://tom0727.github.io/post/019-luogu-p5664/","tags":["数学","计数","dp"],"title":"Luogu P5664 Emiya家今天的饭（计数，dp）"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$\n某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请问每次有多少种付款方法。\n其中，$1 \\leq c_i,d_i,s \\leq 10^5, 1 \\leq n \\leq 1000$\n 题解 先考虑每个硬币有 无限 个的情况。\n设 $dp[i][j]$ 为：使用 前 $i$ 种硬币，购买 价值为 $j$ 的物品的方案数，那么有：\n$dp[i][j] = \\sum\\limits_{k=1}dp[i-1][j-c_i*k]$。\n很明显，这是一个 无穷背包，所以可以直接优化为：\ndp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - c[i] \u0026gt;= 0) dp[j] += dp[j-c[i]]; } }  那么，现在考虑 只有一种硬币有限制 的情况：\n由于 $dp[j]$ 都是从 $dp[j-c_i]$ （实际上就是从 $dp[j-k*c_i]$）转移过来的，那么我们只要把 硬币超出限制的转移情况 删掉即可！\n所以，$dp[j] - dp[(d_i+1) * c_i]$ 就是答案了！\n那么如果 多个硬币有限制 呢？考虑 容斥 ！\n假设有 $3$ 种硬币，那我们就 减去 $1$ 种硬币超限的情况，加上 $2$ 种硬币超限的情况，减去 $3$ 种硬币超限的情况。\n枚举这些情况，使用 bitmask 即可！(具体的见代码)\n 容斥中，每一项的符号根据 bitmask 中 bit 的个数来决定！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; ll dp[maxn]; int arr[5]; int d[5]; int q,s; int main() { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; q; dp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - arr[i] \u0026gt;= 0) dp[j] += dp[j-arr[i]]; } } while (q--) { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; d[i]; cin \u0026gt;\u0026gt; s; ll ans = dp[s]; for (int mask = 1; mask \u0026lt;= (1\u0026lt;\u0026lt;4)-1; mask++) { // 枚举容斥 int cnt = 0; int cur = 0; for (int j = 1; j \u0026lt;= 4; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;(j-1))) { cur += ((d[j]+1) * arr[j]); cnt++; // 判断加号还是减号 } } if (s \u0026gt;= cur) { if (cnt \u0026amp; 1) ans -= dp[s - cur]; else ans += dp[s - cur]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   其他例题(TODO) ","date":"2021-03-04T23:29:54+08:00","permalink":"https://tom0727.github.io/post/018-luogu-p1450/","tags":["数学","计数","容斥"],"title":"Luogu P1450 硬币购物（计数，容斥）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f\n题意\n初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种：\n1 a b：令 $f(x) = f(x) + |x-a| + b$\n2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值\n 题解 $f(x)$ 必然长这样：$f(x) = |x-a_1| + |x-a_2| + \u0026hellip; + |x-a_n| + \\sum\\limits_{i=1}^{n}b_i$\n要让 $f(x)$ 最小，就令 $x$ 等于 $a_1,a_2,\u0026hellip;,a_n$ 的中位数。\n那么已知中位数 $a_k$ 的话，如何找到 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ ？\n假设 $n$ 为奇数，那如果我们将 $a_i$ sort 一下，有：\n$\\sum\\limits_{i=1}^{n} |a_{\\frac{n+1}{2}} - a_i| = \\sum\\limits_{i=1}^{\\frac{n}{2}}(a_{\\frac{n+1}{2}+i} - a_{\\frac{n+1}{2}-i})$\n如果我们分开维护中位数 $a_{\\frac{n+1}{2}}$ 左右两边的 sum 就可以 $O(1)$ 求和了！\n 用对顶堆！\n我们维护两个 multiset\u0026lt;ll\u0026gt;，一个是大顶堆（叫做small），维护小于等于中位数的部分。一个是小顶堆（叫做big），小顶堆维护大于等于中位数的部分，并且保证两者的 size 之差 $\\leq 1$。\n 插入新值的时候，就和当前中位数比较一下，如果小于等于中位数就插入small，否则插入big，然后看一下size之差，如果 size之差 $\u0026gt; 1$ 就从多的那个堆取出来，插入另外一个堆，这样就动态调整了中位数。\n 这样我们可以 $O(1)$ 求出中位数，并且 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ 也可以 $O(1)$ 得出，用big的$sum$ 减去 small的 $sum$ 即可。（写的时候需要讨论一下 size 之差为 1,0,-1 的三种情况）。\n细节部分直接看代码吧。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e5+10; ll c = 0, ssum = 0, bsum = 0; multiset\u0026lt;ll\u0026gt; big; multiset\u0026lt;ll, greater\u0026lt;ll\u0026gt; \u0026gt; small; void ins(ll a, ll b) { c += b; if (!small.size()) { ssum += a; small.insert(a); return; } if (a \u0026lt;= *small.begin()) { small.insert(a); ssum += a; } else { big.insert(a); bsum += a; } if (small.size() \u0026gt; big.size() + 1) { auto p = small.begin(); bsum += *p, ssum -= *p; big.insert(*p); small.erase(p); } if (big.size() \u0026gt; small.size() + 1) { auto p = big.begin(); bsumssum += *p; small.insert(*p); big.erase(p); } } void query() { ll ans = bsum if (small.size() == big.size()) { cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (small.size() == big.size() + 1) { ans += *small.begin(); cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (big.size() == small.size() + 1) { ans -= *big.begin(); cout \u0026lt;\u0026lt; *big.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { fastio; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ins(a,b); } else { query(); } } }   其他例题(TODO)  https://www.luogu.com.cn/problem/P3644  ","date":"2021-03-01T21:35:11+08:00","permalink":"https://tom0727.github.io/post/016-at-abc127f/","tags":["数据结构","堆"],"title":"Atcoder ABC 127F（对顶堆动态维护中位数）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e\n题意\n给定一个矩阵，包含 $N \\times M$ 个格子，现在从中选出 $K \\leq N \\times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), \u0026hellip; , (x_K, y_K)$ ，记\n$cost = \\sum\\limits_{i=1}^{K-1}\\sum\\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$\n求：对于所有不同的 $K$ 个格子的选法，$cost$ 的sum为多少？\n 法一概率 选 $k$ 个格子的方案数为 $C(n+m, k)$，在 $k$ 个格子中，任选 $2$ 个出来，有 $C(k,2)$ 种，考虑它们的贡献：\n因为是全部方案，所以可以考虑用 期望值 来做！\n问题转化为，从 $N \\times M$ 的矩阵中，选择 $2$ 个不同的点 $(x_i, y_i), (x_j,y_j)$ ，求 $|x_i - x_j| + |y_i-y_j|$ 的期望？\n期望为： $\\frac{n+m}{3}$\n 如果推式子很难，这里是一些小技巧（仅用于 分母中无 $n,m$ ，并且分子中不存在 $nm$ 之类的项）：\n 打表找规律：假设期望值 $E(n,m)$ 是一个关于 $n,m$ 的多项式，那么固定一下 $n$ 的值，然后让 $m = 1,2,3\u0026hellip;$ 来打表找出 $E(n,m)$ 和 $m$ 的关系。同理可以找出 $E(n,m)$ 和 $n$ 的关系，相加一下就可以了。\n  拉格朗日插值法：设 $ans = F(n,m) = E(n,m) * C(nm, 2)$，我们可以固定 $n$，然后用插值法找出 $F(n,m)$ 和 $m$ 的关系。（这个函数有两个变量，按理说应该是固定每一个 $n$ 然后对每一个 $n$ 都进行一次插值法的，以后遇到了可以尝试一下。）\n  严谨证明：\n考虑一个点 $(x,y)$，那么\n纵向贡献 为： $v_{x,y} = [(1+2+\u0026hellip;+x-1) + (1+2+\u0026hellip;+n-x)] * m$\n横向贡献 为： $h_{x,y} = [(1+2+\u0026hellip;y-1) + (1+2+\u0026hellip;+m-y)] * n$\n期望就是 $E(n,m) = \\frac{\\sum\\limits_{x=1}^n \\sum\\limits_{y=1}^m (v_{x,y} + h_{x,y})}{C(nm,2)} = \\frac{n+m}{3}$\n 以上，最终的答案就是\n$ans = C(nm,k) * C(k,2) * \\frac{n+m}{3}$\n 法二计数 我们选择 $2$ 个格子，有 $C(nm-2, k-2)$ 种。\n对于横坐标的差值为 $d_x$ 的情况，有 $(n-d_x) m^2$ 种。贡献就是 $(n-d_x)m^2*d_x$\n对于纵坐标的差值为 $d_y$ 的情况，有 $(m-d_y) n^2$ 种。贡献就是 $(m-d_y) n^2*d_y$\n所以答案就是\n$ans = C(nm-2, k-2) (\\sum\\limits_{d_x=1}^{n-1} (n-d_x)m^2d_x + \\sum\\limits_{d_y=1}^{m-1} (m-d_y)n^2d_y)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll n,m,k; ll fac[maxn]; void init() { fac[0] = 1; fac[1] = 1; for (int i = 2; i \u0026lt;= n*m; i++) { fac[i] = (fac[i-1] * (ll)(i)) % mod; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; init(); ll nu = fac[n*m] * k % mod * (k-1) % mod * (n+m) % mod; ll de = inv(fac[k]) * inv(fac[n*m-k]) % mod * inv(6) % mod; cout \u0026lt;\u0026lt; (nu * de) % mod \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/weixin_30323631/article/details/96351727 https://blog.csdn.net/qq_40655981/article/details/90642350  一些数学知识 Q1. 如果不限定坐标为整数，长度为 $n$ 的线段上任取两个点，距离期望值是？\nA1. 答案为 $\\frac{n}{3}$，有两种方法。\n第一种：先假设坐标只能为 $1,2,\u0026hellip;,n$ 的整数，那么求出的期望是 $E_n = 2\\times \\frac{\\sum\\limits_{i=1}^{n}i(n-i)}{n^2} = \\frac{n^2-1}{3n}$，取一个 $n$ 趋向无穷，就有 $E = \\lim_{n \\to \\infty} \\frac{n^2-1}{3n} = \\frac{n}{3}$\n 上述推导需要用到 $1^2 + 2^2 + \u0026hellip; + n^2 = \\frac{1}{6}n(n+1)(2n+1)$\n 第二种：先假设线段长度为 $1$，则有期望为 $\\frac{\\int_{0}^1 \\int_{0}^1 |x-y| ~dydx}{\\int_{0}^1 \\int_{0}^1 1~ dydx} = \\int_{0}^1 \\int_{0}^x (x-y) ~ dydx + \\int_{0}^1 \\int_{x}^1 (y-x) ~dydx = \\frac{1}{3}$，对于线段长度为 $n$，乘上 $n$ 即可。（记得分母要除以样本空间，即 $\\int_{0}^1 \\int_{0}^1 1~ dydx$）\n Q2. 如果不限定坐标为整数，$n \\times n$ 的正方形中任取两个点，距离期望值是？\nA2. 答案约为 $0.521$，具体分析可以见 这里 和 这里\n其他例题(TODO)  https://www.luogu.com.cn/problem/P4781  ","date":"2021-02-28T23:20:51+08:00","permalink":"https://tom0727.github.io/post/015-at-abc127e/","tags":["数学","计数","概率"],"title":"Atcoder ABC 127E（数学，计数，概率）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e\n题意\n给定 $2 \\leq N \\leq 10^5, 2 \\leq K \\leq 10^5$，现有长度为 $N$ 的序列 $\\{ a_1, a_2, \u0026hellip;, a_N \\}$，其中 $1 \\leq a_i \\leq K$\n这样的序列总共有 $K^N$ 个，求所有这些序列的 $\\sum \\gcd(a_1,a_2,\u0026hellip;,a_N)$？\n 题解 发现我们可以根据 $\\gcd$ 的值进行枚举，我们设 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = x$ 的序列数量为 $d_x$，则有：\n$d_1 = K^N - d_2 - d_3 - \u0026hellip; - d_k$\n那么 $d_2$ 呢？我们发现如果 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = 2$，则所有的 $a_i$ 必然为 2的倍数，所以每个位置上有 $\\frac{K}{2}$ 种选法，即：\n$d_2 = (\\frac{K}{2})^N - d_4 - d_6 - \u0026hellip; - d_{\\frac{K}{2} \\times 2}$\n同理有：\n$d_3 = (\\frac{K}{3})^N - d_6 - d_9 - \u0026hellip; - d_{\\frac{K}{3} \\times 3}$\n\u0026hellip;\n$d_K = 1$\n这样，直接用一个 dp[] 记录一下 $d_x$ 的值，然后倒着枚举，暴力计算即可。\n最终的答案为 $\\sum\\limits_{i=1}^K i \\times dp[i]$\n时间复杂度：$T(K) = K + \\frac{K}{2} + \\frac{K}{3} + \u0026hellip; + \\frac{K}{K} = K(1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K})$\n发现这个是 harmonic series 的和，复杂度大概为： $1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K} = O(\\log k)$\n所以最终时间复杂度是 $O(K\\log K)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; int n,k; ll dp[maxn], ans = 0; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = k; i \u0026gt;= 1; i--) { ll d = 0; for (int j = 2; i * j \u0026lt;= k; j++) { d += dp[i*j]; } d %= mod; ll r = qpow(k/i, n); dp[i] = (r-d+(ll)mod) % mod; ans = (ans + (ll)(i) * (ll)(dp[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   一些拓展 在洛谷上看题解的时候，看到了莫比乌斯反演的方法，如果未来学了的话可以重新来做一下，loj上有加强版的题目 ($K \\leq 10^{11}$)\n其他例题(TODO)  https://loj.ac/p/6491 (需要莫比乌斯反演)  ","date":"2021-02-27T14:59:58+08:00","permalink":"https://tom0727.github.io/post/014-at-abc162e/","tags":["数学","计数"],"title":"Atcoder ABC 162E（数学，计数）"},{"categories":["算法"],"contents":"定义 最小环：指图中的一个环，它不包含任何更小的环。\n在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-loop的情况）\n无权无向图求最小环 例题: https://codeforces.com/contest/1364/problem/D\n题意\n给定一个 connected undirected graph:\n$n$个vertex, 和一个int $k$, 其中 $3 \\leq k \\leq n$, 请找出 以下的其中之一:\n  一个独立集(set of vertex， 两两之间没有edge)， 包含 $\\lceil\\frac{k}{2}\\rceil$ 个vertex\n  一个simple cycle (set of vertex, 不包含重复vertex)， 其中 $len \\leq k$\n   题解   如果这是一个tree ($m = n-1$), 则 (1)很容易找, 只要dfs一下，做一个图的染色 (染成 $0,1$)即可, 最后取 全部的 $0$ 或者 全部的 $1$\n  如果不是tree, 必然存在cycle, 那么我们可以找到一个最小环, 最小环必然满足 (1) 或者 (2)！（易证）\n  •怎么找最小环? 用DFS!\n 维护一个环的长度 len 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 pre[] 数组, pre[u] 代表dfs过程中 u的parent 维护一个 int c, 代表找到的cycle的 终点!  然后，\n  从vertex 1开始dfs， dep[to] = dep[cur] + 1 这样来更新 dep[]\n  当我们找到一个backward edge时, 更新最小环长度\nlen = min(len, abs(dep[to] - dep[cur]) + 1))  并且更新c, 使得 c = cur, 然后继续探索！\n  dfs结束后, 直接用\nvector\u0026lt;int\u0026gt; cycle; void findcycle() { while (len--) cycle.push_back(c), c = pre[c]; }  即可找到最小环！\n  时间复杂度：$O(n+m)$\n 无权有向图求最小环 例题：https://atcoder.jp/contests/abc142/tasks/abc142_f\n题意\n给定一个 directed graph，求它的一个 subgraph 满足：\n $V'$ 是 $V$ 的 non-empty subset $E'$ 是 $E$ 中，所有两端均在 $V'$ 内的edges $V'$ 中，所有的 vertex 的 in-degree 和 out-degree 均为1   题解 易知，最小环满足这个条件！\n如何求最小环？可以用 $N$ 次 DFS！\n 维护 ed 代表环的终点，维护最小环长度 final 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 par[] 数组, par[u] 代表dfs过程中 u的parent 维护一个 in[] 数组，代表在dfs过程中，当前的某个vertex是否存在于递归stack中！  dfs过程如下：\nint n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { // 必须得在递归栈内 int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; }   为什么要加 in[] 数组？\n 如下图：\n我们需要保证这个环必然全部同时出现在递归stack内，否则可能会出问题！\n（如上图，如果不考虑 in[] 数组的话，就有可能错误的把 1-\u0026gt;3-\u0026gt;2 当作一个环！\n 为什么要使用 $N$ 次 dfs ？\n 如下图：\n如果我们从 $1$ 开始进行 dfs，那么如果是按照图上的访问顺序，会导致我们找不到最小环！\n但是如果从 $7$ 开始进行 dfs，就可以找到了！\n所以我们需要每一个点都开始一次dfs，总共 $N$ 次 dfs。\n 注：优化：可以在每次dfs中找到的环中找最小环，如果不是环中的节点，就不需要考虑了。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define abs(a) ((a\u0026gt;0)?a:-(a)) const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e3+10; struct Edge { int to,nxt; } edges[maxm]; int head[maxn], ecnt = 1; int n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); } } void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; } void renew() { fill(dep, dep+n+1, 0); fill(par, par+n+1, 0); fill(in, in+n+1, 0); ans = 1e9; } int main() { fastio; init(); for (int i = 1; i \u0026lt;= n; i++) { dfs(i); if (ans \u0026lt; final) { final = ans; cycle.clear(); while (ans--) cycle.push_back(ed), ed = par[ed]; } renew(); } if (final == 1e8) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; final \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int a : cycle) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   有权图求最小环 Floyd $O(n^3)$ 可求！\n无向图/有向图找环 无向图找环 如果有重边的话，dfs记录的应该是parent的边，而不是点！\nvector\u0026lt;int\u0026gt; cycle; void dfs1(int u, int in_edge) { // 这里的参数是 e的编号！ vis[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { if (e == (in_edge ^ 1)) continue; // 特意处理了大小为2的环，注意这里 (in_edge^1) 需要加括号！ int v = edges[e].to; if (vis[v]) { if (!cycle.size()) { // 只跑一个cycle！因为有重边！ int c = u; while (c != v) { cycle.push_back(c); c = pre[c]; } cycle.push_back(c); for (int j : cycle) iscycle[j] = 1; } } else { pre[v] = u; dfs1(v, e); // 注意这里参数是 e } } }  有向图找环 只考虑没有重边的情况，那么就用染色来做。没有访问的染色为 $0$，已经访问了并且在栈里的染色为 $1$，已经访问了，但不在栈里的染色为 $2$。\n然后只用做一次 dfs 就可以了（最小环需要 $n$ 次）。\n","date":"2021-02-25T23:41:02+08:00","permalink":"https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/","tags":["图论","最小环","dfs"],"title":"最小环"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1395/problem/E\n题意\n给定一个 directed and weighted graph，$2 \\leq n \\leq 2\\cdot10^5, 2 \\leq m \\leq \\min(2\\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\\leq k \\leq 9$，每个edge的weight均不相同。\n现在定义一个tuple $(c_1,c_2,\u0026hellip;,c_k)$，其中， $\\forall j \\in [1,k]$，有 $1\\leq c_j \\leq j$。\n且对于所有 out-degree 等于 $j$ 的vertex，只保留它的out-going edges中，weight第 $c_j$ 小的那个edge。\n 例如，对于vertex 5，有 $3$ 条out-going edges (以(u,v,w)的形式)： $(5,2,233), (5,4,25), (5,6,999)$\n如果 $c_3 = 1$，因为 vertex 5 具有 out-degree = $3$，所以 $c_3$ 生效，因为 $c_3 = 1$，所以保留第 $1$ 小的edge，也就是$(5,4,25)$。\n 现在求 $(c_1,c_2,\u0026hellip;,c_k)$ 的数量，使得整个图是强连通的。\n 题解 首先可以发现，因为每个edge的weight都不同，所以对于每一个vertex来说，必然只能保留最多 $1$ 个out-going edge。所以整个图中，只有 $n$ 个edge。\n又因为需要强连通，所以它只有可能是 一个环！所以只要看 每个vertex的 in-degree 是否都等于$1$即可！\n再转化一下，我们只要看在 $(c_1,c_2,\u0026hellip;,c_k)$ 的情况下，所有out-going edge所指向的vertex，并起来，形成的 可重复集合(multiset) 是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n我们可以预处理出 对于每一个 $j$，如果 $c_j = x$，所指向的vertex组成的集合。然后在枚举 $(c_1,c_2,\u0026hellip;,c_k)$ 的时候，判断一下这些集合的并集是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n那么，如何快速的\n 判断集合是否相等 和 求可重复并集 呢？  使用Hashing！\n 我们要定义一种Hash函数，使得上述两个操作的速度为 $O(1)$ 。\n在字符串哈希中，我们用字符的位置来hash，但是因为我们不关心集合中元素的顺序，所以可以用集合中元素的value来hash！\n假设给定一个集合 $\\{a_1,a_2,\u0026hellip;,a_m\\}$，定义哈希值为：$\\sum\\limits_{i=1}^mp^{a_i} = p^{a_1} + p^{a_2} + \u0026hellip; + p^{a_m}$，这样：\n 判断集合是否相等：直接比较两个集合的哈希值 求两个集合的可重复并集：直接将两个集合的哈希值相加   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 2e5+5; const ll p = 31; int n,m,k; vector\u0026lt;pii\u0026gt; adj[maxn]; // {w, to} int out[maxn]; vector\u0026lt;int\u0026gt; deg[10]; // store vertices with deg x ll pow31[maxn]; ll ha[10][10]; //ha[i][j] 代表 c_i=j时，所指向的vertex的并集的哈希值 ll tar = 0; // {1,2,3...,n}对应的哈希值 int ans = 0; void init() { pow31[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) pow31[i] = (pow31[i-1] * p) % mod; for (ll i = 1; i \u0026lt;= n; i++) tar += pow31[i]; tar %= mod; for (int i = 1; i \u0026lt;= k; i++) { // calculate all vertex with deg i for (int j = 1; j \u0026lt;= i; j++) { // if c_i = j for (int a : deg[i]) { int to = adj[a][j-1].second; (ha[i][j] += pow31[to]) %= mod; } } } } void dfs(int dep, ll cur) { //cur: current hash value if (dep == k+1) { if (tar == cur) ans++; return; } for (int j = 1; j \u0026lt;= dep; j++) { dfs(dep+1, (cur + ha[dep][j]) % mod); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({w,v}); out[u]++; } for (int i = 1; i \u0026lt;= n; i++) { sort(adj[i].begin(), adj[i].end()); deg[out[i]].push_back(i); } init(); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题(TODO)  https://www.luogu.com.cn/problem/P6688 https://www.luogu.com.cn/problem/P3792  ","date":"2021-02-25T15:25:22+08:00","permalink":"https://tom0727.github.io/post/012-cf-1395e/","tags":["哈希","图论"],"title":"CF 1395E(集合哈希)"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \\geq 2, m \\geq 1, n \\times m \\leq 250000$\n问是否存在一个array，使得这个array 与 其他每个array的difference（不同元素的个数） $\\leq 2$？\n 题解 暴搜，我们可以先令 $ans$ 等于第一个array，然后看一下其他array中，有没有 $diff \u0026gt; 2$ 的，如果有，尝试更改 $ans$ 中的一个元素，更改后再看一下其他array的difference情况，如果还是不行，就继续尝试更改其他元素。 直到所有array的 $diff \\leq 2$\n注意到，因为$ans$基于第一个array，所以最多只能更改两个元素，我们可以给在搜索的时候设置一个深度 left，代表还可以更改几个元素。一开始就是dfs(2)。\n 注1: 本题时限卡的比较紧，时限为2s，我们可以设定2s内如果搜索不出结果就直接返回\u0026quot;No\u0026quot;。\ndouble start = clock(); double passed = clock() - start; if (passed \u0026gt; 1950.0) { // 1950ms cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; exit(0); }    注2: 暴搜的时候记得回溯！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; arr; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; cnt; double start; inline bool check() { for (int i = 0; i \u0026lt; n; i++) { if (cnt[i] \u0026gt; 2) return 0; } return 1; } void dfs(int left) { if (left \u0026lt; 0) return; if (clock()-start \u0026gt; 1950) { printf(\u0026quot;No\\n\u0026quot;); exit(0); } for (int i = 0; i \u0026lt; n; i++) { cnt[i] = 0; vector\u0026lt;int\u0026gt; pos; for (int j = 0; j \u0026lt; m; j++) { if (ans[j] != arr[i][j]) { cnt[i] += 1; pos.push_back(j); } } if (cnt[i]-left \u0026gt; 2) { return; } if (cnt[i] \u0026gt; 2) { for (int j : pos) { int pre = ans[j]; ans[j] = arr[i][j]; dfs(left-1); ans[j] = pre; //记得回溯 } } } if (check()) { printf(\u0026quot;Yes\\n\u0026quot;); for (int j = 0; j \u0026lt; m; j++) printf(\u0026quot;%d \u0026quot;, ans[j]); printf(\u0026quot;\\n\u0026quot;); exit(0); } } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); start = clock(); arr = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n, vector\u0026lt;int\u0026gt;(m,0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i][j]); } } ans = arr[0]; cnt = vector\u0026lt;int\u0026gt;(n,0); dfs(2); printf(\u0026quot;No\\n\u0026quot;); }  ","date":"2021-02-24T22:27:41+08:00","permalink":"https://tom0727.github.io/post/011-cf-1492e/","tags":["搜索","dfs优化"],"title":"CF 1492E(暴搜)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于HTML,CSS,JS的知识点\nCSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测当前在哪个页面，然后让当前页面对应的link的img更换一个，怎么办？（不使用javascript，仅用CSS）\n方案 可以用CSS中的 Pseudo-classes 中的 target，当网页链接中存在 #some_id 时，所有 id = \u0026quot;some_id\u0026quot; 的tag就会变成 :target 的状态。\n所以可以给每个 a 的 href 加上一个 #some_id，然后给 img 加上 id = some_id，如下：\nHTML代码 \u0026lt;nav\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026quot;index.html#index\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; id=\u0026quot;index\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;aboutus.html#about\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/2.jpg\u0026quot; id=\u0026quot;about\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;staff.html#staff\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/3.jpg\u0026quot; id=\u0026quot;staff\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt;   CSS代码 这里以index为例：\nnav \u0026gt; div \u0026gt; a[href*=\u0026quot;index\u0026quot;] \u0026gt; img:target { content:url(\u0026quot;images/index_selected.jpg\u0026quot;); }   参考链接  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target  HTML/CSS 手机字体大小不一 在手机上发现 font-size 相同的字体大小不一致，怎么办？\n方案   在HTML文件前面加上\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt;    添加上述代码后，网页中可能会出现 horizontal scrollbar。可以在css中添加：\n@media only screen and (max-width: 600px) { html, body { overflow-x: hidden; } body { position: relative; } }  然后在 media query 里面调整一下字体大小，图片大小之类的属性，保证 overflow-x: hidden; 不会隐藏内容。\n  参考链接  https://stackoverflow.com/questions/27074259/html-css-table-font-size-different-in-mobile-device https://stackoverflow.com/questions/4192277/disable-horizontal-scroll-on-mobile-web  Hot Reload 网页 使用 browser-sync 即可：\n npm install -g browser-sync browser-sync start --server --files \u0026quot;.\u0026quot;  • 注意需要把HTML文件改名为 index.html。\n动态网页（带PHP）  cd 进到目标文件夹。 输入 php -S 127.0.0.1:8000。 输入 browser-sync start --proxy 127.0.0.1:8000 --files \u0026quot;./\u0026quot;。 在弹出的窗口中浏览（一般是 127.0.0.1:3000）  JQuery \u0026lt;script src='https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js'\u0026gt;\u0026lt;/script\u0026gt;  ","date":"2021-02-21T23:39:36+08:00","permalink":"https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","tags":["前端","HTML","js","css"],"title":"HTML/CSS/JS笔记"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于vim的知识点\nHTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening tag跳转到closing tag怎么做？\n方案  在vscode下载一个叫 Highlight Matching Tag 的插件 下载叫做 matchit 的vim插件，放在本地的 ~/.vimrc/plugin/ 下（如果没有plugin文件夹，就创建一个），在.vimrc里添加 filetype plugin on runtime macros/matchit.vim  这样就可以用 % 进行跳转了。 vscode上似乎不能装插件，可以把cursor移动到tag上，然后按 esc 进入normal mode，然后 v a t 跳转到matching tag  参考链接  https://stackoverflow.com/questions/7281459/matchit-not-working https://vi.stackexchange.com/questions/780/how-to-jump-between-matching-html-xml-tags  ","date":"2021-02-20T23:15:28+08:00","permalink":"https://tom0727.github.io/post/009-vim/","tags":["vim"],"title":"vim笔记"},{"categories":["算法"],"contents":"介绍 树形dp就是在树上进行dp，常用于 \u0026ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大\u0026rdquo; 的问题。\n一般来说，DP的形式为：\n设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个元素得到的最大值。\n这样，状态转移就有：\n$$dp[u][j] = \\max\\limits_{to} \\{ dp[u][j-k] + dp[to][k]\\}$$\n代码如下：\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  需要注意的点：\n 类似于 $01$ 背包，在枚举 j 的值时，要从大到小，防止一个child被重复选择。 对于依赖关系（例如，child需要依赖parent），可以利用DP过程中，调整状态转移的 上下限 来达到！  时间复杂度：$O(nm^2)$，其中 $n$ 为节点数，$m$ 为第二维的大小。\n优化 子树 size 优化 对于一个子树，可能它第二维的上限并没有这么高，我们需要尽量避免枚举一些无用的范围。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  例题可见 例1\n复杂度：$O(nm)$\nDFS序 优化 有的时候，第二维表示的不一定是 选择 $j$ 个元素，而可能是某一种权值，此时上面的优化的效果就不显著了。\n我们可以利用 DFS序 进行优化。\n令 $i$ 为 $u$ 的DFS序编号，则对于当前节点 $u$，我们有两种选择：\n  选择当前节点：$dp[i+1][j+w_u] = \\max \\{dp[i][j] + v_u \\}$\n  不选当前节点：$dp[i + sz_i][j] = \\max \\{ dp[i][j]\\}$\n  解释：\n如果选择当前节点，说明可以继续往子树里传递，所以传递到 $dp[i+1][j+w_u]$。\n如果不选择当前节点，由于依赖关系，就必须跳过子树，所以传递到 $dp[i + sz_i][j]$。\n最终的答案就是 $ans = \\max\\limits_{j=0}^m \\{dp[n+1][j] \\}$。\n复杂度：$O(nm)$\n例题可见 例2\n例题 例1 洛谷P2014 题意\n有 $N$ 门课程，每门课程有 $1$ 或 $0$ 门前置课程，需要上了前置课程才能上这门课。每门课 $i$ 有 $s_i$ 学分。\n现要选 $M$ 门课，使得学分总和最大。\n 题解 设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个课程得到的最大值\n根据前置课程的关系建图(会发现这是一棵树)，因为有前置课程，所以必须选了root才能选别的，故:\n$$dp[i][1] = s_i$$\n在处理某一个节点i的时候，$dp[i][j]$ 代表的是： 以它为root的 \u0026ldquo;已探索\u0026rdquo; 子树中的最大值，所以在探索各个子树过程中有：\n$dp\\left[cur\\right]\\left[j\\right]=\\max\\left(dp\\left[cur\\right]\\left[j\\right],dp\\left[cur\\right]\\left[k\\right]+dp\\left[nei\\right]\\left[j-k\\right]\\right),\\ k=\\left[1,j-1\\right]$\n 实现细节\n 我们利用 $dp[i][1] = s_i$ 来处理前置课程，是非常高效的做法！ 状态转移的时候，要 倒序枚举 $j$， 也就是 $j = m \u0026hellip; 1$， 因为此时 $dp[cur][k]$ 代表的是已探索的部分，不能包括 $nei$ (因为 $nei$ 正在被探索)。为了防止同一个 $nei$ 被考虑多次，要倒序枚举！ 给定的图可能是一个森林，所以创建一个超级root $0$，并且将 $M$++ (因为 $0$ 肯定要包含进去)，最终答案就是 $dp[0][M+1]$   算法优化\n注意，在dp状态转移的时候，我们可能用的是如下loop:\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  每个节点 cur 都这样loop一次，总复杂度是 $O(nm^2)$，看起来不可接受。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  时间复杂度：$O(n^2)$\n证明：我们考虑每一个 nei 被用来转移 的次数，会发现它只会在计算它的 parent 的dp值时才会被拿来统计，又因为每一个节点只有1个parent，所以每个节点对应的子树都只会被统计一次。\n所以时间复杂度就是 $T(\\sum\\limits_{i=1}^n i * sz[i]) = O(n^2)$\n更严谨的数学证明可以参见 https://www.luogu.com.cn/blog/Chenxiao-Yan/solution-p4322\n luogu-P2014-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 305; const int maxm = 305; int n,m; int s[maxn]; int dp[maxn][maxn]; int sz[maxn]; //记录i的子树大小 struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); fill(head, head+n+2, -1); //因为存在编号为0的节点，所以初始化为-1 for (int i = 1; i \u0026lt;= n; i++) { int sc,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,\u0026amp;sc); s[i] = sc; add(k, i); } } void dfs(int cur, int par) { if (sz[cur]) return; // visited dp[cur][1] = s[cur]; sz[cur] = 1; for (int e = head[cur]; ~e; e = edges[e].nxt) { int nei = edges[e].to; if (par == nei) continue; dfs(nei, cur); sz[cur] += sz[nei]; for (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } } } } int main() { init(); m++; dfs(0, -1); printf(\u0026quot;%d\\n\u0026quot;, dp[0][m]); }    如果每门课的前置课程不止1门，就不再是一棵树了，这样的话似乎可以用状压dp来解，leetcode某次比赛中出现过。\n 例2 洛谷P2515 [HAOI2010]软件安装 题意\n给定 $N$ 个软件，每个软件 $i$ 要占用 $W_i$ 的空间，价值为 $V_i$，并且每个软件 $i$ 会依赖最多一个软件 $D_i$。\n如果要安装软件 $i$，必须要安装所有的直接/间接依赖软件。\n电脑的空间为 $M$，求最大价值。\n其中，$1 \\leq N \\leq 100, 0 \\leq M \\leq 500, 0 \\leq W_i \\leq M, 0 \\leq V_i \\leq 1000, D_i \\in [0,N], D_i \\neq i$\n 题解 注意到，本题可能有 循环依赖。\n对于循环依赖，直接用 SCC 缩点，剩下的就是一个标准的有依赖背包（本质上，树形DP）问题了：\n如果 $i$ 依赖 $D_i$，那么将 $D_i$ 所在的 SCC 连一条有向边，指向 $i$ 所在的 SCC 即可。\n另外需要注意，本题可能是一个森林。所以缩点后，对于所有入度为 $0$ 的点 $u$，需要用 $0$ 连一条有向边指向 $u$。\n最后，从 $0$ 开始 DP 即可。\n DP 的核心代码：\nvoid dfs(int u) { if (wei[u] \u0026lt;= m) dp[u][wei[u]] = val[u]; for (int to : adj2[u]) { dfs(to); for (int i = m; i \u0026gt;= wei[u]; i--) { for (int j = wei[to]; j \u0026lt;= i - wei[u]; j++) { dp[u][i] = max(dp[u][i], dp[u][i-j] + dp[to][j]); } } } }  注意几点：\n dp[u][wei[u]] = val[u]; 放在最前面。 DP的过程中，类似于 $01$ 背包，$i$ 是从大到小的，并且下限是 wei[u]。 DP的过程中，$j$ 的下限是 wei[to]，上限是 i - wei[u]（因为 i-j 的有效值必须 $\\geq$ wei[u]）。  • 另外，别忘记 tarjan 过程中，更新 low[] 要判断是否在栈内。\n 树形DP（无优化版本）代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, w[105], v[105], d[105]; int dp[103][503]; vector\u0026lt;int\u0026gt; adj1[103]; set\u0026lt;int\u0026gt; adj2[103]; int dfn[103], low[103], id = 0, st[103], tail = -1; bool in[103]; int from[103], scc = 0; void tarjan(int u) { in[u] = 1; st[++tail] = u; dfn[u] = low[u] = ++id; for (int to : adj1[u]) { if (!dfn[to]) { tarjan(to); low[u] = min(low[u], low[to]); } else if (in[to]) { // 注意这里有 in[to] low[u] = min(low[u], dfn[to]); } } if (low[u] == dfn[u]) { from[u] = ++scc; while (tail \u0026gt;= 0 \u0026amp;\u0026amp; st[tail] != u) { int cur = st[tail--]; in[cur] = 0; from[cur] = scc; } tail--; in[u] = 0; } } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; d[i]; if (d[i] == 0) continue; adj1[d[i]].push_back(i); } for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) tarjan(i); } } int wei[103], val[103], ind[103]; void rebuild() { for (int i = 1; i \u0026lt;= n; i++) { int fu = from[i]; wei[fu] += w[i]; val[fu] += v[i]; int fv = from[d[i]]; if (fu == fv || fv == 0) continue; adj2[fv].insert(fu); ind[fu]++; } for (int i = 1; i \u0026lt;= scc; i++) { if (!ind[i]) adj2[0].insert(i); } } void dfs(int u) { if (wei[u] \u0026lt;= m) dp[u][wei[u]] = val[u]; for (int to : adj2[u]) { dfs(to); for (int i = m; i \u0026gt;= wei[u]; i--) { // 注意从大到小，注意下限 for (int j = wei[to]; j \u0026lt;= i - wei[u]; j++) { // 注意上下限 dp[u][i] = max(dp[u][i], dp[u][i-j] + dp[to][j]); } } } } int main() { init(); rebuild(); dfs(0); int ans = 0; for (int i = 0; i \u0026lt;= m; i++) ans = max(ans, dp[0][i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   DFS序 优化 我们可以利用 DFS序 进行优化，让时间复杂度从 $O(nm^2)$ 降到 $O(nm)$。\n令 $i$ 为 $u$ 的DFS序编号，则对于当前节点 $u$，我们有两种选择：\n  选择当前节点：$dp[i+1][j+w_u] = \\max \\{dp[i][j] + v_u \\}$\n  不选当前节点：$dp[i + sz_i][j] = \\max \\{ dp[i][j]\\}$\n  解释：\n如果选择当前节点，说明可以继续往子树里传递，所以传递到 $dp[i+1][j+w_u]$。\n如果不选择当前节点，由于依赖关系，就必须跳过子树，所以传递到 $dp[i + sz_i][j]$。\n最终的答案就是 $ans = \\max\\limits_{j=0}^m \\{dp[n+1][j] \\}$。\n 另外需要注意，由于依赖问题，我们需要 记录每一个节点 $u$ 的所有ancestor的权值和，在枚举的时候，将下限设置为这个权值和。（在代码中，pre[u] 代表 $u$ 所有ancestor的权值和。）\n 优化代码 // 注意 idcnt = -1，因为我们是从 0 开始 DFS的！ int mp[103], idcnt = -1, sz[103]; // mp[i]: DFS序为 i 的节点编号 u int pre[103]; // pre[u] 代表 u 的 ancestor 的 weight的和 void dfs(int u) { mp[++idcnt] = u; sz[u] = 1; for (int to : adj2[u]) { pre[to] = pre[u] + wei[u]; // ancestor的权值和 dfs(to); sz[u] += sz[to]; } } void solve() { for (int i = 1; i \u0026lt;= scc; i++) { int u = mp[i]; for (int j = pre[u]; j \u0026lt;= m; j++) { // 注意枚举下限从 pre[u] 开始 dp[i+sz[u]][j] = max(dp[i+sz[u]][j], dp[i][j]); // 不选 if (j + wei[u] \u0026lt;= m) // 选择（要保证 j+wei[u] \u0026lt;= m） dp[i+1][j+wei[u]] = max(dp[i+1][j+wei[u]], dp[i][j] + val[u]); } } } int main() { init(); rebuild(); dfs(0); solve(); int ans = 0; for (int j = 0; j \u0026lt;= m; j++) ans = max(ans, dp[scc+1][j]); // 注意是 scc+1 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 洛谷P4395 [BOI2003]Gem 气垫车 题意\n给一棵 $n$ 个节点的树，要求给所有节点标上正整数权值，使得相邻节点不能权值相同，求最小总权值。\n其中，$n \\leq 10^4$。\n 题解 第一眼看过去是个树染色问题，要么权值为 $1$，要么为 $2$。\n很遗憾这个做法是错的，考虑一下这个数据，两个菊花接在一起：\n这里很明显应该给 $1,2$ 分别标上 $2,3$ 的权值，其余全部标 $1$。\n所以我们暴力枚举一下每个节点上可能标什么权值就好了，直觉上告诉我们这个上限不会太大。\n然后利用树形DP来求最小值即可。\n代码中取了上限 $M = 55$，所以复杂度就是 $O(55^2 * n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 10005; const int M = 55; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1, n, m; int dp[maxn][M+3]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); for (int j = 1; j \u0026lt;= M; j++) { int r = 1e9; for (int k = 1; k \u0026lt;= M; k++) { if (j == k) continue; r = min(r, dp[to][k]); } dp[u][j] += r; } } for (int j = 1; j \u0026lt;= M; j++) dp[u][j] += j; } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1, 0); int ans = 1e9; for (int j = 1; j \u0026lt;= M; j++) ans = min(dp[1][j], ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例4 洛谷P3177 [HAOI2015]树上染色 题意\n给定一棵 $n$ 个节点的树，树的边上有权值。\n给定一个整数 $k \\in [0,n]$，要求从树上选择 $k$ 个点，将其染成黑色，剩余的染成白色。\n染色后，获得的价值为 黑点两两之间的距离之和 + 白点两两之间的距离之和。\n求最大价值？\n其中，$n,k \\leq 2000$。\n 题解 数据范围看起来就非常树形DP。\n设 dp[u][i] 为在 $u$ 的子树内，染 $i$ 个黑点的总价值。\n现在考虑一下怎么转移？\n如果我们直接进行转移，就需要维护节点的深度之和，然而这很明显不现实，所以我们可以 考虑每条边 的贡献。\n假设考虑的子树 $v$ 中，染了 $j$ 个黑点，那么一条边 $(u,v,w)$ 的贡献刚好就是：\n$$w * (j * (k-j) + (sz[to] - j) * (n - k - sz[to] + j))$$\n其中 j * (k-j) 是这条边两端的黑点数量的乘积，而 (sz[to] - j) * (n - k - sz[to] + j) 就是这条边两端的白点数量的乘积。\n然后直接转移就可以了（注意第二维度的转移顺序是从 $0$ 开始，否则会导致 $dp[u][i]$ 被更新两次），注意一下使用 sz[] 进行时间复杂度优化到 $O(n^2)$，否则是 $O(n^3)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2003; ll dp[maxn][maxn]; ll sz[maxn]; int n,k; struct Edge { int to, nxt; ll w; } edges[maxn\u0026lt;\u0026lt;1]; int ecnt = 1, head[maxn]; void addEdge(int u, int v, ll w) { Edge e = {v, head[u], w}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { sz[u] = 1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; } } void dfs(int u, int p) { dp[u][0] = dp[u][1] = 0; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); ll w = edges[e].w; for (ll i = (ll)min((ll)k, sz[u]); i \u0026gt;= 0; i--) { // u 用多少个黑 for (ll j = 0; j \u0026lt;= min(i,sz[to]); j++) { // v 用多少个黑 ll cnt = j * (k - j) + (sz[to] - j) * (n - k - sz[to] + j); dp[u][i] = (ll)max(dp[u][i], dp[u][i-j] + dp[to][j] + cnt * w); // j = 0 开始: dp[u][i], dp[u][i-1] ... (正确) // j = min(i,sz[to]) 开始: dp[u][0], dp[u][1], ..., dp[u][i] -\u0026gt; 这导致 dp[u][i] 被更新了两次 } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; ll w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; addEdge(u,v,w); addEdge(v,u,w); } for (int i = 1; i \u0026lt;= n; i++) for (int j = 2; j \u0026lt;= k; j++) dp[i][j] = -1e18; dfs1(1, 0); dfs(1, 0); cout \u0026lt;\u0026lt; dp[1][k] \u0026lt;\u0026lt; endl; }   注意事项\n 本题枚举 $i,j$ 时，注意要加上 $sz[u], sz[to]$ 作为上限来优化。 注意初始化 $dp[i][j]$ 为负无穷，并且设 $dp[i][0] = dp[i][1] = 0$。 注意第二维度的转移顺序（第一维倒序这个是必须的）。   例5 [1到n经过特定点的最短路] 题意\n给定 $n$ 个节点的一棵树，树上有 $m$ 个点被标记了，求从节点 $1$ 走到节点 $n$，中途需要经过这些标记点的最短路长度，所有边权值为 1。\n其中，$n \\leq 2 \\times 10^5$。\n 题解 • 这是一道群里传的题目，没有代码。\n 首先将 $1$ 到 $n$ 的路径拉成一条链，链上所有的点一定会被经过，不用管。\n接下来就是挂在链上的若干子树，对于每个子树，思考如下问题：\n 从一棵树的根出发，经过树内的所有标记点，再回到这棵树的根，需要的最短路长度？\n 对于这个问题，我们考虑对于每个被标记的点 $u$，从根（假设为 $1$）到 $u$ 的路径一定会被经过，被经过的这些边被打上标记，代表这些边一定会被经过。\n打完标记后，我们知道在最优解中，每条边一定会被经过 $2$ 次，所以答案就是标记边 $*2$。\n如何打标记？\n只要一次dfs即可，每次dfs时判断这个子树里面有没有需要标记的点，如果有，这条边就打上标记。\n 例6 NAQ2017E. Company Picnic 题意\n给定一棵树，每个节点有权值 $w_i$。\n定义一组节点为：两个直接相连的节点 $i,j$，这组节点的权值定义为 $\\min (w_i,w_j)$。\n求选出若干组节点的方法，使得每组节点用到的点各不相同，并且满足选出节点组数最多。\n在节点组数量最多的情况下，求出这些节点的权值和最大值。\n其中，$2 \\leq n \\leq 1000, w_i \\in [2.2,5.3]$。\n 题解 这个题需要维护最多节点组数，还要维护权值和最大值。所以 dp 数组维护两个值。\n定义 $dp(u,0)$ 为：$u$ 的parent没有选它，$dp(u,1)$ 则是选了它的。\ndp 值则是一个pair：\u0026lt;int, double\u0026gt;，代表子树中最大的节点组数，以及对应的最大权值和。\n在转移的时候，注意到 $dp(u,1)$ 不能选任何 $dp(v,1)$ 转移。而 $dp(u,0)$ 只能选一个 $dp(v,1)$ 转移（或者也可以不选）。\n转移的过程中，优先更新第一个值（节点组数），如果第一个值相等，再更新第二个值（权值和最大值）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e3+5; pair\u0026lt;int,double\u0026gt; dp[maxn][2]; vector\u0026lt;string\u0026gt; adj[maxn]; map\u0026lt;string, int\u0026gt; mp; double sp[maxn]; struct Edge { int to, nxt; } edges[maxn\u0026lt;\u0026lt;1]; int head[maxn], ecnt = 1; void addEdge(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } int rt; void dfs(int u, int p) { int cnt = 0, b = 0; // b: 最优转移 1 的点v double sum = 0; // 0 的情况 for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; dfs(v, u); cnt += dp[v][0].first; sum += dp[v][0].second; if (b == 0) b = v; else if (dp[v][1].first - dp[v][0].first \u0026gt; dp[b][1].first - dp[b][0].first) { b = v; } else if (dp[v][1].first - dp[v][0].first == dp[b][1].first - dp[b][0].first \u0026amp;\u0026amp; min(sp[u], sp[v]) + dp[v][1].second - dp[v][0].second \u0026gt; min(sp[u], sp[b]) + dp[b][1].second - dp[b][0].second) { b = v; } } if (!b) return; cnt -= dp[b][0].first; cnt += dp[b][1].first; sum -= dp[b][0].second; sum += min(sp[u], sp[b]) + dp[b][1].second; dp[u][0].first = cnt + 1; dp[u][0].second = sum; cnt = 0, sum = 0; for (int e = head[u]; e; e = edges[e].nxt) { int v = edges[e].to; if (v == p) continue; cnt += dp[v][0].first; sum += dp[v][0].second; } dp[u][1].first = cnt; dp[u][1].second = sum; if (cnt \u0026gt; dp[u][0].first || (cnt == dp[u][0].first \u0026amp;\u0026amp; sum \u0026gt; dp[u][0].second)) { dp[u][0].first = cnt; dp[u][0].second = sum; } } int main() { fastio; int n; cin \u0026gt;\u0026gt; n; int id = 0; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; if (!mp.count(s) \u0026amp;\u0026amp; s != \u0026quot;CEO\u0026quot;) mp[s] = ++id; double w; cin \u0026gt;\u0026gt; w; string t; cin \u0026gt;\u0026gt; t; if (!mp.count(t) \u0026amp;\u0026amp; t != \u0026quot;CEO\u0026quot;) mp[t] = ++id; int u = mp[s], v = mp[t]; if (t == \u0026quot;CEO\u0026quot;) { rt = u; } else { addEdge(u,v); addEdge(v,u); } sp[u] = w; } dfs(rt, -1); cout \u0026lt;\u0026lt; dp[rt][0].first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; dp[rt][0].second / dp[rt][0].first \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   ","date":"2021-02-18T15:42:09+08:00","permalink":"https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/","tags":["树形dp","dp优化"],"title":"树形dp"},{"categories":["算法"],"contents":"介绍 01分数规划用于 求一个分式的极值\n例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大/最小？\n方法 (二分) 一般使用二分答案的方法进行求解，假设我们要求最大值，那么 二分一个答案 $mid$，有\n$\\frac{\\sum a_i}{\\sum b_i} \\geq mid$, 所以\n$\\sum a_i- (mid \\times b_i) \\geq 0$\n所以只要求出左边的最大值，判断是否 \u0026gt;= 0 即可！\n 如果左边最大值 \u0026gt;= 0，说明当前答案 $mid$ 可行，提高下边界 如果左边最大值 \u0026lt; 0，说明当前答案 $mid$ 不可行，降低上边界  例题 例1 POJ2976 Dropping tests 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大。\n 题解 二分答案，当前答案为 $mid$ 时，把第 $i$ 个物品的权值设为 $a_i - mid \\times b_i$，然后取最大的 $k$ 个即可得到最大值。\n 例2 洛谷P1419 题意\n给定 $n$ 个整数，求一个长度在 $[S,T]$ 之间的subarray(连续)，使得平均值最大？\n 题解 二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1}$ 最大。\n令 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1} \\geq mid$，有 $\\sum\\limits_{i=l}^r(a_i - mid) \\geq 0$，\n定义一个新的数组$b$，其中 $b_i = a_i - mid$。\n左边的最大值就是 $b$ 这个数组中最大的连续区间，用前缀和即可。\n 另外一种思考方法:\n二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{sum[r] - sum[l-1]}{r-l+1}$ 最大。\n$\\frac{sum[r] - sum[l-1]}{r-l+1} \\geq mid$ ，有 $(mid \\times (l-1) - sum[l-1]) - (mid \\times r - sum[r]) \\geq 0$\n因为 $r$ 固定，所以只要找 $mid*l - sum[l]$ 的最大值，其中 $l \\in [\\max(0, r-T), r-s]$。\n遍历 $r$ 的时候，维护一个单调队列即可。\n luogu-P1419-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; const int maxn = 1e5+5; int n, s, t; int arr[maxn]; int sum[maxn]; double a[maxn]; int q[maxn]; int head = 0, tail = -1; double ans = -1e4; bool check(double cur) { for (int i = 0; i \u0026lt;= n; i++) a[i] = cur * (double)(i) - (double)(sum[i]); double res = -1e18; head = 0, tail = -1; for (int r = s; r \u0026lt;= n; r++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; q[head] \u0026lt; r-t) head++; while (head \u0026lt;= tail \u0026amp;\u0026amp; a[q[tail]] \u0026lt; a[r-s]) tail--; q[++tail] = r-s; res = max(res, a[q[head]] - a[r]); } // for (int r = 1; r \u0026lt;= n; r++) { // double tmp = -1e18; // for (int i = max(0, r-t); i \u0026lt;= r-s; i++) { // tmp = max(tmp, a[i]); // } // res = max(res, tmp - a[r]); // } if (res \u0026gt;= 0) return 1; return 0; } int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } double l = -1e4, r = 1e4; while (abs(l-r) \u0026gt; eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = mid; } else { r = mid; } } printf(\u0026quot;%.3f\\n\u0026quot;, ans); }   例3 洛谷P4377 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n你可以选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大, 且 $\\sum b_i \\geq W$\n 题解 和例1几乎一样，但是多了一个 $\\sum b_i \\geq W$ 的限制。\n设 $d_i = a_i - mid \\times b_i$，然后我们要做的事就是：\n选取一组$i$，保证在 $\\sum b_i \\geq W$ 的前提下，使得 $\\sum d_i$ 最大\n可以用01背包解决，令 $dp[n][k]$ 为：使用前 $n$ 个元素，$\\sum b_i = k$ 时， $\\sum d_i$ 的最大值。\n那么答案就是 $dp[n][W]$。\n如果在状态转移过程中出现 $k \u0026gt; W$，直接转移到 $k = W$ 的状态上即可。\n 注: 写01背包的时候不要忘了 倒序枚举 ！\n  luogu-P4377-AC代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const double eps = (double)1e-6; const int maxn = 255; int n,W; int w[maxn], t[maxn]; double dp[1001]; struct node { double d; int w; } arr[maxn]; bool check(double cur) { for (int i = 1; i \u0026lt;= n; i++) { arr[i] = {(double)t[i] - cur * (double)w[i], w[i]}; } fill(dp, dp+1001, -1e9); dp[0] = 0.0; for (int i = 1; i \u0026lt;= n; i++) { for (int d = 1000; d \u0026gt;= 0; d--) { int tar = min(d + arr[i].w, 1000); dp[tar] = max(dp[tar], dp[d] + arr[i].d); } } for (int d = W; d \u0026lt;= 1000; d++) { if (dp[d] \u0026gt;= 0.0) return 1; } return 0; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;W); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;w[i], \u0026amp;t[i]); } double l = 0.0, r = 1e6, ans = 0.0; while (abs(l-r) \u0026gt;= eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = max(ans, mid); } else { r = mid; } } printf(\u0026quot;%d\\n\u0026quot;, (int)((ans+5e-5) * 1000)); }   例4 洛谷P4322 题意\n给定一棵$N$个节点的树，每个节点 $i$ 具有两个权值 $P_i, S_i$，求树中的一组节点，满足：\n $\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大 如果 节点 $i$ 被选中了，那么它的parent $R_i$ 也必须被选中 选中的节点数量 刚好为$K$  求满足条件的最大比值？\n 题解 首先看条件1：$\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大，仍然是分数规划的套路，二分答案。令 $d_i = P_i - mid \\times S_i$\n所以问题转化为求一组节点使得 $\\sum d_i$ 最大。\n然后就会发现，这是一个经典的树形dp模型，和 选课(洛谷P2014) 几乎一样。\n具体做法和注意事项见下一篇博客。\n","date":"2021-02-17T17:20:49+08:00","permalink":"https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":["01分数规划","二分"],"title":"01分数规划"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1159/problem/B\n题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\frac{\\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \\in [1,n], i \\neq j$\n 题解 对于这类的枚举问题，一般套路都是 \u0026ldquo;固定一个数\u0026rdquo;，这里很明显是固定一下 $\\min(a_i, a_j)$。\n所以只要从 $a_1$ 遍历到 $a_n$，把当前遍历到的值作为最小值，然后不管最左侧或者最右侧元素是否小于它，直接最大化分母就可以了。\n为什么不会漏解？因为 每一个 $a_i$ 都当了一次分子！\n 代码 const int maxn = 3e5+5; int n, arr[maxn]; int ans = 1e9; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { int d = max(i-1, n-i); ans = min(ans, arr[i] / d); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-02-17T15:19:54+08:00","permalink":"https://tom0727.github.io/post/006-cf-1159b/","tags":["枚举"],"title":"CF1159B 题解(枚举优化)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些爬虫相关的知识点：\n分段下载 如果我们需要设定下载的timeout怎么办？\n直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout参数意义是 \u0026ldquo;从服务器返回任意数据\u0026rdquo; 的时间差。如果我们想要设定 timeout 使得在一定时间内下载不完就break，可以用分段下载！\n分段下载由stream=True实现\ndef download_img(img_url, path): timeout = 150 # 设定150秒如果下载不完就停止下载 try: img_html = requests.get(img_url, headers=get_download_header(), timeout=10, stream=True) if img_html.status_code != 200: return body = [] start = time.time() for chunk in img_html.iter_content(1024): body.append(chunk) if time.time() \u0026gt; start + timeout: print(\u0026quot;Time out!\u0026quot;) break else: # 下载完毕 with open(path, 'wb') as file: file.write(b''.join(body)) file.flush() except BaseException as err: print(err)  多进程下载 多进程下载经常在访问一些速度较慢的网站时很有用，因为本地的带宽不是主要限制，所以可以开很多个进程同时访问然后进行下载，这样更快。\ndef f(arg): ... # 下载程序 if __name__ == '__main__': processes = [] for _ in range(20): p = multiprocessing.Process(target=f, args=(some_arg, )) p.start() processes.append(p) for p in processes: p.join()  正则表达式Regex的注意事项   匹配时注意区分懒惰匹配和贪婪匹配，懒惰匹配可以在匹配符号后加上?，如 .*?\n  如果在匹配过程中需要用到()，但是需要获取整个匹配结果（不想被()框起来的部分干扰），可以使用non-capturing group，即，(?:)，如:\nre.findall(\u0026quot;https://abc.net/images/.*?(?:jpg|png|jpeg)\u0026quot;, txt)\n这样，返回的就是整个匹配的网址，而不是()框起来的部分\n  ","date":"2021-02-10T22:52:26+08:00","permalink":"https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","tags":["爬虫","python"],"title":"爬虫笔记"},{"categories":["算法"],"contents":"定义 给定正整数$n$，求$\\varphi(n)$， 即\n 小于等于$n$ 且 与$n$互质  的正整数个数。\n性质  $\\varphi(p) = p-1, ~\\forall \\text{prime } p$ $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ $\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  证明 证明性质1 求证： $\\varphi(p) = p-1, ~\\forall \\text{prime } p$\n 由质数的定义可知，小于等于$p$ 且 与$p$互质的数，在$[1,p]$中，除了 $p$以外均满足！\n 注： $\\varphi(1) = 1$\n 证明性质2 求证： $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$\n 首先，易知 $\\varphi(n) = |\\mathbb{Z}_n^{\\times}|$ , 即 $\\mathbb{Z}_n$ 中 unit(存在关于$\\bmod~ n$乘法逆元的元素)的数量\n因为 $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$\n所以 $\\mathbb{Z}_{mn}$的units $\\mathbb{Z}_{mn}^{\\times}$ ， 与\n$\\mathbb{Z}_m \\times \\mathbb{Z}_n$的 units $(\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times}$ 之间存在一个 bijection, 即\n$\\mathbb{Z}_{mn}^{\\times} \\cong (\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times} = \\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}$\n所以 $\\varphi(mn) = |\\mathbb{Z}_{mn}^{\\times}| = |\\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}| = |\\mathbb{Z}_m^{\\times}||\\mathbb{Z}_n^{\\times}| = \\varphi(m)\\varphi(n)$\n 注：\n $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$ 的证明见 这里 更严格的证明需要用到抽代里的中国剩余定理 （以Ring和Ideal表示的）   证明性质3 求证：$\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$\n $\\forall n = p^k$，所有与它不互质的数$m$必然包含$p$这个质数因子，因此满足条件的$m$为：$1p, 2p, 3p, \u0026hellip; , p^{k-1}p$，共 $p^{k-1}$个。\n所以，与$n = p^k$互质的数共有 $p^k-p^{k-1}$个。\n  证明性质4 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，且$p_1,p_2,\u0026hellip;,p_r$都是质数（所以两两互质）\n由性质2， $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3，$\\varphi(p_i^{k_i}) = p_i^{k_i} - p_i^{k_i-1} = p_i^{k_i}(1-\\frac{1}{p_i})$\n所以 $\\varphi(n) = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n  证明性质5 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，\n由性质2，$\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3， $\\varphi(p^k) = p^k - p^{k-1}$, 我们可以推出 $\\varphi(p^{k+1}) = \\varphi(p^{k}) * p$\n因为 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$，由上可得出 $\\varphi(p_i^{k_i}) = \\varphi(p_i^{k_i-1}) * p_i$\n即 $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip; (\\varphi(p_i^{k_i-1})*p_i)\u0026hellip;\\varphi(p_r^{k_r}) = \\varphi(\\frac{n}{p_i})*p_i$\n  求单个数的欧拉函数值 $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，直接质因数分解，由性质4即可求出！\n时间复杂度：$O(\\sqrt n)$\n代码 ll phi(ll x) { ll res = x; for (ll p = 2; p * p \u0026lt;= x; p++) { if (x % p == 0) { res = (res / p) * (p-1); } while (x % p == 0) x /= p; } if (x \u0026gt; 1) res = res / x * (x-1); return res; }  线性筛求1~n的欧拉函数值 和线性筛的基本思路一样，只不过要分类讨论 i % p == 0 与否。（i是当前处理到的数, p是当前用到的质数）\n  如果 i % p == 0，说明 i * p 这个数里，包含了至少2个质因子$p$ (即$p^2$)。\n由性质5，有 $\\varphi(i * p) = \\varphi(i) * p$\n  如果 i % p != 0，说明 $\\gcd(i,p) = 1$。\n由性质2，有 $\\varphi(i * p) = \\varphi(i) * \\varphi(p)$\n  时间复杂度： $O(n)$\n代码 luogu-P2158-AC代码 题目链接: https://www.luogu.com.cn/problem/P2158\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244352; const int maxn = 4e4+5; int phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } phi[1] = 1; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= n; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } int ans = 3; for (int i = 2; i \u0026lt;= n-1; i++) ans += 2*phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 CF1295D 题意\n给定两个正整数 $a$, $m$, 求满足以下条件的 $x$ 的数量？\n $0 \\leq x \u0026lt; m$ $\\gcd(a,m) = \\gcd(a+x,m)$  其中，$1 \\leq a \u0026lt; m \\leq 10^{10}$\n 题解 设 $g = \\gcd(a,m)$，则 $g = \\gcd(a+x,m)$，所以 $\\gcd(\\frac{a+x}{g}, \\frac{m}{g}) = 1~$ 且 $~g|(a+x)$，又因为 $g|a$，所以 $~g|x$\n所以问题转化为：\n设 $c = \\frac{a}{g}, x = \\frac{m}{g}$，求 $k \\in [c,c+x)$，使得 $k$ 满足：$gcd(x, k) = 1$ 的 $k$ 的数量？\n我们会发现当 $k \u0026gt; x$ 时，因为 $\\gcd(x,k) = \\gcd(x, k-x)$，所以我们可以将 $k \\in (x,c+x)$ 的这一段，映射到 $k \\in (0,c)$ 上。\n所以最后我们要求的$k$就是： $k \\in [1,x]$ 使得 $\\gcd(k, x) = 1$，所以满足条件的 $k$ 的数量就等于 $\\varphi(x)$\n 例2 CF1731E. Graph Cost 题意\n给定一个 $n$ 个节点的图 $1,2,\u0026hellip;,n$，初始状态下图中没有边。\n我们在一次操作中，可以选定任意一个正整数 $k$，往图中添加恰好 $k$ 条边。一条边如果连接的是点 $i,j$，那么必须满足 $\\gcd(i,j) = k+1$。\n图中不能出现自环和重边。\n给定整数 $m$，求最少需要几次操作，使得图中边的数量恰好为 $m$？如果不存在，输出 $-1$。\n其中，$n \\leq 10^6, m \\leq \\frac{n(n-1)}{2}$。\n 题解 先考虑 $f(k)$：有多少个点对 $i\u0026lt;j$ 满足 $\\gcd(i,j)=k$？\n注意到 $\\gcd(i,j)=k \\iff i=ak, j=bk$ 且 $\\gcd(a,b)=1$。\n所以要求 $\\gcd(i,j)=k$ 的点对数量，令 $m = \\frac{n}{k}$。\n则我们所求的变成 $1\u0026hellip;m$ 中互质的数对的数量。\n形式化的，求：\n$$\\sum\\limits_{i=1}^m \\sum\\limits_{j=1}^{i-1} [1|gcd(i,j)=1]$$\n注意到如果我们固定 $i$，那么里面那层求和就是欧拉函数 $\\phi(i)$，也就是求\n$$\\sum\\limits_{i=1}^m \\phi(i)$$\n这个预处理出来就可以了。\n 接下来考虑最少加几次边可以得到 $m$？\n$m$ 超级大所以没法背包。但注意到对于每一个 $k$，我们都至少可以加一次。\n有了这个性质，说明只要 $m$ 小于等于最大可能加的边数，就一定有解（可以理解成 $1,2,4,8\u0026hellip;$ 这种构成了二进制的basis，覆盖了所有数，那这个更密集的 $k$ 一定也可以）。\n所以贪心的从大往小加，就可以得到最少加边次数了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int M = 1e6; int phi[maxn]; ll sum_phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; ll cnt[maxn]; void solve(int n, ll m) { for (int k = 2; k \u0026lt;= n; k++) { cnt[k] = sum_phi[n/k]; } ll ans = 0; for (int k = n; k \u0026gt;= 2; k--) { // weight = k, cost = k, add (k-1) edges ll r = min(cnt[k], m) / (k-1); // 拿了 r 次 ans += r * k; m -= r * (k-1); if (!m) { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } int main() { int T; cin \u0026gt;\u0026gt; T; phi[1] = 0; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= M; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= M; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } for (int i = 1; i \u0026lt;= M; i++) { sum_phi[i] = sum_phi[i-1] + phi[i]; } while (T--) { int n; ll m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; solve(n, m); } }   参考链接  https://blog.csdn.net/paxhujing/article/details/51353672 https://www.luogu.com.cn/blog/JustinRochester/solution-p2158 https://blog.nowcoder.net/n/0cbf747dc0874027b5c48cf7fbf27060  后记 写这篇文章的时候出了几个数学公式上的问题:\n 如果排版炸了，可以试着在 _ 的前面加上 \\  ","date":"2021-02-06T17:23:34+08:00","permalink":"https://tom0727.github.io/post/004-euler-function/","tags":["数学","抽代"],"title":"欧拉函数"},{"categories":["算法"],"contents":"扩展欧几里得 (exgcd) 这是 CRT 的前置知识，用于解决如下问题：\n题意\n给定方程 ax + by = c，其中 $a,b,c$ 为已知的正整数，求一组正整数解 $x,y$？\nFollow up:\n 如果解不存在，输出 $-1$。 如果解存在，但没有正整数解（正整数解表示 $x,y$ 均 $\u0026gt;0$）求出所有整数解中，$x,y$ 的最小正整数值。 如果解存在，并且有正整数解，求出正整数解的数量，并求出 $x,y$ 在所有正整数解中，可能的最大最小值。   推导过程如下：\n首先判断是否有解，只要知道 $c$ 是否为 $\\gcd(a,b)$ 的倍数即可。\n以下，我们设 $c=k * \\gcd(a,b)$，那么我们只要先求出 $ax+by = \\gcd(a,b)$ 的一组可行解 $x,y$，求出原方程的 $x,y$ 只要乘上 $\\frac{c}{\\gcd(a,b)}$ 即可。\n$$ax_1 + by_1 = \\gcd(a,b)$$\n$$bx_2 + (a\\% b)y_2 = \\gcd(a,b)$$\n注意到 $a \\% b = a - \\frac{a}{b} * b$，所以化简有：\n$$ay_2 + b(x_2 - \\frac{a}{b}y_2) = \\gcd(a,b)$$\n对比第一个式子的系数 $ax_1 + by_1 = \\gcd(a,b)$ 可得\n$$x_1 = y_2, y_1 = x_2 - \\frac{a}{b} y_2$$\n递归求解即可，base case为 $x = 1, y = 0$。\nll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; // 这是 gcd(a,b) } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; // 这是 gcd(a,b) } int main() { ll a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll x,y; // 无需定义，exgcd结束后 x,y 即为所求的 ax+by = gcd(a,b) 中的x,y值 exgcd(a, b, x, y); }  Follow Up  判断是否有解，只要判断 $c$ 是否为 $\\gcd(a,b)$ 的倍数即可。  在考虑剩下两个问题之前，我们先将 $a,b,c$ 同除以 $\\gcd(a,b)$，这样保证 $\\gcd(a,b) = 1$，以下均遵循这个假设（主要是为了保证 $a,b$ 尽可能小）\n 要求 $x,y$ 的最小正整数解 $x_{min}, y_{min}$，注意到： $$a(x\\pm kb) + b(y \\mp ka) = c$$ 其中 $k$ 是任意整数。 并且 $x$ 越小，$y$ 越大，反之亦然。\n所以要求 $x_{min}$，只要保证 $k$ 的值使得 $(x+kb) \u0026gt; 0$ 并且尽可能小即可，此时 $y$ 的值取到所有正整数解（若存在）中的最大值，如果这个最大值仍然 $\\leq 0$ 说明对于 $x_{min}$ 正整数解不存在。对于 $y_{min}$ 也要check一下，如果两种情况下都不存在正整数解，我们即可得出结论原方程无正整数解。\n• 注意到上面让 $a = \\frac{a}{\\gcd(a,b)}, b = \\frac{b}{\\gcd(a,b)}$ 使得 $a,b$ 尽可能小，保证了 $x_{min}, y_{min}$ 的正确性。\n  如果存在正整数解，那么根据上面的描述，解的数量和最大最小值就很容易得出了。\n   中国剩余定理 (crt) 定义 给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\ x\\equiv a_2 (\\text{mod }m_2) \\\\ \u0026hellip; \\\\ x\\equiv a_k (\\text{mod }m_k) \\\\ \\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$, 且 $m_i$ 之间两两互质。\n求满足条件的最小非负整数解 $x$ ？\n结论 令 $M = m_1 \\cdot m_2 ~\u0026hellip; ~m_k$, $M_i = \\frac{M}{m_i}$\n令 $M_i^{-1}$ 为 $M_i$ 在 $\\color{red} \\text{mod }m_i$ 意义下的逆元\n则，答案为: $x = \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} ~ (\\text{mod }M)$\n证明 因为 $\\forall i \\neq j, M_i \\equiv 0 ~(\\text{mod } m_j)$\n所以 $\\forall i \\neq j, a_iM_iM_i^{-1} \\equiv 0~ (\\text{mod } m_j)$\n所以 $\\forall i, x \\equiv \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} \\equiv a_iM_iM_i^{-1} ~ (\\bmod ~m_i)$\n又因为 $\\forall i, M_iM_i^{-1} \\equiv 1 ~(\\text{mod } m_i)$\n所以 $\\forall i, x \\equiv a_iM_iM_i^{-1} \\equiv a_i ~ (\\text{mod } m_i)$\n证明推导过程 证明推导过程 这里直接放参考链接一中的片段：\n 由于 $M = 3\\times5\\times7 = 105$\n所以最后的解就是 $x = (n_1 + n_2 + n_3) ~\\bmod ~ 105 = 233 ~ \\bmod 105 = 23$\n  例题  https://www.luogu.com.cn/problem/P3868  快速乘 在题目中，有可能出现 $\\bmod$ 接近 $1e18$ 的情况，有可能会爆 long long，所以在计算大数乘法时，要用快速乘（原理类似于快速幂）：\nll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % mod; b \u0026gt;\u0026gt;= 1; a = (a + a) % mod; } return ans; }  模版 luogu-P3868-AC代码 题目链接: https://www.luogu.com.cn/problem/P3868\n#include \u0026lt;bits/stdc++.h\u0026gt; #define fastio ios::sync_with_stdio(false); cin.tie(0); #define ll long long ll M = 1; ll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % M; b \u0026gt;\u0026gt;= 1; a = (a + a) % M; } return ans; } ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll curx = y; ll cury = x - (a/b) * y; x = curx; y = cury; return g; } ll a[15], b[15]; int k; ll crt() { ll ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ll m = M / b[i]; ll x,y; exgcd(m, b[i], x, y); if (x \u0026lt; 0) x += b[i]; ans = (ans + qmul(qmul(a[i], m), x)) % M; } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; b[i], M *= b[i]; for (int i = 1; i \u0026lt;= k; i++) { a[i] -= (a[i]/b[i]) * b[i]; //将a[i]变成正数 a[i] += b[i]; a[i] %= b[i]; } cout \u0026lt;\u0026lt; crt() \u0026lt;\u0026lt; endl; }   参考链接  https://zhuanlan.zhihu.com/p/103394468  拓展中国剩余定理 (excrt) 定义 用于 $m_1,m_2,\u0026hellip;,m_k$ 并不互质的情况\n给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\ x\\equiv a_2 (\\text{mod }m_2) \\\\ \u0026hellip; \\\\ x\\equiv a_k (\\text{mod }m_k) \\\\ \\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$，（$m_i$ 之间无特殊关联）\n求满足条件的最小非负整数解 $x$ ？\nIntuition 先看一些简单的例子：\n$$\\begin{cases} x\\equiv 2 ~(\\text{mod }4) \\\\\n\\\\ x\\equiv 4 ~(\\text{mod }6) \\\\ \\end{cases}\\Longrightarrow x \\equiv 10 ~(\\text{mod } 12)$$\n$$\\begin{cases} x\\equiv 4 ~(\\text{mod }6) \\\\\n\\\\ x\\equiv 3 ~(\\text{mod }5) \\\\ \\end{cases}\\Longrightarrow ~\\varnothing$$\n可以看出几个特点：\n 答案的 $\\text{mod}$ 为 $\\text{lcm}(m_1, m_2)$ 有可能无解 （若$m_1,m_2$互质则必然有解）  推导 考虑 $x$ 满足：\n$$\\begin{cases} x\\equiv a_1 ~(\\text{mod }m_1) \\\\\n\\\\ x\\equiv a_2 ~(\\text{mod }m_2) \\\\ \\end{cases}$$\n则有 $x = k_1m_1 + a_1 = k_2m_2 + a_2$\n 即：$k_1m_1 - k_2m_2 = a_2 - a_1$\n这个方程有解 $\\iff \\gcd(m_1,m_2) | (a_2 - a_1)$ （即 $(a_2 - a_1)$ 是 $\\gcd(m_1,m_2)$ 的倍数）。\n 如果无解，就直接退出。\n如果有解，就用 $exgcd(m_1, m_2, x', y')$ 解出 $k_1$ 的值。\n设 $\\gcd(m_1, m_2) = g$，则 $k_1 = x' \\cdot\\frac{a_2 - a_1}{g}$\n然后将 $k_1$ 代入 $x = k_1m_1 + a_1$，得到 $x$ 的值，答案就是 $x \\equiv (k_1m_1 + a_1) (\\text{mod ~lcm}(m_1,m_2))$\n这样，$2$个同余方程就转化为了$1$个，用同样的方法继续进行下去，即可化为一个同余方程。\n最终的 $\\text{mod}$ 数就是 $M = \\text{lcm}(m_1, m_2, m_3 \u0026hellip; , m_n)$\n模版 luogu-P4777-AC代码 题目链接: https://www.luogu.com.cn/problem/P4777\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll mul(ll a, ll b, ll mod) { ll res = 0; while (b) { if (b\u0026amp;1) (res += a) %= mod; (a += a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } int n; ll a[maxn], m[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; m[i] \u0026gt;\u0026gt; a[i]; ll cura = a[1], curm = m[1]; for (int i = 2; i \u0026lt;= n; i++) { /* m1 = curm, m2 = m[i], a1 = cura, a2 = a[i] */ ll x,y; ll g = exgcd(curm, m[i], x, y); // g = gcd(curm, m[i]) ll c = a[i] - cura; // c = a2 - a1 c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) if (c % g) { // 无解 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } ll M = (m[i] * (curm / g)); // M = lcm(m1, m2) ll k = mul(x, c / g, M); // k1 = x' * (a2-a1) / g cura = (mul(k, curm, M) + cura) % M; // x = k1m1 + a1 curm = M; } cout \u0026lt;\u0026lt; (cura % curm + curm) % curm \u0026lt;\u0026lt; endl; }   注意事项   我们需要处理可能出现的负数！（比如在快速乘的时候，如果 $b$ 为负数就会炸）\n 在 $exgcd(a,b,x',y')$ 中，$x'$ 有可能为负数。 $c = a_2 - a_1$，则 $c$ 也有可能为负数。  那么如何处理负数？我们需要找到这个负数对应的 $\\text{mod}$为多少，我们可以在等式 $k_1m_1 - k_2m_2 = a_2 - a_1$ 中找到！\n因为我们要求的是 $k_1$ 的值，实际上 $k_1m_1 = (a_2-a_1) + k_2m_2$，即 $k_1m_1 \\equiv (a_2-a_1) \\text{ (mod } m_2)$\n所以无论是 $k_1 = x' \\cdot\\frac{a_2 - a_1}{g}$ 还是 $(a_2-a_1)$，都取一个 $\\text{mod } m_2$ 即可！\n代码段：\nll c = a[i] - cura; c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) ll k = mul(x, c / g, M); // k = ((k % m[i]) + m[i]) % m[i]; 可以处理，但是没有必要，因为快速乘中的 a 可以为负数    注意快速乘过程中的 $\\text{mod}$ ！因为快速乘求的实际上是 $x$ 的值，所以 $\\text{mod } M$，其中 M = lcm(curm, m[i])\n  我们用 cura, curm 来维护当前的 同余方程，之后记得更新一下 curm = lcm(curm, m[i])\n  参考链接  https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li  ","date":"2021-02-06T10:46:42+08:00","permalink":"https://tom0727.github.io/post/003-crt/","tags":["数学","中国剩余定理","crt","exgcd"],"title":"exgcd/中国剩余定理介绍"},{"categories":["工程"],"contents":"写博客好累啊，是我太久没有写作了吗\n这次来记录一下我第一次学习爬虫的经历\n起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とにかくかわいい的生肉漫画，但是这网站广告特别多，还会检测我adblocker，禁用javascript的话漫画就加载不出来了，气死我了，一怒之下决定学习爬虫把漫画爬下来看。\n爬虫教程有很多，这里特别推荐一个Jack Cui的教程：\n [资源分享] Python3 网络爬虫：漫画下载，动态加载、反爬虫这都不叫事\n 爬 manga1001.com 这个网站设置的比较粗糙，图片都是静态加载的(F12就能看见图片链接)，根据标签soup.find_all()一下即可。对于这个网站的话，简单说一下爬虫的基本流程吧。\n基本流程\n  观察一下页面的HTML，用F12打开可以看到大致结构，如果要看源代码的话，可以选择：\n1.1. res = requests.get(url), print(res.txt) 或\n1.2. 在url前加上view-source:，然后用浏览器打开。\n  找到包含图片的tag， 找一下规律，然后用 soup.find_all() 即可。\n  获取所有章节的URL，然后分别去每个URL里抓取。\n   参考代码 import requests from bs4 import BeautifulSoup import os import random import time def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] # get content of one chapter def get_content(folder, prefix, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('figure') i = 1 folder_name = os.path.join(folder, f'Chapter_{prefix:03}/') create_dir(folder_name) for item in items: for child in item.children: if i != 1: img_url = child.get('data-src') else: img_url = child.get('src') print(img_url) headers = random.choice(USER_AGENTS) img_html = requests.get(img_url, headers) img_name = os.path.join(folder_name, f'{i:02}.jpg') with open(img_name, 'wb') as file: file.write(img_html.content) file.flush() i += 1 time.sleep(random.uniform(0, 3.33)) # sleep random time # get manga url list def get_url_list(manga_name, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('option') for i in range(len(items) - 2, -1, -1): if items[i] == items[-1]: # get manga chapter url list without duplicates items = items[i+1:] break chapter = 1 folder = os.path.join(root_folder, f'{manga_name}/') for item in items: manga_url = item.get('value') get_content(folder, chapter, manga_url) print(manga_url) chapter += 1 def main(): url1 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e3%83%88%e3%83%8b%e3%82%ab%e3%82%af%e3%82%ab%e3%83%af%e3%82%a4%e3%82%a4-raw/\u0026quot; name1 = 'Tonikaku_Kawaii' get_url_list(name1, url1) url2 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e5%b9%b2%e7%89%a9%e5%a6%b9%e3%81%86%e3%81%be%e3%82%8b%e3%81%a1%e3%82%83%e3%82%93-raw/\u0026quot; name2 = 'Umaru_Chan' get_url_list(name2, url2) main()    注: 这里用的USER_AGENT和sleep()都是为了防止被发现然后封IP\n 爬 manhuagui.com 上面那个太没挑战性了，于是我打算再爬一个。\n打开漫画网站， 发现没有图片链接，说明是动态加载的图片(用javascript加载的)，那怎么办呢？\nStep 1 先在网页里找找链接长啥样，毕竟用浏览器浏览的话，图片总是会被加载出来的，然后就能看到链接了，果然，在chrome的Elements这个tag里，我们翻到了图片链接：\n不过直接把链接复制到浏览器里打开的话会403，所以我们先搁置一下。\nStep 2 我们要获得某一话的所有图片链接，可以从图上看出似乎有一大段像是加密后的字符串，我们打开第一话和第二话的HTML，用命令行diff一下以后，会发现差异就刚好出现在这串字符串上：我们可以肯定这里面包含了图片链接相关的信息。\nStep 3 既然找到了加密串，那就要找一个钥匙来解码，看一下网页里内容不多，看起来并没有其他有用信息了，但是还有几个.js文件，一个个打开来看一下，终于在其中一个文件里找到了一大堆代码，然后这一大堆里面，有一段看起来又被加密了（有点此地无银三百两啊）： 把这段代码复制到chrome的console里，发现被自动解码了，得到了一个js函数： 我们点开这个函数，看一下里面的内容：\n函数内容 var LZString=(function(){var f=String.fromCharCode;var keyStrBase64=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026quot;;var baseReverseDic={};function getBaseValue(alphabet,character){if(!baseReverseDic[alphabet]){baseReverseDic[alphabet]={};for(var i=0;i\u0026lt;alphabet.length;i++){baseReverseDic[alphabet][alphabet.charAt(i)]=i}}return baseReverseDic[alphabet][character]}var LZString={decompressFromBase64:function(input){if(input==null)return\u0026quot;\u0026quot;;if(input==\u0026quot;\u0026quot;)return null;return LZString._0(input.length,32,function(index){return getBaseValue(keyStrBase64,input.charAt(index))})},_0:function(length,resetValue,getNextValue){var dictionary=[],next,enlargeIn=4,dictSize=4,numBits=3,entry=\u0026quot;\u0026quot;,result=[],i,w,bits,resb,maxpower,power,c,data={val:getNextValue(0),position:resetValue,index:1};for(i=0;i\u0026lt;3;i+=1){dictionary[i]=i}bits=0;maxpower=Math.pow(2,2);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(next=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 2:return\u0026quot;\u0026quot;}dictionary[3]=c;w=c;result.push(c);while(true){if(data.index\u0026gt;length){return\u0026quot;\u0026quot;}bits=0;maxpower=Math.pow(2,numBits);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(c=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 2:return result.join('')}if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}if(dictionary[c]){entry=dictionary[c]}else{if(c===dictSize){entry=w+w.charAt(0)}else{return null}}result.push(entry);dictionary[dictSize++]=w+entry.charAt(0);enlargeIn--;w=entry;if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}}}};return LZString})();String.prototype.splic=function(f){return LZString.decompressFromBase64(this).split(f)};   获得这个函数以后，我们尝试着把之前获得的加密串放进去看看： 这看起来就正常多了，而且这里面的 04|05|06|... 之类的信息看起来也能和之前找到的图片链接对应上。但是它似乎并没有按照某个特定的规律来，所以可以肯定还有一个函数来处理这个字符串。\nStep 4 有了这个信息，我们就接着找处理这个字符串的函数，再次观察一下HTML，发现这个Base64的串被包含在了一个\u0026lt;script\u0026gt;当中，长这样：\nscript内容 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;window[\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();',62,70,'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['\\x73\\x70\\x6c\\x69\\x63']('\\x7c'),0,{})) \u0026lt;/script\u0026gt;   看起来这也是一个函数啊，而且这个Base64的串似乎作为参数了，再次动用chrome的console帮助我们解析一下：\n这下我们大概可以明白几个事情：\n 这段代码实际上是 window[\u0026quot;eval\u0026quot;](...) 省略号部分是一个函数 function(p,a,c,k,e,d), 以 {} 包起来的是函数内容，那return p;} 后面的想必就是这6个参数。  观察一下这6个参数，我们会发现：\n p = 'X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();'\n  a = 62, c = 70\n  k = 'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['split']('|')\n  e = 0, d = {}\n 唯一需要处理的似乎就是k了，虽然k里没有|这个符号，不过刚才使用LZString.decompressfromBase64()函数解析出来的东西倒是有很多|。\n自此真相大白了，我们需要做的事情很简单：\n 提取出p,a,c,k,e,d这6个参数。 将k放进LZString.decompressfromBase64()解析一下。 调用 decode_func （也就是 function(p,a,c,k,e,d) ），得到结果。  结果长这样：\n我们要的图片链接就找到啦！在 files 里。\nStep 5: 我们还剩下最后一个问题：有了图片链接但是访问不了（403）怎么办？这似乎是一种简单的反爬虫方式，google一下，只要假装我们是从本站（即这个漫画的网站）进去的，而不是从其他地方进去的，就可以访问了。虽然在浏览器上做不到，但是python里可以通过更改Referer的方式来达到：\ndef get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;}  Step 6: 最后的最后，就是爬虫的基本过程了，不过我们有一段javascript代码需要运行，怎么在python中运行javascript呢？\n 首先保存一下javascript代码，叫 decode_func.js。内容如下：  const jsdom = require(\u0026quot;jsdom\u0026quot;); const { JSDOM } = jsdom; const dom = new JSDOM(`\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;`); window = dom.window; document = window.document; XMLHttpRequest = window.XMLHttpRequest; decode_func = window[\u0026quot;eval\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;})  然后用以下这段代码就可以了：  def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js()  调用的时候就用 res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d)\n最终代码如下：\n参考代码 import requests from bs4 import BeautifulSoup import os import time import random import lzstring import execjs import re import json def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] def get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;} def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js() def decode(s): x = lzstring.LZString() decoded_str = x.decompressFromBase64(s) return decoded_str.split(\u0026quot;|\u0026quot;) # p = \u0026quot;\u0026quot;\u0026quot;1h.14({\u0026quot;q\u0026quot;:7,\u0026quot;r\u0026quot;:\u0026quot;s t u v w x\u0026quot;,\u0026quot;y\u0026quot;:\u0026quot;7.1\u0026quot;,\u0026quot;A\u0026quot;:B,\u0026quot;C\u0026quot;:\u0026quot;6\u0026quot;,\u0026quot;D\u0026quot;:[\u0026quot;E.1.2\u0026quot;,\u0026quot;F.1.2\u0026quot;,\u0026quot;G.1.2\u0026quot;,\u0026quot;H.1.2\u0026quot;,\u0026quot;o.1.2\u0026quot;,\u0026quot;I.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;a.1.2\u0026quot;,\u0026quot;9.1.2\u0026quot;,\u0026quot;8.1.2\u0026quot;,\u0026quot;l.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;i.1.2\u0026quot;,\u0026quot;j.1.2\u0026quot;,\u0026quot;p.1.2\u0026quot;,\u0026quot;J.1.2\u0026quot;,\u0026quot;Y.1.2\u0026quot;,\u0026quot;L.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;K.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;18.1.2\u0026quot;,\u0026quot;1a.1.2\u0026quot;,\u0026quot;1g.1.2\u0026quot;,\u0026quot;1b.1.2\u0026quot;,\u0026quot;1c.1.2\u0026quot;,\u0026quot;1d.1.2\u0026quot;,\u0026quot;%1e%5%3%4%5%1f%4%3%12.1.2\u0026quot;],\u0026quot;19\u0026quot;:10,\u0026quot;Z\u0026quot;:11,\u0026quot;X\u0026quot;:\u0026quot;/W/z/V/6/\u0026quot;,\u0026quot;U\u0026quot;:0,\u0026quot;T\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;S\u0026quot;:R,\u0026quot;Q\u0026quot;:P,\u0026quot;O\u0026quot;:{\u0026quot;e\u0026quot;:N,\u0026quot;m\u0026quot;:\u0026quot;M\u0026quot;}}).n();\u0026quot;\u0026quot;\u0026quot; # a,c = 62,80 # k=['', 'jpg', 'webp', '9B', 'E5', '8B', '第02回', '27099', 'P0056', 'P0055', 'P0054', 'P0058', 'P0053', 'P0052', '', 'P0059', 'P0060', 'P0051', 'P0061', 'P0062', 'P0050', 'P0057', '', 'preInit', 'P0048', 'P0063', 'bid', 'bname', '总之就是非常可爱', 'fly', 'me', 'to', 'the', 'moon', 'bpic', '', 'cid', '354852', 'cname', 'files', 'P0044', 'P0045', 'P0046', 'P0047', 'P0049', 'P0064', 'P0068', 'P0066', 'GYeIdl7ujUrxJ1ls7JvwpQ', '1612951385', 'sl', '354596', 'prevId', '356912', 'nextId', 'block_cc', 'status', 'zzjsfckafmttm_lj2l', 'ps1', 'path', 'P0065', 'len', 'false', '35', 'BE', 'P0067', 'imgData', 'P0069', 'P0070', 'P0071', 'P0072', 'finished', 'P0073', 'P0075', 'P0076', 'P0077', 'E6', '9F', 'P0074', 'SMH'] # e = 0 # d = dict() # res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) # print(type(res)) # print(res) # get content of one chapter def get_content(title, url): create_dir(os.path.join(root_folder, title)) res = requests.get(f\u0026quot;https://manhuagui.com{url}\u0026quot;, random.choice(USER_AGENTS)) # print(res.text) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all(lambda tag:tag.name=='script', recursive=True) for item in items: txt = item.string # 必须是item.string, 不能是item.txt if txt and \u0026quot;return p;\u0026quot; in txt: # 如果tag里没有文字，txt==None parts = txt.split(\u0026quot;return p;}(\u0026quot;) part = parts[1][:-2] split_res = re.split(r',([0-9]+,[0-9]+,)', part) p = split_res[0][1:-1] split_res[1] = split_res[1][:-1] a, c = map(int, split_res[1].split(',')) k = split_res[2].split(\u0026quot;'['\u0026quot;)[0][1:] k = decode(k) e = 0 d = dict() res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) s = re.search('({.+})', res).group(0) # 找到一个由 {} 包裹的group info_dict = json.loads(s) files_list = info_dict[\u0026quot;files\u0026quot;] path_prefix = 'https://i.hamreus.com' + info_dict[\u0026quot;path\u0026quot;] i = 1 for file_name in files_list: complete_path = path_prefix + file_name[:-5] print(complete_path) res = requests.get(complete_path, headers=get_download_header()) img_name = os.path.join(root_folder, title, f'{i}.jpg') with open(img_name, 'wb') as file: file.write(res.content) file.flush() time.sleep(random.uniform(5.0, 10.0)) i += 1 # get manga url list def get_url_list(url): res = requests.get(url, random.choice(USER_AGENTS)) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('div', {\u0026quot;id\u0026quot;: \u0026quot;chapter-list-1\u0026quot;}) for manga_list in items: links = manga_list.find_all(\u0026quot;a\u0026quot;, recursive=True) links = links[1:] for link in links: title = link.get(\u0026quot;title\u0026quot;) ref = link.get(\u0026quot;href\u0026quot;) if title[-1] == '卷': continue print(f\u0026quot;{title}, {ref}\u0026quot;) get_content(title, ref) url = \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot; get_url_list(url)    注：上面这块代码被识别成lua语言了，样式出了点问题，可以在markdown里面指定语言，在第一个 ``` 后面加上语言名即可，如 ```python\n 后记 写这篇blog比玩爬虫本身还累啊，看来我果然不适合写作文（虽然我从小就深刻的明白这个道理）。不过这篇博客很大程度上也是写给自己看的，作为下次爬虫的参考（不知道下次爬虫要等到什么时候了）。\n以后可能会补点儿算法笔记，或者题解之类的。\n","date":"2021-02-01T22:45:03+08:00","permalink":"https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/","tags":["爬虫","python"],"title":"初学爬虫小记"},{"categories":["工程"],"contents":"起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动手开始构建咕咕已久的个人网站。\n由于我对自己的前端水平十分有数，所以想都没想就立刻放弃了“要不自己写一个网站？”的想法。\n后来想起之前逛过的ouuan大佬的博客非常好看，我的收藏夹里甚至还有他搭建博客的指南，就直接拿来用了，采用的是 hugo + even主题 + github actions，参考资料如下:\n https://ouuan.gitee.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 阅读指南 首先阅读ouuan的指南(上述链接)，然后使用他的hugo模版，按照模版里指示的进行clone。\nStep 2 Config的修改 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  Step 2.5 创建repository 因为我打算部署到github pages上，就在github上创建一个新的repository，叫tom0727.github.io\nStep 3 本地测试 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果(也可以边写边看效果，热加载真香)。最后用hugo命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了。\n注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 Github Settings 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5 Github Actions 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\n push到master以后，可以在repository的Actions页面查看一下deploy的情况：  Step 6 gitee镜像 因为github.io似乎被墙了，所以学ouuan弄了一个gitee镜像，教程的话参照这两个就可以了：\n https://jasonkayzk.github.io/2020/09/18/%E5%9C%A8Gitee%E6%90%AD%E5%BB%BAGithub-Pages/\n  https://github.com/yanglbme/gitee-pages-action\n gitee镜像的访问网址：tom0727.gitee.io\n注：在 hugo-blog/.github/workflows/sync.yml里记得设置一下on，不然触发不了自动部署。\n我这里设置的是：\non: push: branches: - master workflow_dispatch:  Step 7 评论区 评论区用很多种，我选用了utterances，部署步骤如下：\n 在Github上安装 utterances app，选择这个博客的repo 在 config.toml 中更改配置，将 [params.utterances] 下的 repo 改成这个repo的名字即可。（可以新开一个repo来储存评论，不过评论会以issues的形式出现在repo里，所以没必要新开一个）  一些其他的魔改 更改右上方的导航栏 先打开 view-source 的博客，找到导航栏的 class=\u0026quot;post-toc\u0026quot;。\n然后利用 Linux的根据content搜索文件，使用 grep -rnwl '.' -e 'post-toc-title' 找到相应的文件。最后在 ./themes/even/assets/sass/_partial/_post/_toc.scss 和 ./themes/even/assets/sass/_variables.scss 找到了相关信息。\n修改内容的宽度 ouuan大佬在 2021年04月11日 更新了一下博客的内容宽度，在大屏上显示效果更加优秀了。\n以下是ouuan的commit链接：\nfeat: use scrollbar for TOC feat: adjust widths\n修改了 themes/even/assets/js/even.js，themes/even/assets/sass/_partial/_post/_toc.scss，themes/even/assets/sass/_variables.scss。\n我在 2021年04月20日 直接复制并替换了这三个文件，之后如果需要revert，可以从github里找对应版本。\n增强搜索功能 ouuan大佬在 2021年05月16日 更新了博客的搜索功能，再复制粘贴就显得我很low了所以我选择 cherry-pick，步骤如下：\n git add remote ouuan https://github.com/ouuan/hugo-blog-template.git git fetch ouuan git log ouuan/master 查看得到这个修改的 commit ID git cherry-pick 01798429c1585662c50cf890fa7f92c9e3ca9c96  自定义 shortcodes 所谓 shortcode 就是一些模版，比如 {% question %} 之类的。\n如果要自定义 shortcode，可以在\nhugo-blog/themes/even/layouts/shortcodes/ 下面创建新的html文件，修改一下里面的 class，然后直接用就可以了。\n同样，shortcode也有一个图标，我至今没有找到这些图标是从哪里来的，但是可以在：\nhugo-blog/themes/even/assets/sass/_partial/_post/_admonition.scss 看到 shortcode 的其他样式，还有\n./themes/even/assets/sass/_iconfont.scss 看到一些图标的名称和对应 unicode 编号。\n目前自定义的 shortcode 有：\n center：让内容居中 small：让内部的图片变小（原理是 max-width:50%）  自定义页面 在 2021年06月09日，我参考 https://kenkoooo.com/atcoder#/table/ ，利用 Codeforces API 高仿一个类似的页面。经 kenkoooo 本人同意，现在已经上线在 这里 了。主要的技术点如下：\n 利用 python 和 Codeforces API 进行交互（因为 requests 有自动重试功能，而 CF 的 API 并不是太稳定）。数据以 contests.json 的形式存在 /static/ 中，/scripts/UpdateCF_Problems.py 用于更新这个 json，这个更新的过程已经设置在 Github Action 中了。 将写好的 html 文件放在 /layouts/_default/cf-problems.html 中（需要更改一下才能正常使用导航栏等模版，具体的看这个文件里的内容即可），再创建 /content/cf-problems.md（其中需要更改 layout = 'cf-problems'），最后在 /config.toml 中把这个页面挂在导航栏里面。对应的 css 和 js 文件我分别放在了 /static/css/cf-problems.css 和 /static/js/cf-problem.js（在 cf-problems.html 中引用的时候也要注意使用变量名）。 为了使得用户体验更好，/static/css/cf-problems.css 还 override 了部分模版的 style，比如使得 CF-problems 页面的宽度变成 95% 等等。 在电脑上测试手机端的 media query 的时候最好使用 Safari（在 Develop \u0026gt; Enter Responsive Design Mode，如果导航栏里面没有 Develop 的话需要手动打开一下），chrome 的体验真的挺差的。  • 附：kenkoooo 大佬用的是 react，我一是不会写 react，二是不太清楚 hugo 是否支持 react 写的页面，如果以后有需求的时候可以尝试一下。\n修改样式 我觉得数学公式字体有点小，发现可以更改模版里的 css 来修改样式。同理也可以增添一些其他的东西进去，比如 class 为 center 的 div。\n/Users/huzhenwei/hugo-blog/themes/even/assets/sass/_custom/_custom.scss\n更改css文件来源CDN cdn.bootcss.com 似乎炸了，导致 highlight.js 加载不出来，所以利用 grep 搜索到了 ./themes/even/layouts/partials/scripts.html 中的 highlight.js 来源 CDN 后进行了修改，cdnjs.cloudflare.com 快的飞起！\n置顶博客 要置顶一篇文章，只需要在markdown文件一开始加入 weight = 1 即可：\n+++ title = '[置顶]竞赛注意事项' date = 2022-09-19T10:26:35-05:00 draft = false categories = [''] tags = ['', ''] weight = 1 +++  一些注意事项  博客默认模版的最底部有一个 --more--，要把它删掉，否则预览的时候整个博客都会被预览出来。  结语 新的一轮折腾结束了，总体来说还是比较满意这个博客的，个人很喜欢这种极简风的博客，功能也比较全，某种意义上算是告别了在Microsoft Word里做笔记的生活（？），之后打算先补上爬虫的一些笔记，还有搬运一点Word上的笔记吧。\n","date":"2021-02-01T21:21:41+08:00","permalink":"https://tom0727.github.io/post/001-hugo-tutorial/","tags":["hugo","博客"],"title":"Hugo博客搭建小记"},{"categories":null,"contents":"Hello, this is Tom! If you have trouble visiting this site (especially for mainland China users), please try visit\nhttps://tom0727.gitee.io/\nAbout me  Undergraduate study CS @ HKU (The University of Hong Kong), Sep 2018 - June 2022 Graduate study CS @ UIUC (University of Illinois, Urbana-Champaign), Sep 2022 - Dec 2023 Competitive programmer   Resume  Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu_Resume.pdf  Links  Linkedin: Zhenwei Hu Codeforces:  Leetcode: tom0727  Contact  Email: huzhenweitom@gmail.com QQ/Wechat: 980409152  ","date":"2021-01-31T22:57:58+08:00","permalink":"https://tom0727.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://tom0727.github.io/search/","tags":null,"title":"搜索"}]