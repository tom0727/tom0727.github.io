[{"categories":["题解"],"contents":"题目链接 题意\n给定正整数 $c,d,x$，求正整数pair $(a,b)$ 的数量使得 $$c \\times lcm(a,b) - d \\times gcd(a,b) = x$$\n其中，共 $T \\leq 10^4$ 个testcase，$1 \\leq c,d,x \\leq 10^7$\n• $(a,b)$ 和 $(b,a)$ 不同，例如 $(1,6), (6,1)$ 算两个，但是 $(3,3),(3,3)$ 算一个。\n 题解 对于任意一个$(a,b)，$令 $l = lcm(a,b), ~g = gcd(a,b)$，则必然有 $g|l$。\n那么两边同除 $g$，我们有\n$$c \\times \\frac{l}{g} - d = \\frac{x}{g}$$\n这说明： $g|x$\n所以我们可以枚举 $x$的所有因子 $g$ （例如 $x = 12$，因子有 $g=1,2,3,4,6,12$），当我们已知 $g = gcd(a,b)$ 时，$l = lcm(a,b)$ 也可以计算出来。\n  怎么枚举 $x$ 的所有因子 $g$？\n for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } }    问题转化为：已知 $gcd(a,b), ~ lcm(a,b)$，如何求满足条件的 $(a,b)$ 数量？\n 发现 $gcd$ 为所有质因子的 $\\min$，而 $lcm$ 为所有质因子的 $\\max$。\n所以对于 $lcm(a,b)$ 的每一个质因子 $p_i$，看一下 $p_i$ 在 $lcm(a,b)$ 中出现的次数是否大于它在 $gcd(a,b)$ 中出现的次数即可。\n如果大于，我们可以将这个质因子 出现次数较小的分配给 $a$，或者给 $b$，所以答案乘上 $2$。\n如果等于，则这个质因子没有贡献，答案不变。\n实现过程中，直接令 $r = \\frac{lcm(a,b)}{gcd(a,b)}$，然后看一下 $r$ 有多少个质因子就可以了。\n设 $r$ 的质因子数量为 $m$，则 $ans = 2^m$\n  我们可以预处理出 每一个数的质因子数量，但是数组的上限 maxn 是多少？\n 注意到 $c\\times r - d = \\frac{x}{g}$，所以 $r = \\frac{x}{gc} + \\frac{d}{c}$，分母最小的情况下，$g = c = 1$，所以 $r = (x + d) \\leq 2\\times10^7$，只要预处理 maxn \u0026lt;= 2e7 的部分即可。\n  怎么预处理出每一个数的质因子数量？\n 有两种方法，比较简单的是直接用 Eratosthenes 筛法，还有一种是欧拉筛 + dp。\n法一：Eratosthenes 筛法\nint sum[maxn]; // 每个数的质因子出现个数 void init() { for (int i = 2; i \u0026lt;= maxn-5; i++) { if (sum[i] == 0) { // i为质数 for (int j = i; j \u0026lt;= maxn-5; j += i) sum[j]++; } } }  因为 $j$ 是从 $i$ 开始的，所以复杂度为 $O(n\\log n)$\n法二：欧拉筛 + dp\nbool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; // dp，继承之前的质数数量 if (i % cur) sum[tar]++; // 如果 i 和 cur互质，说明 cur 是一个没用过的质数 if (i % cur == 0) break; } } }   复杂度：$O(n)$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 2e7+5; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int sum[maxn]; ll a,b,x,ans = 0; void cal(ll g) { ll l = (b*g + x); if (l % (a * g)) return; ans += (1LL \u0026lt;\u0026lt; (sum[l/(a*g)])); } bool p[maxn]; vector\u0026lt;int\u0026gt; primes; void init() { fill(p, p+maxn, 1); p[1] = 0; sum[2] = 1; for (int i = 2; i \u0026lt;= maxn-5; i++) { if (p[i]) { primes.push_back(i); sum[i] = 1; } for (int j = 0; j \u0026lt; primes.size(); j++) { int cur = primes[j]; ll tar = cur * i; if (tar \u0026gt;= maxn) break; p[tar] = 0; sum[tar] = sum[i]; if (i % cur) sum[tar]++; if (i % cur == 0) break; } } } int main() { int T; cin \u0026gt;\u0026gt; T; init(); while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; x; ans = 0; for (int g = 1; g * g \u0026lt;= x; g++) { if (x % g == 0) { cal(g); if (x/g != g) cal(x/g); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-22T23:47:16+08:00","permalink":"https://tom0727.github.io/post/034-cf-1499d/","tags":["数学"],"title":"CF 1499D（数学，筛法）"},{"categories":["算法"],"contents":"介绍 数位DP是指这样一类题型：\n给定一些限定条件，求 $[L,R]$ 内满足这些条件的数字数量，一般 $L,R$ 可能非常大（例如$10^{18}, 10^{1000}$）\n限定条件的一些例子：\n例1. 不含前导0，相邻两个数字差至少为2\n例2. 不包含4，不包含62\n例3. 存在长度至少为2的回文子串\n算法 首先，求 $[L,R]$ 内满足条件的数字数量，可以转化为 先求 $[1,R]$，再减去 $[1,L-1]$ 的部分。\n然后，因为数字很大，所以把它拆成每一位数来看，就可以进行 DP 或者 记忆化搜索 了。\n记忆化搜索 经典的搜索状态有：\n 当前在第几位数：int pos 是否含有前导0：bool zero 当前数字的前面部分，是否受到最大值限制：bool limit 前一位使用的数字 int pre  • 上述部分状态，有可能用不到。\n• 可能有额外状态，根据题目具体来定。\n• 一般来说，记忆化用到的 dp 数组，不需要记录 zero 和 limit。\n• 记忆化搜索的代码难度远远小于递推。\n 记忆化搜索时，有以下需要注意的点：\n 将数位 从低到高 进行排列（因为也许可以重复利用），从高位开始，往低位搜。 有前缀 $0$ 时（zero = 1），注意其他的搜索状态全部清零。（因为有前缀 $0$ 就相当于我们刚刚开始搜索） dp 数组初始化为 -1，一般每次搜索都要重新 memset(dp, -1, sizeof(dp)) dp 数组记录的状态是 (!limit \u0026amp;\u0026amp; !zero) 的状态（即，无任何限制的情况），这样才可以利用。当 (limit || zero) 时，我们需要继续搜索。  DP DP • 因为不推荐这么写，所以折叠了。\n本质和记忆化搜索相同，DP速度可能较快，但是一般很难写，一般有两种写法：\n 写法一：\n令 dp 数组记录 严格小于数字 $x$ 的满足条件的数量。\n将数位按照 高位到低位 排好，然后对于前缀等于 $x$ 的那些数，进行单独处理。\n这种写法可以见 ABC194F的题解\n 写法二：\n将数位按照 低位到高位 排好。（注意，和上面相反）\n预处理出 dp 数组（不带任何限制）。\n预处理以后，对于每一个询问，都直接进行处理，有3种情况：\n(以下的 $n$ 指的是当前询问数字 $x$ 的数位个数)\n 数字使用的位数 $\u0026lt; n$，则没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $\u0026lt; arr[n]$，也没有任何限制，直接加上即可。 数字使用的位数 $= n$，且最高位的数字 $= arr[n]$，则我们需要从最高位的前一位 n-1 开始，对于每一位 i，都枚举当前使用的数字 j = 0,1,...,arr[i]-1，然后再到前一位 i-1。   为什么不枚举 j = arr[i] 的情况？\n 注意到 dp 数组里表示的是不带任何限制的数量，当 j = arr[i] 时，更高位的数字都被固定为 $x$ 的高位部分了，所以是有限制的，不能算进去。\n以下给出 SCOI2009 windy 数 的写法：\nll dp[12][12]; int arr[12]; void init() { // 处理无限制的部分 for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数 = p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数 = p，最高位 == arr[p] for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果高位固定的部分已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; // 检查一下这个数字 arr[] 本身是否满足条件 return ans; }  注：在DP处理高位 等于 $x$的高位 时，一定要注意 高位的数字都已经被固定了，所以需要算进答案里，或者需要检查一下被固定的数是否满足条件了。\n注：最后要单独检查一下 这个数字 $x$ 本身是否满足条件。\n 例题 例1 洛谷P2657 Windy数 题意\n给定 $a,b \\leq 2 \\times 10^9$，求 $[a,b]$ 内满足以下条件的数字数量：\n 不含前导 $0$ 两个数字之差至少为 $2$   代码-DP法二 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[12][12]; int arr[12]; void init() { for (int j = 0; j \u0026lt;= 9; j++) dp[1][j] = 1; for (int i = 2; i \u0026lt;= 11; i++) { for (int j = 0; j \u0026lt;= 9; j++) { for (int k = 0; k \u0026lt;= 9; k++) { if (abs(j-k) \u0026lt; 2) continue; dp[i][j] += dp[i-1][k]; } } } } int p; bool check() { for (int i = 2; i \u0026lt;= p; i++) { if (abs(arr[i] - arr[i-1]) \u0026lt; 2) return 0; } return 1; } ll solve(int a) { if (!a) return 0; p = 0; while (a) { arr[++p] = a % 10; a /= 10; } ll ans = 0; for (int i = 1; i \u0026lt;= p-1; i++) { for (int j = 1; j \u0026lt;= 9; j++) ans += dp[i][j]; // Case1: 位数 \u0026lt; p } for (int j = 1; j \u0026lt; arr[p]; j++) ans += dp[p][j]; // Case2: 位数=p，最高位 \u0026lt; p for (int i = p-1; i \u0026gt;= 1; i--) { // Case3: 位数=p，最高位=p for (int j = 0; j \u0026lt;= arr[i]-1; j++) { // 枚举第i位 \u0026lt; arr[i]的情况 (等于的情况需要单独来处理) if (abs(j - arr[i+1]) \u0026lt; 2) continue; ans += dp[i][j]; } // 第i位 == arr[i] 时, 如果前缀已经不满足了，就不用看后面了 if (abs(arr[i] - arr[i+1]) \u0026lt; 2) break; } if (check()) ans++; return ans; } int main() { init(); int a,b; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; a; int r = solve(a) - solve(b-1); cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; }   例2 洛谷P2602 数字计数 题意\n给定两个正整数 $a \\leq b \\leq 10^{12}$，求 $[a,b]$ 内的所有整数中，每个 digit 出现的次数。\n 题解 我们枚举每一个digit，然后进行记忆化搜索即可。\n记忆化搜索一般比较模版化，其中 zero, limit 的套路是可以背下来的。\n对于本题，枚举每一个digit $cur$，令 $dp[i][j]$ 表示到了 第 $i$ 位，包含 $j$ 个 $cur$的数字数量。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll a,b; ll dp[14][14]; // dp[i][j]: 到第i位，包含j个cur的数的数量 int arr[14]; // 数字x的各个数位 （从低位到高位） int n; // 数字x的长度 int cur; // 当前枚举的数字 (0...9) // pos: 当前到了第几位 // cnt: 当前数字包含了 cnt 个 cur // zero: 是否有前缀 0 // limit: 前面部分是否完全等于高位 ll dfs(int pos, int cnt, bool zero, bool limit) { if (pos \u0026lt;= 0) { return cnt; } if (!zero \u0026amp;\u0026amp; !limit \u0026amp;\u0026amp; dp[pos][cnt] != -1) // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时获得dp值，否则继续往下搜索 return dp[pos][cnt]; int ed = 9; if (limit) ed = arr[pos]; // 如果前面完全等于高位，那么这一位不能超过当前位 ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) res += dfs(pos-1, 0, 1, 0); // 如果仍然保持前缀 0，那么记得将 cnt 清零，limit也要清零。 else { res += dfs(pos-1, cnt + (j == cur), 0, limit \u0026amp;\u0026amp; (j == arr[pos])); } } if (!zero \u0026amp;\u0026amp; !limit) dp[pos][cnt] = res; // 只有在 (!zero \u0026amp;\u0026amp; !limit) 时记录dp值 return res; } ll solve(ll x) { n = 0; memset(dp, -1, sizeof(dp)); while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 1, 1); // 从高位开始 } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (cur = 0; cur \u0026lt;= 9; cur++) { cout \u0026lt;\u0026lt; solve(b) - solve(a-1) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   例3 洛谷P3413 萌数 题意\n给定两个正整数 $L \\leq R \\leq 10^{1000}$，求满足以下条件的数字数量：\n $x \\in [L,R]$ $x$ 包含长度至少为2的回文子串 $x$ 没有前缀 $0$   题解 我们只需要考虑长度为 $2$ 或者 $3$ 的回文子串即可（因为 $\u0026gt;3$ 的情况已经被它们两个包含了）。\n那么我们可以设定 dp 数组为：\n$dp[i][j][k][0/1]$：我们当前在第 $i$ 位，往前 $2$ 位的数字为 $j$，往前 $1$ 位的数字为 $k$，且 不包含（0）/ 包含（1） 回文子串 的数字数量。\n注意到，最后一维度判断了是否包含回文子串。因为一个数有可能 前面几位没有回文子串，但是 后来又有了。如果我们只记录 包含 的情况，会漏掉很多答案。\n而 dfs() 函数的意思是：我们从当前这个状态出发，能获得多少符合条件的数字。\n 注：因为本题数字过大，所以不采用减去 $dfs(L-1)$ 的形式，而是 减去 $dfs(L)$，然后特判一下 $L$ 本身是否满足。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[1002][11][11][2]; string s; int n; ll dfs(int pos, int pre2, int pre1, bool zero, bool limit, bool moe) { if (pos \u0026gt;= n) { return moe; } int ed = 9; if (limit) ed = s[pos] - '0'; if (!limit \u0026amp;\u0026amp; !zero \u0026amp;\u0026amp; dp[pos][pre2][pre1][moe] != -1) return dp[pos][pre2][pre1][moe]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { if (!j \u0026amp;\u0026amp; zero) (res += dfs(pos+1, 10, 10, 1, 0, 0)) %= mod; else { (res += dfs(pos+1, pre1, j, 0, limit \u0026amp;\u0026amp; (j == ed), moe || (j == pre1 || j == pre2))) %= mod; } } if (!limit \u0026amp;\u0026amp; !zero) dp[pos][pre2][pre1][moe] = res; return res; } ll solve(string a) { n = a.size(); if (n \u0026lt;= 1) return 0; memset(dp, -1, sizeof(dp)); s = a; return dfs(0, 10, 10, 1, 1, 0); } bool check(string s) { int n = s.size(); for (int i = 0; i \u0026lt; n-1; i++) { if (s[i] == s[i+1]) return 1; if (i+2 \u0026lt; n \u0026amp;\u0026amp; s[i] == s[i+2]) return 1; } return 0; } int main() { string a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll r = solve(b) - solve(a); r += check(a); cout \u0026lt;\u0026lt; (r % mod + mod) % mod \u0026lt;\u0026lt; endl; }   例4 洛谷P4127 同类分布 题意\n给定两个正整数 $a,b \\leq 10^{18}$，求 $[a,b]$ 中，各位置上数字之和 能够整除该数字 的数字个数。\n 题解 可以发现最大的数字只有 $18$ 个 $9$，所以最大的数位和就是 $18 \\times 9 = 162$。\n所以我们可以枚举数位和 $cur$，然后找到符合以下条件的数字 $x$ 的数量：\n $x \\in [a,b]$ $x$ 各位置上数位和 等于 $cur$ $x \\text{ mod } cur = 0$  令 dp 数组为：\n$dp[i][j][k]$：当前到了第 $i$ 位，数位和为 $j$，数字本身 $\\text{mod } cur = k$ 的数字数量。\n 注意到本题不关心前缀 $0$，因为就算有前缀 $0$，也不会对 dfs() 内的其他参数 $sum, v$ 产生任何影响，也不会对枚举当前位使用的数字 $j$ 产生影响，所以可以舍去了。\n 有一个很重要的优化（在多testcase的情况下，优化程度极大）：\n注意到代码里面：\nfor (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); }  我们在 solve(b) 结束后，并没有 memset(dp, -1, sizeof(dp));\n这是因为我们的 dfs() 是从高位开始，枚举到低位。因为 dp[] 数组里保存的都是 !limit 的无限制情况，所以这里面的内容是可以重复利用的！\n但是对于 不同的 cur 就不能重复利用了，因为数组本身的意义已经不同了。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll dp[19][163][163]; int arr[19]; int n; int cur; ll dfs(int pos, int sum, int v, bool limit) { // sum为数位和，v为 x % cur 的值 if (!pos) { return (sum == cur) \u0026amp;\u0026amp; (!v); } if (!limit \u0026amp;\u0026amp; dp[pos][sum][v] != -1) return dp[pos][sum][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { res += dfs(pos-1, sum + j, (v * 10 + j) % cur, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][sum][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n, 0, 0, 1); } int main() { memset(dp, -1, sizeof(dp)); ll a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll ans = 0; for (cur = 1; cur \u0026lt;= 162; cur++) { memset(dp, -1, sizeof(dp)); ans += solve(b) - solve(a-1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例5 CF55D Beautiful numbers 题意\n给定正整数 $L \\leq R \\leq 9 \\times 10^{18}$，求满足以下条件的数字 $x$ 的数量：\n $x \\in [L,R]$ $x$ 能够被它每一位上的数字整除  共有 $T \\leq 10$ 个 testcase\n 题解 $x$ 可以被每一位上的数字整除 $\\iff$ $x \\text { mod } lcm = 0$\n其中 $lcm$ 是 $x$ 每一位上的数字的 $lcm$。\n发现 $lcm(1,2,\u0026hellip;,9) = 2520$，所以我们可以大致得出以下的状态：\n$dp[i][j][k]$：我们来到了第 $i$ 位，$j$ 表示我们使用了哪些数字，$k$ 代表当前数字 $x \\text { mod } 2520$ 的值。\n这样最后在 pos == 0 时，判断一下 $j$ 对应的 $lcm$，然后判断 $k \\text { mod } lcm_j = 0$ 是否成立即可。\n 现在问题是，这个 $j$ 怎么表示？（$j$ 代表 $x$ 用了 $0,1,2,\u0026hellip;9$ 中的哪些数字）\n可以用状压来实现，其中忽略掉 $0,1$，只记录是否包含 $2,3,\u0026hellip;,9$。大概有 $2^8 - 1$ 种状态，但是这样仍然会 $TLE$，怎么办？\n我们发现，记录使用了哪些数字，只是为了求出这些数字的 $lcm$，那我们直接记录 $lcm$ 作为状态即可！\n但是好像维度反而变大了，因为 $lcm$ 最大可以达到 $2520$，比之前状压的 $2^8 - 1$ 还大。\n 再观察一下，发现我们只关心有效的 $lcm$ 值，$2520$ 内的绝大多数值是无效的，所以我们可以枚举出所有 有效的 $lcm$，而这些有效的 $lcm$ 就是 $2520$ 的所有因子。总共只有 $48$ 个。\n所以我们只需要进行一次 离散化 的操作，将这些因子 map 到 $0,1,2,\u0026hellip;,47$，这样 $j$ 就可以只用 $48$ 个数字来表示了。\n 最后就是 memset(dp, -1, sizeof(dp)) 的优化了，因为本题的 dp[] 数组在不同的 case 之间的含义没有任何变化（都是 $\\text {mod } 2520$），所以只在一开始 memset 一次，之后就一直重复利用。\n• 本题的 memset 优化非常重要，因为有 $T = 10$ 个 case ，大概会有 $2 \\times T = 20$ 倍左右的速度差（如果不优化会 $TLE$ 的很惨）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 2520; ll dp[20][49][2520]; int idx[2521]; int n = 0, arr[20]; int gcd(int a, int b) { if (!b) return a; return gcd(b, a%b); } int LCM(int a, int b) { return a/gcd(a,b)*b; } vector\u0026lt;int\u0026gt; fac; void init() { for (int i = 1; i \u0026lt;= sqrt(mod); i++) { if (mod % i == 0) { fac.push_back(i); if (i != mod/i) fac.push_back(mod/i); } } sort(fac.begin(), fac.end()); for (int i = 0; i \u0026lt; fac.size(); i++) { idx[fac[i]] = i; // 离散化，例如 idx[1] = 0, idx[2520] = 47 } } // lc 代表当前的 lcm, v 代表 x % 2520 的值 ll dfs(int pos, int lc, int v, bool limit) { if (pos \u0026lt;= 0) { return v % lc == 0; // 注意，只有在 pos == 0时，才判断 % lc，其余情况都是 % 2520 } if (!limit \u0026amp;\u0026amp; dp[pos][idx[lc]][v] != -1) return dp[pos][idx[lc]][v]; int ed = 9; if (limit) ed = arr[pos]; ll res = 0; for (int j = 0; j \u0026lt;= ed; j++) { int newval = (v * 10 + j) % mod; if (j \u0026lt; 2) res += dfs(pos-1, lc, newval, limit \u0026amp;\u0026amp; (j == ed)); else res += dfs(pos-1, lcm(lc, j), newval, limit \u0026amp;\u0026amp; (j == ed)); } if (!limit) dp[pos][idx[lc]][v] = res; return res; } ll solve(ll x) { n = 0; while (x) { arr[++n] = x % 10; x /= 10; } return dfs(n,1,0,1); } int main() { init(); int T; cin \u0026gt;\u0026gt; T; memset(dp, -1, sizeof(dp)); // 注意，只进行一次 memset while (T--) { ll l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; cout \u0026lt;\u0026lt; solve(r) - solve(l) \u0026lt;\u0026lt; endl; } }   ","date":"2021-03-18T10:53:51+08:00","permalink":"https://tom0727.github.io/post/033-%E6%95%B0%E4%BD%8Ddp/","tags":["数位dp","数学","dp"],"title":"数位DP"},{"categories":["题解"],"contents":"主要记录一些遇到的线段树/分块例题。\n例1 CF438D 题意\n给定 $N$ 个正整数和 $M$ 个询问，询问有 3 种：\n$1 ~ l ~ r$：输出 $\\sum\\limits_{i=l}^r a_i$\n$2 ~ l ~ r ~ x$：将 $a_l$ 到 $a_r$ 的所有数取 $\\text{mod } x$\n$3 ~ k ~ x$：将 $a_k = x$\n其中，$1 \\leq N,M \\leq 10^5, 1 \\leq a_i,x \\leq 10^9$\n 题解 本题分块和线段树都可以做，我们这里用 线段树 来做。\n主要是需要考虑 区间取模 怎么办？\n回忆一下分块例题中的 区间开方，我们维护了一个额外的tag表示这个区间是否为 全0/全1，如果不是 全0/全1 就暴力开方。\n取模操作同理，我们发现，如果 $a_i \u0026gt; x$，那么 $a_i \\text{ mod } x \\leq \\frac{a_i}{2}$，所以对于每个 $a_i$，最多只会被 $\\text{mod}$ $\\log (a_i)$ 次！\n所以，我们维护一个 区间最大值，取模时，检查一下 区间最大值是否大于 $x$：\n 如果大于 $x$，就继续往下递归。 如果小于 $x$，就直接返回。  base case 就是区间长度为 $1$ 时，直接对这个元素开方即可。\n 例2 CF558E 题意\n给定一个长度为 $n$ 的string，仅包含小写字母。给 $q$ 个询问：\n$l,r,k$：将string的 $[l,r]$ 进行sort，如果 $k=1$ 就升序，$k=0$ 降序。\n输出所有询问结束后的string。\n其中，$1\\leq n \\leq 10^5, 1 \\leq q\\leq 50000$\n 题解 线段树来处理。\n首先，string只包含小写字母。所以每个 node 可以维护一个 cnt[26] 代表这个node里的每个字母出现的次数。\n其次，对于排序，我们在每个 node 中维护一个标记 $k$ 来代表该区间是否排序好了。若 $k=0$ 代表降序，$k=1$ 代表升序，$k = -1$ 代表乱序。\n最后，维护一个 $lazy$ 标记，我们会注意到对于一个node而言，若 $lazy = 1$，那么这个 node 必然是排序好了的！（要么 $k=0$ ，要么 $k=1$）。\n有了以上信息，我们就可以进行 sort 操作了！\n sort $[L,R]$ 的时候，步骤如下：\n 提取出 $[L,R]$ 内每个字母出现的次数。 求出 $[L,R]$ 与 $[l,mid]$（当前node 左child的范围）的区间交集 $[l_1,r_1]$ 求出 $[L,R]$ 与 $[mid+1, r]$（当前node 右child的范围）的区间交集 $[l_2,r_2]$ 用指针遍历 $a-z$（或者 $z-a$），根据升序/降序 将 字母出现的次数分别填充 到 左child和右child的 cnt[] 中。（注意，这里的填充是指：先填充进一个 int* buf = new int[26]; 的动态数组，然后将 buf[] 作为参数，再往下传递，直到区间完全覆盖，再将 buf[] 的内容复制进 cnt[] 里）。   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+10; int n,q; char arr[maxn]; struct Node { int l,r,k,cnt[26]; bool lazy = 0; } tr[4*maxn]; int tmp[26]; inline int len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; for (int i = 0; i \u0026lt; 26; i++) { tr[cur].cnt[i] = tr[lc].cnt[i] + tr[rc].cnt[i]; } if (tr[lc].k != -1 \u0026amp;\u0026amp; tr[lc].k == tr[rc].k) tr[cur].k = tr[lc].k; // k = 1: increasing, k = 0: decreasing else tr[cur].k = -1; } void put(int cur, int k) { int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; memset(tr[lc].cnt, 0, sizeof(tr[lc].cnt)); memset(tr[rc].cnt, 0, sizeof(tr[rc].cnt)); memcpy(tmp, tr[cur].cnt, sizeof(tmp)); int lsz = len(lc), rsz = len(rc); if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p++; } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, tmp[p]); tr[lc].cnt[p] += delta; lsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, tmp[p]); tr[rc].cnt[p] += delta; rsz -= delta; tmp[p] -= delta; if (!tmp[p]) p--; } } assert(lsz == 0); assert(rsz == 0); } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; tr[cur].lazy = 0; tr[lc].lazy = tr[rc].lazy = 1; assert(tr[cur].k != -1); int k = tr[cur].k; tr[lc].k = k; tr[rc].k = k; put(cur,k); } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { memset(tr[cur].cnt, 0, sizeof(tr[cur].cnt)); tr[cur].cnt[arr[L]-'a'] = 1; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } int ress[26]; // 每次query的结果会存到这里 void clear(int* buf) { for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; } int inter(int l1, int r1, int l2, int r2) { // 求区间交集的长度 int l = max(l1,l2), r = min(r1,r2); return max(0,r-l+1); } void update(int cur, int L, int R, int k, int* res) { // 注意参数里有个动态数组 res int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].k = k; tr[cur].lazy = 1; for (int i = 0; i \u0026lt; 26; i++) tr[cur].cnt[i] = res[i]; // 区间完全覆盖，复制到 cnt 中。 clear(res); // 记得清空，之后可能还要用 return; } int mid = (l+r) \u0026gt;\u0026gt; 1; int lsz = inter(l,mid,L,R), rsz = inter(mid+1,r,L,R); int* buf = new int[26]; // 这里采用了动态数组 for (int i = 0; i \u0026lt; 26; i++) buf[i] = 0; //注意new出来的需要先清空一下，另外不能使用 memset(因为是指针) if (k) { int p = 0; while (p \u0026lt; 26 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026lt; 26 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p++; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } else { int p = 25; while (p \u0026gt;= 0 \u0026amp;\u0026amp; lsz) { int delta = min(lsz, res[p]); buf[p] += delta; lsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (L \u0026lt;= mid) { update(lc, L, R, k, buf); // 传递 buf } while (p \u0026gt;= 0 \u0026amp;\u0026amp; rsz) { int delta = min(rsz, res[p]); buf[p] += delta; rsz -= delta; res[p] -= delta; if (!res[p]) p--; } if (R \u0026gt; mid) { update(rc, L, R, k, buf); // 传递 buf } } delete[] buf; assert(lsz == 0); assert(rsz == 0); push_up(cur); } void query(int cur, int L, int R) { // 求区间内每个字母出现的个数 int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { for (int i = 0; i \u0026lt; 26; i++) ress[i] += tr[cur].cnt[i]; return; } int lc = cur\u0026lt;\u0026lt;1, rc = lc+1; push_down(cur); int mid = (l+r) \u0026gt;\u0026gt; 1; if (L \u0026lt;= mid) query(lc, L, R); if (R \u0026gt; mid) query(rc, L, R); push_up(cur); } void printans() { for (int i = 1; i \u0026lt;= n; i++) { memset(ress, 0, sizeof(ress)); query(1,i,i); for (int j = 0; j \u0026lt; 26; j++) { if (ress[j]) { printf(\u0026quot;%c\u0026quot;,(char)('a'+j)); ress[j]--; break; } } } printf(\u0026quot;\\n\u0026quot;); } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;q); scanf(\u0026quot;%s\u0026quot;, arr+1); build(1, 1, n); while (q--) { int l,r,k; scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;l,\u0026amp;r,\u0026amp;k); memset(ress, 0, sizeof(ress)); query(1,l,r); update(1,l,r,k,ress); } printans(); }  ","date":"2021-03-16T22:10:22+08:00","permalink":"https://tom0727.github.io/post/032-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BE%8B%E9%A2%98/","tags":["暴力优化","线段树"],"title":"线段树/分块 例题"},{"categories":["算法"],"contents":"介绍 树上启发式合并 一般用于 满足以下条件的问题：\n 所有询问离线，无修改，仅询问子树的信息（不能用于链的询问） $ans[u]$ 可以转化为 $\\sum\\limits_{v}ans[v]$ 的形式（其中，$v$ 是 $u$ 的child） 如果已知 $ans[v]$，可以在 $O(1)$ 的时间（或者无需任何操作）添加到 $ans[u]$ (其中，$v$ 是 $u$ 的child）   先用 CF600E 来举个例子。\n题意\n已知一棵包含 $N$ 个节点的有根树（root为 $1$），每个节点 $i$ 有一个颜色 $c_i$。\n对于每一个节点 $i$，我们都要求出它的 subtree（包含自己）中，出现颜色次数最多的所有颜色编号和（可能不止一种颜色）。\n例：$1$ 的subtree中，共有 5 个节点，颜色分别为 $2,2,5,5,1$，那么出现颜色次数最多的颜色编号为 $2,5$，所求的和为 $2+5 = 7$，所以 $ans_1 = 7$。\n输出对于每一个 $i$ 的 $ans_i$\n其中，$1\\leq n \\leq 10^5, 1 \\leq c_i \\leq n$\n 思想 暴力做法 首先，我们开一个全局的数组 cnt[]，记录每一种颜色出现的次数。再开一个全局数组 sum[]，其中 sum[i] 代表出现次数为 i 的颜色的编号和。\n然后，对于每一个节点 $i$，遍历它 subtree 中的所有节点，统计答案。统计完以后，清空这两个全局数组，再换下一个节点重复此步骤。\n复杂度：$O(n^2)$\n优化思路 • 注：以下 $u$ 均表示parent，$v$ 表示 $u$ 的child。\n我们发现，对于任何一个节点 $u$ ，$cnt[u] = \\sum\\limits_v cnt[v]$ ，$sum[u] = \\sum\\limits_v sum[v]$ （这里不是指真的sum，而是说我们可以通过所有child的信息合并，得到 $u$ 的信息）。\n那么，我们的暴力思路是：\n来到节点 $u$ 时，\n 先统计所有 $v$ 的答案 $ans_v$（代表 $v$ 对应subtree的答案），每统计完一个 $v$ 就清空一次全局数组。 全部的 $v$ 统计完以后，再遍历所有的 $v$ 的subtree，把所有 $v$ 的 cnt[], sum[] 进行合并。 加上 $u$ 本身，就得到了 $u$ 所在subtree的答案 $ans_u$。  这里我们发现了一个可以优化的地方：\n对于最后一个 $v$，我们统计完它以后，不需要清空全局数组，因为我们马上就要进行 Step 2，刚好需要合并所有 $v$ 的信息，所以保留它就可以节省一些时间。\n那么这最后一个 $v$，所对应的subtree 自然是 size 越大越好。所以我们就选择 $u$ 的重儿子作为最后一个 $v$。\n这就是树上启发式合并了，复杂度为 $O(n\\log n)$，证明见下面。\n算法步骤  创建全局数组（一般是 cnt[] 一类的数颜色数组）。 进行第一次 $DFS$（$dfs_1$），获得每个节点的 sz[]（subtree大小），son[]（重儿子）。 进行第二次 $DFS$（$dfs_2$），来到节点 $u$ 后：  先递归 $DFS(v)$，对于每一个 $v$（除了重儿子以外），获得 $ans_v$。然后清空全局数组。 递归 $DFS(x)$，获得 $ans_x$（其中，$x$ 是 $u$ 的重儿子）。不清空全局数组。 遍历所有 $v$ 的subtree（除了重儿子以外），把信息加到全局数组上。（注意，这里的遍历并不是上面的 $DFS(v)$，一般实现过程中，用 add(v, 1) 来表示）。 加上 $u$ 自己的信息，得到 $ans_u$。    伪代码 void dfs1(int u, int p) { //略，普通的统计 sz[] 和 son[] } void add(int u, int f) { // 单点更新信息 cnt[u] += f; if (f \u0026lt; 0) maxcnt = 0; //因为 f \u0026lt; 0 时意味着全局数组清空，所以一些额外的全局变量也会清空 } void add(int u, int p, int f) { // 遍历subtree，加到数组上。f = 1（加上信息）或者 -1（清空信息） add(u, f); // 单点更新 for (v : child[u]) { if (v == p) continue; add(v, u, f); } } void dfs2(int u, int p, bool keep) { // keep 代表该节点是否为重儿子（如果keep = 1就不清空数组） for (v : child[u]) { if (v == p || v == son[u]) continue; dfs2(v, u, 0); // Step1: 轻儿子不保留信息，keep = 0表示，在dfs2(v)结束后，全局数组不会有任何变化。 } if (son[u]) dfs2(son[u], u, 1); // Step2: 重儿子保留信息 for (v : child[u]) { if (v == p || v == son[u]) continue; add(v, u, 1); // Step3: 遍历所有v（除了重儿子以外），加上信息 } add(u, 1); // Step 4: 单点更新 u 的信息 ans[u] = (cnt[u] + ...); // Step4: 得到 ans[u] if (!keep) add(u, p, -1); // 如果keep = 0，说明需要清空数组，就把整个subtree(u)的影响再减掉就可以了 } int main() { init(); // 建树，预处理查询等 dfs(1, 0); dfs2(1, 0, 1); }  复杂度证明 对于任何一个节点 $u$，如果它被清空了，那么这说明它的某个祖先是轻儿子。而轻儿子的数量 = 重链数量 = $O(\\log n)$，所以每个节点最多被清空 $\\log n$ 次。总复杂度为 $O(n\\log n)$\n例题 例1 CF600E 题意和题解都讲了，就直接放代码了：\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int n, sz[maxn], head[maxn], ecnt = 1, color[maxn], son[maxn]; ll cnt[maxn], sum[maxn], ans[maxn], maxcnt = 0; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p) { sz[u] = 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void update(int u, int f) { // 单点更新 int c = color[u]; cnt[c] += (ll)f; sum[cnt[c]-f] -= (ll)c; sum[cnt[c]] += (ll)c; while (f \u0026gt; 0 \u0026amp;\u0026amp; sum[maxcnt+1]) maxcnt++; if (f \u0026lt; 0) maxcnt = 0; } void add(int u, int p, int f) { // f = 1: add, f = -1: del update(u, f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } update(u, 1); ans[u] = sum[maxcnt]; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; color[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例2 CF208E 题意\n已知一棵包含 $N$ 个节点的森林（可能有多个root），并且给出 $M$ 个询问。\n$v, p$：输出存在多少个点 $u$，使得 $u$ 和 $v$ 的第 $p$ 个祖先相同。\n其中，$1\\leq n,m \\leq 10^5$\n 法一树上莫队 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n那么，用 DFS序 先把树上问题转化为区间问题，就变成了：\n在区间 $[L,R]$ 内，有多少个 $u \\in [L,R]$ 使得 dep[u] = dep[x] + p ？\n然后用 莫队 来处理每个询问即可。\n 树上莫队代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, tmp[maxn]; int par[maxn][22]; int cnt[maxn], id[maxn], idcnt = 1; struct Edge { int to, nxt; } edges[maxm]; struct Query { int l,r,id,d; } q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; id[u] = idcnt++; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { // 注意这里先处理parent，之后再 dfs(to) par[u][j] = par[par[u][j-1]][j-1]; } for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; } } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void add(int x) { cnt[dep[x]]++; } void del(int x) { cnt[dep[x]]--; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } memcpy(tmp, dep, sizeof(dep)); for (int i = 1; i \u0026lt;= n; i++) dep[id[i]] = tmp[i]; cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int l,r,d; if (!p) l = 0; else l = id[p]; r = l + sz[p] - 1; d = dep[id[u]]; // find number of vertices in subtree of u, which has depth d q[i] = {l,r,i,d}; } int BLOCK = sqrt(n); sort(q+1, q+m+1, [\u0026amp;](auto a, auto b) { int be1 = (a.l-1) / BLOCK, be2 = (b.l-1) / BLOCK; if (be1 == be2) return a.r \u0026lt; b.r; return be1 \u0026lt; be2; }); int l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int L,R,ID,D; L = q[i].l, R = q[i].r, ID = q[i].id, D = q[i].d; if (!L) { ans[ID] = 0; continue; } while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026gt; L) add(--l); while (l \u0026lt; L) del(l++); ans[ID] = cnt[D] - 1; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   法二树上启发式合并 每次询问 $v,p$ 时，我们先用倍增求出 $v$ 的第 $p$ 个祖先 $x$。那么，问题转化为：\n在 $x$ 的 subtree中，有多少个 $u$，使得 dep[u] = dep[x] + p？\n可以发现，如果我们求出来了 child $v$ 的 cnt[] 信息（即，在 $v$ 的subtree内，每个 dep 对应的节点数量），则直接把 cnt[] 数组加到 parent $u$ 上即可。所以在继承重儿子 cnt[] 信息时，无需任何操作。\n这样就可以 树上启发式合并了！\n 树上启发式合并代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e5+5; const int maxm = 2e5+5; int dep[maxn], sz[maxn], head[maxn], ecnt = 1, ans[maxn], n, m, son[maxn]; int par[maxn][22]; int cnt[maxn]; struct Edge { int to, nxt; } edges[maxm]; struct Query { int id, d; }; vector\u0026lt;Query\u0026gt; q[maxn]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u) { sz[u] = 1; dep[u] = dep[par[u][0]] + 1; for (int j = 1; j \u0026lt; 22; j++) { par[u][j] = par[par[u][j-1]][j-1]; } int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; dfs(to); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) { maxsz = sz[to]; son[u] = to; } } } void add(int u, int f) { cnt[dep[u]] += f; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; add(to, f); } } void dfs2(int u, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; dfs2(to, 0); } if (son[u]) dfs2(son[u], 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == son[u]) continue; add(to, 1); } cnt[dep[u]]++; for (Query que : q[u]) { int id = que.id, d = que.d; ans[id] = cnt[d] - 1; } if (!keep) add(u, -1); } int jump(int u, int p) { for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= p; j++) { if ((1\u0026lt;\u0026lt;j) \u0026amp; p) u = par[u][j]; } return u; } void debug() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 2; j++) { printf(\u0026quot;i = %d, j = %d, par = %d\\n\u0026quot;,i,j,par[i][j]); } } } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int u; cin \u0026gt;\u0026gt; u; if (u) { addEdge(u, i); par[i][0] = u; } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs(i); } cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,p; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; p; p = jump(u, p); int d = dep[u]; // find number of vertices in subtree of u, which has depth d if (!p) ans[i] = 0; else { q[p].push_back({i,d}); } } for (int i = 1; i \u0026lt;= n; i++) { if (!par[i][0]) dfs2(i, 0); } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   例3 CF1009F 题意\n已知一棵包含 $N$ 个节点的有根树。\n设 $d(u,k)$ 为 $u$ 的subtree中，到 $u$ 距离为 $k$ 的节点数量。\n对于每一个点 $u$，输出一个最小的 $k$，使得 $d(u,k)$ 最大。\n其中，$1\\leq N \\leq 10^6$\n 题解  注意对于这一类型的问题，有些信息看起来是 vertex-dependent（和vertex本身有关，例如 到 $u$ 距离为 $k$）。但是我们转化一下，就可以将它变成一个静态的信息，比如：\n到 $u$ 距离为 $k$ $\\iff$ 深度等于 $dep[u] + k$\n这样，这个信息用一个 cnt[] 数组就可以继承了，例二也是同理。\n 用 cnt[] 数组记录每一个深度 $d$ 对应的数量，维护一个 maxcnt 和 cur，分别代表 $\\max\\limits_k \\{d(u,k)\\}$ 和 $k$ 的值。\n剩下就是启发式合并的板子了。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 1e6+5; const int maxm = 2e6+10; int head[maxn], dep[maxn], sz[maxn], son[maxn], n, ecnt = 1, cnt[maxn], ans[maxn]; struct Edge { int to, nxt; } edges[maxm]; void addEdge(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } void dfs1(int u, int p) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, u); sz[u] += sz[to]; if (sz[to] \u0026gt; maxsz) maxsz = sz[to], son[u] = to; } } int maxcnt = 0, cur = 1e9; void add(int u, int f) { int d = dep[u]; if (f \u0026gt; 0) { cnt[d]++; if (maxcnt \u0026lt; cnt[d]) { maxcnt = cnt[d]; cur = d; } if (maxcnt == cnt[d] \u0026amp;\u0026amp; cur \u0026gt; d) cur = d; } else { cnt[d]--; maxcnt = 0, cur = 1e9; } } void add(int u, int p, int f) { add(u,f); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, f); } } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); add(u, 1); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); } ans[u] = cur; if (!keep) add(u, p, -1); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; addEdge(u,v); addEdge(v,u); } dfs1(1,0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] - dep[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例4 CF741D 题意\n已知一棵包含 $N$ 个节点的有根树，每条边上有一个字符（a-v共22种）。\n定义 Dokhtar-kosh 路径为满足以下条件的路径：\n 简单路径（无环） 路径上的字符经过重新排序后，可以形成一个回文串  对于每一个节点 $u$，求 $u$ 所在子树中，最长的 Dokhtar-kosh 路径长度。\n其中，$1\\leq N \\leq 5 \\times 10^5$\n 题解 2900分的压轴题，很难。\n首先定义 $f_u$ 为：从 $1$（root）开始，一直到节点 $u$ 的路径所组成的字符序列。\n因为字符只有 a-v 22种，并且我们并不关心字符具体数量，只关心奇偶性，所以可以用 状压 来表示一个字符序列。\n例如：$1 \\rightarrow u$ 的路径上有 $a,a,b,b,b,c$，则对应的bitmask为：$000\u0026hellip;110$（$a$有偶数个，$b,c$有奇数个）。\n我们可以预处理出所有的 $f_u$，怎么得到 $u,v$ 之间路径对应的 $f$ 值？\n会发现：\n$$f_{u,v} = (f_u \\text{ xor } f_x) \\text{ xor } (f_v \\text{ xor } f_x) = f_u \\text{ xor } f_v$$\n其中，$f_{u,v}$ 代表 $u,v$ 之间路径对应的 $f$ 值，$x = LCA(u,v)$。\n 又发现，一个 Dokhtar-kosh 路径只要满足：$f_{u,v}$ 所包含的 $1$ 的数量 $\\leq 1$ 即可。\n例如 $f_{u,v} = 000\u0026hellip;000$ 或 $000\u0026hellip;001$ 或 $000\u0026hellip;010$ 等等…… 均满足条件。\n 所以，问题转化为：\n对于每一个节点 $x$，求 $x$ 所在子树中，距离最长的 $u,v$，使得 $f_{u,v} = f_u \\text{ xor } f_v$ 包含最多一个 $1$。\n 那么这就是一个比较标准的 树形dp 问题：\n定义 $dp[mask]$ 为，在当前的节点 $x$ 的 已探索子树 中，$f_u = mask$ 的 最深深度。（因为 $x$ 太多了，所以不能定义二维数组，只能用一个全局数组）。\n又发现这是关于深度的信息，可以直接向上传递，所以可以采用 树上启发式合并 进行转移。\n对于每一个节点 $u$，dp的转移方程如下：\n  路径完全存在于某一个child的子树内：从所有的child的子树中取最大值即可！ $$ans_u = \\max\\limits_v \\{ ans_v \\}$$\n  $u$ 本身和某一个 child 的子树中某一个节点 $v$ 组成路径： $$ans_u = \\max\\limits_v \\{dp[f_v] + dep[u]\\} - 2\\times dep[u]$$\n其中 $f_u \\text{ xor } f_v$ 只能包含最多一个 $1$。\n  $u$ 的子树中有两个节点 $a,b$ 跨过了 $u$，组成一条路径： $$ans_u = \\max\\limits_b \\{dp[f_a] + dep[b]\\} - 2 \\times dep[u]$$\n其中 $f_a \\text{ xor } f_b$ 只能包含最多一个 $1$。\n  其中，Case $1,2$ 都比较好处理。对于第三种情况，我们可以在 add() 函数中，遍历子树的时候顺便处理。\n 注意，树形dp中一定要注意更新的先后顺序，以免出现某个节点自己和自己形成路径的情况！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 5e5+5; const int maxm = 1e6+10; int head[maxn], ecnt = 1, dep[maxn], sz[maxn], son[maxn], ans[maxn], f[maxn], dp[(1\u0026lt;\u0026lt;22) + 5], masks[25], n; struct Edge { int to, nxt; char c; } edges[maxm]; void addEdge(int u, int v, char c) { Edge e = {v, head[u], c}; head[u] = ecnt; edges[ecnt++] = e; } void dfs(int u, int p, int mask) { sz[u] = 1; dep[u] = dep[p] + 1; int maxsz = -1; f[u] = mask; for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; int c = edges[e].c - 'a' + 1; dfs(to, u, mask ^ masks[c]); sz[u] += sz[to]; if (maxsz \u0026lt; sz[to]) { maxsz = sz[to]; son[u] = to; } } } int ori; void add(int u, int p, int sgn) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; add(to, u, sgn); } if (sgn \u0026gt; 0) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[ori] = max(ans[ori], dp[tar] + dep[u]); // 注意这里是 ori，因为更新的是 ans[ancestor] } } if (sgn \u0026lt; 0) dp[f[u]] = -1e9; // 这里清空，必须初始化为负无穷 } void update(int u, int p) { dp[f[u]] = max(dp[f[u]], dep[u]); for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; update(to, u); } } void add(int u) { for (int j = 0; j \u0026lt;= 22; j++) { int tar = f[u] ^ masks[j]; ans[u] = max(ans[u], dp[tar] + dep[u]); // Case 2: u 本身和 子树内某个节点 } } void update(int u) { dp[f[u]] = max(dp[f[u]], dep[u]); } void dfs2(int u, int p, bool keep) { for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; dfs2(to, u, 0); } if (son[u]) dfs2(son[u], u, 1); ori = u; // Case 3: 因为 add过程中，需要更新的是 ans[u]，所以用全局变量 ori 来传递。 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p || to == son[u]) continue; add(to, u, 1); // 树形dp注意点：先更新ans update(to, u); // 更新ans后，再更新dp数组！ } add(u); // 注意这里单点更新 update(u); // 注意这里单点更新 ans[u] -= 2 * dep[u]; // 这里要减去 2*dep[u] ans[u] = max(ans[u], 0); // 需要大于0，因为有可能是负数 for (int e = head[u]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; // Case1: 取每个子树的最大值 ans[u] = max(ans[u], ans[to]); // 注意，是在减去 2*dep[u] 以后，才取的max！ } if (!keep) add(u, p, -1); } int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; i++) { int p; char c; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; addEdge(i, p, c); addEdge(p, i, c); } for (int i = 1; i \u0026lt;= 22; i++) masks[i] = (1\u0026lt;\u0026lt;(i-1)); fill(dp, dp+(1\u0026lt;\u0026lt;22)+5, -1e9); dfs(1, 0, 0); dfs2(1, 0, 1); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/pb122401/article/details/84648993 https://codeforces.com/blog/entry/44351  ","date":"2021-03-15T20:53:14+08:00","permalink":"https://tom0727.github.io/post/031-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","tags":["树上启发式合并"],"title":"树上启发式合并（DSU on Tree）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc131/tasks/abc131_f\n题意\n给定 $N$ 个二维平面中的点 $(x_i,y_i)$，我们可以一直重复以下操作：\n选择 4 个整数 $a,b,c,d$，保证 $(a,b),(a,d),(c,b),(c,d)$ 中 有且仅有 3 个点存在，并在剩下的那个位置添加一个点。（即，形成一个长方形）\n我们一直重复此操作，求可以进行多少次？（可以证明，一定是有限次）\n其中，$1 \\leq N,x_i,y_i \\leq 10^5$，每个点互不相同。\n 题解 把每一个 $x$ 坐标当作一个 vertex，每一个 $y$ 坐标也当作一个 vertex。\n每个平面上的点当作一个 edge：例如一个点为 $(x_i,y_i)$，就把 $x_i$ 和 $y_i$ 之间连一个 edge。\n我们会发现：一个包含4个点的长方形，刚好就是 4个vertex + 4个edge。所以有：\n能够加一个点 $\\iff$ 4个点连通，且只有3个edge。\n扩展一下，如果有 $n$ 个 $x$ 坐标和 $m$ 个 $y$ 坐标形成同一个连通块，那么我们最多可以有 $n \\times m$ 个点（edge）（长方形中的每一个点都被填上了）。\n 所以，用并查集维护一下所有点形成的连通块，然后找到每个连通块的 $x,y$ 坐标个数。最终减去所有edge数量，即：\n$$ans = \\sum\\limits_i (n_i \\times m_i) - e$$\n  这题主要是学习一下 以坐标为 vertex，点为 edge 的思想\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 2e5+5; const int maxm = 1e5; int n; int par[maxn]; // [1...1e5] 储存x坐标，[1e5+1...2e5] 储存y坐标 int l[maxn], r[maxn]; //记录每个par对应的块有几个x，y坐标 int finds(int u) { if (par[u] == u) return u; return par[u] = finds(par[u]); } void unions(int u, int v) { u = finds(u), v = finds(v); if (u \u0026gt; v) swap(u,v); par[v] = u; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2*maxm; i++) par[i] = i; for (int i = 1; i \u0026lt;= n; i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unions(x, y+maxm); // y坐标对应的是 y+1e5 } for (int i = 1; i \u0026lt;= maxm; i++) { int u = finds(i); // x坐标 l[u]++; u = finds(i+maxm); // y坐标 r[u]++; } ll ans = 0; for (int i = 1; i \u0026lt;= 2*maxm; i++) { ans += (ll)(l[i]) * (ll)(r[i]); } ans -= n; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题  https://codeforces.com/contest/1012/problem/B （完全一样的思想）  ","date":"2021-03-12T21:48:23+08:00","permalink":"https://tom0727.github.io/post/030-at-abc131f/","tags":["图论","并查集"],"title":"Atcoder ABC 131F（图论）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/165/problem/E\n题意\n给定 $n$ 个数 $a_1,a_2,\u0026hellip;,a_n$，对于每一个 $a_i$，找出是否存在 $a_j$ 使得 $a_i$ \u0026amp; $a_j = 0$？\n其中 $1 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 4\\times10^6$\n 题解 结论1：如果 $a_i$ \u0026amp; $a_j = 0$，则对于 $a_j$ 的任何一个子集 $b$（$b \\subset a_j$），都有 $a_i$ \u0026amp; $b = 0$\n结论2：$\\forall i, ~a_i$ \u0026amp; $($~$a_i) = 0$\n 由上，对于每一个 $a_i$，我们都知道 ~$a_i$ 必然满足条件。所以只要找是否存在 $a_j$ 使得 $a_j \\subset$ ~$a_i$ 即可。\n换而言之，我们可以从高往低进行 dp，从每一个 ~$a_i$ 开始，枚举 ~$a_i$ 的子集，将满足条件的信息传递到子集中，最后看是否存在 $a_j$ 被传递了即可。\n然而直接枚举子集复杂度太高，我们可以考虑按照 位数 进行dp：\n我们从 $111\u0026hellip;111$ 开始枚举，然后枚举少一个 $1$ 的情况：即 $011\u0026hellip;11, 101\u0026hellip;11, 110\u0026hellip;11$ 等等。然后继续往下传递即可。\n 状态转移方程：\n令 dp[mask] 为：这个mask是否存在 $a_j$ 使得 $mask$ \u0026amp; $a_j = 0$，如果存在，就是 $a_j$ 的值，否则为 $-1$\n转移过程就是上述的，枚举 少一个 $1$ 的子集过程。\n• 实现代码中，是从 多一个 $1$ 转移过来的，本质相同。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e6+5; const int maxm = (1\u0026lt;\u0026lt;22); // 1\u0026lt;\u0026lt;22 == 4.1e6 int n; int arr[maxn]; int dp[maxm]; int INF = (1\u0026lt;\u0026lt;22) - 1; // 注意INF \u0026gt; 4e6，我们要根据 位数 取INF，而不是根据数据范围 int inv(int x) { return (~x) \u0026amp; INF; // 注意这里有 \u0026amp; INF 的操作，否则会得到负数 } int main() { fill(dp, dp+maxm, -1); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i], dp[inv(arr[i])] = arr[i]; for (int mask = INF; mask \u0026gt;= 1; mask--) { // 注意从 INF开始，而不是从 4e6开始，因为 inv(arr[i]) 有可能 \u0026gt; 4e6 if (dp[mask] != -1) continue; for (int j = 0; j \u0026lt; 22; j++) { int a = mask | (1\u0026lt;\u0026lt;j); // 枚举多一位 if (a == mask) continue; if (dp[a] != -1) { dp[mask] = dp[a]; break; } } } for (int i = 1; i \u0026lt;= n; i++) { int a = arr[i]; cout \u0026lt;\u0026lt; dp[a] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; }   高维前缀和 本题似乎与高维前缀和有关，这里介绍一下高维前缀和的知识。\n高维前缀和主要用于解决 $dp[S] = \\sum\\limits_{T \\subset S}a[T]$ 的问题。\n在我们求一个多维度的前缀和时，有两种方法：（以下，使用求一个矩阵的前缀和来举例）\n法一：枚举dp数组位置 + 容斥： $O(n2^d)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];  法二：枚举维度，不用容斥： $O(nd)$ for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i][j - 1]; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) a[i][j] += a[i - 1][j];  • 如上，先枚举了第一维，然后枚举第二维。\n• 这种方法的复杂度远低于法一！\n 如果有更多维度的话，也是枚举每一个维度，然后求每个维度的前缀和：\nfor (int i = 0; i \u0026lt; d; i++) { // 枚举每一个维度 for (int mask = 0; mask \u0026lt; (1\u0026lt;\u0026lt;d); mask++) { //求前缀和 if (mask \u0026amp; (1\u0026lt;\u0026lt;i)) dp[mask] += dp[mask ^ (1\u0026lt;\u0026lt;i)]; } }  ","date":"2021-03-11T23:20:32+08:00","permalink":"https://tom0727.github.io/post/029-cf-165e/","tags":["状压dp"],"title":"CF 165E题解（状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1188/problem/B\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，和一个非负整数 $k$，求满足以下条件的 $(i,j)$ 数量：\n $1\\leq i \u0026lt; j \\leq n$ $(a_i+a_j)(a_i^2+a_j^2) \\equiv k \\text{ mod } p$  其中，$2 \\leq n \\leq 3 \\times 10^5, 2 \\leq p \\leq 10^9, 0\\leq k \\leq p-1, p$ 是质数。\n 题解 一般这种求 $(i,j)$ 的数量，一个常规操作是构造出 $f(i) = g(j)$，然后在遍历过程中维护一个 cnt，直接加到 ans 上。\n所以我们想个办法 把 $i,j$ 分到两边：\n$(a_i+a_j)(a_i^2+a_j^2) = k$，两边同乘 $(a_i-a_j)$，有 $a_i^4-a_j^4 = k(a_i-a_j)$，移项得到\n$$a_i^4 - ka_i = a_j^4-ka_j$$\n所以维护一个 cnt 来记录 $a_i^4 - ka_i$ 的值就可以了，代码略。\n","date":"2021-03-11T14:37:13+08:00","permalink":"https://tom0727.github.io/post/028-cf-1188b/","tags":["枚举"],"title":"CF 1188B（枚举优化）"},{"categories":["算法"],"contents":"介绍 数论分块一般用于解决 含有 $\\lfloor \\frac{N}{i} \\rfloor$ 的求和问题。\n数论分块主要利用了 $\\lfloor \\frac{N}{i} \\rfloor$ 的取值范围相当有限的特点，所以有\n$$i \\leq j, ~\\lfloor \\frac{N}{i} \\rfloor = \\lfloor \\frac{N}{j} \\rfloor$$\n这样一些求和问题就可以转化为 $(j-i+1) \\times \\lfloor \\frac{N}{j} \\rfloor$ （或者类似的形式）\n时间复杂度：$O(\\sqrt n)$\n证明 $\\forall i \\leq n,$ $\\exists$ 最大的 $j$ 使得 $~i \\leq j \\leq n$，且 $\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloor$\n则 $$j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$$\n 证明：\n显然 $j \\leq n$，只要证 $j \\geq i$：\n因为 $j = \\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor$，又因为 $i = \\lfloor \\frac{n}{\\frac{n}{i}} \\rfloor$ （分母没有下取整）\n因为 $\\lfloor \\frac{n}{i} \\rfloor \\leq \\frac{n}{i}$，所以有 $j \\geq i$\n例题 例1 求 $\\sum\\limits_{i=1}^N \\lfloor \\frac{N}{i} \\rfloor$  以下的代码中，我们令 l,r 代表上文的 i,j\n int r; for (int l = 1; l \u0026lt;= n; l = r + 1) { // 注意这里是 l = r+1 r = n / (n / i); ans += (n / l) * (r - l + 1); }  • 可以发现，数论分块的本质思想是 枚举 $\\lfloor \\frac{N}{i} \\rfloor$ 的值。\n例2 洛谷P2261 余数求和 题意\n给定正整数 $n,k \\leq 10^9$，求 $\\sum\\limits_{i=1}^n k \\text{ mod } i$\n 题解 因为 （以下略去 下取整符号） $$k \\text{ mod } i = k - \\frac{k}{i} \\times i$$\n对于 $n \u0026gt; k$ 的部分，就加上 $(n-k) \\times k$。\n对于 $n \\leq k$ 的部分，有 $$\\sum\\limits_{i=1}^n k \\text{ mod } i = n\\times k - \\sum\\limits_{i=1}^n \\frac{k}{i} \\times i$$\n然后数论分块枚举 $\\lfloor \\frac{k}{i} \\rfloor$ 的值，每个块分别用等差数列求和即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll ans = 0; if (n \u0026gt; k) { ans += (n-k) * k; n = k; } ll r; ans += (n*k); for (ll l = 1; l \u0026lt;= n; l = r+1) { r = min(n, k / (k/l)); // 注意这里取 min，因为 k/(k/l) 有可能超过n ans -= (k/l) * ((l+r) * (r-l+1) / 2LL); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例3 Atcoder ABC132F Small Products 题意\n给定正整数 $n \\leq 10^9$，$2 \\leq k \\leq 100$，求满足以下条件的序列数量：\n 长度为 $k$ 任意两个相邻元素的乘积 $\\leq n$  答案对 $10^9+7$ 取模。\n 题解 很容易发现 dp 思路：\n设 $dp[i][j]$ 为：当前用到第 $i$ 个元素，结尾的元素的值为 $j$ 的数量。则答案为 $\\sum\\limits_{j=1}^{n}dp[k][j]$\n但是 $n \\leq 10^9$，dp数组开不了这么大。\n我们可以考虑只将 dp[][] 的第二维开到 $\\sqrt n$ 的大小，对于 $j \u0026gt; \\sqrt n$ 的部分用数论分块解决。\n令 $m = \\sqrt n$，且维护前缀和 $sum[i][j] = \\sum\\limits_{k=1}^j dp[i][j]$，转移方程有：\n$$dp[i][1] = \\sum\\limits_{j=1}^n dp[i-1][j] = \\sum\\limits_{j=1}^m dp[i-1][j] + \\sum\\limits_{j=m+1}^n dp[i-1][j]$$\n其中，\n$$\\forall j \u0026gt; m, ~dp[i-1][j] = \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k]$$\n会发现，对于不同的 $j$，$\\lfloor \\frac{n}{j} \\rfloor$ 的取值相当有限，所以可以用数论分块。所以有：\n$$dp[i][1] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n \\sum\\limits_{k=1}^{\\lfloor \\frac{n}{j} \\rfloor} dp[i-2][k] = sum[i-1][j] + \\sum\\limits_{j=m+1}^n sum[i-2][\\frac{n}{j}]$$\n第二项用数论分块处理即可，注意到随着 $j$ 的增大，$\\frac{n}{j}$ 逐渐减小，所以可以反着枚举 $j$ （即 $j = m~\u0026hellip;~1$）\n最后，答案就是 $dp[k+1][1] = \\sum\\limits_{j=1}^{n}dp[k][j]$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ll n,k,m; ll dp[103][31642]; ll sum[103][31642]; int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; m = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) dp[1][i] = 1, sum[1][i] = sum[1][i-1] + 1; for (int i = 1; i \u0026lt;= m; i++) dp[2][i] = n/i, sum[2][i] = (sum[2][i-1] + dp[2][i]) % mod; for (int i = 3; i \u0026lt;= k+1; i++) { ll cur = 0; ll l = m+1,r; for (int j = m; j \u0026gt;= 1; j--) { //倒序枚举 j dp[i][j] = sum[i-1][m]; if (n/j \u0026lt;= m) { // 注意这里需要特判，否则 n/j \u0026lt;= m 是有可能的，导致RE continue; } r = min(n/j, n / (n/l)); cur = (cur + ((r-l+1) * (sum[i-2][n/l]) % mod)) % mod; l = r + 1; dp[i][j] = (dp[i][j] + cur) % mod; } for (int j = 1; j \u0026lt;= m; j++) sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod; } ll ans = dp[k+1][1]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-10T15:49:46+08:00","permalink":"https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","tags":["数学"],"title":"数论分块"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1243/problem/E\n题意\n给定 $k$ 个 box，每个 box $i$ 里有 $n_i$ 个整数，所有整数均不同。\n现在我们需要执行 Exactly Once 以下操作：\n从每一个box中拿一个数出来，然后以permutation的形式放回每一个box（即每一个box放入且仅放入一个数）。\n判断是否存在这样的操作使得所有box里的sum相同，如果有，输出具体方案。\n其中，$k \\leq 15, n \\leq 5000$\n 题解 首先，所有box的sum必须被 $k$ 整除，否则无解。\n令 $tar$ 为最终每个box的sum。\n我们可以枚举 $box ~1$ 要拿哪个数出来（叫做 $a_1$），这样我们就可以知道它需要被放入哪个数（叫做 $b_1$）。又因为所有数字都不相同，故我们就可以知道 $b_1$ 的来源是哪个box，假设来自 $box_i$，那么我们就可以得到 $a_i = b_1$，于是就可以计算出 $b_i$，一直这么继续下去。\n如果最终形成了一个 完整环（以 $box_1$ 作为起点，并且以 $box_1$ 作为终点）的话，就说明这个方案可行。\n但是，这个环不一定覆盖了所有的点。所以我们需要找到所有的环，我们分别以 $1,2,3,\u0026hellip;,k$ 作为起点，并且对于每个box都枚举一下要拿的数。这样我们可以最多形成 $\\sum\\limits_{i=1}^k n_i \\leq 75000$ 个环。并且每个环一定互不相同。\n 现在的问题就转化为：给定了这些环，我们能否从中挑选出几个环，使得每个 $box$ 被访问，且仅被访问一次？\n用 Bitmask ！\n因为 $k \\leq 15$，我们将每个环表示为一个bitmask，比如某个环是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 1$，那么对应的bitmask就是 $000\u0026hellip;1011$。\n我们会发现，可能会有很多个环对应同一个bitmask，但是没关系，我们只需要输出一个解即可。\n 最后，问题转化为：给定一些bitmask，如何让它们组合成 $2^k-1$，且每个bit仅被覆盖一次？\n用 状压dp！\n定义 bool ori[(1\u0026lt;\u0026lt;16)+2], dp[(1\u0026lt;\u0026lt;16)+2];\n其中 ori[mask] 代表这个mask是否由 单独一个环 所组成，而 dp[mask] 代表这个mask能否由 $1$ 个 或多个环 组成。\n然后就是一个很经典的模版了：\nfor (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { // 枚举mask的子集，使用 (sub-1) \u0026amp; mask来加速枚举 if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { // 使用xor保证同一个bit只被覆盖一次 dp[mask] = 1; break; } } }   最后就是实现了，本题实现起来相当麻烦，找 完整环 用的是 $dfs$ + $bitmask$ + 记录起点（和起点使用的数），每次找到一个环，就把 起点 放在对应的 $bitmask$ 数组 plan[] 里。\n在找完所有的环之后，再根据每个 $bitmask$，再进行一次 $dfs$ 来找到这个环的具体路径。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define pii pair\u0026lt;int,int\u0026gt; int k; int adj[16][5002]; //记录第i个box的第j个数 int sz[16]; //记录第i个box的大小 ll sum[16]; ll diff[16]; // 记录第i个box的sum和target的差 unordered_map\u0026lt;ll, int\u0026gt; belong; // 记录某个数属于第几个box pii plan[(1\u0026lt;\u0026lt;16)+2]; // 储存每个bitmask对应的起点 {start, a} bool ori[(1\u0026lt;\u0026lt;16)+2]; bool dp[(1\u0026lt;\u0026lt;16)+2]; int from[(1\u0026lt;\u0026lt;16)+2]; // 记录每个bitmask在dp过程中由哪个子集转移过来的 pii ans[16]; void dfs(int cur, ll a, int mask, int start, ll oa) { //cur: current vertex, a: the number we are taking OUT from cur, start: the starting vertex, oa: the \u0026quot;a\u0026quot; for starting vertex ll need = a - diff[cur]; if (!belong.count(need)) return; // no vertex to go int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); if (to == start \u0026amp;\u0026amp; need == oa) { ori[mask] = 1; plan[mask] = {start, oa}; return; } if (mask \u0026amp; (1\u0026lt;\u0026lt;(to-1))) return; // form a cycle, but not a cycle start with \u0026quot;start\u0026quot; dfs(to, need, mask, start, oa); } void dfs2(int cur, ll a, int mask, int start) { ll need = a - diff[cur]; int to = belong[need]; mask |= (1\u0026lt;\u0026lt;(cur-1)); ans[to] = {need, cur}; if (to == start) { return; } dfs2(to, need, mask, start); } void findans(int mask) { if (!ori[mask]) { findans(from[mask]); findans(from[mask] ^ mask); return; } int start = plan[mask].first; ll a = plan[mask].second; dfs2(start, a, 0, start); } int main() { cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { int n; cin \u0026gt;\u0026gt; n; sz[i] = n; for (int j = 1; j \u0026lt;= n; j++) { ll a; cin \u0026gt;\u0026gt; a; adj[i][j] = a; sum[i] += a; belong[a] = i; } } ll tar = 0; for (int i = 1; i \u0026lt;= k; i++) tar += sum[i]; if (tar % k) { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; endl; return 0; } tar = tar/k; for (int i = 1; i \u0026lt;= k; i++) { diff[i] = sum[i] - tar; } for (int start = 1; start \u0026lt;= k; start++) { for (int j = 1; j \u0026lt;= sz[start]; j++) { dfs(start, (ll)adj[start][j], 0, start, adj[start][j]); } } for (int mask = 0; mask \u0026lt;= (1\u0026lt;\u0026lt;k)-1; mask++) { if (ori[mask]) { dp[mask] = 1; continue; } for (int sub = mask; sub; sub = (sub-1) \u0026amp; mask) { if (dp[sub] \u0026amp;\u0026amp; dp[mask ^ sub]) { dp[mask] = 1; from[mask] = sub; break; } } } if (dp[(1\u0026lt;\u0026lt;k)-1]) { cout \u0026lt;\u0026lt; \u0026quot;Yes\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; findans((1\u0026lt;\u0026lt;k)-1); for (int i = 1; i \u0026lt;= k; i++) printf(\u0026quot;%d %d\\n\u0026quot;, ans[i].first, ans[i].second); } else { cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   ","date":"2021-03-09T12:34:01+08:00","permalink":"https://tom0727.github.io/post/026-cf-1243e/","tags":["图论","dp"],"title":"CF1243E 题解（图论，状压dp）"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1154/problem/G\n题意\n给定 $n$ 个正整数 $a_1,a_2,\u0026hellip;,a_n$，求 $i \\neq j$ 使得 $\\text{lcm}(a_i, a_j)$ 最小？\n其中 $2 \\leq n \\leq 10^6, 1 \\leq a_i \\leq 10^7$\n 题解 一般和 $gcd, lcm$ 相关的题，一般就 $2$ 种trick：\n 质因子分解 枚举 $gcd$ 的值  这道题是 枚举 $gcd$ 的值。因为 $lcm(a_i,a_j) = \\frac{a_ia_j}{\\gcd(a_i,a_j)}$，所以我们枚举一下 $gcd(a_i,a_j)$ 的值即可。\n设 $g$ 为可能的 $gcd$ 的值，从 $1$ 枚举到 $10^7$，对于每一个 $g$，只要找出 最小的两个 $a_i,a_j$ 使得 $g|a_i, g|a_j$ 即可。\n时间复杂度：$T(n) = \\frac{10^7}{1} + \\frac{10^7}{2} + \u0026hellip; + \\frac{10^7}{10^7} = 10^7(1+\\frac{1}{2} + \u0026hellip; \\frac{1}{10^7}) = O(10^7 \\log(10^7))$\n 证明正确性：\n无论最终答案是什么，$\\gcd(a_i,a_j)$ 必然会被枚举到。所以不会漏解。\n如果我们枚举到的 $g$ 不一定是真的 $gcd$ 呢？比如 $g = 2$，然后 $a_i$ 中最小的两个倍数为 $4, 8$？\n答：我们总会枚举到真正的 $gcd$，如果 $g$ 不是真实的 $gcd$，它只会比真实的 $gcd$ 更小，所以获得的 $lcm$ 更大，所以不影响答案的正确性。\n  另：枚举 $gcd$ 的trick之前在 Atcoder-ABC-162E 也出现过。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e6+5; const int maxm = 1e7+5; int arr[maxn]; int vis[maxm]; // 不要用 unordered_set, 会TLE int n; ll ans = 1e18; int ai,aj; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); if (vis[arr[i]] \u0026amp;\u0026amp; arr[i] \u0026lt; ans) ans = arr[i], ai = vis[arr[i]], aj = i; vis[arr[i]] = i; } for (int g = 1; g \u0026lt;= 1e7; g++) { int cur = 0; if ((g\u0026lt;\u0026lt;1) \u0026gt; ans) break; // 优化时间 for (int j = g; j \u0026lt;= 1e7; j += g) { if (vis[j]) { if (cur) { int d = j / g; ll r = 1LL * cur * d; if (r \u0026lt; ans) { ai = vis[cur]; aj = vis[j]; ans = r; } break; } else cur = j; } } } if (ai \u0026gt; aj) swap(ai, aj); printf(\u0026quot;%d %d\\n\u0026quot;, ai,aj); }  ","date":"2021-03-08T21:36:22+08:00","permalink":"https://tom0727.github.io/post/025-cf-1154g/","tags":["枚举","数论"],"title":"CF1154G 题解（gcd/lcm的枚举优化）"},{"categories":["算法"],"contents":"介绍 莫队算法是一种基于分块思想的暴力算法，一般应用于同时满足以下条件的区间问题中：\n 已知 $[L,R]$ 之间的答案，能在 $O(1)$ 时间内转移到 $[L+1,R], [L-1,R], [L,R+1], [L,R-1]$ 的答案。 所有询问均离线。 不存在修改。  我们用模版举个例子：\n题意\n给定一个长度为 $N$ 的正整数序列 $a$，给定一个 $k$，满足 $\\forall i, a_i \\in [1,k]$。\n现在有 $M$ 个询问，每个询问给定一个区间 $[l,r]$，求 $\\sum_{i=1}^kc_i^2$\n其中 $c_i$ 为数字 $i$ 在 $[l,r]$ 中的出现次数。\n数据范围：$1 \\leq n,m,k \\leq 5\\times10^4$\n 算法 Part1 O(1)的状态转移 对于上面的例题，我们可以发现从 $[L,R]$ 转移到 $[L,R+1]$ 是 $O(1)$ 的。\n我们维护两个指针 $l,r$，并且维护一个 cnt[] 数组来记录当前区间的 $c_i$，在 $r$ 右移一格的时候，加上对应的 $cnt$，然后要维护的 $\\sum_{i=1}^kc_i^2$ 也很好转移，计算一下，就会得到\n$$s_{l,r+1} = s_{l,r} + 2\\times c_{a_{r+1}} + 1$$\n同理对于其他三种情况，转移都是 $O(1)$ 的。\n所以，假设我们有两个询问 $[L_1, R_1], [L_2, R_2]$，我们在询问完 $[L_1, R_1]$ 后，将左右指针一个个移动到 $[L_2, R_2]$ 似乎就可以节省一点时间了。（如果它们离得比较近的话）\nPart2 莫队思路 既然我们可以通过维护两个指针 $l,r$ 来快速转移，我们又事先知道所有的询问（因为询问离线），那有什么办法将这些询问靠近一些，来节省更多时间呢？\n分块思想！\n我们将区间划分为 $\\sqrt n$ 块，然后对于每个询问 $[L_i,R_i]$，我们根据 $L_i$ 的值，把它放进对应的块中。\n然后，我们将所有的询问首先根据 所在块的编号 来sort，对于同一块内的询问，根据 $R_i$ 从小到大 来sort。\n最后，根据sort的顺序来处理每个询问，询问之间的转移 就按照上面的左右指针移动来处理。这样我们能在 $O(n\\sqrt n)$ 时间内处理好每一个区间。\n算法步骤  预处理所有询问，记录询问的 l,r，记录 be （代表 l 对应是哪个块），记录 id（代表原先是第几个询问）。 根据 be 作为第一关键字，r 作为第二关键字进行sort。 定义global variable int l = 1, r = 0, ans = 0。 按照sort后的顺序进行询问，调整 l,r 指针，并相应更新 ans，然后将 ans 根据 id 放入答案数组中。  需要注意的点  注意在转移过程中，使用的是 --l 还是 l++。r 还有更新 ans 的时候也类似，要根据具体情况来看。 注意初始情况下， l = 1, r = 0。 be 是根据 l 的位置决定的。  复杂度证明 先注意：\n 同一个块内的 $L_i$ 并没有顺序。 同一个块内的 $R_i$ 没有限制，可以横跨整个区间。  左指针在块内移动 的复杂度：注意到，同一个块内的 $L_i$ 并没有顺序，所以每次询问可能有 $O(B)$ 的复杂度（$B$为块的大小）。总复杂度为 $O(mB)$\n右指针在块内移动 的复杂度：因为是 $R_i$ 是有序的，所以在同一个块内移动的总复杂度为 $O(n)$\n左指针在块之间移动 的复杂度：每次移动复杂度为 $O(2B)$。总复杂度为 $O(\\frac{n}{B} * 2B) = O(2n)$\n右指针在块之间移动 的复杂度：总共有 $\\frac{n}{B}$ 个块，每次在块之间移动没有限制，复杂度为 $O(n)$。总复杂度为 $O(\\frac{n^2}{B})$\n综上，复杂度为 $O(mB) + O(n) + O(\\frac{n^2}{B})$\n当我们取 $B = \\sqrt n$ 时，复杂度为 $O(n \\sqrt n)$\n• 实际上最优复杂度应该取 $B = \\frac{n}{\\sqrt m}$，总复杂度为 $O(n \\sqrt m)$\n例题 例1 小B的询问 就是上面的例题，这里直接放代码。\n代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m,k; int sz; int arr[maxn]; ll cnt[maxn]; ll ans[maxn]; struct query { int l,r,be,id; } q[maxm]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 1,r = 0; ll add(int x) { ll res = 2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]++; return res; } ll del(int x) { ll res = -2LL * cnt[arr[x]] + 1LL; cnt[arr[x]]--; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; q[i].be = (q[i].l-1) / sz; } sort(q+1, q+m+1, cmp); ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r; while (r \u0026lt; qr) res += add(++r); while (r \u0026gt; qr) res += del(r--); while (l \u0026lt; ql) res += del(l++); while (l \u0026gt; ql) res += add(--l); ans[q[i].id] = res; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   例2 小Z的袜子 题意\n有 $N$ 个袜子，每个袜子 $i$ 有一个颜色 $c_i$，给定 $M$ 个询问 $[L,R]$，每次询问回答 $[L,R]$ 区间内随机抽两个袜子，颜色相同的概率？\n其中 $N,M \\leq 50000, c_i \\in [1,N]$\n 题解 维护 分子和分母：\n每次区间长度加 $1$：分母增加 $len$（$len$ 为增加前的区间长度），分子增加 $cnt_{c_i}$ （$cnt_{c_i}$ 为新增的颜色 $c_i$ 原来的数量）。\n每次区间长度减 $1$：分母减少 $len-1$（$len$ 为减少前的区间长度），分子减少 $cnt_{c_i} - 1$ （$cnt_{c_i}$ 为减少的颜色 $c_i$ 原来的数量）。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn = 5e4+5; const int maxm = 5e4+5; int n,m; struct query { int l,r,be,id; ll nu,de; } q[maxm]; int arr[maxn]; int cnt[maxn]; bool cmp(query\u0026amp; a, query\u0026amp; b) { if (a.be == b.be) { return a.r \u0026lt; b.r; } return a.be \u0026lt; b.be; } ll nu = 0, de = 0; ll gcd(ll a, ll b) { if (!b) return a; return gcd(b, a%b); } int sz; int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); sz = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]); for (int i = 1; i \u0026lt;= m; i++) { int l,r; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;l,\u0026amp;r); q[i].id = i; q[i].be = (l-1)/sz; q[i].l = l, q[i].r = r; } sort(q+1, q+m+1, cmp); ll l = 1, r = 0; for (int i = 1; i \u0026lt;= m; i++) { int ql = q[i].l, qr = q[i].r, id = q[i].id; if (ql == qr) { q[id].nu = 0, q[id].de = 1; continue; } while (r \u0026lt; qr) de += (r-l+1), r++, nu += cnt[arr[r]], cnt[arr[r]]++; while (r \u0026gt; qr) de -= (r-l), nu -= (cnt[arr[r]] - 1), cnt[arr[r]]--, r--; while (l \u0026gt; ql) de += (r-l+1), l--, nu += cnt[arr[l]], cnt[arr[l]]++; while (l \u0026lt; ql) de -= (r-l), nu -= (cnt[arr[l]] - 1), cnt[arr[l]]--, l++; q[id].nu = nu, q[id].de = de; } for (int i = 1; i \u0026lt;= m; i++) { nu = q[i].nu, de = q[i].de; if (nu == 0) { printf(\u0026quot;0/1\\n\u0026quot;); continue; } ll g = gcd(nu,de); nu /= g, de /= g; printf(\u0026quot;%lld/%lld\\n\u0026quot;,nu,de); } }   例3 CF617E 题意\n给定 $n$ 个整数 $a_1,a_2,\u0026hellip;,a_n$，还有一个整数 $k$ ，以及 $m$ 个询问 $[l,r]$，每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $a_i \\text{ xor } a_{i+1} \\text{ xor } \u0026hellip; \\text{ xor } a_j = k$  其中，$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^6, 0 \\leq a_i \\leq 10^6$\n 题解 首先定义一个前缀 $\\text{ xor }$ 数组满足 $s_i = a_1 \\text{ xor } a_2 \\text{ xor } \u0026hellip; \\text{ xor } a_i$，这样问题转化为：\n每次询问求 有多少个$i,j$ 满足：\n $l \\leq i \\leq j \\leq r$ $s_i \\text{ xor } s_j = k$  注意到，$s_j = s_i \\text{ xor } k$，所以我们可以维护一个 cnt[] 数组，记录一下当前区间每个元素出现了多少次。\n然后，比如在区间扩张的过程中，就检查 cnt[] 中当前元素 cur 出现的次数，给 ans 加上，然后 cnt[cur ^ k]++;\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; const int maxm = 1e6+5; int n,m,k; struct query { int l,r,id,be; } q[maxn]; bool cmp(query a, query b) { if (a.be == b.be) return a.r \u0026lt; b.r; return a.be \u0026lt; b.be; } int l = 0, r = -1; int cnt[2*maxm]; int s[maxn]; ll b[maxn]; double start; ll ans = 0; void add(int x) { ans += (ll)cnt[s[x]]; cnt[s[x] ^ k]++; } void del(int x) { cnt[s[x] ^ k]--; ans -= (ll)cnt[s[x]]; } void ask(int L, int R) { while (r \u0026lt; R) add(++r); while (r \u0026gt; R) del(r--); while (l \u0026lt; L) del(l++); while (l \u0026gt; L) add(--l); } int main() { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; s[i]; for (int i = 1; i \u0026lt;= n; i++) s[i] ^= s[i-1]; int sz = sqrt(n); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].l--; q[i].id = i; q[i].be = (q[i].l-1)/sz; } sort(q+1, q+m+1, cmp); for (int i = 1; i \u0026lt;= m; i++) { ask(q[i].l, q[i].r); b[q[i].id] = ans; } for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }   带修莫队 略。例题参考：https://www.luogu.com.cn/problem/P1903\n参考链接  https://ouuan.github.io/post/%E8%8E%AB%E9%98%9F%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/#%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F https://www.cnblogs.com/WAMonster/p/10118934.html  ","date":"2021-03-07T21:50:41+08:00","permalink":"https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/","tags":["莫队"],"title":"莫队"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc194/tasks/abc194_f\n题意\n给定一个数 $1\\leq N \\leq 16^{2\\times10^5}$，求：\n在 16进制 下，满足以下条件的整数 $x$ 数量：\n 拥有 Exactly $K$ 个不同的digit （例如 $x = 1F21$，就有3个不同的digit） $x \\in [1,N]$   题解 我们使用 dp，为了方便处理 $x \\leq N$ 的问题，我们从最高位（Most significant digit）开始处理。\n我们设 dp[i][j] 为，我们处理到了第 i 位，使用了 j 个不同的digit，且满足以下条件的数字 $x$ 的数量：\n $x$ 严格小于 $N$ 的前 i 位 $x \\neq 0$   注意，$x$ 不一定完全有 i 个digit，但是它至少有一个有效的digit。\n 由上，因为第一个条件，我们无论在这一位选择什么digit，都必然会仍然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第一个转移方程：\nfor (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; }   我们发现，这样只考虑到了前 i-1 位至少有一个有效digit的情况，没有考虑全部为前缀0的情况。\n如果前 i-1 位全是前缀0，那么无论在这一位选择任何数，都必然满足条件 $1$ 中的 严格小于 $N$。\n所以我们可以得到第二个转移方程：\ndp[i][1] = (dp[i-1][1] + 15) % mod;   注意到，我们的 dp 数组里，并没有包含 $x$ 的前 i-1 位 完全等同于 $N$ 的前 i-1 位的情况。我们需要单独处理它！\n我们在当前这一位（第i位），能够计入 dp 数组的只有 第 i 位小于 $N$ 的第 i 位的情况。\n并且，我们可以很容易得到 $N$ 的前 i-1 位有多少个不同的digit（这样就得到了 dp 数组里的 j）。\n所以，我们只要枚举一下，第 i 位可以选择的所有digit，计算一下不同的digit数量，然后计入 dp 数组即可。\n所以我们得到了第三个转移方程：\nmap\u0026lt;char, int\u0026gt; dict; // 用于将 0123456789ABCDEF map到对应的int set\u0026lt;int\u0026gt; used; // 记录N的前i-1位用了哪些数字 char c = s[i-1]; // N的第i位数字 int cur = dict[c]; int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { //枚举所有可以选择的digit if (!used.count(j)) { // 计算不同digit的数量 dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur);   最后别忘记，看一下 $N$ 自己是否也满足条件（拥有Exactly $K$ 个不同的digit）。\n 小结：\n本题是一个非常不错的dp，主要用了以下几个关键的trick：\n 对于 Exactly $K$ 不同的digit，我们不关心具体是哪几个digit，只需知道不同的digit数量就可以计数了。 通过限制 dp 数组的定义，让 dp 数组仅记录 严格小于 $N$ 的数字，方便计数。 单独处理 $x$ 与 $N$ 的前 i 位相同的情况，并且将符合条件的计数加到 dp 数组当中去。  需要重点关注的是这个 DP并不记录最终答案，而是记录 满足某种条件的部分答案，其余特殊情况单独处理的思想。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll dp[maxn][18]; string s; int k; map\u0026lt;char, int\u0026gt; dict; set\u0026lt;int\u0026gt; used; int main() { fastio; for (int i = 0; i \u0026lt;= 9; i++) dict[(char)(i+'0')] = i; int o = 10; for (char c = 'A'; c \u0026lt;= 'F'; c++) dict[c] = o++; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; k; int n = s.size(); dp[1][1] = dict[s[0]] - 1; used.insert(dict[s[0]]); for (ll i = 2; i \u0026lt;= n; i++) { char c = s[i-1]; dp[i][1] = (dp[i-1][1] + 15) % mod; int cur = dict[c]; for (ll j = 2; j \u0026lt;= k; j++) { dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (16-j+1)) % mod; dp[i][j] = (dp[i][j] + dp[i-1][j] * j) % mod; } int pre = used.size(); for (int j = 0; j \u0026lt; cur; j++) { if (!used.count(j)) { dp[i][pre+1]++; } else dp[i][pre]++; } used.insert(cur); } if (used.size() == k) dp[n][k]++; ll ans = dp[n][k] % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-03-06T22:16:46+08:00","permalink":"https://tom0727.github.io/post/023-at-abc194f/","tags":["数位dp","进制"],"title":"Atcoder ABC 194F（数位DP，进制处理）"},{"categories":["算法"],"contents":"介绍 树链剖分主要用于将 树上修改/查询 通过 DFS序 变成 区间修改/查询，然后利用 线段树 进行修改/查询。\n我们可以用模版来举个例子：\n题意\n已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n$1\\ x\\ y\\ z$ ：将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n$2\\ x\\ y$ ：求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n$3\\ x\\ z$ ：将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n$4\\ x$ ：求以 $x$ 为根节点的子树内所有节点值之和。\n 主要知识点有三个：DFS序，LCA，线段树\n前置知识回顾 DFS序 DFS序的作用是，根据DFS的顺序将节点编号，就可以得到以下性质：\n 同一个subtree内的编号是连续的，且parent的编号最小。 在从上到下的DFS过程中，一条链上的编号也是连续的，且越靠上，编号越小。   注：记得将原array中的节点权值（或者其他信息） map 到dfs序上的新节点。\n  LCA（最近公共祖先） 在 LCA 中，寻找共同祖先的过程中，要注意不能往上跳过头了，在树链剖分中也一样，只不过没有采用倍增思想。\n 线段树 在树链剖分中，线段树的应用并没有什么变化。\n 概念定义   重儿子：每一个节点的child中，所在subtree（包括它自己）节点数最多的child 叫做该节点的重儿子（每个节点有且仅有一个重儿子）。\n  轻儿子：除了重儿子的所有节点，都是轻儿子。（我们可以把 root 看作一个轻儿子）\n  重边：一个节点连接它的重儿子的edge就是重边。\n  重链：以轻儿子作为起点，向下延伸，连接子树内的所有重儿子，形成的链叫做重链。\n（对于一个leaf，如果它是一个轻儿子，那么它自己形成一条重链）\n  算法 算法步骤如下：\n 进行第一次DFS dfs1() 进行第二次DFS dfs2() 建线段树 将树上操作 对应到 区间上，然后用线段树解决  第一次DFS 第一次DFS，我们需要维护的信息有：\n 记录每个点的 深度： dep[] 记录每个点的 parent： par[] 记录每个点的 subtree大小（包括它自己）：sz[] 记录每个点的 重儿子：son[]  int dep[maxn], par[maxn], sz[maxn], son[maxn]; void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // subtree包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 判断重儿子 maxsz = sz[to]; son[cur] = to; } } }  第二次DFS 第二次DFS，我们需要维护的信息有：\n 记录每个点的 DFS序编号：id[] 记录每个点 所在重链的最顶端：top[] （如果有），将树上的信息通过DFS序编号 转移到 区间上   注意：dfs2() 过程中，我们需要 优先处理重儿子，这是为了保证 同一条重链 对应的必然是 一段连续的区间。\n 这样处理以后，我们能得到如下的DFS序编号：\nint w[maxn]; //weight int arr[maxn]; // array for segment tree to use int top[maxn], id[maxn]; int cnt = 1; //current id void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // 这个节点是leaf dfs2(son[cur], t); // 优先处理重儿子 for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; //重儿子处理过了 dfs2(to, to); // 轻儿子是重链的开始 } }  建线段树 常规操作，并没有什么不同。\n将树上操作对应到区间上 操作 $3,4$ （更新/查询一个子树内的值）：\n在DFS序中，同一个子树内的DFS序编号是连续的，我们有了 parent 对应的编号，就有了区间上的左端点，利用 sz[] 来找到 右端点，左右端点都有了，就用线段树处理即可。\nvoid update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); }   操作 $1,2$ （更新/查询两个点之间最短路径的值）：\n给定两个点 u,v：\n  如果 u,v 在同一条重链上，那么对应的是区间上的一段连续区间（dep 较小的那个对应左端点，dep较深的那个对应右端点），直接用线段树即可。\n  否则，比较 top[u] 和 top[v]，如果 dep[top[u]] \u0026gt; dep[top[v]] （top[u] 比 top[v] 更深），就将 u 往上跳，在线段树上操作 u 到 top[u] 的这一段操作，然后跳到 par[top[u]] 上（即，重链顶端再往上一格），然后重新执行上述判断。\n   为什么要让 top 更深的来跳？为了保证不会跳过头！\n 证明：无论怎么跳，我们都不能超过 u,v 的LCA。设 LCA(u,v) = x，因为它们不在同一条链上，那么 u,v 必然在 x 的两边（或者，其中之一刚好等于 x，另外一个被一个轻儿子挡住了）。无论是哪种情况，因为重链有可能直接从 root 一直延伸下来，所以肯定不能选 top 更靠上层的那个。\n而选择 top 更深的那个，能够保证我们 最远只能刚好跳到x处（因为 x 有且仅有一个重儿子，如果不跳这个重儿子，必然不会跳出 x 的范围）。\n• 由上分析，我们还能发现：在往上跳的过程中，如果发现 u,v 在同一条重链上，那么 dep 较小的那个节点，就是 u,v 的LCA！\nvoid update_path(int u, int v, ll x) { while (top[u] != top[v]) { // u,v 还不是同一个重链上 if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; // 往上跳 } if (dep[u] \u0026gt; dep[v]) swap(u,v); // dep较小的是左端点 update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; }  时间复杂度 性质1 如果 $v$ 是 $u$ 的轻儿子，那么 $size(v) \\leq \\frac{size(u)}{2}$\n证明：根据定义即可。\n 性质2 树中任意两条节点之间，重链的数量 $\\leq \\log_2(n)$\n证明：因为每出现一个重链，意味着出现了一个轻儿子，根据性质1，size减少一半，所以\n#重链 $=$ #轻儿子 $= log_2(n)$\n 由性质1，2，我们可知：\n  路径修改/查询：每个重链进行一次线段树操作，有 $log_2(n)$ 个重链，每次线段树操作复杂度为 $log_2(n)$，所以每次路径操作的总复杂度为 $(log_2(n))^2$\n  子树修改/查询：只有一次线段树操作，所以复杂度为 $log_2(n)$\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; const int maxm = 2e5+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int n,m,root,mod; int w[maxn]; //weight int dep[maxn], par[maxn], sz[maxn], son[maxn]; int top[maxn], id[maxn]; int arr[maxn]; // array for segment tree to use int cnt = 1; //current id void dfs1(int cur, int p) { dep[cur] = dep[p] + 1; par[cur] = p; sz[cur] = 1; // 包括自己 int maxsz = -1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs1(to, cur); sz[cur] += sz[to]; if (sz[to] \u0026gt; maxsz) { // 更新重儿子 maxsz = sz[to]; son[cur] = to; } } } void dfs2(int cur, int t) { id[cur] = cnt++; top[cur] = t; arr[id[cur]] = w[cur]; if (!son[cur]) return; // leaf dfs2(son[cur], t); for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == par[cur] || to == son[cur]) continue; dfs2(to, to); // 轻儿子是重链的开始 } } struct node { int l,r; ll sum = 0; ll lazy = 0; } tr[4*maxn]; inline ll len(int cur) { return tr[cur].r - tr[cur].l + 1; } void push_up(int cur) { tr[cur].sum = (tr[cur\u0026lt;\u0026lt;1].sum + tr[cur\u0026lt;\u0026lt;1|1].sum) % mod; } void push_down(int cur) { if (!tr[cur].lazy) return; int lc = cur\u0026lt;\u0026lt;1, rc = lc|1; tr[lc].lazy = (tr[lc].lazy + tr[cur].lazy) % mod; tr[rc].lazy = (tr[rc].lazy + tr[cur].lazy) % mod; tr[lc].sum = (tr[lc].sum + len(lc) * tr[cur].lazy) % mod; tr[rc].sum = (tr[rc].sum + len(rc) * tr[cur].lazy) % mod; tr[cur].lazy = 0; } void build(int cur, int L, int R) { tr[cur].l = L, tr[cur].r = R; if (L == R) { tr[cur].sum = arr[L]; return; } int mid = (L+R) \u0026gt;\u0026gt; 1; build(cur\u0026lt;\u0026lt;1, L, mid); build(cur\u0026lt;\u0026lt;1|1, mid+1, R); push_up(cur); } void update(int cur, int L, int R, ll x) { int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { tr[cur].lazy = (tr[cur].lazy + x) % mod; tr[cur].sum = (tr[cur].sum + x * len(cur)) % mod; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) update(cur\u0026lt;\u0026lt;1, L, R, x); if (R \u0026gt; mid) update(cur\u0026lt;\u0026lt;1|1, L, R, x); push_up(cur); } ll query(int cur, int L, int R) { ll res = 0; int l = tr[cur].l, r = tr[cur].r; if (l \u0026gt;= L \u0026amp;\u0026amp; r \u0026lt;= R) { return tr[cur].sum; } int mid = (l+r) \u0026gt;\u0026gt; 1; push_down(cur); if (L \u0026lt;= mid) res += query(cur\u0026lt;\u0026lt;1, L, R); if (R \u0026gt; mid) res += query(cur\u0026lt;\u0026lt;1|1, L, R); push_up(cur); return res % mod; } void update_tree(int u, ll x) { update(1, id[u], id[u]+sz[u]-1, x); } ll query_tree(int u) { return query(1, id[u], id[u]+sz[u]-1); } void update_path(int u, int v, ll x) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); update(1, id[top[u]], id[u], x); u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); update(1, id[u], id[v], x); } ll query_path(int u, int v) { ll res = 0; while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); res = (res + query(1, id[top[u]], id[u])) % mod; u = par[top[u]]; } if (dep[u] \u0026gt; dep[v]) swap(u,v); res = (res + query(1, id[u], id[v])) % mod; return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } dfs1(root, 0); dfs2(root, root); build(1, 1, n); while (m--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int u,v,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; x; update_path(u,v,x); } else if (op == 2) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; ll res = query_path(u,v); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } else if (op == 3) { int u,x; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; x; update_tree(u, x); } else { int u; cin \u0026gt;\u0026gt; u; ll res = query_tree(u); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } }  其他例题  https://codeforces.com/problemset/problem/343/D  参考链接  https://www.luogu.com.cn/problem/P3384 （模版题，上面的AC代码） https://www.cnblogs.com/chinhhh/p/7965433.html （强烈推荐） https://www.cnblogs.com/zwfymqz/p/8094500.html  ","date":"2021-03-06T15:58:27+08:00","permalink":"https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","tags":["树链剖分"],"title":"树链剖分"},{"categories":["算法"],"contents":"介绍 给定一棵有根树（不一定为binary tree），求两个节点的最近公共祖先？\n算法 LCA的思路和ST表比较相似，都是利用了倍增思想，大概流程如下：\n预处理：   用dfs预处理出每一个节点 $u$ 的第$1,2,4,8,\u0026hellip;,$ 个parent（即，如果从$u$ 开始，往上跳 $1,2,4,8,\u0026hellip;,$ 格，是哪个节点）\n  记录每一个节点的深度(depth)\n  预处理parent的时候，利用了倍增的思想：\nfor (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1];   询问 $u,v$ 的LCA：   先比较 $u,v$ 的深度，将深的那个往上跳（使用倍增来跳），跳到同一深度。\n  比较一下当前 $u,v$ 是否相等，如果已经相等了就直接返回 $u$。\n  否则，尝试同时将 $u,v$ 往上跳，从 步幅最大 的开始尝试，如果发现 步幅过大（即 $u,v$ 的第 $j$ 个parent相同），就不跳（防止跳过头了），否则就两者同时往上跳。\n  最后，$u,v$ 必然不相同，此时再让它们同时往上跳 $1$ 格就是LCA了。\n  代码 Luogu-P3379-代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int maxn = 5e5+5; const int maxm = 1e6+10; struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; head[u] = ecnt; edges[ecnt++] = e; } int par[maxn][33]; //记录parent int d[maxn]; //深度 int n,m,s; int lg[maxn]; //log2预处理 void dfs(int cur, int p) { par[cur][0] = p; d[cur] = d[p] + 1; for (int j = 1; j \u0026lt;= lg[d[cur]]; j++) par[cur][j] = par[par[cur][j-1]][j-1]; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (to == p) continue; dfs(to, cur); } } int query(int u, int v) { if (d[u] \u0026lt; d[v]) swap(u,v); int diff = d[u] - d[v]; for (int j = 0; (1\u0026lt;\u0026lt;j) \u0026lt;= diff; j++) { if (diff \u0026amp; (1\u0026lt;\u0026lt;j)) { u = par[u][j]; } } if (u == v) return u; for (int j = lg[d[u]]; j \u0026gt;= 0; j--) { if (par[u][j] != par[v][j]) { // 不相同就往上跳 u = par[u][j], v = par[v][j]; } } return par[u][0]; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // s是树的root for (int i = 1; i \u0026lt;= n-1; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); add(v,u); } lg[1] = 0, lg[2] = 1; for (int i = 3; i \u0026lt;= 5e5; i++) lg[i] = lg[i\u0026gt;\u0026gt;1] + 1; } int main() { init(); dfs(s, 0); while (m--) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; int a = query(u,v); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","date":"2021-03-06T11:57:25+08:00","permalink":"https://tom0727.github.io/post/021-lca/","tags":["LCA","最近公共祖先"],"title":"最近公共祖先 LCA"},{"categories":["算法"],"contents":"介绍 三分法 (tenary search) 和 二分法(binary search) 类似，只不过三分法可以用于搜索一个 二次函数 的最值。\n以搜索二次函数最值为例，假如有一个二次函数存在最大值。\n要搜索这个最大值，可以令 $mid = \\frac{l+r}{2}$，然后令 $lmid = mid - eps$，$rmid = mid + eps$，然后比较一下 $f(lmid)$ 和 $f(rmid)$ 的大小。\n $f(lmid) \u0026lt; f(rmid)$：最大值一定在 $[lmid, r]$ 之间。 $f(lmid) \u0026gt; f(rmid)$：最大值一定在 $[l, rmid]$ 之间。   证明：假如 $f(lmid) \u0026lt; f(rmid)$，那么如果最大值在 $lmid$ 的左边则必然不可能，因为 $rmid$ 离最大值比 $lmid$ 更远。另外一种情况亦然。\n 例题 例1 洛谷P3382 题意\n给定一个 $N$ 次函数，保证 $[l,r]$ 内存在一个点 $x$，使得 $[l,x]$ 单调增，$[x,r]$ 单调减，求 $x$\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-7; int n; double l,r; double arr[16]; double get(double x) { double res = 0; double cur = 1.0; for (int i = 1; i \u0026lt;= n+1; i++) { res += cur * arr[i]; cur *= x; } return res; } int main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = n+1; i \u0026gt;= 1; i--) cin \u0026gt;\u0026gt; arr[i]; double low = l, high = r; while (high - low \u0026gt; 5e-7) { double mid = (low + high) * 0.5; double lmid = mid - eps, rmid = mid + eps; if (get(lmid) \u0026lt; get(rmid)) low = lmid; else high = rmid; } printf(\u0026quot;%.7f\\n\u0026quot;, low); }   例2 CF1355E 题意\n有 $N$ 个柱子，高度分别为 $h_1, h_2, \u0026hellip; h_N$。现在有3种操作：\n 令一个柱子的高度+1，cost为 $A$ 令一个柱子的高度-1，cost为 $R$ 令一个柱子的高度+1，且令另外一个柱子的高度-1，cost为 $M$  求最小的cost使得所有柱子高度相等？\n其中 $1 \\leq N \\leq 10^5, 0 \\leq h_i \\leq 10^9$\n 题解 如果我们枚举最终的高度 $h$，对于每一个 $h$ 都可以在 $\\log(N)$ 的时间内计算出来对应的 $cost$。\n然后我们会发现，随着 $h$ 的增加，$cost$ 是一个二次函数，具有一个最小值。（证明略）\n所以就可以使用三分搜索了！\n 因为三分搜索的边界不太好处理，所以可以限定一个范围，在范围之内就停止搜索开始暴力枚举。\n 搜索的部分代码：\nll low = 1, high = 1e9; while (high - low \u0026gt;= 10) { ll mid = (low + high) \u0026gt;\u0026gt; 1; ll lmid = mid-1, rmid = mid+1; ll lv = solve(lmid), rv = solve(rmid); if (lv \u0026gt; rv) low = lmid; else high = rmid; } for (ll p = low; p \u0026lt;= high; p++) { ll r = solve(p); ans = min(ans, r); }  ","date":"2021-03-05T22:20:54+08:00","permalink":"https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/","tags":["三分搜索"],"title":"三分法"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P5664\n题意\n有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的菜。所以总共有 $\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m a_{ij}$ 道不同的菜。\n现在需要求做菜方案 （设总共有 $k$ 道菜，$k$ 可以取任何数），满足：\n $k \\geq 1$ 每道菜的烹饪方法 $i$ 各不相同 每种主要食材 $j$ 最多在一半（$\\lfloor \\frac{k}{2} \\rfloor$）的菜中出现  求满足上述条件的做菜方案个数？\n$1 \\leq n \\leq 100, 1 \\leq m \\leq 2000, 0 \\leq a_{ij} \u0026lt; 998244353$\n 题解 首先考虑条件1和2，满足这些条件的总方案数有 $((s_1+1) * (s_2+1) * (s_3+1) * \u0026hellip; * (s_n+1) - 1)$ 种，其中 $s_i = \\sum\\limits_{j=1}^m a_{ij}$\n（因为对于每种烹饪方法 $i$，还可以 不选，所以是 $(s_i+1)$，最后减去 全部不选 的情况）\n这样，我们减去 不满足条件3 的方案数即可！\n我们枚举超过限制的主要食材 $j$，然后设 $dp[i][k]$ 为：当前到了第 $i$ 种烹饪方法，使用了 $k$ 种主要食材 $j$ 的方案数。\n那么问题关键在于，对于某一种烹饪方法 $i$，我们可以不选任何菜，这怎么办？\n我们假设有 $t$ 个不选的，那么总共就选了 $n-t$ 个菜，要保证 $k \u0026gt; \\lfloor \\frac{n-t}{2} \\rfloor$，即 $2k + t \u0026gt; n$。\n所以，我们可以改变一下状态的定义，我们可以将 不选 变成 选了一种主要食材 $j$，而 选择主要食材 $j$ 就变成 选择了两个主要食材 $j$。这样，只要满足 2 * 选择主要食材 + 不选的数量 = 2k + t \u0026gt; n，就不满足条件3了！\n转移方程就很好写了，对于每一种烹饪方法 $i$，有 $3$ 种决策方案：\n 选择主要食材 $j$：dp[i][k] += dp[i-1][k-2] * a[i][j]; 不选任何菜： dp[i][k] += dp[i-1][k-1]; 选择非主要食材：dp[i][k] += (dp[i-1][k] * (sum[i] - a[i][j]));   注意，不能将 dp 数组变成一维然后倒序转移！\n比如，在第三种转移时，(sum[i] - a[i][j]) == 0，那么如果是二维的，此时 dp[i][k] = 0，而如果是一维的，就会变成 dp[i][k] = dp[i-1][k]。\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 998244353; const int maxn = 1e5+5; ll dp[103][205]; ll sum[105]; ll a[103][2003]; int n,m; int main() { fastio; ll ans = 1; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; sum[i] = (sum[i] + a[i][j]) % mod; } ans = (ans * (sum[i]+1LL)) % mod; } ll delta = 1LL; for (int j = 1; j \u0026lt;= m; j++) { memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 0; k \u0026lt;= 2*n; k++) { dp[i][k] = (dp[i][k] + dp[i-1][k] * (sum[i] - a[i][j]) % mod) % mod; if (k \u0026gt;= 1) { (dp[i][k] += dp[i-1][k-1]) %= mod; } if (k \u0026gt;= 2) { dp[i][k] = (dp[i][k] + dp[i-1][k-2] * a[i][j] % mod) % mod; } } } for (int k = n+1; k \u0026lt;= 2*n; k++) (delta += dp[n][k]) %= mod; } ans -= delta; (ans %= mod) += mod; ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  ","date":"2021-03-05T14:58:19+08:00","permalink":"https://tom0727.github.io/post/019-luogu-p5664/","tags":["数学","计数","dp"],"title":"Luogu P5664 Emiya家今天的饭（计数，dp）"},{"categories":["题解"],"contents":"题目链接 https://www.luogu.com.cn/problem/P1450\n题意\n共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$\n某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请问每次有多少种付款方法。\n其中，$1 \\leq c_i,d_i,s \\leq 10^5, 1 \\leq n \\leq 1000$\n 题解 先考虑每个硬币有 无限 个的情况。\n设 $dp[i][j]$ 为：使用 前 $i$ 种硬币，购买 价值为 $j$ 的物品的方案数，那么有：\n$dp[i][j] = \\sum\\limits_{k=1}dp[i-1][j-c_i*k]$。\n很明显，这是一个 无穷背包，所以可以直接优化为：\ndp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - c[i] \u0026gt;= 0) dp[j] += dp[j-c[i]]; } }  那么，现在考虑 只有一种硬币有限制 的情况：\n由于 $dp[j]$ 都是从 $dp[j-c_i]$ （实际上就是从 $dp[j-k*c_i]$）转移过来的，那么我们只要把 硬币超出限制的转移情况 删掉即可！\n所以，$dp[j] - dp[(d_i+1) * c_i]$ 就是答案了！\n那么如果 多个硬币有限制 呢？考虑 容斥 ！\n假设有 $3$ 种硬币，那我们就 减去 $1$ 种硬币超限的情况，加上 $2$ 种硬币超限的情况，减去 $3$ 种硬币超限的情况。\n枚举这些情况，使用 bitmask 即可！(具体的见代码)\n 容斥中，每一项的符号根据 bitmask 中 bit 的个数来决定！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e5+5; ll dp[maxn]; int arr[5]; int d[5]; int q,s; int main() { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; arr[i]; cin \u0026gt;\u0026gt; q; dp[0] = 1; for (int i = 1; i \u0026lt;= 4; i++) { for (int j = 1; j \u0026lt;= 1e5; j++) { if (j - arr[i] \u0026gt;= 0) dp[j] += dp[j-arr[i]]; } } while (q--) { for (int i = 1; i \u0026lt;= 4; i++) cin \u0026gt;\u0026gt; d[i]; cin \u0026gt;\u0026gt; s; ll ans = dp[s]; for (int mask = 1; mask \u0026lt;= (1\u0026lt;\u0026lt;4)-1; mask++) { // 枚举容斥 int cnt = 0; int cur = 0; for (int j = 1; j \u0026lt;= 4; j++) { if (mask \u0026amp; (1\u0026lt;\u0026lt;(j-1))) { cur += ((d[j]+1) * arr[j]); cnt++; // 判断加号还是减号 } } if (s \u0026gt;= cur) { if (cnt \u0026amp; 1) ans -= dp[s - cur]; else ans += dp[s - cur]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   其他例题(TODO) ","date":"2021-03-04T23:29:54+08:00","permalink":"https://tom0727.github.io/post/018-luogu-p1450/","tags":["数学","计数","容斥"],"title":"Luogu P1450 硬币购物（计数，容斥）"},{"categories":["算法"],"contents":"记录一些组合数学的公式。\n公式 组合数 $C(n,m)$  $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \\frac{n!}{k!(n-k)!}$   注：$0! = 1, (0!)^{-1} = 1$\n 证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素：\n 如果它被选中，有 $C_{n-1}^{k-1}$ 种。 如果它没有被选中，有 $C_{n-1}^k$ 种。    二项式定理 $(a+b)^n = \\sum\\limits_{k=0}^n C_n^ka^kb^{n-k}$\n 卡特兰数 (Catalan) 通项公式：\n $H_n = 1 ~ (n=0,1)$\n  $H_n = \\frac{C_{2n}^n}{n+1}~(n \\geq 2)$\n  $H_n = C_{2n}^n - C_{2n}^{n-1}$\n  递推式：\n  $H_n = \\sum\\limits_{i=0}^{n-1}H_{i}H_{n-i-1} = H_0H_{n-1} + H_1H_{n-2} + \u0026hellip; + H_{n-1}H_0$\n  $H_n = \\frac{(4n-2)}{n+1} H_{n-1}$\n   第二类斯特林数 $S(n,m)$ 代表将 $n$ 个不同的小球，放进 $m$ 个相同，非空盒子的方案数\n通项公式：\n$S(n,m) = \\sum\\limits_{i=0}^m (-1)^{m-i}\\frac{i^n}{i!(m-i)!}$\n递推式：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n证明 考虑第一个小球，有两种情况：\n 独占一个盒子：相当于，其他 $n-1$ 个小球要放进 $m-1$ 个盒子中，且盒子不为空，所以为 $S(n-1,m-1)$ 不独占一个盒子：相当于，先将其他 $n-1$ 个小球放进 $m$ 个盒子中，且盒子不为空，然后从 $m$ 个盒子中选一个，把当前小球放进去，所以为 $m*S(n-1,m)$   经典例题 例1 男女生排列问题 题意\n三个女生和五个男生站成一排。\n  如果女生必须全排在一起，有多少种排法？\n  如果女生不能相邻，有多少种排法？\n  如果两端都不排女生，有多少种排法？\n  如果两端不都排女生，有多少种排法？\n   第一题答案 将3个女生看作1个，所以就有 $A_6^6$ 种。对于女生内部的排列有 $A_3^3$ 种。所以总共为 $A_6^6A_3^3$ 种。\n 第二题答案 先排男生，有 $A_5^5$ 种，然后将女生插入6个空位中，有 $A_6^3$ 种。所以总共为 $A_5^5A_6^3$ 种。\n 第三题答案 先排好两个男生在两边，有 $A_5^2$ 种，两个男生中间的人就可以随便排了，就有 $A_6^6$ 种。所以总共为 $A_5^2A_6^6$ 种。\n也可以这么想，让女生在中间的6个位置先选好3个，有 $A_6^3$ 种，剩下的男生随便排，有 $A_5^5$ 种。所以总共为 $A_6^3A_5^5$ 种，答案和上面一样。\n 第四题答案 所有排列情况有 $A_8^8$ 种，如果两边都排女生，有 $A_3^2A_6^6$ 种。所以总共为 $A_8^8 - A_3^2A_6^6$ 种。\n  例2 小球放盒子问题 假设有 $n$ 个小球，$m$ 个盒子。\n小球无区别-盒子无区别-不允许空盒 略（还没遇到）\n 小球无区别-盒子无区别-允许空盒 略（还没遇到）\n 小球无区别-盒子有区别-不允许空盒 使用隔板法，在 $n$ 个小球中间放置 $m-1$ 块挡板，将小球分为不为空的 $m$ 部分。小球之间的空位有 $n-1$ 个。所以答案为\n$C_{n-1}^{m-1}$\n 小球无区别-盒子有区别-允许空盒 先多加 $m$ 个小球，转化为 不允许空盒 的问题后，再把多加的 $m$ 个小球拿出来即可。所以答案为\n$C_{n+m-1}^{m-1}$\n 小球有区别-盒子无区别-不允许空盒 答案就是第二类斯特林数 $S(n,m)$，递推式如上：\n$S(n,m) = m*S(n-1,m) + S(n-1,m-1)$\n 小球有区别-盒子无区别-允许空盒 在 不允许空盒 的基础上，枚举一下 空盒的个数。所以答案为\n$\\sum\\limits_{i=1}^{\\min(n,m)}S(n,i)$\n 小球有区别-盒子有区别-不允许空盒 在 盒子无区别 的基础上，乘上盒子的排列 $m!$ 即可，所以答案为：\n$S(n,m) * m!$\n 小球有区别-盒子有区别-允许空盒 每个小球可以随便选，互不影响，所以答案为：\n$n^m$\n  例3 错排问题 题意\n有 $1,2,3,\u0026hellip;,n$ 这些数字，重新排序使得不存在任何一个数字的位置和原来相同，有多少种方法？\n 答案 $D_n = (n-1)(D_{n-1} + D_{n-2})$，其中 $D_1 = 0, D_2 = 1$\n证明：初始情况下如图：\n在图中，上下两行对应的元素需要错开。我们设这种情况下，排序的方法有 $f(n)$ 种。\n对于元素 $1$，我们可以选择除 $1$ 以外的任何一个元素，所以有 $n-1$ 种。\n假设我们选了 $1 \\rightarrow 2$，就会变成下图：\n那么，再看元素 $2$：\n  如果 $2 \\rightarrow 1$，那么就会变成下图，即 $f(n-2)$ 种。   如果 $2 \\rightarrow 3 ~ or ~ 4 ~ or ~ \u0026hellip; ~ n$，就相当于 $2$ 和 $1$ 必须错开，那就相当于下图，即 $f(n-1)$ 种。\n  所以最终就可以得到 $f(n) = (n-1)(f(n-1) + f(n-2))$\n","date":"2021-03-02T18:35:43+08:00","permalink":"https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["数学"],"title":"组合数学"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f\n题意\n初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种：\n1 a b：令 $f(x) = f(x) + |x-a| + b$\n2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值\n 题解 $f(x)$ 必然长这样：$f(x) = |x-a_1| + |x-a_2| + \u0026hellip; + |x-a_n| + \\sum\\limits_{i=1}^{n}b_i$\n要让 $f(x)$ 最小，就令 $x$ 等于 $a_1,a_2,\u0026hellip;,a_n$ 的中位数。\n那么已知中位数 $a_k$ 的话，如何找到 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ ？\n假设 $n$ 为奇数，那如果我们将 $a_i$ sort 一下，有：\n$\\sum\\limits_{i=1}^{n} |a_{\\frac{n+1}{2}} - a_i| = \\sum\\limits_{i=1}^{\\frac{n}{2}}(a_{\\frac{n+1}{2}+i} - a_{\\frac{n+1}{2}-i})$\n如果我们分开维护中位数 $a_{\\frac{n+1}{2}}$ 左右两边的 sum 就可以 $O(1)$ 求和了！\n 用对顶堆！\n我们维护两个 multiset\u0026lt;ll\u0026gt;，一个是大顶堆（叫做small），维护小于等于中位数的部分。一个是小顶堆（叫做big），小顶堆维护大于等于中位数的部分，并且保证两者的 size 之差 $\\leq 1$。\n 插入新值的时候，就和当前中位数比较一下，如果小于等于中位数就插入small，否则插入big，然后看一下size之差，如果 size之差 $\u0026gt; 1$ 就从多的那个堆取出来，插入另外一个堆，这样就动态调整了中位数。\n 这样我们可以 $O(1)$ 求出中位数，并且 $\\sum\\limits_{i=1}^{n} |a_k - a_i|$ 也可以 $O(1)$ 得出，用big的$sum$ 减去 small的 $sum$ 即可。（写的时候需要讨论一下 size 之差为 1,0,-1 的三种情况）。\n细节部分直接看代码吧。\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e5+10; ll c = 0, ssum = 0, bsum = 0; multiset\u0026lt;ll\u0026gt; big; multiset\u0026lt;ll, greater\u0026lt;ll\u0026gt; \u0026gt; small; void ins(ll a, ll b) { c += b; if (!small.size()) { ssum += a; small.insert(a); return; } if (a \u0026lt;= *small.begin()) { small.insert(a); ssum += a; } else { big.insert(a); bsum += a; } if (small.size() \u0026gt; big.size() + 1) { auto p = small.begin(); bsum += *p, ssum -= *p; big.insert(*p); small.erase(p); } if (big.size() \u0026gt; small.size() + 1) { auto p = big.begin(); bsumssum += *p; small.insert(*p); big.erase(p); } } void query() { ll ans = bsum if (small.size() == big.size()) { cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (small.size() == big.size() + 1) { ans += *small.begin(); cout \u0026lt;\u0026lt; *small.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return; } if (big.size() == small.size() + 1) { ans -= *big.begin(); cout \u0026lt;\u0026lt; *big.begin() \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } } int main() { fastio; int Q; cin \u0026gt;\u0026gt; Q; while (Q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ins(a,b); } else { query(); } } }   其他例题(TODO)  https://www.luogu.com.cn/problem/P3644  ","date":"2021-03-01T21:35:11+08:00","permalink":"https://tom0727.github.io/post/016-at-abc127f/","tags":["数据结构","堆"],"title":"Atcoder ABC 127F（对顶堆动态维护中位数）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e\n题意\n给定一个矩阵，包含 $N \\times M$ 个格子，现在从中选出 $K \\leq N \\times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), \u0026hellip; , (x_K, y_K)$ ，记\n$cost = \\sum\\limits_{i=1}^{K-1}\\sum\\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$\n求：对于所有不同的 $K$ 个格子的选法，$cost$ 的sum为多少？\n 法一概率 选 $k$ 个格子的方案数为 $C(n+m, k)$，在 $k$ 个格子中，任选 $2$ 个出来，有 $C(k,2)$ 种，考虑它们的贡献：\n因为是全部方案，所以可以考虑用 期望值 来做！\n问题转化为，从 $N \\times M$ 的矩阵中，选择 $2$ 个不同的点 $(x_i, y_i), (x_j,y_j)$ ，求 $|x_i - x_j| + |y_i-y_j|$ 的期望？\n期望为： $\\frac{n+m}{3}$\n 如果推式子很难，这里是一些小技巧（仅用于 分母中无 $n,m$ ，并且分子中不存在 $nm$ 之类的项）：\n 打表找规律：假设期望值 $E(n,m)$ 是一个关于 $n,m$ 的多项式，那么固定一下 $n$ 的值，然后让 $m = 1,2,3\u0026hellip;$ 来打表找出 $E(n,m)$ 和 $m$ 的关系。同理可以找出 $E(n,m)$ 和 $n$ 的关系，相加一下就可以了。\n  拉格朗日插值法：设 $ans = F(n,m) = E(n,m) * C(nm, 2)$，我们可以固定 $n$，然后用插值法找出 $F(n,m)$ 和 $m$ 的关系。（这个函数有两个变量，按理说应该是固定每一个 $n$ 然后对每一个 $n$ 都进行一次插值法的，以后遇到了可以尝试一下。）\n  严谨证明：\n考虑一个点 $(x,y)$，那么\n纵向贡献 为： $v_{x,y} = [(1+2+\u0026hellip;+x-1) + (1+2+\u0026hellip;+n-x)] * m$\n横向贡献 为： $h_{x,y} = [(1+2+\u0026hellip;y-1) + (1+2+\u0026hellip;+m-y)] * n$\n期望就是 $E(n,m) = \\frac{\\sum\\limits_{x=1}^n \\sum\\limits_{y=1}^m (v_{x,y} + h_{x,y})}{C(nm,2)} = \\frac{n+m}{3}$\n 以上，最终的答案就是\n$ans = C(nm,k) * C(k,2) * \\frac{n+m}{3}$\n 法二计数 我们选择 $2$ 个格子，有 $C(nm-2, k-2)$ 种。\n对于横坐标的差值为 $d_x$ 的情况，有 $(n-d_x) m^2$ 种。贡献就是 $(n-d_x)m^2*d_x$\n对于纵坐标的差值为 $d_y$ 的情况，有 $(m-d_y) n^2$ 种。贡献就是 $(m-d_y) n^2*d_y$\n所以答案就是\n$ans = C(nm-2, k-2) (\\sum\\limits_{d_x=1}^{n-1} (n-d_x)m^2*d_x + \\sum\\limits_{d_y=1}^{m-1} (m-d_y)n^2*d_y)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int mod = 1e9+7; const int maxn = 2e5+5; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; (a *= a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll a) { return qpow(a, mod-2); } ll n,m,k; ll fac[maxn]; void init() { fac[0] = 1; fac[1] = 1; for (int i = 2; i \u0026lt;= n*m; i++) { fac[i] = (fac[i-1] * (ll)(i)) % mod; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; init(); ll nu = fac[n*m] * k % mod * (k-1) % mod * (n+m) % mod; ll de = inv(fac[k]) * inv(fac[n*m-k]) % mod * inv(6) % mod; cout \u0026lt;\u0026lt; (nu * de) % mod \u0026lt;\u0026lt; endl; }   参考链接  https://blog.csdn.net/weixin_30323631/article/details/96351727 https://blog.csdn.net/qq_40655981/article/details/90642350  一些数学知识 Q1. 如果不限定坐标为整数，长度为 $n$ 的线段上任取两个点，距离期望值是？\nA1. 答案为 $\\frac{n}{3}$，有两种方法。\n第一种：先假设坐标只能为 $1,2,\u0026hellip;,n$ 的整数，那么求出的期望是 $E_n = 2\\times \\frac{\\sum\\limits_{i=1}^{n}i(n-i)}{n^2} = \\frac{n^2-1}{3n}$，取一个 $n$ 趋向无穷，就有 $E = \\lim_{n \\to \\infty} \\frac{n^2-1}{3n} = \\frac{n}{3}$\n 上述推导需要用到 $1^2 + 2^2 + \u0026hellip; + n^2 = \\frac{1}{6}n(n+1)(2n+1)$\n 第二种：先假设线段长度为 $1$，则有期望为 $\\frac{\\int_{0}^1 \\int_{0}^1 |x-y| ~dydx}{\\int_{0}^1 \\int_{0}^1 1~ dydx} = \\int_{0}^1 \\int_{0}^x (x-y) ~ dydx + \\int_{0}^1 \\int_{x}^1 (y-x) ~dydx = \\frac{1}{3}$，对于线段长度为 $n$，乘上 $n$ 即可。（记得分母要除以样本空间，即 $\\int_{0}^1 \\int_{0}^1 1~ dydx$）\n Q2. 如果不限定坐标为整数，$n \\times n$ 的正方形中任取两个点，距离期望值是？\nA2. 答案约为 $0.521$，具体分析可以见 这里 和 这里\n其他例题(TODO)  https://www.luogu.com.cn/problem/P4781  ","date":"2021-02-28T23:20:51+08:00","permalink":"https://tom0727.github.io/post/015-at-abc127e/","tags":["数学","计数","概率"],"title":"Atcoder ABC 127E（数学，计数，概率）"},{"categories":["题解"],"contents":"题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e\n题意\n给定 $2 \\leq N \\leq 10^5, 2 \\leq K \\leq 10^5$，现有长度为 $N$ 的序列 $\\{ a_1, a_2, \u0026hellip;, a_N \\}$，其中 $1 \\leq a_i \\leq K$\n这样的序列总共有 $K^N$ 个，求所有这些序列的 $\\sum \\gcd(a_1,a_2,\u0026hellip;,a_N)$？\n 题解 发现我们可以根据 $\\gcd$ 的值进行枚举，我们设 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = x$ 的序列数量为 $d_x$，则有：\n$d_1 = K^N - d_2 - d_3 - \u0026hellip; - d_k$\n那么 $d_2$ 呢？我们发现如果 $\\gcd(a_1,a_2,\u0026hellip;,a_N) = 2$，则所有的 $a_i$ 必然为 2的倍数，所以每个位置上有 $\\frac{K}{2}$ 种选法，即：\n$d_2 = (\\frac{K}{2})^N - d_4 - d_6 - \u0026hellip; - d_{\\frac{K}{2} \\times 2}$\n同理有：\n$d_3 = (\\frac{K}{3})^N - d_6 - d_9 - \u0026hellip; - d_{\\frac{K}{3} \\times 3}$\n\u0026hellip;\n$d_K = 1$\n这样，直接用一个 dp[] 记录一下 $d_x$ 的值，然后倒着枚举，暴力计算即可。\n最终的答案为 $\\sum\\limits_{i=1}^K i \\times dp[i]$\n时间复杂度：$T(K) = K + \\frac{K}{2} + \\frac{K}{3} + \u0026hellip; + \\frac{K}{K} = K(1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K})$\n发现这个是 harmonic series 的和，复杂度大概为： $1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{K} = O(\\log k)$\n所以最终时间复杂度是 $O(K\\log K)$\n 代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 1e5+5; int n,k; ll dp[maxn], ans = 0; ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b\u0026amp;1) (res *= a) %= mod; b \u0026gt;\u0026gt;= 1; (a *= a) %= mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = k; i \u0026gt;= 1; i--) { ll d = 0; for (int j = 2; i * j \u0026lt;= k; j++) { d += dp[i*j]; } d %= mod; ll r = qpow(k/i, n); dp[i] = (r-d+(ll)mod) % mod; ans = (ans + (ll)(i) * (ll)(dp[i])) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   一些拓展 在洛谷上看题解的时候，看到了莫比乌斯反演的方法，如果未来学了的话可以重新来做一下，loj上有加强版的题目 ($K \\leq 10^{11}$)\n其他例题(TODO)  https://loj.ac/p/6491 (需要莫比乌斯反演)  ","date":"2021-02-27T14:59:58+08:00","permalink":"https://tom0727.github.io/post/014-at-abc162e/","tags":["数学","计数"],"title":"Atcoder ABC 162E（数学，计数）"},{"categories":["算法"],"contents":"定义 最小环：指图中的一个环，它不包含任何更小的环。\n在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-loop的情况）\n无权无向图求最小环 例题: https://codeforces.com/contest/1364/problem/D\n题意\n给定一个 connected undirected graph:\n$n$个vertex, 和一个int $k$, 其中 $3 \\leq k \\leq n$, 请找出 以下的其中之一:\n  一个独立集(set of vertex， 两两之间没有edge)， 包含 $\\lceil\\frac{k}{2}\\rceil$ 个vertex\n  一个simple cycle (set of vertex, 不包含重复vertex)， 其中 $len \\leq k$\n   题解   如果这是一个tree ($m = n-1$), 则 (1)很容易找, 只要dfs一下，做一个图的染色 (染成 $0,1$)即可, 最后取 全部的 $0$ 或者 全部的 $1$\n  如果不是tree, 必然存在cycle, 那么我们可以找到一个最小环, 最小环必然满足 (1) 或者 (2)！（易证）\n  •怎么找最小环? 用DFS!\n 维护一个环的长度 len 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 pre[] 数组, pre[u] 代表dfs过程中 u的parent 维护一个 int c, 代表找到的cycle的 终点!  然后，\n  从vertex 1开始dfs， dep[to] = dep[cur] + 1 这样来更新 dep[]\n  当我们找到一个backward edge时, 更新最小环长度\nlen = min(len, abs(dep[to] - dep[cur]) + 1))  并且更新c, 使得 c = cur, 然后继续探索！\n  dfs结束后, 直接用\nvector\u0026lt;int\u0026gt; cycle; void findcycle() { while (len--) cycle.push_back(c), c = pre[c]; }  即可找到最小环！\n  时间复杂度：$O(n+m)$\n 无权有向图求最小环 例题：https://atcoder.jp/contests/abc142/tasks/abc142_f\n题意\n给定一个 directed graph，求它的一个 subgraph 满足：\n $V'$ 是 $V$ 的 non-empty subset $E'$ 是 $E$ 中，所有两端均在 $V'$ 内的edges $V'$ 中，所有的 vertex 的 in-degree 和 out-degree 均为1   题解 易知，最小环满足这个条件！\n如何求最小环？可以用 $N$ 次 DFS！\n 维护 ed 代表环的终点，维护最小环长度 final 维护一个 dep[] 数组, 代表每个vertex的depth 维护一个 par[] 数组, par[u] 代表dfs过程中 u的parent 维护一个 in[] 数组，代表在dfs过程中，当前的某个vertex是否存在于递归stack中！  dfs过程如下：\nint n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { // 必须得在递归栈内 int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; }   为什么要加 in[] 数组？\n 如下图：\n我们需要保证这个环必然全部同时出现在递归stack内，否则可能会出问题！\n（如上图，如果不考虑 in[] 数组的话，就有可能错误的把 1-\u0026gt;3-\u0026gt;2 当作一个环！\n 为什么要使用 $N$ 次 dfs ？\n 如下图：\n如果我们从 $1$ 开始进行 dfs，那么如果是按照图上的访问顺序，会导致我们找不到最小环！\n但是如果从 $7$ 开始进行 dfs，就可以找到了！\n所以我们需要每一个点都开始一次dfs，总共 $N$ 次 dfs。\n 注：优化：可以在每次dfs中找到的环中找最小环，如果不是环中的节点，就不需要考虑了。\n  代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define abs(a) ((a\u0026gt;0)?a:-(a)) const int mod = 1e9+7; const int maxn = 1e3+5; const int maxm = 2e3+10; struct Edge { int to,nxt; } edges[maxm]; int head[maxn], ecnt = 1; int n,m, dep[maxn], par[maxn]; int ans = 1e9, ed = -1, final = 1e8; vector\u0026lt;int\u0026gt; cycle; bool in[maxn]; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u,v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u,v); } } void dfs(int cur) { in[cur] = 1; dep[cur] = dep[par[cur]] + 1; for (int e = head[cur]; e; e = edges[e].nxt) { int to = edges[e].to; if (dep[to]) { if (in[to]) { int res = abs(dep[cur] - dep[to]) + 1; if (res \u0026lt; ans) { ans = res; ed = cur; } } } else { par[to] = cur; dfs(to); } } in[cur] = 0; } void renew() { fill(dep, dep+n+1, 0); fill(par, par+n+1, 0); fill(in, in+n+1, 0); ans = 1e9; } int main() { fastio; init(); for (int i = 1; i \u0026lt;= n; i++) { dfs(i); if (ans \u0026lt; final) { final = ans; cycle.clear(); while (ans--) cycle.push_back(ed), ed = par[ed]; } renew(); } if (final == 1e8) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; final \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int a : cycle) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }   有权图求最小环 Floyd $O(n^3)$ 可求！\n","date":"2021-02-25T23:41:02+08:00","permalink":"https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/","tags":["图论","最小环","dfs"],"title":"最小环"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1395/problem/E\n题意\n给定一个 directed and weighted graph，$2 \\leq n \\leq 2\\cdot10^5, 2 \\leq m \\leq \\min(2\\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\\leq k \\leq 9$，每个edge的weight均不相同。\n现在定义一个tuple $(c_1,c_2,\u0026hellip;,c_k)$，其中， $\\forall j \\in [1,k]$，有 $1\\leq c_j \\leq j$。\n且对于所有 out-degree 等于 $j$ 的vertex，只保留它的out-going edges中，weight第 $c_j$ 小的那个edge。\n 例如，对于vertex 5，有 $3$ 条out-going edges (以(u,v,w)的形式)： $(5,2,233), (5,4,25), (5,6,999)$\n如果 $c_3 = 1$，因为 vertex 5 具有 out-degree = $3$，所以 $c_3$ 生效，因为 $c_3 = 1$，所以保留第 $1$ 小的edge，也就是$(5,4,25)$。\n 现在求 $(c_1,c_2,\u0026hellip;,c_k)$ 的数量，使得整个图是强连通的。\n 题解 首先可以发现，因为每个edge的weight都不同，所以对于每一个vertex来说，必然只能保留最多 $1$ 个out-going edge。所以整个图中，只有 $n$ 个edge。\n又因为需要强连通，所以它只有可能是 一个环！所以只要看 每个vertex的 in-degree 是否都等于$1$即可！\n再转化一下，我们只要看在 $(c_1,c_2,\u0026hellip;,c_k)$ 的情况下，所有out-going edge所指向的vertex，并起来，形成的 可重复集合(multiset) 是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n我们可以预处理出 对于每一个 $j$，如果 $c_j = x$，所指向的vertex组成的集合。然后在枚举 $(c_1,c_2,\u0026hellip;,c_k)$ 的时候，判断一下这些集合的并集是否为 $\\{1,2,3,\u0026hellip;,n\\}$ 即可！\n那么，如何快速的\n 判断集合是否相等 和 求可重复并集 呢？  使用Hashing！\n 我们要定义一种Hash函数，使得上述两个操作的速度为 $O(1)$ 。\n在字符串哈希中，我们用字符的位置来hash，但是因为我们不关心集合中元素的顺序，所以可以用集合中元素的value来hash！\n假设给定一个集合 $\\{a_1,a_2,\u0026hellip;,a_m\\}$，定义哈希值为：$\\sum\\limits_{i=1}^mp^{a_i} = p^{a_1} + p^{a_2} + \u0026hellip; + p^{a_m}$，这样：\n 判断集合是否相等：直接比较两个集合的哈希值 求两个集合的可重复并集：直接将两个集合的哈希值相加   代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const int mod = 1e9+7; const int maxn = 2e5+5; const ll p = 31; int n,m,k; vector\u0026lt;pii\u0026gt; adj[maxn]; // {w, to} int out[maxn]; vector\u0026lt;int\u0026gt; deg[10]; // store vertices with deg x ll pow31[maxn]; ll ha[10][10]; //ha[i][j] 代表 c_i=j时，所指向的vertex的并集的哈希值 ll tar = 0; // {1,2,3...,n}对应的哈希值 int ans = 0; void init() { pow31[0] = 1; for (ll i = 1; i \u0026lt;= n; i++) pow31[i] = (pow31[i-1] * p) % mod; for (ll i = 1; i \u0026lt;= n; i++) tar += pow31[i]; tar %= mod; for (int i = 1; i \u0026lt;= k; i++) { // calculate all vertex with deg i for (int j = 1; j \u0026lt;= i; j++) { // if c_i = j for (int a : deg[i]) { int to = adj[a][j-1].second; (ha[i][j] += pow31[to]) %= mod; } } } } void dfs(int dep, ll cur) { //cur: current hash value if (dep == k+1) { if (tar == cur) ans++; return; } for (int j = 1; j \u0026lt;= dep; j++) { dfs(dep+1, (cur + ha[dep][j]) % mod); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; adj[u].push_back({w,v}); out[u]++; } for (int i = 1; i \u0026lt;= n; i++) { sort(adj[i].begin(), adj[i].end()); deg[out[i]].push_back(i); } init(); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   其他例题(TODO)  https://www.luogu.com.cn/problem/P6688 https://www.luogu.com.cn/problem/P3792  ","date":"2021-02-25T15:25:22+08:00","permalink":"https://tom0727.github.io/post/012-cf-1395e/","tags":["哈希","图论"],"title":"CF 1395E(集合哈希)"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1492/problem/E\n题意\n给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \\geq 2, m \\geq 1, n \\times m \\leq 250000$\n问是否存在一个array，使得这个array 与 其他每个array的difference（不同元素的个数） $\\leq 2$？\n 题解 暴搜，我们可以先令 $ans$ 等于第一个array，然后看一下其他array中，有没有 $diff \u0026gt; 2$ 的，如果有，尝试更改 $ans$ 中的一个元素，更改后再看一下其他array的difference情况，如果还是不行，就继续尝试更改其他元素。 直到所有array的 $diff \\leq 2$\n注意到，因为$ans$基于第一个array，所以最多只能更改两个元素，我们可以给在搜索的时候设置一个深度 left，代表还可以更改几个元素。一开始就是dfs(2)。\n 注1: 本题时限卡的比较紧，时限为2s，我们可以设定2s内如果搜索不出结果就直接返回\u0026quot;No\u0026rdquo;。\ndouble start = clock(); double passed = clock() - start; if (passed \u0026gt; 1950.0) { // 1950ms cout \u0026lt;\u0026lt; \u0026quot;No\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; exit(0); }    注2: 暴搜的时候记得回溯！\n  代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; vector\u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; arr; vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; cnt; double start; inline bool check() { for (int i = 0; i \u0026lt; n; i++) { if (cnt[i] \u0026gt; 2) return 0; } return 1; } void dfs(int left) { if (left \u0026lt; 0) return; if (clock()-start \u0026gt; 1950) { printf(\u0026quot;No\\n\u0026quot;); exit(0); } for (int i = 0; i \u0026lt; n; i++) { cnt[i] = 0; vector\u0026lt;int\u0026gt; pos; for (int j = 0; j \u0026lt; m; j++) { if (ans[j] != arr[i][j]) { cnt[i] += 1; pos.push_back(j); } } if (cnt[i]-left \u0026gt; 2) { return; } if (cnt[i] \u0026gt; 2) { for (int j : pos) { int pre = ans[j]; ans[j] = arr[i][j]; dfs(left-1); ans[j] = pre; //记得回溯 } } } if (check()) { printf(\u0026quot;Yes\\n\u0026quot;); for (int j = 0; j \u0026lt; m; j++) printf(\u0026quot;%d \u0026quot;, ans[j]); printf(\u0026quot;\\n\u0026quot;); exit(0); } } int main() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); start = clock(); arr = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n, vector\u0026lt;int\u0026gt;(m,0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i][j]); } } ans = arr[0]; cnt = vector\u0026lt;int\u0026gt;(n,0); dfs(2); printf(\u0026quot;No\\n\u0026quot;); }  ","date":"2021-02-24T22:27:41+08:00","permalink":"https://tom0727.github.io/post/011-cf-1492e/","tags":["搜索","dfs优化"],"title":"CF 1492E(暴搜)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于HTML,CSS,JS的知识点\nCSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测当前在哪个页面，然后让当前页面对应的link的img更换一个，怎么办？（不使用javascript，仅用CSS）\n方案 可以用CSS中的 Pseudo-classes 中的 target，当网页链接中存在 #some_id 时，所有 id = \u0026quot;some_id\u0026quot; 的tag就会变成 :target 的状态。\n所以可以给每个 a 的 href 加上一个 #some_id，然后给 img 加上 id = some_id，如下：\nHTML代码 \u0026lt;nav\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026quot;index.html#index\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; id=\u0026quot;index\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;aboutus.html#about\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/2.jpg\u0026quot; id=\u0026quot;about\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;staff.html#staff\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;images/3.jpg\u0026quot; id=\u0026quot;staff\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt;   CSS代码 这里以index为例：\nnav \u0026gt; div \u0026gt; a[href*=\u0026quot;index\u0026quot;] \u0026gt; img:target { content:url(\u0026quot;images/index_selected.jpg\u0026quot;); }   参考链接  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target  HTML/CSS 手机字体大小不一 在手机上发现font-size相同的字体大小不一致，怎么办？\n方案   在HTML文件前面加上\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt;    添加上述代码后，网页中可能会出现 horizontal scrollbar。可以在css中添加：\n@media only screen and (max-width: 600px) { html, body { overflow-x: hidden; } body { position: relative; } }  然后在 media query 里面调整一下字体大小，图片大小之类的属性，保证 overflow-x: hidden; 不会隐藏内容。\n  参考链接  https://stackoverflow.com/questions/27074259/html-css-table-font-size-different-in-mobile-device https://stackoverflow.com/questions/4192277/disable-horizontal-scroll-on-mobile-web  Hot Reload 网页 使用 browser-sync 即可：\n npm install -g browser-sync browser-sync start --server --files \u0026quot;.\u0026quot;  ","date":"2021-02-21T23:39:36+08:00","permalink":"https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","tags":["前端","HTML","js","css"],"title":"HTML/CSS/JS笔记"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些关于vim的知识点\nHTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening tag跳转到closing tag怎么做？\n方案  在vscode下载一个叫 Highlight Matching Tag 的插件 下载叫做 matchit 的vim插件，放在本地的 ~/.vimrc/plugin/ 下（如果没有plugin文件夹，就创建一个），在.vimrc里添加 filetype plugin on runtime macros/matchit.vim  这样就可以用 % 进行跳转了。\n vscode上似乎不能装插件，可以把cursor移动到tag上，然后按 esc 进入normal mode，然后 v a t 跳转到matching tag  参考链接  https://stackoverflow.com/questions/7281459/matchit-not-working https://vi.stackexchange.com/questions/780/how-to-jump-between-matching-html-xml-tags  ","date":"2021-02-20T23:15:28+08:00","permalink":"https://tom0727.github.io/post/009-vim/","tags":["vim"],"title":"vim笔记"},{"categories":["算法"],"contents":"介绍 树形dp就是在树上进行dp，常用于 \u0026ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大\u0026rdquo; 的问题。\n树形dp实现过程中也有很多需要注意的点，以下放一道经典例题：\n例题 例1 洛谷P2014 题意\n有 $N$ 门课程，每门课程有 $1$ 或 $0$ 门前置课程，需要上了前置课程才能上这门课。每门课 $i$ 有 $s_i$ 学分。\n现要选 $M$ 门课，使得学分总和最大。\n 题解 设 $dp[i][j]$ 为: 以 $i$ 为根的子树当中，选了 $j$ 个课程得到的最大值\n根据前置课程的关系建图(会发现这是一棵树)，因为有前置课程，所以必须选了root才能选别的，故:\n$dp[i][1] = s_i$\n在处理某一个节点i的时候，$dp[i][j]$ 代表的是： 以它为root的 \u0026ldquo;已探索\u0026rdquo; 子树中的最大值，所以在探索各个子树过程中有：\n$dp\\left[cur\\right]\\left[j\\right]=\\max\\left(dp\\left[cur\\right]\\left[j\\right],dp\\left[cur\\right]\\left[k\\right]+dp\\left[nei\\right]\\left[j-k\\right]\\right),\\ k=\\left[1,j-1\\right]$\n 实现细节\n 我们利用 $dp[i][1] = s_i$ 来处理前置课程，是非常高效的做法！ 状态转移的时候，要 倒序枚举 $j$， 也就是 $j = m \u0026hellip; 1$， 因为此时 $dp[cur][k]$ 代表的是已探索的部分，不能包括 $nei$ (因为 $nei$ 正在被探索)。为了防止同一个 $nei$ 被考虑多次，要倒序枚举！ 给定的图可能是一个森林，所以创建一个超级root $0$，并且将 $M$++ (因为 $0$ 肯定要包含进去)，最终答案就是 $dp[0][M+1]$   算法优化\n注意，在dp状态转移的时候，我们可能用的是如下loop:\nfor (int j = m; j \u0026gt;= 1; j--) { for (int k = 1; k \u0026lt;= j-1; k++) { dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  每个节点 cur 都这样loop一次，总复杂度是 $O(nm^2)$，看起来不可接受。\n我们可以优化一下：\n对于每一个root节点 cur，我们记录一下 int sz[cur]，代表 以cur为根的子树的节点数量， 这样枚举的时候我们就可以优化成这样：\nfor (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } }  时间复杂度：$O(n^2)$\n证明：我们考虑每一个 nei 被用来转移 的次数，会发现它只会在计算它的 parent 的dp值时才会被拿来统计，又因为每一个节点只有1个parent，所以每个节点对应的子树都只会被统计一次。\n所以时间复杂度就是 $T(\\sum\\limits_{i=1}^n i * sz[i]) = O(n^2)$\n更严谨的数学证明可以参见 https://www.luogu.com.cn/blog/Chenxiao-Yan/solution-p4322\n luogu-P2014-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 305; const int maxm = 305; int n,m; int s[maxn]; int dp[maxn][maxn]; int sz[maxn]; //记录i的子树大小 struct Edge { int to, nxt; } edges[maxm]; int head[maxn], ecnt = 1; void add(int u, int v) { Edge e = {v, head[u]}; edges[ecnt] = e; head[u] = ecnt++; } void init() { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); fill(head, head+n+2, -1); //因为存在编号为0的节点，所以初始化为-1 for (int i = 1; i \u0026lt;= n; i++) { int sc,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,\u0026amp;sc); s[i] = sc; add(k, i); } } void dfs(int cur, int par) { if (sz[cur]) return; // visited dp[cur][1] = s[cur]; sz[cur] = 1; for (int e = head[cur]; ~e; e = edges[e].nxt) { int nei = edges[e].to; if (par == nei) continue; dfs(nei, cur); sz[cur] += sz[nei]; for (int j = min(m, sz[cur]); j \u0026gt;= 1; j--) { //优化 for (int k = 1; k \u0026lt;= min(j-1, sz[nei]); k++) { //优化 dp[cur][j] = max(dp[cur][j], dp[cur][j-k] + dp[nei][k]); } } } } int main() { init(); m++; dfs(0, -1); printf(\u0026quot;%d\\n\u0026quot;, dp[0][m]); }    题外话：如果每门课的前置课程不止1门，就不再是一棵树了，这样的话似乎可以用状压dp来解，leetcode某次比赛中出现过。\n ","date":"2021-02-18T15:42:09+08:00","permalink":"https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/","tags":["树形dp","dp优化"],"title":"树形dp"},{"categories":["算法"],"contents":"介绍 01分数规划用于 求一个分式的极值\n例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大/最小？\n方法 (二分) 一般使用二分答案的方法进行求解，假设我们要求最大值，那么 二分一个答案 $mid$，有\n$\\frac{\\sum a_i}{\\sum b_i} \\geq mid$, 所以\n$\\sum a_i- (mid \\times b_i) \\geq 0$\n所以只要求出左边的最大值，判断是否 \u0026gt;= 0 即可！\n 如果左边最大值 \u0026gt;= 0，说明当前答案 $mid$ 可行，提高下边界 如果左边最大值 \u0026lt; 0，说明当前答案 $mid$ 不可行，降低上边界  例题 例1 POJ2976 Dropping tests 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大。\n 题解 二分答案，当前答案为 $mid$ 时，把第 $i$ 个物品的权值设为 $a_i - mid \\times b_i$，然后取最大的 $k$ 个即可得到最大值。\n 例2 洛谷P1419 题意\n给定 $n$ 个整数，求一个长度在 $[S,T]$ 之间的subarray(连续)，使得平均值最大？\n 题解 二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1}$ 最大。\n令 $\\frac{\\sum\\limits_{i=l}^ra_i}{r-l+1} \\geq mid$，有 $\\sum\\limits_{i=l}^r(a_i - mid) \\geq 0$，\n定义一个新的数组$b$，其中 $b_i = a_i - mid$。\n左边的最大值就是 $b$ 这个数组中最大的连续区间，用前缀和即可。\n 另外一种思考方法:\n二分答案，当前答案为 $mid$ 时，我们遍历一下区间的右端点 $r$，从 $1$ 遍历到 $n$，固定一个 $r$，则我们需要找到 左端点 $l$ 使得 $\\frac{sum[r] - sum[l-1]}{r-l+1}$ 最大。\n$\\frac{sum[r] - sum[l-1]}{r-l+1} \\geq mid$ ，有 $(mid \\times (l-1) - sum[l-1]) - (mid \\times r - sum[r]) \\geq 0$\n因为 $r$ 固定，所以只要找 $mid*l - sum[l]$ 的最大值，其中 $l \\in [\\max(0, r-T), r-s]$。\n遍历 $r$ 的时候，维护一个单调队列即可。\n luogu-P1419-AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = (double)1e-6; const int maxn = 1e5+5; int n, s, t; int arr[maxn]; int sum[maxn]; double a[maxn]; int q[maxn]; int head = 0, tail = -1; double ans = -1e4; bool check(double cur) { for (int i = 0; i \u0026lt;= n; i++) a[i] = cur * (double)(i) - (double)(sum[i]); double res = -1e18; head = 0, tail = -1; for (int r = s; r \u0026lt;= n; r++) { while (head \u0026lt;= tail \u0026amp;\u0026amp; q[head] \u0026lt; r-t) head++; while (head \u0026lt;= tail \u0026amp;\u0026amp; a[q[tail]] \u0026lt; a[r-s]) tail--; q[++tail] = r-s; res = max(res, a[q[head]] - a[r]); } // for (int r = 1; r \u0026lt;= n; r++) { // double tmp = -1e18; // for (int i = max(0, r-t); i \u0026lt;= r-s; i++) { // tmp = max(tmp, a[i]); // } // res = max(res, tmp - a[r]); // } if (res \u0026gt;= 0) return 1; return 0; } int main() { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } double l = -1e4, r = 1e4; while (abs(l-r) \u0026gt; eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = mid; } else { r = mid; } } printf(\u0026quot;%.3f\\n\u0026quot;, ans); }   例3 洛谷P4377 题意\n有 n 个物品，每个物品 $i$ 有两个权值 $a_i, b_i$。\n你可以选 $k$ 个物品 ，使得 $\\frac{\\sum a_i}{\\sum b_i}$ 最大, 且 $\\sum b_i \\geq W$\n 题解 和例1几乎一样，但是多了一个 $\\sum b_i \\geq W$ 的限制。\n设 $d_i = a_i - mid \\times b_i$，然后我们要做的事就是：\n选取一组$i$，保证在 $\\sum b_i \\geq W$ 的前提下，使得 $\\sum d_i$ 最大\n可以用01背包解决，令 $dp[n][k]$ 为：使用前 $n$ 个元素，$\\sum b_i = k$ 时， $\\sum d_i$ 的最大值。\n那么答案就是 $dp[n][W]$。\n如果在状态转移过程中出现 $k \u0026gt; W$，直接转移到 $k = W$ 的状态上即可。\n 注: 写01背包的时候不要忘了 倒序枚举 ！\n  luogu-P4377-AC代码 using namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; const double eps = (double)1e-6; const int maxn = 255; int n,W; int w[maxn], t[maxn]; double dp[1001]; struct node { double d; int w; } arr[maxn]; bool check(double cur) { for (int i = 1; i \u0026lt;= n; i++) { arr[i] = {(double)t[i] - cur * (double)w[i], w[i]}; } fill(dp, dp+1001, -1e9); dp[0] = 0.0; for (int i = 1; i \u0026lt;= n; i++) { for (int d = 1000; d \u0026gt;= 0; d--) { int tar = min(d + arr[i].w, 1000); dp[tar] = max(dp[tar], dp[d] + arr[i].d); } } for (int d = W; d \u0026lt;= 1000; d++) { if (dp[d] \u0026gt;= 0.0) return 1; } return 0; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n,\u0026amp;W); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;w[i], \u0026amp;t[i]); } double l = 0.0, r = 1e6, ans = 0.0; while (abs(l-r) \u0026gt;= eps) { double mid = (l+r) * 0.5; if (check(mid)) { l = mid; ans = max(ans, mid); } else { r = mid; } } printf(\u0026quot;%d\\n\u0026quot;, (int)((ans+5e-5) * 1000)); }   例4 洛谷P4322 题意\n给定一棵$N$个节点的树，每个节点 $i$ 具有两个权值 $P_i, S_i$，求树中的一组节点，满足：\n $\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大 如果 节点 $i$ 被选中了，那么它的parent $R_i$ 也必须被选中 选中的节点数量 刚好为$K$  求满足条件的最大比值？\n 题解 首先看条件1：$\\frac{\\sum\\limits_i P_i}{\\sum\\limits_i S_i}$ 最大，仍然是分数规划的套路，二分答案。令 $d_i = P_i - mid \\times S_i$\n所以问题转化为求一组节点使得 $\\sum d_i$ 最大。\n然后就会发现，这是一个经典的树形dp模型，和 选课(洛谷P2014) 几乎一样。\n具体做法和注意事项见下一篇博客。\n","date":"2021-02-17T17:20:49+08:00","permalink":"https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":["01分数规划","二分"],"title":"01分数规划"},{"categories":["题解"],"contents":"题目链接 https://codeforces.com/contest/1159/problem/B\n题意\n给定 $n$ 个非负整数 $a_1,a_2,\u0026hellip;,a_n$，求 $\\frac{\\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \\in [1,n], i \\neq j$\n 题解 对于这类的枚举问题，一般套路都是 \u0026ldquo;固定一个数\u0026rdquo;，这里很明显是固定一下 $\\min(a_i, a_j)$。\n所以只要从 $a_1$ 遍历到 $a_n$，把当前遍历到的值作为最小值，然后不管最左侧或者最右侧元素是否小于它，直接最大化分母就可以了。\n为什么不会漏解？因为 每一个 $a_i$ 都当了一次分子！\n 代码 const int maxn = 3e5+5; int n, arr[maxn]; int ans = 1e9; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; arr[i]; for (int i = 1; i \u0026lt;= n; i++) { int d = max(i-1, n-i); ans = min(ans, arr[i] / d); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","date":"2021-02-17T15:19:54+08:00","permalink":"https://tom0727.github.io/post/006-cf-1159b/","tags":["枚举"],"title":"CF1159B 题解(枚举优化)"},{"categories":["工程","笔记"],"contents":"这篇博客主要收录一些爬虫相关的知识点：\n分段下载 如果我们需要设定下载的timeout怎么办？\n直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout参数意义是 \u0026ldquo;从服务器返回任意数据\u0026rdquo; 的时间差。如果我们想要设定 timeout 使得在一定时间内下载不完就break，可以用分段下载！\n分段下载由stream=True实现\ndef download_img(img_url, path): timeout = 150 # 设定150秒如果下载不完就停止下载 try: img_html = requests.get(img_url, headers=get_download_header(), timeout=10, stream=True) if img_html.status_code != 200: return body = [] start = time.time() for chunk in img_html.iter_content(1024): body.append(chunk) if time.time() \u0026gt; start + timeout: print(\u0026quot;Time out!\u0026quot;) break else: # 下载完毕 with open(path, 'wb') as file: file.write(b''.join(body)) file.flush() except BaseException as err: print(err)  多进程下载 多进程下载经常在访问一些速度较慢的网站时很有用，因为本地的带宽不是主要限制，所以可以开很多个进程同时访问然后进行下载，这样更快。\ndef f(arg): ... # 下载程序 if __name__ == '__main__': processes = [] for _ in range(20): p = multiprocessing.Process(target=f, args=(some_arg, )) p.start() processes.append(p) for p in processes: p.join()  正则表达式Regex的注意事项   匹配时注意区分懒惰匹配和贪婪匹配，懒惰匹配可以在匹配符号后加上?，如 .*?\n  如果在匹配过程中需要用到()，但是需要获取整个匹配结果（不想被()框起来的部分干扰），可以使用non-capturing group，即，(?:)，如:\nre.findall(\u0026quot;https://abc.net/images/.*?(?:jpg|png|jpeg)\u0026quot;, txt)\n这样，返回的就是整个匹配的网址，而不是()框起来的部分\n  ","date":"2021-02-10T22:52:26+08:00","permalink":"https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/","tags":["爬虫","python"],"title":"爬虫笔记"},{"categories":["算法"],"contents":"定义 给定正整数$n$，求$\\varphi(n)$， 即\n 小于等于$n$ 且 与$n$互质  的正整数个数。\n性质  $\\varphi(p) = p-1, ~\\forall \\text{prime } p$ $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$ $\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$ $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$  证明 证明性质1 求证： $\\varphi(p) = p-1, ~\\forall \\text{prime } p$\n 由质数的定义可知，小于等于$p$ 且 与$p$互质的数，在$[1,p]$中，除了 $p$以外均满足！\n 注： $\\varphi(1) = 1$\n 证明性质2 求证： $\\varphi(mn) = \\varphi(m)\\varphi(n) \\iff \\gcd(m,n) = 1$\n 首先，易知 $\\varphi(n) = |\\mathbb{Z}_n^{\\times}|$ , 即 $\\mathbb{Z}_n$ 中 unit(存在关于$\\bmod~ n$乘法逆元的元素)的数量\n因为 $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$\n所以 $\\mathbb{Z}_{mn}$的units $\\mathbb{Z}_{mn}^{\\times}$ ， 与\n$\\mathbb{Z}_m \\times \\mathbb{Z}_n$的 units $(\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times}$ 之间存在一个 bijection, 即\n$\\mathbb{Z}_{mn}^{\\times} \\cong (\\mathbb{Z}_m \\times \\mathbb{Z}_n)^{\\times} = \\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}$\n所以 $\\varphi(mn) = |\\mathbb{Z}_{mn}^{\\times}| = |\\mathbb{Z}_m^{\\times} \\times \\mathbb{Z}_n^{\\times}| = |\\mathbb{Z}_m^{\\times}||\\mathbb{Z}_n^{\\times}| = \\varphi(m)\\varphi(n)$\n 注：\n $\\mathbb{Z}_{mn} \\cong \\mathbb{Z}_m \\times \\mathbb{Z}_n \\iff \\gcd(m,n) = 1$ 的证明见 这里 更严格的证明需要用到抽代里的中国剩余定理 （以Ring和Ideal表示的）   证明性质3 求证：$\\varphi(p^k) = p^k - p^{k-1} = p^k(1-\\frac{1}{p})$\n $\\forall n = p^k$，所有与它不互质的数$m$必然包含$p$这个质数因子，因此满足条件的$m$为：$1p, 2p, 3p, \u0026hellip; , p^{k-1}p$，共 $p^{k-1}$个。\n所以，与$n = p^k$互质的数共有 $p^k-p^{k-1}$个。\n  证明性质4 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}, ~\\varphi(n) = n\\prod_{i=1}^{r}(1-\\frac{1}{p_i}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，且$p_1,p_2,\u0026hellip;,p_r$都是质数（所以两两互质）\n由性质2， $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3，$\\varphi(p_i^{k_i}) = p_i^{k_i} - p_i^{k_i-1} = p_i^{k_i}(1-\\frac{1}{p_i})$\n所以 $\\varphi(n) = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r}) = n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\u0026hellip;(1-\\frac{1}{p_r})$\n  证明性质5 求证：$\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$, 如果 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$, 则 $\\varphi(n) = \\varphi(\\frac{n}{p_i})*p_i$\n 因为 $n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，\n由性质2，$\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip;\\varphi(p_r^{k_r})$\n由性质3， $\\varphi(p^k) = p^k - p^{k-1}$, 我们可以推出 $\\varphi(p^{k+1}) = \\varphi(p^{k}) * p$\n因为 $~\\exists ~i, ~s.t. ~k_i \u0026gt; 1$，由上可得出 $\\varphi(p_i^{k_i}) = \\varphi(p_i^{k_i-1}) * p_i$\n即 $\\varphi(n) = \\varphi(p_1^{k_1})\\varphi(p_2^{k_2})\u0026hellip; (\\varphi(p_i^{k_i-1})*p_i)\u0026hellip;\\varphi(p_r^{k_r}) = \\varphi(\\frac{n}{p_i})*p_i$\n  求单个数的欧拉函数值 $\\forall n = p_1^{k_1}p_2^{k_2}\u0026hellip;p_r^{k_r}$，直接质因数分解，由性质4即可求出！\n时间复杂度：$O(\\sqrt n)$\n代码 ll phi(ll x) { ll res = x; for (ll p = 2; p * p \u0026lt;= x; p++) { if (x % p == 0) { res = (res / p) * (p-1); } while (x % p == 0) x /= p; } if (x \u0026gt; 1) res = res / x * (x-1); return res; }  线性筛求1~n的欧拉函数值 和线性筛的基本思路一样，只不过要分类讨论 i % p == 0 与否。（i是当前处理到的数, p是当前用到的质数）\n  如果 i % p == 0，说明 i * p 这个数里，包含了至少2个质因子$p$ (即$p^2$)。\n由性质5，有 $\\varphi(i * p) = \\varphi(i) * p$\n  如果 i % p != 0，说明 $\\gcd(i,p) = 1$。\n由性质2，有 $\\varphi(i * p) = \\varphi(i) * \\varphi(p)$\n  时间复杂度： $O(n)$\n代码 luogu-P2158-AC代码 题目链接: https://www.luogu.com.cn/problem/P2158\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int mod = 998244352; const int maxn = 4e4+5; int phi[maxn]; bool p[maxn]; vector\u0026lt;int\u0026gt; primes; int main() { int n; cin \u0026gt;\u0026gt; n; if (n \u0026lt;= 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } phi[1] = 1; fill(p, p+maxn, 1); for (int i = 2; i \u0026lt;= n; i++) { if (p[i]) { phi[i] = i-1; primes.push_back(i); } for (int j = 0; j \u0026lt; primes.size() \u0026amp;\u0026amp; i * primes[j] \u0026lt;= n; j++) { int cur = primes[j]; p[i*cur] = 0; if (i % cur == 0) { phi[i*cur] = phi[i] * cur; break; } else { phi[i*cur] = phi[i] * phi[cur]; } } } int ans = 3; for (int i = 2; i \u0026lt;= n-1; i++) ans += 2*phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   例题 例1 CF1295 题意\n给定两个正整数 $a$, $m$, 求满足以下条件的 $x$ 的数量？\n $0 \\leq x \u0026lt; m$ $\\gcd(a,m) = \\gcd(a+x,m)$  其中，$1 \\leq a \u0026lt; m \\leq 10^{10}$\n 题解 设 $g = \\gcd(a,m)$，则 $g = \\gcd(a+x,m)$，所以 $\\gcd(\\frac{a+x}{g}, \\frac{m}{g}) = 1~$ 且 $~g|(a+x)$，又因为 $g|a$，所以 $~g|x$\n所以问题转化为：\n设 $c = \\frac{a}{g}, x = \\frac{m}{g}$，求 $k \\in [c,c+x)$，使得 $k$ 满足：$gcd(x, k) = 1$ 的 $k$ 的数量？\n我们会发现当 $k \u0026gt; x$ 时，因为 $\\gcd(x,k) = \\gcd(x, k-x)$，所以我们可以将 $k \\in (x,c+x)$ 的这一段，映射到 $k \\in (0,c)$ 上。\n所以最后我们要求的$k$就是： $k \\in [1,x]$ 使得 $\\gcd(k, x) = 1$，所以满足条件的 $k$ 的数量就等于 $\\varphi(x)$\n 参考链接  https://blog.csdn.net/paxhujing/article/details/51353672 https://www.luogu.com.cn/blog/JustinRochester/solution-p2158 https://blog.nowcoder.net/n/0cbf747dc0874027b5c48cf7fbf27060  后记 写这篇文章的时候出了几个数学公式上的问题:\n 如果排版炸了，可以试着在 _ 的前面加上 \\  ","date":"2021-02-06T17:23:34+08:00","permalink":"https://tom0727.github.io/post/004-euler-function/","tags":["数学","抽代"],"title":"欧拉函数"},{"categories":["算法"],"contents":"中国剩余定理 (crt) 定义 给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$, 且 $m_i$ 之间两两互质。\n求满足条件的最小非负整数解 $x$ ？\n结论 令 $M = m_1 \\cdot m_2 ~\u0026hellip; ~m_k$, $M_i = \\frac{M}{m_i}$\n令 $M_i^{-1}$ 为 $M_i$ 在 $\\color{red} \\text{mod }m_i$ 意义下的逆元\n则，答案为: $x = \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} ~ (\\text{mod }M)$\n证明 因为 $\\forall i \\neq j, M_i \\equiv 0 ~(\\text{mod } m_j)$\n所以 $\\forall i \\neq j, a_iM_iM_i^{-1} \\equiv 0~ (\\text{mod } m_j)$\n所以 $\\forall i, x \\equiv \\sum\\limits_{i=1}^{k}a_iM_iM_i^{-1} \\equiv a_iM_iM_i^{-1} ~ (\\bmod ~m_i)$\n又因为 $\\forall i, M_iM_i^{-1} \\equiv 1 ~(\\text{mod } m_i)$\n所以 $\\forall i, x \\equiv a_iM_iM_i^{-1} \\equiv a_i ~ (\\text{mod } m_i)$\n证明推导过程 证明推导过程 这里直接放参考链接一中的片段：\n 由于 $M = 3\\times5\\times7 = 105$\n所以最后的解就是 $x = (n_1 + n_2 + n_3) ~\\bmod ~ 105 = 233 ~ \\bmod 105 = 23$\n  例题  https://www.luogu.com.cn/problem/P3868  快速乘 在题目中，有可能出现 $\\bmod$ 接近 $1e18$ 的情况，有可能会爆 long long，所以在计算大数乘法时，要用快速乘（原理类似于快速幂）：\nll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % mod; b \u0026gt;\u0026gt;= 1; a = (a + a) % mod; } return ans; }  模版 luogu-P3868-AC代码 题目链接: https://www.luogu.com.cn/problem/P3868\n#include \u0026lt;bits/stdc++.h\u0026gt; #define fastio ios::sync_with_stdio(false); cin.tie(0); #define ll long long ll M = 1; ll qmul(ll a, ll b) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % M; b \u0026gt;\u0026gt;= 1; a = (a + a) % M; } return ans; } ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll curx = y; ll cury = x - (a/b) * y; x = curx; y = cury; return g; } ll a[15], b[15]; int k; ll crt() { ll ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ll m = M / b[i]; ll x,y; exgcd(m, b[i], x, y); if (x \u0026lt; 0) x += b[i]; ans = (ans + qmul(qmul(a[i], m), x)) % M; } return ans; } int main() { fastio; cin \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; b[i], M *= b[i]; for (int i = 1; i \u0026lt;= k; i++) { a[i] -= (a[i]/b[i]) * b[i]; //将a[i]变成正数 a[i] += b[i]; a[i] %= b[i]; } cout \u0026lt;\u0026lt; crt() \u0026lt;\u0026lt; endl; }   参考链接  https://zhuanlan.zhihu.com/p/103394468  拓展中国剩余定理 (excrt) 定义 用于 $m_1,m_2,\u0026hellip;,m_k$ 并不互质的情况\n给定方程组： $$\\begin{cases} x\\equiv a_1 (\\text{mod }m_1) \\\\\nx\\equiv a_2 (\\text{mod }m_2) \\\\\n\u0026hellip; \\\\\nx\\equiv a_k (\\text{mod }m_k) \\\\\n\\end{cases}$$\n其中 $a_i \\geq 0, m_i \u0026gt; 0, a_i,m_i \\in \\mathbb{Z}$，（$m_i$ 之间无特殊关联）\n求满足条件的最小非负整数解 $x$ ？\nIntuition 先看一些简单的例子：\n$$\\begin{cases} x\\equiv 2 ~(\\text{mod }4) \\\\\n\\\\\nx\\equiv 4 ~(\\text{mod }6) \\\\\n\\end{cases}\\Longrightarrow x \\equiv 10 ~(\\text{mod } 12)$$\n$$\\begin{cases} x\\equiv 4 ~(\\text{mod }6) \\\\\n\\\\\nx\\equiv 3 ~(\\text{mod }5) \\\\\n\\end{cases}\\Longrightarrow ~\\varnothing$$\n可以看出几个特点：\n 答案的 $\\text{mod}$ 为 $\\text{lcm}(m_1, m_2)$ 有可能无解 （若$m_1,m_2$互质则必然有解）  推导 考虑 $x$ 满足：\n$$\\begin{cases} x\\equiv a_1 ~(\\text{mod }m_1) \\\\\n\\\\\nx\\equiv a_2 ~(\\text{mod }m_2) \\\\\n\\end{cases}$$\n则有 $x = k_1m_1 + a_1 = k_2m_2 + a_2$\n 即：$k_1m_1 - k_2m_2 = a_2 - a_1$\n这个方程有解 $\\iff \\gcd(m_1,m_2) | (a_2 - a_1)$ （即 $(a_2 - a_1)$ 是 $\\gcd(m_1,m_2)$ 的倍数）。\n 如果无解，就直接退出。\n如果有解，就用 $exgcd(m_1, m_2, x\u0026rsquo;, y\u0026rsquo;)$ 解出 $k_1$ 的值。\n设 $\\gcd(m_1, m_2) = g$，则 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$\n然后将 $k_1$ 代入 $x = k_1m_1 + a_1$，得到 $x$ 的值，答案就是 $x \\equiv (k_1m_1 + a_1) (\\text{mod ~lcm}(m_1,m_2))$\n这样，$2$个同余方程就转化为了$1$个，用同样的方法继续进行下去，即可化为一个同余方程。\n最终的 $\\text{mod}$ 数就是 $M = \\text{lcm}(m_1, m_2, m_3 \u0026hellip; , m_n)$\n模版 luogu-P4777-AC代码 题目链接: https://www.luogu.com.cn/problem/P4777\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long const int maxn = 1e5+5; ll exgcd(ll a, ll b, ll\u0026amp; x, ll\u0026amp; y) { if (!b) { x = 1, y = 0; return a; } ll g = exgcd(b, a%b, x, y); ll x2 = x, y2 = y; x = y2, y = x2 - a/b * y2; return g; } ll mul(ll a, ll b, ll mod) { ll res = 0; while (b) { if (b\u0026amp;1) (res += a) %= mod; (a += a) %= mod; b \u0026gt;\u0026gt;= 1; } return res; } int n; ll a[maxn], m[maxn]; int main() { fastio; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; m[i] \u0026gt;\u0026gt; a[i]; ll cura = a[1], curm = m[1]; for (int i = 2; i \u0026lt;= n; i++) { /* m1 = curm, m2 = m[i], a1 = cura, a2 = a[i] */ ll x,y; ll g = exgcd(curm, m[i], x, y); // g = gcd(curm, m[i]) ll c = a[i] - cura; // c = a2 - a1 c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) if (c % g) { // 无解 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } ll M = (m[i] * (curm / g)); // M = lcm(m1, m2) ll k = mul(x, c / g, M); // k1 = x' * (a2-a1) / g cura = (mul(k, curm, M) + cura) % M; // x = k1m1 + a1 curm = M; } cout \u0026lt;\u0026lt; (cura % curm + curm) % curm \u0026lt;\u0026lt; endl; }   注意事项   我们需要处理可能出现的负数！（比如在快速乘的时候，如果 $b$ 为负数就会炸）\n 在 $exgcd(a,b,x\u0026rsquo;,y\u0026rsquo;)$ 中，$x'$ 有可能为负数。 $c = a_2 - a_1$，则 $c$ 也有可能为负数。  那么如何处理负数？我们需要找到这个负数对应的 $\\text{mod}$为多少，我们可以在等式 $k_1m_1 - k_2m_2 = a_2 - a_1$ 中找到！\n因为我们要求的是 $k_1$ 的值，实际上 $k_1m_1 = (a_2-a_1) + k_2m_2$，即 $k_1m_1 \\equiv (a_2-a_1) \\text{ (mod } m_2)$\n所以无论是 $k_1 = x\u0026rsquo; \\cdot\\frac{a_2 - a_1}{g}$ 还是 $(a_2-a_1)$，都取一个 $\\text{mod } m_2$ 即可！\n代码段：\nll c = a[i] - cura; c = ((c % m[i]) + m[i]) % m[i]; // 处理负数，注意是 mod m2 (即 m[i]) ll k = mul(x, c / g, M); // k = ((k % m[i]) + m[i]) % m[i]; 可以处理，但是没有必要，因为快速乘中的 a 可以为负数    注意快速乘过程中的 $\\text{mod}$ ！因为快速乘求的实际上是 $x$ 的值，所以 $\\text{mod } M$，其中 M = lcm(curm, m[i])\n  我们用 cura, curm 来维护当前的 同余方程，之后记得更新一下 curm = lcm(curm, m[i])\n  参考链接  https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li  ","date":"2021-02-06T10:46:42+08:00","permalink":"https://tom0727.github.io/post/003-crt/","tags":["数学","中国剩余定理","crt"],"title":"中国剩余定理介绍"},{"categories":["工程"],"contents":"写博客好累啊，是我太久没有写作了吗\n这次来记录一下我第一次学习爬虫的经历\n起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とにかくかわいい的生肉漫画，但是这网站广告特别多，还会检测我adblocker，禁用javascript的话漫画就加载不出来了，气死我了，一怒之下决定学习爬虫把漫画爬下来看。\n爬虫教程有很多，这里特别推荐一个Jack Cui的教程：\n [资源分享] Python3 网络爬虫：漫画下载，动态加载、反爬虫这都不叫事\n 爬 manga1001.com 这个网站设置的比较粗糙，图片都是静态加载的(F12就能看见图片链接)，根据标签soup.find_all()一下即可。对于这个网站的话，简单说一下爬虫的基本流程吧。\n基本流程\n  观察一下页面的HTML，用F12打开可以看到大致结构，如果要看源代码的话，可以选择：\n1.1. res = requests.get(url), print(res.txt) 或\n1.2. 在url前加上view-source:，然后用浏览器打开。\n  找到包含图片的tag， 找一下规律，然后用 soup.find_all() 即可。\n  获取所有章节的URL，然后分别去每个URL里抓取。\n   参考代码 import requests from bs4 import BeautifulSoup import os import random import time def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] # get content of one chapter def get_content(folder, prefix, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('figure') i = 1 folder_name = os.path.join(folder, f'Chapter_{prefix:03}/') create_dir(folder_name) for item in items: for child in item.children: if i != 1: img_url = child.get('data-src') else: img_url = child.get('src') print(img_url) headers = random.choice(USER_AGENTS) img_html = requests.get(img_url, headers) img_name = os.path.join(folder_name, f'{i:02}.jpg') with open(img_name, 'wb') as file: file.write(img_html.content) file.flush() i += 1 time.sleep(random.uniform(0, 3.33)) # sleep random time # get manga url list def get_url_list(manga_name, url): res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('option') for i in range(len(items) - 2, -1, -1): if items[i] == items[-1]: # get manga chapter url list without duplicates items = items[i+1:] break chapter = 1 folder = os.path.join(root_folder, f'{manga_name}/') for item in items: manga_url = item.get('value') get_content(folder, chapter, manga_url) print(manga_url) chapter += 1 def main(): url1 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e3%83%88%e3%83%8b%e3%82%ab%e3%82%af%e3%82%ab%e3%83%af%e3%82%a4%e3%82%a4-raw/\u0026quot; name1 = 'Tonikaku_Kawaii' get_url_list(name1, url1) url2 = \u0026quot;https://manga1001.com/%e3%80%90%e7%ac%ac1%e8%a9%b1%e3%80%91%e5%b9%b2%e7%89%a9%e5%a6%b9%e3%81%86%e3%81%be%e3%82%8b%e3%81%a1%e3%82%83%e3%82%93-raw/\u0026quot; name2 = 'Umaru_Chan' get_url_list(name2, url2) main()    注: 这里用的USER_AGENT和sleep()都是为了防止被发现然后封IP\n 爬 manhuagui.com 上面那个太没挑战性了，于是我打算再爬一个。\n打开漫画网站， 发现没有图片链接，说明是动态加载的图片(用javascript加载的)，那怎么办呢？\nStep 1 先在网页里找找链接长啥样，毕竟用浏览器浏览的话，图片总是会被加载出来的，然后就能看到链接了，果然，在chrome的Elements这个tag里，我们翻到了图片链接：\n不过直接把链接复制到浏览器里打开的话会403，所以我们先搁置一下。\nStep 2 我们要获得某一话的所有图片链接，可以从图上看出似乎有一大段像是加密后的字符串，我们打开第一话和第二话的HTML，用命令行diff一下以后，会发现差异就刚好出现在这串字符串上：我们可以肯定这里面包含了图片链接相关的信息。\nStep 3 既然找到了加密串，那就要找一个钥匙来解码，看一下网页里内容不多，看起来并没有其他有用信息了，但是还有几个.js文件，一个个打开来看一下，终于在其中一个文件里找到了一大堆代码，然后这一大堆里面，有一段看起来又被加密了（有点此地无银三百两啊）： 把这段代码复制到chrome的console里，发现被自动解码了，得到了一个js函数： 我们点开这个函数，看一下里面的内容：\n函数内容 var LZString=(function(){var f=String.fromCharCode;var keyStrBase64=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026quot;;var baseReverseDic={};function getBaseValue(alphabet,character){if(!baseReverseDic[alphabet]){baseReverseDic[alphabet]={};for(var i=0;i\u0026lt;alphabet.length;i++){baseReverseDic[alphabet][alphabet.charAt(i)]=i}}return baseReverseDic[alphabet][character]}var LZString={decompressFromBase64:function(input){if(input==null)return\u0026quot;\u0026quot;;if(input==\u0026quot;\u0026quot;)return null;return LZString._0(input.length,32,function(index){return getBaseValue(keyStrBase64,input.charAt(index))})},_0:function(length,resetValue,getNextValue){var dictionary=[],next,enlargeIn=4,dictSize=4,numBits=3,entry=\u0026quot;\u0026quot;,result=[],i,w,bits,resb,maxpower,power,c,data={val:getNextValue(0),position:resetValue,index:1};for(i=0;i\u0026lt;3;i+=1){dictionary[i]=i}bits=0;maxpower=Math.pow(2,2);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(next=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}c=f(bits);break;case 2:return\u0026quot;\u0026quot;}dictionary[3]=c;w=c;result.push(c);while(true){if(data.index\u0026gt;length){return\u0026quot;\u0026quot;}bits=0;maxpower=Math.pow(2,numBits);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}switch(c=bits){case 0:bits=0;maxpower=Math.pow(2,8);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 1:bits=0;maxpower=Math.pow(2,16);power=1;while(power!=maxpower){resb=data.val\u0026amp;data.position;data.position\u0026gt;\u0026gt;=1;if(data.position==0){data.position=resetValue;data.val=getNextValue(data.index++)}bits|=(resb\u0026gt;0?1:0)*power;power\u0026lt;\u0026lt;=1}dictionary[dictSize++]=f(bits);c=dictSize-1;enlargeIn--;break;case 2:return result.join('')}if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}if(dictionary[c]){entry=dictionary[c]}else{if(c===dictSize){entry=w+w.charAt(0)}else{return null}}result.push(entry);dictionary[dictSize++]=w+entry.charAt(0);enlargeIn--;w=entry;if(enlargeIn==0){enlargeIn=Math.pow(2,numBits);numBits++}}}};return LZString})();String.prototype.splic=function(f){return LZString.decompressFromBase64(this).split(f)};   获得这个函数以后，我们尝试着把之前获得的加密串放进去看看： 这看起来就正常多了，而且这里面的 04|05|06|... 之类的信息看起来也能和之前找到的图片链接对应上。但是它似乎并没有按照某个特定的规律来，所以可以肯定还有一个函数来处理这个字符串。\nStep 4 有了这个信息，我们就接着找处理这个字符串的函数，再次观察一下HTML，发现这个Base64的串被包含在了一个\u0026lt;script\u0026gt;当中，长这样：\nscript内容 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;window[\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();',62,70,'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['\\x73\\x70\\x6c\\x69\\x63']('\\x7c'),0,{})) \u0026lt;/script\u0026gt;   看起来这也是一个函数啊，而且这个Base64的串似乎作为参数了，再次动用chrome的console帮助我们解析一下：\n这下我们大概可以明白几个事情：\n 这段代码实际上是 window[\u0026quot;eval\u0026quot;](...) 省略号部分是一个函数 function(p,a,c,k,e,d), 以 {} 包起来的是函数内容，那return p;} 后面的想必就是这6个参数。  观察一下这6个参数，我们会发现：\n p = 'X.B({\u0026quot;y\u0026quot;:8,\u0026quot;x\u0026quot;:\u0026quot;w v u t s r\u0026quot;,\u0026quot;q\u0026quot;:\u0026quot;8.1\u0026quot;,\u0026quot;p\u0026quot;:o,\u0026quot;n\u0026quot;:\u0026quot;4\u0026quot;,\u0026quot;l\u0026quot;:[\u0026quot;j.1.2\u0026quot;,\u0026quot;A.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;9-a.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;10.1.2\u0026quot;,\u0026quot;11.1.2\u0026quot;,\u0026quot;12.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;14.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;C.1.2\u0026quot;,\u0026quot;P.1.2\u0026quot;,\u0026quot;D.1.2\u0026quot;,\u0026quot;U.1.2\u0026quot;,\u0026quot;W.1.2\u0026quot;,\u0026quot;3.1.2\u0026quot;,\u0026quot;%Y%5%7%6%5%Z%6%7%T.1.2\u0026quot;],\u0026quot;V\u0026quot;:R,\u0026quot;Q\u0026quot;:3,\u0026quot;S\u0026quot;:\u0026quot;/O/z/N/4/\u0026quot;,\u0026quot;M\u0026quot;:0,\u0026quot;L\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;K\u0026quot;:J,\u0026quot;I\u0026quot;:H,\u0026quot;G\u0026quot;:{\u0026quot;e\u0026quot;:F,\u0026quot;m\u0026quot;:\u0026quot;E\u0026quot;}}).i();'\n  a = 62, c = 70\n  k = 'D4KwDg5sDuCmBGZgCYCsxA03gBgIyD21YADgCFgBRdATlOQHYtLLgsAWZ9LANmducOGZMc/LAGZgYAE6wAkgDsAlgBdmOYDiYAzBQBtYAZwEBjOQEMAtrGCjULUZSzAjCgCbBECo8HMB7H3OAlAAsrJR9vK00dAE9gQG4DQGk5QEYdQHozQD10wA49QHvlQEYndzNLd1cBLGRgBXMIABFTJVMUR2QygE1UcwB9HyMANQBHABVUfU1iHAAvEF6ARU0AYRYp9U4cUWQHOm59HSXOQmQ1KVgANxk3GxZUSm45WAAPJVP3HS6Aa3ajL306pQBXQzGJsMjC9TJpzEolB0dCBkNswPo1PtgHoAppTDp9FYwLUgsBiGQUOJtIp9CE3Mg2ABlACyAAlyNxKAAxASs1lAA==='['split']('|')\n  e = 0, d = {}\n 唯一需要处理的似乎就是k了，虽然k里没有|这个符号，不过刚才使用LZString.decompressfromBase64()函数解析出来的东西倒是有很多|。\n自此真相大白了，我们需要做的事情很简单：\n 提取出p,a,c,k,e,d这6个参数。 将k放进LZString.decompressfromBase64()解析一下。 调用 decode_func （也就是 function(p,a,c,k,e,d) ），得到结果。  结果长这样：\n我们要的图片链接就找到啦！在 files 里。\nStep 5: 我们还剩下最后一个问题：有了图片链接但是访问不了（403）怎么办？这似乎是一种简单的反爬虫方式，google一下，只要假装我们是从本站（即这个漫画的网站）进去的，而不是从其他地方进去的，就可以访问了。虽然在浏览器上做不到，但是python里可以通过更改Referer的方式来达到：\ndef get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;}  Step 6: 最后的最后，就是爬虫的基本过程了，不过我们有一段javascript代码需要运行，怎么在python中运行javascript呢？\n 首先保存一下javascript代码，叫 decode_func.js。内容如下：  const jsdom = require(\u0026quot;jsdom\u0026quot;); const { JSDOM } = jsdom; const dom = new JSDOM(`\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;`); window = dom.window; document = window.document; XMLHttpRequest = window.XMLHttpRequest; decode_func = window[\u0026quot;eval\u0026quot;](function(p,a,c,k,e,d){e=function(c){return(c\u0026lt;a?\u0026quot;\u0026quot;:e(parseInt(c/a)))+((c=c%a)\u0026gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;})  然后用以下这段代码就可以了：  def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js()  调用的时候就用 res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d)\n最终代码如下：\n参考代码 import requests from bs4 import BeautifulSoup import os import time import random import lzstring import execjs import re import json def create_dir(path): if not os.path.exists(path): os.makedirs(path) root_folder = '/Users/huzhenwei/Desktop/manga/' create_dir(root_folder) USER_AGENTS = [ \u0026quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\u0026quot;, \u0026quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\u0026quot;, \u0026quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\u0026quot;, \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\u0026quot;, \u0026quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\u0026quot;, \u0026quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\u0026quot;, \u0026quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\u0026quot;, \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\u0026quot;, \u0026quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\u0026quot;, ] def get_download_header(): return {'User-Agent': random.choice(USER_AGENTS), \u0026quot;Referer\u0026quot;: \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot;} def load_js(): with open(\u0026quot;decode_func.js\u0026quot;, 'r') as file: js = file.read() context = execjs.compile(js, cwd=\u0026quot;/usr/local/lib/node_modules\u0026quot;) return context context = load_js() def decode(s): x = lzstring.LZString() decoded_str = x.decompressFromBase64(s) return decoded_str.split(\u0026quot;|\u0026quot;) # p = \u0026quot;\u0026quot;\u0026quot;1h.14({\u0026quot;q\u0026quot;:7,\u0026quot;r\u0026quot;:\u0026quot;s t u v w x\u0026quot;,\u0026quot;y\u0026quot;:\u0026quot;7.1\u0026quot;,\u0026quot;A\u0026quot;:B,\u0026quot;C\u0026quot;:\u0026quot;6\u0026quot;,\u0026quot;D\u0026quot;:[\u0026quot;E.1.2\u0026quot;,\u0026quot;F.1.2\u0026quot;,\u0026quot;G.1.2\u0026quot;,\u0026quot;H.1.2\u0026quot;,\u0026quot;o.1.2\u0026quot;,\u0026quot;I.1.2\u0026quot;,\u0026quot;k.1.2\u0026quot;,\u0026quot;h.1.2\u0026quot;,\u0026quot;d.1.2\u0026quot;,\u0026quot;c.1.2\u0026quot;,\u0026quot;a.1.2\u0026quot;,\u0026quot;9.1.2\u0026quot;,\u0026quot;8.1.2\u0026quot;,\u0026quot;l.1.2\u0026quot;,\u0026quot;b.1.2\u0026quot;,\u0026quot;f.1.2\u0026quot;,\u0026quot;g.1.2\u0026quot;,\u0026quot;i.1.2\u0026quot;,\u0026quot;j.1.2\u0026quot;,\u0026quot;p.1.2\u0026quot;,\u0026quot;J.1.2\u0026quot;,\u0026quot;Y.1.2\u0026quot;,\u0026quot;L.1.2\u0026quot;,\u0026quot;13.1.2\u0026quot;,\u0026quot;K.1.2\u0026quot;,\u0026quot;15.1.2\u0026quot;,\u0026quot;16.1.2\u0026quot;,\u0026quot;17.1.2\u0026quot;,\u0026quot;18.1.2\u0026quot;,\u0026quot;1a.1.2\u0026quot;,\u0026quot;1g.1.2\u0026quot;,\u0026quot;1b.1.2\u0026quot;,\u0026quot;1c.1.2\u0026quot;,\u0026quot;1d.1.2\u0026quot;,\u0026quot;%1e%5%3%4%5%1f%4%3%12.1.2\u0026quot;],\u0026quot;19\u0026quot;:10,\u0026quot;Z\u0026quot;:11,\u0026quot;X\u0026quot;:\u0026quot;/W/z/V/6/\u0026quot;,\u0026quot;U\u0026quot;:0,\u0026quot;T\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;S\u0026quot;:R,\u0026quot;Q\u0026quot;:P,\u0026quot;O\u0026quot;:{\u0026quot;e\u0026quot;:N,\u0026quot;m\u0026quot;:\u0026quot;M\u0026quot;}}).n();\u0026quot;\u0026quot;\u0026quot; # a,c = 62,80 # k=['', 'jpg', 'webp', '9B', 'E5', '8B', '第02回', '27099', 'P0056', 'P0055', 'P0054', 'P0058', 'P0053', 'P0052', '', 'P0059', 'P0060', 'P0051', 'P0061', 'P0062', 'P0050', 'P0057', '', 'preInit', 'P0048', 'P0063', 'bid', 'bname', '总之就是非常可爱', 'fly', 'me', 'to', 'the', 'moon', 'bpic', '', 'cid', '354852', 'cname', 'files', 'P0044', 'P0045', 'P0046', 'P0047', 'P0049', 'P0064', 'P0068', 'P0066', 'GYeIdl7ujUrxJ1ls7JvwpQ', '1612951385', 'sl', '354596', 'prevId', '356912', 'nextId', 'block_cc', 'status', 'zzjsfckafmttm_lj2l', 'ps1', 'path', 'P0065', 'len', 'false', '35', 'BE', 'P0067', 'imgData', 'P0069', 'P0070', 'P0071', 'P0072', 'finished', 'P0073', 'P0075', 'P0076', 'P0077', 'E6', '9F', 'P0074', 'SMH'] # e = 0 # d = dict() # res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) # print(type(res)) # print(res) # get content of one chapter def get_content(title, url): create_dir(os.path.join(root_folder, title)) res = requests.get(f\u0026quot;https://manhuagui.com{url}\u0026quot;, random.choice(USER_AGENTS)) # print(res.text) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all(lambda tag:tag.name=='script', recursive=True) for item in items: txt = item.string # 必须是item.string, 不能是item.txt if txt and \u0026quot;return p;\u0026quot; in txt: # 如果tag里没有文字，txt==None parts = txt.split(\u0026quot;return p;}(\u0026quot;) part = parts[1][:-2] split_res = re.split(r',([0-9]+,[0-9]+,)', part) p = split_res[0][1:-1] split_res[1] = split_res[1][:-1] a, c = map(int, split_res[1].split(',')) k = split_res[2].split(\u0026quot;'['\u0026quot;)[0][1:] k = decode(k) e = 0 d = dict() res = context.call((\u0026quot;decode_func\u0026quot;), p,a,c,k,e,d) s = re.search('({.+})', res).group(0) # 找到一个由 {} 包裹的group info_dict = json.loads(s) files_list = info_dict[\u0026quot;files\u0026quot;] path_prefix = 'https://i.hamreus.com' + info_dict[\u0026quot;path\u0026quot;] i = 1 for file_name in files_list: complete_path = path_prefix + file_name[:-5] print(complete_path) res = requests.get(complete_path, headers=get_download_header()) img_name = os.path.join(root_folder, title, f'{i}.jpg') with open(img_name, 'wb') as file: file.write(res.content) file.flush() time.sleep(random.uniform(5.0, 10.0)) i += 1 # get manga url list def get_url_list(url): res = requests.get(url, random.choice(USER_AGENTS)) soup = BeautifulSoup(res.content, 'html.parser') items = soup.find_all('div', {\u0026quot;id\u0026quot;: \u0026quot;chapter-list-1\u0026quot;}) for manga_list in items: links = manga_list.find_all(\u0026quot;a\u0026quot;, recursive=True) links = links[1:] for link in links: title = link.get(\u0026quot;title\u0026quot;) ref = link.get(\u0026quot;href\u0026quot;) if title[-1] == '卷': continue print(f\u0026quot;{title}, {ref}\u0026quot;) get_content(title, ref) url = \u0026quot;https://www.manhuagui.com/comic/27099/\u0026quot; get_url_list(url)    注：上面这块代码被识别成lua语言了，样式出了点问题，可以在markdown里面指定语言，在第一个 ``` 后面加上语言名即可，如 ```python\n 后记 写这篇blog比玩爬虫本身还累啊，看来我果然不适合写作文（虽然我从小就深刻的明白这个道理）。不过这篇博客很大程度上也是写给自己看的，作为下次爬虫的参考（不知道下次爬虫要等到什么时候了）。\n以后可能会补点儿算法笔记，或者题解之类的。\n","date":"2021-02-01T22:45:03+08:00","permalink":"https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/","tags":["爬虫","python"],"title":"初学爬虫小记"},{"categories":["工程"],"contents":"起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动手开始构建咕咕已久的个人网站。\n由于我对自己的前端水平十分有数，所以想都没想就立刻放弃了“要不自己写一个网站？”的想法。\n后来想起之前逛过的ouuan大佬的博客非常好看，我的收藏夹里甚至还有他搭建博客的指南，就直接拿来用了，采用的是 hugo + even主题 + github actions，参考资料如下:\n https://ouuan.gitee.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 首先阅读ouuan的指南(上述链接)，然后使用他的hugo模版，按照模版里指示的进行clone。\nStep 2 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  Step 2.5 因为我打算部署到github pages上，就在github上创建一个新的repository，叫tom0727.github.io\nStep 3 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果(也可以边写边看效果，热加载真香)。最后用hugo命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了。\n注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5: 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\n push到master以后，可以在repository的Actions页面查看一下deploy的情况：  Step 6: 因为github.io似乎被墙了，所以学ouuan弄了一个gitee镜像，教程的话参照这两个就可以了：\n https://jasonkayzk.github.io/2020/09/18/%E5%9C%A8Gitee%E6%90%AD%E5%BB%BAGithub-Pages/\n  https://github.com/yanglbme/gitee-pages-action\n gitee镜像的访问网址：tom0727.gitee.io\n注：在 hugo-blog/.github/workflows/sync.yml里记得设置一下on，不然触发不了自动部署。\n我这里设置的是：\non: push: branches: - master workflow_dispatch:  Step 7: 评论区用很多种，我选用了utterances，部署步骤如下：\n 在Github上安装 utterances app，选择这个博客的repo 在 config.toml 中更改配置，将 [params.utterances] 下的 repo 改成这个repo的名字即可。（可以新开一个repo来储存评论，不过评论会以issues的形式出现在repo里，所以没必要新开一个）  TODO LIST  搞明白baidu push是什么  结语 新的一轮折腾结束了，总体来说还是比较满意这个博客的，个人很喜欢这种极简风的博客，功能也比较全，某种意义上算是告别了在Microsoft Word里做笔记的生活（？），之后打算先补上爬虫的一些笔记，还有搬运一点Word上的笔记吧。\n","date":"2021-02-01T21:21:41+08:00","permalink":"https://tom0727.github.io/post/001-hugo-tutorial/","tags":["hugo","博客"],"title":"Hugo博客搭建小记"},{"categories":null,"contents":"Hello, this is Tom from China! If you have trouble visiting this site (especially for mainland China users), please try visit\nhttps://tom0727.gitee.io/\nAbout me  Year 3 Undergraduate student @ HKU (The University of Hong Kong), 2018-2022 Major in Computer Science Competitive programming as hobby   Resume  Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu.pdf Resume (in Chinese): https://github.com/tom0727/Resume/blob/master/%E8%83%A1%E6%8C%AF%E4%B8%BA.pdf  Contact  Email: huzhenweitom@gmail.com QQ/Wechat: 980409152  Links  Codeforces:  Leetcode: tom0727  ","date":"2021-01-31T22:57:58+08:00","permalink":"https://tom0727.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://tom0727.github.io/search/","tags":null,"title":"搜索"}]