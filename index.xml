<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tom0727's blog</title><link>https://tom0727.github.io/</link><description>Recent content on tom0727's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 31 Jan 2021 22:57:58 +0800</lastBuildDate><atom:link href="https://tom0727.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>割点 桥 点/边双连通分量（BCC）</title><link>https://tom0727.github.io/post/041-%E5%89%B2%E7%82%B9-%E6%A1%A5-bcc/</link><pubDate>Wed, 14 Apr 2021 11:23:25 +0800</pubDate><guid>https://tom0727.github.io/post/041-%E5%89%B2%E7%82%B9-%E6%A1%A5-bcc/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;h3 id="割点">割点&lt;/h3>
&lt;p>在一个 &lt;strong>无向图&lt;/strong> 中，如果删掉节点 $u$ 使得整个图的连通分量增加，那么 $u$ 是一个割点。&lt;/p>
&lt;h3 id="桥">桥&lt;/h3>
&lt;p>在一个 &lt;strong>无向图&lt;/strong> 中，如果删掉一条边 $(u,v)$ 使得整个图的连通分量增加，那么 $(u,v)$ 是一个桥。&lt;/p>
&lt;hr>
&lt;h3 id="点双连通">点双连通&lt;/h3>
&lt;p>一个 &lt;strong>无向图&lt;/strong> 是 &lt;strong>点双连通&lt;/strong> 的，当且仅当（以下表达是 equivalent 的）：&lt;/p>
&lt;ol>
&lt;li>如果删去任意一个&lt;strong>节点&lt;/strong>，其他节点仍然互相连通。&lt;/li>
&lt;li>&lt;strong>不包含割点&lt;/strong>（注意，这个割点是对于 &lt;strong>这个子图&lt;/strong> 而言）。&lt;/li>
&lt;li>&lt;strong>任取两个点 $u,v$&lt;/strong>，$u,v$ 之间都存在两条 &lt;strong>点不重复&lt;/strong> 路径。&lt;/li>
&lt;li>&lt;strong>任取 $2$ 条边&lt;/strong>，都存在一个简单环（环内不包含其他环），使得这 $2$ 条边在这个简单环内。&lt;/li>
&lt;/ol>
&lt;p>• 注意，如果图内只有 $2$ 个连起来的节点，它们仍然点双连通。&lt;/p>
&lt;p>• 点双连通 &lt;strong>不具有传递性&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/041/4.png" alt="img">&lt;/p>
&lt;p>如上图，$a,b$ 点双连通，$b,c$ 点双连通，但是 $a,c$ &lt;strong>并不点双连通&lt;/strong>（$a,c$ 不在同一个点双分量内）。&lt;/p>
&lt;hr>
&lt;h3 id="边双连通">边双连通&lt;/h3>
&lt;p>一个 &lt;strong>无向图&lt;/strong> 是 &lt;strong>边双连通&lt;/strong> 的，当且仅当（以下表达是 equivalent 的）：&lt;/p>
&lt;ol>
&lt;li>一个 &lt;strong>无向图&lt;/strong> 中，如果删去任意一条&lt;strong>边&lt;/strong>，其他节点仍然互相连通。&lt;/li>
&lt;li>一个 &lt;strong>无向图&lt;/strong> 中，&lt;strong>不包含桥&lt;/strong>（注意，这个桥是对于 &lt;strong>整个图&lt;/strong> 而言）。&lt;/li>
&lt;li>一个 &lt;strong>无向图&lt;/strong> 中，&lt;strong>任取两个点 $u,v$&lt;/strong>，$u,v$ 之间都存在两条 &lt;strong>边不重复&lt;/strong> 路径。&lt;/li>
&lt;li>一个 &lt;strong>无向图&lt;/strong> 中，&lt;strong>任取 $1$ 条边&lt;/strong>，都存在一个简单环（环内不包含其他环），使得这条边在这个简单环内。&lt;/li>
&lt;/ol>
&lt;p>• 点双连通 &lt;strong>具有传递性&lt;/strong>：&lt;/p>
&lt;p>如果 $a,b$ 边双连通，$b,c$ 边双连通，则 $a,c$ 边双连通。&lt;/p>
&lt;p>证明：$a,b$ 边双连通说明 删去图中任意一条边，$a,b$ 仍连通。同理，删去图中任意一条边，$b,c$ 仍连通。所以删去任意一条边，$a,c$ 仍连通。&lt;/p>
&lt;hr>
&lt;h3 id="点双连通分量">点双连通分量&lt;/h3>
&lt;p>点双连通分量：一个极大的点双连通的子图。&lt;/p>
&lt;ol>
&lt;li>如果把这个子图 &lt;strong>单独拿出来，它不存在割点&lt;/strong>，但是它在原图中，&lt;strong>如果它与其他点双分量相连&lt;/strong>，那么它一定包含 至少一个原图中的割点。&lt;/li>
&lt;li>原图中，&lt;strong>每个割点&lt;/strong> 存在于至少 $2$ 个点双分量中。&lt;/li>
&lt;li>任意一个 &lt;strong>非割点&lt;/strong> 只存在于一个点双分量中。&lt;/li>
&lt;/ol>
&lt;h4 id="点双缩点">&lt;strong>点双缩点&lt;/strong>&lt;/h4>
&lt;p>利用点双缩点后，得到的新图有以下性质：&lt;/p>
&lt;ol>
&lt;li>新图 &lt;strong>是一棵树&lt;/strong>，每个节点要么是一个&lt;strong>点双&lt;/strong>，要么是一个&lt;strong>割点&lt;/strong>。&lt;/li>
&lt;li>所有 &lt;strong>割点&lt;/strong> 单独成为一个节点。&lt;/li>
&lt;li>点双之间以 &lt;strong>割点&lt;/strong> 相连，并且所有割点的 degree 至少为 $2$。（任意两个点双之间，有且仅有一个公共点，且这个公共点是 &lt;strong>割点&lt;/strong>）。&lt;/li>
&lt;/ol>
&lt;p>例1：&lt;/p>
&lt;p>图中的所有点双分量为：$\{1,2,3\}, \{3,4,5\}$&lt;/p>
&lt;p>图中所有割点为：$3$&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/041/1.jpg" alt="img">&lt;/p>
&lt;p>例2：&lt;/p>
&lt;p>图中的所有点双分量为：$\{1,2\}, \{1,3\}, \{2,4\}, \{2,5\}, \{3,6\}, \{3,7\}$&lt;/p>
&lt;p>图中所有割点为：$1,2,3$&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/041/2.jpg" alt="img">&lt;/p>
&lt;hr>
&lt;h3 id="边双连通分量">边双连通分量&lt;/h3>
&lt;p>边双连通分量：一个极大的边双连通子图。&lt;/p>
&lt;p>相比点双分量来说，边双分量的定义简单很多，因为它 &lt;strong>不需要区分&lt;/strong> 原图和子图！&lt;/p>
&lt;ol>
&lt;li>将原图中的所有桥删掉，剩下的分量就是边双连通分量。&lt;/li>
&lt;li>&lt;strong>桥不属于任何一个边双分量&lt;/strong>，边双分量之间以桥连接。&lt;/li>
&lt;/ol>
&lt;p>例1：&lt;/p>
&lt;p>图中的所有边双分量为：$\{1,2,7\}, \{4,5,6\}, \{3\}$&lt;/p>
&lt;p>图中所有桥为：$(2,3), (2,4)$&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/041/3.jpg" alt="img">&lt;/p>
&lt;h4 id="边双缩点">&lt;strong>边双缩点&lt;/strong>&lt;/h4>
&lt;p>利用边双缩点后，得到的新图有以下性质：&lt;/p>
&lt;ol>
&lt;li>新图是 &lt;strong>一棵树&lt;/strong>，每个节点都是一个&lt;strong>边双&lt;/strong>。&lt;/li>
&lt;li>原图中 &lt;strong>所有的桥&lt;/strong>，在新图中仍然是桥。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="算法">算法&lt;/h2>
&lt;p>我们利用 tarjan 算法求 &lt;strong>割点，桥，点双，边双&lt;/strong>。&lt;/p>
&lt;p>这里的 tarjan 和 有向图求SCC 的tarjan略有不同，主要体现在：&lt;/p>
&lt;ol>
&lt;li>有向图tarjan求SCC：需要记录当前在 &lt;strong>栈内&lt;/strong> 的有哪些元素，更新 &lt;code>low[]&lt;/code> 时，需要 &lt;code>to&lt;/code> 在栈内才更新。&lt;/li>
&lt;li>无向图求割点/桥/点双/边双：需要检查 &lt;code>to&lt;/code> 是不是 &lt;code>u&lt;/code> 的直接 &lt;strong>parent &lt;code>p&lt;/code>&lt;/strong>。（这里指的是 dfs树 内的parent关系），&lt;strong>不需要&lt;/strong>考虑是否在栈内。&lt;/li>
&lt;/ol>
&lt;p>另外，求 &lt;strong>割点 和 桥&lt;/strong> 时，也略有不同，主要体现在：&lt;/p>
&lt;ol>
&lt;li>求割点时，需要讨论当前节点&lt;strong>是否为DFS树的根&lt;/strong>。但是求桥时，不需要。&lt;/li>
&lt;li>求割点时，条件是 $low[to] \geq dfn[u]$。求桥时，条件是 $low[to] &amp;gt; dfn[u]$。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>以下的算法，都要检查 &lt;code>to&lt;/code> 是不是 &lt;code>u&lt;/code> 的直接 &lt;strong>parent &lt;code>p&lt;/code>&lt;/strong>。&lt;/p>
&lt;h3 id="割点-1">割点&lt;/h3>
&lt;p>对于一个节点 $u$，在DFS树中，如果：&lt;/p>
&lt;ol>
&lt;li>它&lt;strong>是&lt;/strong>DFS树的 &lt;strong>根节点&lt;/strong>：如果 $u$ 拥有 $\geq 2$ 个子树，那么 $u$ 就是一个割点。&lt;/li>
&lt;li>它&lt;strong>不是&lt;/strong>DFS树的 根节点：如果 $u$ 存在一个 direct child $~to$，使得 $low[to] \geq dfn[u]$。那么 $u$ 就是一个割点。（因为这说明 $to$ 无法到达 $u$ 的上方）&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3388" target="_blank">模版题&lt;/a>&lt;/p>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定一个无向图，求图的所有割点。&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 2e4+5;
const int maxm = 1e5+10;
struct Edge {
int to, nxt;
} edges[maxm&amp;lt;&amp;lt;1];
int dfn[maxn], low[maxn], head[maxn], ecnt = 1, n, m, id;
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
vector&amp;lt;int&amp;gt; ans;
void dfs(int u, int p) {
dfn[u] = ++id;
low[u] = id;
int child = 0; // 子树数量
bool cut = 0; // 是否为割点
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue; // 不能直接用parent
if (dfn[to]) {
low[u] = min(low[u], dfn[to]);
continue;
}
dfs(to, u);
child++;
low[u] = min(low[u], low[to]);
if (p &amp;amp;&amp;amp; low[to] &amp;gt;= dfn[u]) cut = 1;
// 如果u不是根节点，且存在 direct child使得 low[to] &amp;gt;= dfn[u]，则u是割点
}
if (!p &amp;amp;&amp;amp; child &amp;gt;= 2) cut = 1; // 如果为根节点，且有 &amp;gt;= 2个子树
if (cut) ans.push_back(u);
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i, 0);
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v); addEdge(v,u);
}
tarjan();
sort(ans.begin(), ans.end());
cout &amp;lt;&amp;lt; ans.size() &amp;lt;&amp;lt; endl;
for (int a : ans) cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
cout &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h3 id="桥-1">桥&lt;/h3>
&lt;p>判断一个边 $(u,to)$ 是不是桥，我们设 $u$ 在DFS树中，是 $to$ 的parent。&lt;/p>
&lt;p>如果 $low[to] &amp;gt; dfn[u]$，则 $(u,to)$ 是一个桥。（因为这说明 $to$ 无法到达 $u$ 和 $u$ 的上方）。&lt;/p>
&lt;hr>
&lt;p>实现过程中，需要注意以下几点：&lt;/p>
&lt;ol>
&lt;li>边的编号从 $0$ 开始（记得将 &lt;code>head[]&lt;/code> 初始化为 -1），这样保证了 &lt;code>e&lt;/code> 和 &lt;code>e^1&lt;/code> 刚好为 $(u,v)$ 和 $(v,u)$。&lt;/li>
&lt;li>标记桥的时候，一次标记两个边 &lt;code>e&lt;/code> 和 &lt;code>e^1&lt;/code>。&lt;/li>
&lt;/ol>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">void tarjan(int u, int p) {
dfn[u] = low[u] = ++id;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue; // 注意不能用parent
if (dfn[to]) low[u] = min(low[u], dfn[to]);
else {
tarjan(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt; dfn[u]) { // 注意这里的条件
bridge[e] = bridge[e^1] = 1;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h3 id="点双连通分量dcc">点双连通分量（dcc）&lt;/h3>
&lt;p>求点双分量，可以在&lt;strong>求割点的时候顺便求出来&lt;/strong>。&lt;/p>
&lt;p>当我们发现 $low[to] \geq dfn[u]$ 时，就说明 $to$ 及其子树（加上 $u$）一起形成了一个点双。&lt;/p>
&lt;p>此时，我们将 栈内的点一直pop，&lt;code>pop&lt;/code> 到 &lt;code>to&lt;/code> 为止（&lt;strong>包括 &lt;code>to&lt;/code>&lt;/strong>），但是 &lt;strong>不包括 &lt;code>u&lt;/code>&lt;/strong>。这是因为 &lt;code>u&lt;/code> 作为割点，可能还属于别的点双分量，之后还要用到。&lt;/p>
&lt;p>• 求点双时，我们并&lt;strong>不关心 $u$ 本身是否为割点&lt;/strong>，只要出现了 $low[to] \geq dfn[u]$，就说明出现了一个新点双。（例如，在只有 $1,2$ 这两个点的情况下，不存在割点，但是 $1,2$ 仍然是一个点双）。&lt;/p>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">bool cut[maxn];
vector&amp;lt;int&amp;gt; dcc_list[maxn];
void dfs(int u, int p) {
dfn[u] = low[u] = ++id;
st[++tail] = u;
int child = 0;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue;
if (dfn[to]) {
low[u] = min(low[u], dfn[to]);
} else {
child++;
dfs(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt;= dfn[u]) { // 不关心 u 是否为割点，直接开始pop
from[to] = ++dcc;
while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to）
int cur = st[tail--];
from[cur] = from[to];
dcc_list[dcc].push_back(cur);
}
tail--; // tail--后，指向的是 u
dcc_list[dcc].push_back(to);
dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量
// from[u] = dcc; // from[u] 实际上没有意义
}
if (low[to] &amp;gt;= dfn[u] &amp;amp;&amp;amp; p) cut[u] = 1; // 割点（非根节点）
}
}
if (!p &amp;amp;&amp;amp; child &amp;gt;= 2) cut[u] = 1; // 割点（根节点）
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h3 id="边双连通分量ecc">边双连通分量（ecc）&lt;/h3>
&lt;p>求边双分量，可以根据定义：删去所有的桥，剩下的连通分量，就是边双分量。&lt;/p>
&lt;p>所以求边双分量，分以下两步：&lt;/p>
&lt;ol>
&lt;li>tarjan 求出所有的桥。&lt;/li>
&lt;li>进行一次 &lt;code>dfs()&lt;/code>，如果 $(u,to)$ 是桥，则不经过这条边。以此求出所有的连通分量。&lt;/li>
&lt;/ol>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">int from[maxn];
bool bridge[maxm&amp;lt;&amp;lt;1];
void tarjan(int u, int p) {
dfn[u] = low[u] = ++id;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue;
if (dfn[to]) low[u] = min(low[u], dfn[to]);
else {
tarjan(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt; dfn[u]) {
bridge[e] = bridge[e^1] = 1;
}
}
}
}
// dfs求出所有的边双
// f 代表 from (ecc编号)
void dfs(int u, int f) {
from[u] = f;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥
dfs(to, f);
}
}
int main() {
// ...
for (int i = 1; i &amp;lt;= n; i++)
if (!from[i])
dfs(i, ++ecc);
// ...
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h2 id="例题">例题&lt;/h2>
&lt;h3 id="例1-洛谷p3225-hnoi2012矿场搭建httpswwwluogucomcnproblemp3225">例1 &lt;a href="https://www.luogu.com.cn/problem/P3225" target="_blank">洛谷P3225 [HNOI2012]矿场搭建&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定 $M$ 条边的无向图。初始状态下，每个节点没有标记。&lt;/p>
&lt;p>我们需要给节点打上标记，使得：&lt;/p>
&lt;p>删去图中的任意一个节点，其他的所有节点均可到达一个有标记的节点。&lt;/p>
&lt;p>求：标记节点的最少数量，最少标记数量的方案总数。&lt;/p>
&lt;p>其中，$M \leq 500$，数据保证不存在单个独立点。&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>首先根据 &lt;strong>点双连通&lt;/strong> 进行缩点。缩点以后，整个图会变成一个由 &lt;strong>割点&lt;/strong> 和 &lt;strong>点双分量&lt;/strong> 组成的 &lt;strong>树&lt;/strong>。&lt;/p>
&lt;p>由于点双的性质，我们知道，如果删去点双分量中的任意一个点（除割点以外），该分量仍然和其他的分量连通。&lt;/p>
&lt;p>所以我们不需要考虑删去 &lt;strong>非割点&lt;/strong> 的情况，我们只关心如果删去了一个 &lt;strong>割点&lt;/strong>，会不会使得有些节点无法到达有标记的节点。&lt;/p>
&lt;p>由上可知，我们 &lt;strong>不需要标记割点&lt;/strong>（因为我们只考虑删去 &lt;strong>割点&lt;/strong> 的情况，如果要删去割点，那说明标记割点是无意义的）。&lt;/p>
&lt;hr>
&lt;p>对于一个点双分量而言，可以分以下情况讨论：&lt;/p>
&lt;ol>
&lt;li>点双内含有 $\geq 2$ 个割点：无论删去哪个割点，该分量仍然和其他分量连通，所以无需在该分量内标记。&lt;/li>
&lt;li>点双内含有 $1$ 个割点：如果该割点被删了，那么这个分量就断开了，所以该分量内部需要标记 $1$ 个节点。（不标记割点），方案数为 $(sz-1)$ （因为分量里面有一个割点，要去掉标记它的可能性）。&lt;/li>
&lt;li>点双内没有割点：说明这个分量本来就是独立开的（在缩点后，是单个独立节点）。所以该分量内需要标记 $2$ 个节点。方案数为 $C_{sz}^2$。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>实现中的一些细节：&lt;/p>
&lt;ol>
&lt;li>由于一个割点可能属于多个点双分量，所以我们采用 &lt;code>vector&amp;lt;int&amp;gt; dcc_list[maxn];&lt;/code> 来记录每个点双里面的节点。&lt;/li>
&lt;li>对于一个割点 $u$ 来说，它的 &lt;code>from[]&lt;/code> 数组没有意义。（如果需要缩点，则后续会让 &lt;code>from[u] = ++dcc&lt;/code>，缩点后的 &lt;code>from[u]&lt;/code> 就有意义了）&lt;/li>
&lt;li>与 tarjan 求 SCC 不同，我们&lt;strong>不需要&lt;/strong>记录节点是否在栈内。&lt;/li>
&lt;li>在 &lt;code>pop&lt;/code> 栈的时候，注意我们是 &lt;code>pop&lt;/code> 到 &lt;code>to&lt;/code> 为止（&lt;strong>包括 &lt;code>to&lt;/code>&lt;/strong>），但是 &lt;strong>不包括 &lt;code>u&lt;/code>&lt;/strong>。这是因为 &lt;code>u&lt;/code> 作为割点，可能还属于别的点双分量，之后还要用到。&lt;/li>
&lt;/ol>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 1005;
int n,m, head[maxn], ecnt = 1;
struct Edge {
int to, nxt;
} edges[maxn];
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
int dfn[maxn], low[maxn], id, st[maxn], tail, from[maxn], dcc;
bool cut[maxn];
vector&amp;lt;int&amp;gt; dcc_list[maxn];
void dfs(int u, int p) {
dfn[u] = low[u] = ++id;
st[++tail] = u;
int child = 0;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue;
if (dfn[to]) {
low[u] = min(low[u], dfn[to]);
} else {
child++;
dfs(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt;= dfn[u]) {
from[to] = ++dcc;
while (st[tail] != to) { // 注意是 pop 到 to 为止（包括to）
int cur = st[tail--];
from[cur] = from[to];
dcc_list[dcc].push_back(cur);
}
tail--; // tail--后，指向的是 u
dcc_list[dcc].push_back(to);
dcc_list[dcc].push_back(u); // 注意 u是割点，也要进入该分量
// from[u] = dcc; // from[u] 实际上没有意义
}
if (low[to] &amp;gt;= dfn[u] &amp;amp;&amp;amp; p) cut[u] = 1; // 割点（非根节点）
}
}
if (!p &amp;amp;&amp;amp; child &amp;gt;= 2) cut[u] = 1; // 割点（根节点）
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i, 0);
}
}
void init() {
for (int i = 1; i &amp;lt;= dcc; i++) dcc_list[i].clear();
id = 0;
tail = -1;
dcc = 0;
n = 0;
ecnt = 1;
fill(cut, cut+maxn, 0);
fill(from, from+maxn, 0);
fill(head, head+maxn, 0);
fill(dfn, dfn+maxn, 0);
fill(low, low+maxn, 0);
}
void solve(int T) {
init();
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
n = max(n,u); n = max(n,v);
addEdge(u,v); addEdge(v,u);
}
tarjan();
int ans1 = 0;
ll ans2 = 1;
for (int i = 1; i &amp;lt;= dcc; i++) {
int cut_cnt = 0;
int sz = dcc_list[i].size();
for (int j = 0; j &amp;lt; dcc_list[i].size(); j++) {
int cur = dcc_list[i][j];
if (cut[cur]) cut_cnt++;
}
if (cut_cnt &amp;gt;= 2) continue;
if (cut_cnt == 1) ans1++, ans2 *= (ll)(sz - 1);
if (cut_cnt == 0) ans1+=2, ans2 *= (ll)(sz) * (ll)(sz-1LL) / 2LL;
}
printf(&amp;quot;Case %d: %d %lld\n&amp;quot;, T, max(ans1, 2), ans2);
}
int main() {
int T = 0;
while (cin &amp;gt;&amp;gt; m &amp;amp;&amp;amp; m) {
T++;
solve(T);
}
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h3 id="例2-洛谷p5058-zjoi2004嗅探器httpswwwluogucomcnproblemp5058">例2 &lt;a href="https://www.luogu.com.cn/problem/P5058" target="_blank">洛谷P5058 [ZJOI2004]嗅探器&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>现有 $n$ 个节点的无向图。&lt;/p>
&lt;p>给定两个节点 $a,b$，输出 最小编号的 $u$ 使得 $a,b$ 之间所有的路径都需要经过 $u$，且 $u \neq a, u \neq b$。&lt;/p>
&lt;p>如果无解，则输出 &amp;ldquo;No solution&amp;rdquo;。&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>先&lt;strong>点双缩点&lt;/strong>，如果 $a,b$ 在同一个点双内必然无解（根据定义，大小等于 $3$ 的点双内，任意两点之间有&lt;strong>点不重复&lt;/strong>的路径）。&lt;/p>
&lt;p>如果 $a,b$ 在不同的点双内则说明有解，缩点后，$a,b$ 就是树上的两个节点，它们之间有唯一路径，取这个路径上编号最小的割点即可。&lt;/p>
&lt;hr>
&lt;p>一些注意事项：&lt;/p>
&lt;ol>
&lt;li>每个割点单独形成一个点双。&lt;/li>
&lt;li>缩点得到的树，所有的边必然和 &lt;strong>割点&lt;/strong> 相连，所以建边的时候&lt;strong>只需要考虑割点所在的dcc&lt;/strong>，还有它旁边有哪些dcc就可以了。本题中在缩点建树的过程中，使用了数组 &lt;code>vector&amp;lt;int&amp;gt; cut_from[maxn];&lt;/code>。其中 &lt;code>cut_from[u]&lt;/code> 代表以 $u$ 作为割点，它neighbor的dcc编号。&lt;/li>
&lt;/ol>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 2e5+5;
const int maxm = 5e5+5;
int n,a,b,head[maxn],ecnt = 0;
struct Edge {
int to, nxt;
} edges[maxm&amp;lt;&amp;lt;1];
void addEdge(int u, int v) {
Edge e = {v, head[u]};
head[u] = ecnt;
edges[ecnt++] = e;
}
int dfn[maxn], low[maxn], dcc = 0, id = 0, st[maxn], from[maxn], tail = -1;
bool cut[maxn];
vector&amp;lt;int&amp;gt; dcc_list[maxn&amp;lt;&amp;lt;1];
vector&amp;lt;int&amp;gt; cut_from[maxn]; // cut_from[u] 代表以 u 作为割点，它neighbor的dcc编号
void tarjan(int u, int p) {
dfn[u] = low[u] = ++id;
st[++tail] = u;
int child = 0;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue;
if (dfn[to]) low[u] = min(low[u], dfn[to]);
else {
child++;
tarjan(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt;= dfn[u]) {
from[u] = ++dcc;
while (st[tail] != to) {
int cur = st[tail--];
from[cur] = from[u];
dcc_list[dcc].push_back(cur);
}
tail--;
from[to] = from[u];
dcc_list[dcc].push_back(to);
dcc_list[dcc].push_back(u);
}
if (low[to] &amp;gt;= dfn[u] &amp;amp;&amp;amp; p) {
cut[u] = 1;
}
}
}
if (child &amp;gt;= 2 &amp;amp;&amp;amp; !p)
cut[u] = 1;
}
vector&amp;lt;int&amp;gt; adj[maxn&amp;lt;&amp;lt;1]; // 缩点后的图
int par[maxn&amp;lt;&amp;lt;1], dep[maxn&amp;lt;&amp;lt;1]; // 缩点后，dfs树用到的数组
int mp[maxn&amp;lt;&amp;lt;1]; // map: dcc -&amp;gt; cut vertex id (只有该dcc对应的是 单个割点形成的 dcc才有用)
void dfs(int u, int p) {
par[u] = p;
dep[u] = dep[p] + 1;
for (int to : adj[u]) {
if (to == p) continue;
dfs(to, u);
}
}
int ans = 1e9;
void LCA(int u, int v) {
int f1 = mp[u], f2 = mp[v];
if (dep[u] &amp;lt; dep[v]) swap(u,v);
int d = dep[u] - dep[v];
vector&amp;lt;int&amp;gt; path;
while (d--) {
path.push_back(u);
u = par[u];
}
path.push_back(u);
while (u != v) {
path.push_back(u);
path.push_back(v);
u = par[u], v = par[v];
}
path.push_back(u);
path.push_back(v);
for (int c : path) {
if (mp[c] == f1 || mp[c] == f2) continue;
if (cut[mp[c]]) ans = min(ans, mp[c]);
}
}
void rebuild() {
for (int i = 1; i &amp;lt;= dcc; i++) {
for (int j : dcc_list[i]) {
if (cut[j]) cut_from[j].push_back(i);
}
}
for (int u = 1; u &amp;lt;= n; u++) {
if (cut[u]) {
int fu = from[u] = ++dcc;
mp[dcc] = u;
dcc_list[dcc].push_back(u);
for (int fv : cut_from[u]) {
adj[fu].push_back(fv);
adj[fv].push_back(fu);
}
}
}
}
int main() {
cin &amp;gt;&amp;gt; n;
int u,v;
fill(head, head+maxn, -1);
while (cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;amp;&amp;amp; u &amp;amp;&amp;amp; v) {
addEdge(u,v); addEdge(v,u);
}
cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) tarjan(i,0);
}
rebuild();
for (int i = 1; i &amp;lt;= dcc; i++) {
if (!dep[i]) dfs(i,0);
}
LCA(from[a], from[b]);
if (ans == 0 || ans == 1e9) cout &amp;lt;&amp;lt; &amp;quot;No solution&amp;quot; &amp;lt;&amp;lt; endl;
else cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h3 id="例3-poj3694-networkhttpsvjudgenetproblempoj-3694">例3 &lt;a href="https://vjudge.net/problem/POJ-3694" target="_blank">POJ3694 Network&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定 $N$ 个节点和 $M$ 条边的无向图，初始图是连通的。&lt;/p>
&lt;p>现在要加 $Q$ 条边（可重复），每次加边后，回答图中有多少个桥。&lt;/p>
&lt;p>其中，$1 \leq N \leq 10^5, N-1 \leq M \leq 2 \times 10^5, 1\leq Q \leq 1000$&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>既然是桥，那么就直接先求一个边双，然后缩点。&lt;/p>
&lt;p>边双缩点后可以得到一棵树，所有加边操作都放到这个树上来考虑。&lt;/p>
&lt;p>首先会发现，加上的新边&lt;strong>必不可能&lt;/strong>是桥（因为图原本是连通的）。&lt;/p>
&lt;p>每次加边 $(u,v)$，如果 $u,v$ 在同一个边双里，那么不会有任何影响。&lt;/p>
&lt;p>如果 $u,v$ 不在同一个边双里，那么加上的这条新边就会在树上形成一个环，使得环内的所有边均 &lt;strong>不再是桥&lt;/strong>。&lt;/p>
&lt;hr>
&lt;p>那么，回忆一下 &lt;a href="https://tom0727.github.io/post/037-%e6%a0%91%e4%b8%8a%e5%b7%ae%e5%88%86/#%e4%be%8b1-acwing-352-%e6%9a%97%e4%b9%8b%e8%bf%9e%e9%94%81httpswwwacwingcomproblemcontentdescription354">AcWing 352 暗之连锁&lt;/a> 中，我们可以将树边看作主要边，新加上的边就转化为主要边。&lt;/p>
&lt;p>比如，我们加上 $(u,v)$，那么就给 $u,v$ 之间路径上所有的边打一个标记。被标记过的就不是桥，没标记的就都是桥。&lt;/p>
&lt;p>然而树上差分的做法只适用于离线，只有所有修改操作结束后询问才有效。&lt;/p>
&lt;p>在线的做法我们可以利用 &lt;strong>树链剖分&lt;/strong>（询问边），每次修改前，先进行一下询问，查询有多少个在修改前是无标记的，将答案减去这个数量即可。&lt;/p>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 1e5+5;
const int maxm = 2e5+5;
int n,m, head[maxn], ecnt = 0, dfn[maxn], low[maxn], id = 0, from[maxn], ecc = 0;
bool bridge[maxm&amp;lt;&amp;lt;1];
struct Edge {
int to, nxt;
} edges[maxm&amp;lt;&amp;lt;1];
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
void tarjan(int u, int p) {
dfn[u] = low[u] = ++id;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (to == p) continue;
if (dfn[to]) low[u] = min(low[u], dfn[to]);
else {
tarjan(to, u);
low[u] = min(low[u], low[to]);
if (low[to] &amp;gt; dfn[u]) {
bridge[e] = bridge[e^1] = 1;
}
}
}
}
// f 代表 from (ecc编号)
void dfs(int u, int f) {
from[u] = f;
for (int e = head[u]; ~e; e = edges[e].nxt) {
int to = edges[e].to;
if (from[to] || bridge[e]) continue; // to已访问，或者该边是桥
dfs(to, f);
}
}
vector&amp;lt;int&amp;gt; adj[maxn];
void rebuild() {
for (int u = 1; u &amp;lt;= n; u++) {
for (int e = head[u]; ~e; e = edges[e].nxt) {
int v = edges[e].to;
int fu = from[u], fv = from[v];
if (fu == fv) continue;
adj[fu].push_back(fv);
}
}
}
int sz[maxn], son[maxn], top[maxn], tr_id[maxn];
int par[maxn][20], dep[maxn];
void dfs2(int u, int p) {
sz[u] = 1;
dep[u] = dep[p] + 1;
par[u][0] = p;
for (int j = 1; j &amp;lt;= 19; j++) par[u][j] = par[par[u][j-1]][j-1];
int maxsz = -1;
for (int i = 0; i &amp;lt; adj[u].size(); i++) {
int to = adj[u][i];
if (to == p) continue;
dfs2(to, u);
sz[u] += sz[to];
if (sz[to] &amp;gt; maxsz) maxsz = sz[to], son[u] = to;
}
}
void dfs3(int u, int p, int topf) {
top[u] = topf;
tr_id[u] = ++id;
if (son[u]) dfs3(son[u], u, topf);
for (int i = 0; i &amp;lt; adj[u].size(); i++) {
int to = adj[u][i];
if (to == p || to == son[u]) continue;
dfs3(to, u, to);
}
}
struct tree_node {
int sum;
bool lazy;
} tr[maxn&amp;lt;&amp;lt;2];
void push_up(int cur) {
tr[cur].sum = tr[cur&amp;lt;&amp;lt;1].sum + tr[cur&amp;lt;&amp;lt;1|1].sum;
}
void push_down(int cur) {
if (!tr[cur].lazy) return;
tr[cur].lazy = 0;
int l = cur&amp;lt;&amp;lt;1, r = cur&amp;lt;&amp;lt;1|1;
tr[l].lazy = tr[r].lazy = 1;
tr[l].sum = tr[r].sum = 0;
}
void update(int cur, int l, int r, int L, int R) {
if (l &amp;gt;= L &amp;amp;&amp;amp; r &amp;lt;= R) {
tr[cur].lazy = 1;
tr[cur].sum = 0;
return;
}
push_down(cur);
int mid = (l+r) &amp;gt;&amp;gt; 1;
if (L &amp;lt;= mid) update(cur&amp;lt;&amp;lt;1, l, mid, L, R);
if (R &amp;gt; mid) update(cur&amp;lt;&amp;lt;1|1, mid+1, r, L, R);
push_up(cur);
}
int query(int cur, int l, int r, int L, int R) {
if (l &amp;gt;= L &amp;amp;&amp;amp; r &amp;lt;= R) return tr[cur].sum;
push_down(cur);
int mid = (l+r) &amp;gt;&amp;gt; 1;
int res = 0;
if (L &amp;lt;= mid) res += query(cur&amp;lt;&amp;lt;1, l, mid, L, R);
if (R &amp;gt; mid) res += query(cur&amp;lt;&amp;lt;1|1, mid+1, r, L, R);
return res;
}
void build_tree(int cur, int l, int r) {
if (l == r) {
tr[cur].sum = 1;
return;
}
int mid = (l+r) &amp;gt;&amp;gt; 1;
build_tree(cur&amp;lt;&amp;lt;1, l, mid);
build_tree(cur&amp;lt;&amp;lt;1|1, mid+1, r);
push_up(cur);
}
int jump(int u, int d) {
int j = 0;
while (d) {
if (d&amp;amp;1) u = par[u][j];
j++, d &amp;gt;&amp;gt;= 1;
}
return u;
}
int LCA(int u, int v) {
if (dep[u] &amp;lt; dep[v]) swap(u,v);
int d = dep[u] - dep[v];
u = jump(u, d);
if (u == v) return u;
for (int j = 19; j &amp;gt;= 0; j--) {
if (par[u][j] != par[v][j])
u = par[u][j], v = par[v][j];
}
return par[u][0];
}
int curans;
void update_path_helper(int u, int v) {
if (v == -1) return;
while (top[u] != top[v]) {
if (dep[top[u]] &amp;lt; dep[top[v]]) swap(u,v);
curans -= query(1, 2, ecc, tr_id[top[u]], tr_id[u]);
update(1, 2, ecc, tr_id[top[u]], tr_id[u]);
u = par[top[u]][0];
}
if (dep[u] &amp;gt; dep[v]) swap(u,v);
curans -= query(1, 2, ecc, tr_id[u], tr_id[v]);
update(1, 2, ecc, tr_id[u], tr_id[v]);
}
void update_path(int u, int v) {
int x = LCA(u,v);
int d,ux,vx;
d = dep[u] - dep[x];
if (!d) ux = -1;
else ux = jump(u, d-1);
d = dep[v] - dep[x];
if (!d) vx = -1;
else vx = jump(v, d-1);
update_path_helper(u, ux);
update_path_helper(v, vx);
}
void clearall() {
fill(head, head+n+1, -1);
fill(dfn, dfn+n+1, 0);
fill(low, low+n+1, 0);
fill(from, from+n+1, 0);
fill(bridge, bridge+(m&amp;lt;&amp;lt;1)+2, 0);
fill(sz, sz+ecc+1, 0);
fill(son, son+ecc+1, 0);
fill(top, top+ecc+1, 0);
fill(tr_id, tr_id+ecc+1, 0);
for (int i = 1; i &amp;lt;= 4*ecc+5; i++) tr[i].lazy = 0;
for (int i = 1; i &amp;lt;= ecc; i++)
for (int j = 0; j &amp;lt;= 19; j++) par[i][j] = 0;
fill(dep, dep+ecc+1, 0);
for (int i = 1; i &amp;lt;= n; i++) adj[i].clear();
ecnt = id = ecc = 0;
}
int main() {
fastio;
int T = 0;
fill(head, head+maxn, -1);
while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;amp;&amp;amp; n &amp;amp;&amp;amp; m) {
T++;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v); addEdge(v,u);
}
tarjan(1, 0);
for (int i = 1; i &amp;lt;= n; i++) {
if (!from[i]) dfs(i, ++ecc);
}
rebuild();
id = 0;
dfs2(1, 0);
dfs3(1, 0, 1);
curans = ecc-1;
cout &amp;lt;&amp;lt; &amp;quot;Case &amp;quot; &amp;lt;&amp;lt; T &amp;lt;&amp;lt; &amp;quot;:\n&amp;quot;;
int Q; cin &amp;gt;&amp;gt; Q;
if (ecc == 1) {
while (Q--) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}
} else {
build_tree(1, 2, ecc);
while (Q--) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
update_path(from[u],from[v]);
cout &amp;lt;&amp;lt; curans &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}
cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}
clearall();
}
}
&lt;/code>&lt;/pre>
&lt;/details></description></item><item><title>强连通分量（SCC）</title><link>https://tom0727.github.io/post/040-tarjan/</link><pubDate>Mon, 12 Apr 2021 22:02:41 +0800</pubDate><guid>https://tom0727.github.io/post/040-tarjan/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;p>在一个 &lt;strong>有向图&lt;/strong> 中，任意取两个节点 $(u,v)$，$u \rightarrow v, v \rightarrow u$ 均有路径，这样的图叫做强连通。&lt;/p>
&lt;p>&lt;strong>SCC（强连通分量）&lt;/strong>：一个极大的强连通子图。&lt;/p>
&lt;p>&lt;strong>缩点&lt;/strong>：当我们求出一个图中的所有 SCC 后，我们可以将每一个 SCC 缩成一个点。缩点过后，我们可以得到一个新的图，我们遍历所有 &lt;strong>原图中的边&lt;/strong>，将原图中的边加到新图中（注意判断 &lt;strong>自环&lt;/strong>，并且一般会出现&lt;strong>重复边&lt;/strong>）。&lt;/p>
&lt;p>• 缩点后得到的图一定是一个 &lt;strong>DAG（有向无环图）&lt;/strong>。&lt;/p>
&lt;p>• DAG 有着很多优秀的性质，比如可以进行 &lt;strong>拓扑排序&lt;/strong>，可以利用 拓扑排序进行 &lt;strong>DP&lt;/strong> 等。&lt;/p>
&lt;p>求一个有向图中的强连通分量，有两种算法，Tarjan 与 kosaraju 算法（复杂度均为 $O(n+m)$）。&lt;/p>
&lt;h2 id="tarjan-求有向图的-scc">Tarjan 求有向图的 SCC&lt;/h2>
&lt;h3 id="算法流程">算法流程&lt;/h3>
&lt;p>定义 $DFS$ 树为：从任意节点出发，形成的一条从上往下的生成树。&lt;/p>
&lt;p>当我们从 $u$ 访问到 direct neighbor $v$ 时，如果 $v$ 尚未被访问过，那么 $(u,v)$ 是一条 &lt;strong>树边&lt;/strong>。否则 $(u,v)$ 是一条 &lt;strong>非树边&lt;/strong>。&lt;/p>
&lt;hr>
&lt;p>我们先维护一个栈 &lt;code>st[]&lt;/code>，里面储存的是我们当前正在处理的 SCC。&lt;/p>
&lt;p>定义两个数组 $dfn[u], low[u]$。&lt;/p>
&lt;ol>
&lt;li>$dfn[u]$ ：DFS过程中，节点 $u$ 的编号（前序编号）。&lt;/li>
&lt;li>$low[u]$ ：当前，在&lt;strong>栈中的所有节点&lt;/strong>，以下两者的最小值：
&lt;ol>
&lt;li>$u$ 的子树中，所有节点 $v$ 的 $low[v]$ 最小值。&lt;/li>
&lt;li>从 $u$ 出发，经过一条 &lt;strong>非树边&lt;/strong> 达到节点 $v$ 的 $dfn[v]$ 的最小值。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-cpp">void dfs(int u) {
// ....
in[u] = 1; // u 进栈
st[++tail] = u; // 进栈
dfn[u] = low[u] = ++id; // 前序编号
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]); // 需要在栈内
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
// ....
&lt;/code>&lt;/pre>
&lt;p>经过 DFS 后，我们可以发现，在 &lt;strong>栈内&lt;/strong>，&lt;strong>有且仅有一个节点&lt;/strong> $u$ 使得 $dfn[u] = low[u]$。这个节点就代表 SCC 在DFS树中的根节点。&lt;/p>
&lt;p>所以，当我们进行DFS回溯的时候，检查一下当前节点 $u$ 是否满足 $dfn[u] = low[u]$。如果满足，将栈中所有的节点（直到 $u$ 为止）全部拿出来，就是一个新的 SCC 了。&lt;/p>
&lt;pre>&lt;code class="language-cpp">// from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小
int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn];
bool in[maxn]; // instack or not
int st[maxn], tail = -1;
void dfs(int u) {
in[u] = 1;
st[++tail] = u;
dfn[u] = low[u] = ++id;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]);
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (tail &amp;gt;= 0 &amp;amp;&amp;amp; st[tail] != u) {
int cur = st[tail];
from[cur] = from[u];
sz[scc]++;
tail--;
in[cur] = 0; // 记得这里，将在栈中的标记去掉
}
tail--;
in[u] = 0; // 记得这里，将在栈中的标记去掉
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="例题-洛谷p2341-usaco03fallhaoi2006受欢迎的牛-ghttpswwwluogucomcnproblemp2341">例题 &lt;a href="https://www.luogu.com.cn/problem/P2341" target="_blank">洛谷P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定一个 $N$ 个节点，$M$ 条边的有向图。&lt;/p>
&lt;p>定义一个节点 $u$ 为明星，当且仅当：&lt;/p>
&lt;p>对于 &lt;strong>任意节点&lt;/strong> $v$ ，均有至少一条到 $u$ 的路径。&lt;/p>
&lt;p>问，图中有多少个节点是明星？&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>对原图跑一次tarjan求SCC，然后缩点。&lt;/p>
&lt;p>缩点后，我们会发现 &lt;strong>新图中只有一个明星&lt;/strong>。&lt;/p>
&lt;p>• 如果新图中有 $2$ 个明星，那么 明星 $1$ 存在到 明星 $2$ 的边，反之亦然。那么明星 $1,2$ 就属于同一个SCC，contradiction。&lt;/p>
&lt;p>并且我们会发现，明星的 &lt;strong>out-degree&lt;/strong> 一定为 $0$，否则，明星指向的节点也是一个明星。&lt;/p>
&lt;p>所以，如果缩点后，新图满足：&lt;strong>存在 且 仅存在&lt;/strong> $1$ 个节点，使得它的 &lt;strong>out-degree&lt;/strong> 为 $0$，那么有解，输出这个SCC对应的大小即可。&lt;/p>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">const int maxn = 1e4+5;
const int maxm = 5e4+10;
struct Edge {
int to, nxt;
} edges[maxm];
int head[maxn], ecnt = 1, n,m;
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn];
bool in[maxn]; // instack or not
int st[maxn], tail = -1;
void dfs(int u) {
in[u] = 1;
st[++tail] = u;
dfn[u] = low[u] = ++id;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]);
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (tail &amp;gt;= 0 &amp;amp;&amp;amp; st[tail] != u) {
int cur = st[tail];
from[cur] = from[u];
sz[scc]++;
tail--;
in[cur] = 0;
}
tail--;
in[u] = 0;
}
}
int deg[maxn];
void build() {
for (int u = 1; u &amp;lt;= n; u++) {
for (int e = head[u]; e; e = edges[e].nxt) {
int v = edges[e].to;
int fu = from[u], fv = from[v];
if (fv == fu) continue; // 记得去掉自环
deg[fu]++;
}
}
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i);
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
int cnt = 0, ans;
for (int i = 1; i &amp;lt;= scc; i++) {
if (!deg[i]) cnt++, ans = i;
}
if (cnt &amp;gt; 1) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
else cout &amp;lt;&amp;lt; sz[ans] &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h2 id="kosaraju-算法">kosaraju 算法&lt;/h2>
&lt;p>kosaraju 算法本质上利用了 &lt;strong>正反 $2$ 次DFS&lt;/strong> 求出一个图中的强连通分量。&lt;/p>
&lt;h3 id="算法流程-1">算法流程&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>建立原图 $G$，和一个反图 $G'$（将所有的边反过来）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在原图 $G$ 上跑 DFS，&lt;strong>回溯&lt;/strong> 的时候记录 ID。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在反图 $G'$ 上跑 DFS，起始节点的顺序是 &lt;strong>ID从大到小&lt;/strong>。每次 DFS 的 &lt;strong>起始节点&lt;/strong> 就代表了一个新的SCC，DFS访问到的所有节点就是这个SCC。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="感性理解">感性理解&lt;/h3>
&lt;p>如果将原图进行一个缩点操作，那么我们可以得到一个DAG：&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/040/1.jpg" alt="img">&lt;/p>
&lt;p>如上图，可以看出 节点 $1$ 拥有 &lt;strong>支配地位&lt;/strong>（它能到达别的点，但是别的点无法到达它）。&lt;/p>
&lt;p>也可以说，节点 $1$ 在&lt;strong>拓扑序&lt;/strong>中，位置最靠前。&lt;/p>
&lt;p>由于我们是 &lt;strong>回溯&lt;/strong> 的时候才记录 ID，所以节点 $1$ 的 ID 是&lt;strong>最大&lt;/strong>的。&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://tom0727.github.io/images/040/2.jpg" alt="img">&lt;/p>
&lt;p>那么，在反图 $G'$ 中，所有节点的地位反转了，节点 $1$ 的地位最低，且它在拓扑序中，位置最靠后。&lt;/p>
&lt;p>为了找到 SCC，我们希望的就是找到一个节点，使得它无法到达任何其他节点。那么节点 $1$ 就是我们想要的。&lt;/p>
&lt;p>这解释了为什么我们要 &lt;strong>ID从大到小&lt;/strong> 进行反图的 DFS。&lt;/p>
&lt;hr>
&lt;p>注：原图不一定连通，DFS的时候要注意。&lt;/p>
&lt;h3 id="模版题">模版题&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P2863" target="_blank">洛谷P2863 [USACO06JAN]The Cow Prom S&lt;/a>&lt;/p>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定 $n$ 个节点，$m$ 条边的有向图。&lt;/p>
&lt;p>求点数大于 $1$ 的SCC个数。&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">const int maxn = 1e4+5;
const int maxm = 5e4+5;
struct Edge {
int to, nxt;
} edges[maxm], redges[maxm];
int head[maxn], rhead[maxn], ecnt = 1, recnt = 1;
void addEdge(int u, int v) {
Edge e = {v, head[u]};
head[u] = ecnt;
edges[ecnt++] = e;
}
void rev_addEdge(int u, int v) {
Edge e = {v, rhead[u]};
rhead[u] = recnt;
redges[recnt++] = e;
}
int id[maxn], idcnt = 0;
bool vis[maxn];
void dfs(int u) {
vis[u] = 1;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (vis[to]) continue; // 已经访问过了，忽略
dfs(to);
}
id[++idcnt] = u; // 回溯的时候更新ID
}
int sz[maxn];
void dfs2(int u) {
sz[u] = 1;
for (int e = rhead[u]; e; e = redges[e].nxt) {
int to = redges[e].to;
if (sz[to]) continue; // 已经访问过，忽略
dfs2(to);
sz[u] += sz[to];
}
}
int main() {
int n,m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
rev_addEdge(v,u);
}
for (int i = 1; i &amp;lt;= n; i++) {
if (!vis[i]) dfs(i);
}
int ans = 0;
for (int i = n; i &amp;gt;= 1; i--) {
if (!sz[id[i]]) { // 还没dfs过，说明这是一个新的SCC
dfs2(id[i]);
if (sz[id[i]] &amp;gt; 1)
ans++;
}
}
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h2 id="例题">例题&lt;/h2>
&lt;h3 id="例1-洛谷p3119-usaco15jangrass-cownoisseur-ghttpswwwluogucomcnproblemp3119">例1 &lt;a href="https://www.luogu.com.cn/problem/P3119" target="_blank">洛谷P3119 [USACO15JAN]Grass Cownoisseur G&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定一个 $n$ 个节点，$m$ 条边的&lt;strong>有向图&lt;/strong>。&lt;/p>
&lt;p>现在我们需要从 $1$ 号节点出发，走一条路径，再返回到 $1$ 号节点。（每个节点可以被通过多次）。&lt;/p>
&lt;p>我们允许反向穿过一条边，但是只能反向一次。&lt;/p>
&lt;p>输出我们能够访问的 distinct 节点的最大数量。&lt;/p>
&lt;p>其中，$1 \leq n,m \leq 10^5$&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>看到 &lt;strong>每个节点可以被穿过多次&lt;/strong>，首先想到缩点。&lt;/p>
&lt;p>缩点后，假设我们去掉 &lt;strong>可以反向一次&lt;/strong> 的这个条件，那么答案就是 $1$ 所属的SCC的大小。&lt;/p>
&lt;hr>
&lt;p>因为我们只能反向一次，我们可以想到利用 &lt;strong>分层图&lt;/strong> 的思想。&lt;/p>
&lt;p>我们先缩点，得到一个新图 $G_1$，然后将缩点后的图 &lt;strong>复制一份&lt;/strong>，得到 $G_2$。&lt;/p>
&lt;p>对于 $G_1$ 中的每条边 $(u_1,v_1)$，我们建一条新边 $(v_1, u_2)$，从 $G_1 \rightarrow G_2$。&lt;/p>
&lt;hr>
&lt;p>观察到我们只能由 $G_1 \rightarrow G_2$，又因为 $G_1 = G_2$ 且 $G_1,G_2$ 均为 DAG，所以整个图中满足以下条件：&lt;/p>
&lt;ol>
&lt;li>无环（仍然是一个DAG）&lt;/li>
&lt;li>$G_1 \rightarrow G_2$ 只能发生一次。（从 $G_2$ 无法返回 $G_1$）&lt;/li>
&lt;/ol>
&lt;p>所以问题就转化为：&lt;/p>
&lt;blockquote>
&lt;p>在这个新图中，从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$，最多能经过多少个节点？&lt;/p>
&lt;/blockquote>
&lt;p>将 $G_1,G_2$（包括$G_1 \rightarrow G_2$）中，所有边 $(u,v)$ 赋上权值 $size[v]$。那么我们只要求&lt;/p>
&lt;p>从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$ 的&lt;strong>最长路&lt;/strong> 即可。&lt;/p>
&lt;hr>
&lt;p>• 注：最长路不能用 dijkstra，只能用 &lt;strong>SPFA&lt;/strong>。复杂度最坏 $O(nm)$&lt;/p>
&lt;p>• 注2：对于 &lt;strong>DAG&lt;/strong> 而言，求最长路也可以直接用 &lt;strong>拓扑排序 + DP&lt;/strong>。复杂度 $O(n+m)$，在DAG中，可以完美替代 SPFA&lt;/p>
&lt;p>• 注3：需要&lt;strong>特判一下原图是不是一个SCC&lt;/strong>（一般这种题都要特判一下）。如果是，直接输出答案 $n$。&lt;/p>
&lt;hr>
&lt;p>正确性证明：我们为什么不需要考虑 &lt;strong>重复经过某个节点&lt;/strong>，然后多算了的情况？&lt;/p>
&lt;p>答：因为我们不可能重复经过某个节点。&lt;/p>
&lt;p>证：如果我们在 $G_1$ 中经过了某个节点 $u$，说明 $1$ 是可以到达 $u$ 的。&lt;/p>
&lt;p>那么，如果在 $G_2$ 中经过了同样的节点 $u$，然后由 $u$ 又返回了 $1$。这说明 $1 \rightarrow u \rightarrow 1$ 是一个环。然而缩点后的图不可能有环，contradiction。&lt;/p>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码（SPFA）&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 1e5+5;
struct Edge {
int to,nxt;
} edges[maxn];
int head[maxn], ecnt = 1, id = 0, scc = 0, from[maxn], sz[maxn], st[maxn], tail = -1, n, m, dfn[maxn], low[maxn];
bool in[maxn];
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
void dfs(int u) {
dfn[u] = low[u] = ++id;
in[u] = 1;
st[++tail] = u;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) {
low[u] = min(low[u], dfn[to]);
}
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (st[tail] != u) {
int cur = st[tail--];
from[cur] = from[u];
sz[scc]++;
in[cur] = 0;
}
tail--;
in[u] = 0;
}
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i);
}
}
struct New_Edge {
int to, nxt, w;
} new_edges[maxn&amp;lt;&amp;lt;2];
int new_head[maxn&amp;lt;&amp;lt;1], new_ecnt = 1;
void new_addEdge(int u, int v, int w) {
New_Edge e = {v, new_head[u], w};
new_head[u] = new_ecnt;
new_edges[new_ecnt++] = e;
}
void build() {
for (int u = 1; u &amp;lt;= n; u++) {
for (int e = head[u]; e; e = edges[e].nxt) {
int v = edges[e].to;
int fu = from[u], fv = from[v];
if (fu == fv) continue; // 注意判重
new_addEdge(fu, fv, sz[fv]); // 原边
new_addEdge(fu+scc, fv+scc, sz[fv]); // 复制
new_addEdge(fv, fu+scc, sz[fu]); // 反向边
}
}
}
int d[maxn&amp;lt;&amp;lt;1], q[maxn&amp;lt;&amp;lt;1]; // 因为复制了一份，记得开2倍大小
bool inq[maxn&amp;lt;&amp;lt;1];
void spfa() {
tail = -1;
q[++tail] = from[1];
inq[from[1]] = 1; // 注意是 from[1]
while (tail &amp;gt;= 0) {
int cur = q[tail--];
for (int e = new_head[cur]; e; e = new_edges[e].nxt) {
int to = new_edges[e].to, w = new_edges[e].w;
if (d[cur] + w &amp;gt; d[to]) { // 无论是否 inq[] 都要更新
d[to] = d[cur] + w;
if (!inq[to])
q[++tail] = to;
inq[to] = 1;
}
}
inq[cur] = 0;
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
spfa();
int ans = d[from[1] + scc]; // 注意是 from[1]
if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码（拓扑排序 &amp;#43; DP）&lt;/summary>
&lt;p>因为其他部分完全一样，这里就省略，只保留 &lt;code>main()&lt;/code> 和 &lt;code>DP&lt;/code> 部分。&lt;/p>
&lt;pre>&lt;code class="language-cpp">
void solve() {
tail = -1;
fill(dp, dp+2*scc+1, -1e9); // 注意赋值为 -inf，因为我们只关心从 from[1] 出发的部分
dp[from[1]] = 0;
for (int u = 1; u &amp;lt;= 2*scc; u++) {
if (!ind[u]) st[++tail] = u;
}
while (tail &amp;gt;= 0) {
int cur = st[tail--];
for (int e = new_head[cur]; e; e = new_edges[e].nxt) {
int to = new_edges[e].to, w = new_edges[e].w;
dp[to] = max(dp[to], dp[cur] + w);
ind[to]--;
if (!ind[to]) st[++tail] = to;
}
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
solve();
int ans = dp[from[1] + scc]; // 注意是 from[1]
if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details></description></item><item><title>背包问题</title><link>https://tom0727.github.io/post/039-%E8%83%8C%E5%8C%85/</link><pubDate>Sun, 11 Apr 2021 21:42:06 +0800</pubDate><guid>https://tom0727.github.io/post/039-%E8%83%8C%E5%8C%85/</guid><description>&lt;h3 id="多重背包二进制">多重背包二进制&lt;/h3>
&lt;pre>&lt;code class="language-cpp">int n, V;
int dp[2005];
void pack01(int v, int w) {
for (int j = V; j &amp;gt;= v; j--) {
dp[j] = max(dp[j], dp[j-v] + w);
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; V;
while (n--) {
int v,w,s; cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w &amp;gt;&amp;gt; s;
int k = 1;
while (k &amp;lt;= s) {
pack01(v*k, w*k);
s -= k;
k &amp;lt;&amp;lt;= 1;
}
pack01(v*s, w*s);
}
int ans = 0;
for (int j = 0; j &amp;lt;= V; j++) ans = max(ans, dp[j]);
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;h3 id="多重背包单调队列优化">多重背包（单调队列优化）&lt;/h3>
&lt;pre>&lt;code class="language-cpp">struct node {
int pos, val;
} q[20005];
int head = -1, tail = 0, n, V, dp[20005];
void solve(int v, int w, int s) {
for (int j = 0; j &amp;lt; v; j++) {
head = 0, tail = -1;
q[++tail] = {0,0};
for (int i = 1; i*v + j &amp;lt;= V; i++) {
while (i - q[head].pos &amp;gt; s) head++;
int cur = i*v + j;
int val = dp[cur] - i*w;
dp[cur] = max(dp[cur], q[head].val + i*w);
while (head &amp;lt;= tail &amp;amp;&amp;amp; val &amp;gt;= q[tail].val) tail--;
q[++tail] = {i, val};
}
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; V;
for (int i = 1; i &amp;lt;= n; i++) {
int v,w,s; cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w &amp;gt;&amp;gt; s;
solve(v,w,s);
}
int ans = 0;
for (int j = 0; j &amp;lt;= V; j++) ans = max(ans, dp[j]);
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre></description></item><item><title>树上差分</title><link>https://tom0727.github.io/post/037-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</link><pubDate>Mon, 05 Apr 2021 15:02:19 +0800</pubDate><guid>https://tom0727.github.io/post/037-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</guid><description>介绍 树上差分就是将数组上的差分思想，转化到树上。 树上差分是一种思想，很多时候树链剖分可以代替树上差分，如果询问不复杂的时候，就可以用树上差分</description></item><item><title>主席树</title><link>https://tom0727.github.io/post/036-%E4%B8%BB%E5%B8%AD%E6%A0%91/</link><pubDate>Wed, 31 Mar 2021 10:42:02 +0800</pubDate><guid>https://tom0727.github.io/post/036-%E4%B8%BB%E5%B8%AD%E6%A0%91/</guid><description>介绍 主席树全名叫做 可持久化权值线段树，一般用于一个数组上，有以下的功能： 对于每一个区间 都能 开一个权值线段树。 能够维护数组的 历史版本。（仅用于</description></item><item><title>权值线段树（动态开点）</title><link>https://tom0727.github.io/post/035-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/</link><pubDate>Sat, 27 Mar 2021 20:13:23 +0800</pubDate><guid>https://tom0727.github.io/post/035-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid><description>介绍 权值线段树 权值线段树用于维护一定值域内，各个元素出现的次数，结合动态开点可以 避免离散化的处理。 举个例子，我们现在有一个长度为 $10$ 的数组 $[1,5,2,3,4,1,3,4,4,4]$ $1$</description></item><item><title>CF 1499D（数学，筛法）</title><link>https://tom0727.github.io/post/034-cf-1499d/</link><pubDate>Mon, 22 Mar 2021 23:47:16 +0800</pubDate><guid>https://tom0727.github.io/post/034-cf-1499d/</guid><description>题目链接 题意 给定正整数 $c,d,x$，求正整数pair $(a,b)$ 的数量使得 $$c \times lcm(a,b) - d \times gcd(a,b) = x$$ 其中，共 $T \leq 10^4$ 个testcase，$1 \leq c,d,x \leq 10^7$ • $(a,b)$ 和 $(b,a)$ 不</description></item><item><title>数位DP</title><link>https://tom0727.github.io/post/033-%E6%95%B0%E4%BD%8Ddp/</link><pubDate>Thu, 18 Mar 2021 10:53:51 +0800</pubDate><guid>https://tom0727.github.io/post/033-%E6%95%B0%E4%BD%8Ddp/</guid><description>介绍 数位DP是指这样一类题型： 给定一些限定条件，求 $[L,R]$ 内满足这些条件的数字数量，一般 $L,R$ 可能非常大（例如$10^{18}, 10^{1000}$）</description></item><item><title>线段树/分块 例题</title><link>https://tom0727.github.io/post/032-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BE%8B%E9%A2%98/</link><pubDate>Tue, 16 Mar 2021 22:10:22 +0800</pubDate><guid>https://tom0727.github.io/post/032-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BE%8B%E9%A2%98/</guid><description>主要记录一些遇到的线段树/分块例题。 例1 CF438D 题意 给定 $N$ 个正整数和 $M$ 个询问，询问有 3 种： $1 ~ l ~ r$：输出 $\sum\limits_{i=l}^r a_i$ $2 ~ l ~ r ~ x$：将 $a_l$ 到 $a_r$ 的所有数</description></item><item><title>树上启发式合并（DSU on Tree）</title><link>https://tom0727.github.io/post/031-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</link><pubDate>Mon, 15 Mar 2021 20:53:14 +0800</pubDate><guid>https://tom0727.github.io/post/031-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</guid><description>介绍 树上启发式合并 一般用于 满足以下条件的问题： 所有询问离线，无修改，仅询问子树的信息（不能用于链的询问） $ans[u]$ 可以转化为 $\sum\limits_{v}ans[v]$ 的形式（其中，$v$ 是</description></item><item><title>Atcoder ABC 131F（图论）</title><link>https://tom0727.github.io/post/030-at-abc131f/</link><pubDate>Fri, 12 Mar 2021 21:48:23 +0800</pubDate><guid>https://tom0727.github.io/post/030-at-abc131f/</guid><description>题目链接 https://atcoder.jp/contests/abc131/tasks/abc131_f 题意 给定 $N$ 个二维平面中的点 $(x_i,y_i)$，我们可以一直重复以下操作： 选择 4 个整数 $a,b,c,d$，保证 $(a,b),(a,d),(c,b),(c,d)$ 中 有且仅有 3 个点</description></item><item><title>CF 165E题解（状压dp）</title><link>https://tom0727.github.io/post/029-cf-165e/</link><pubDate>Thu, 11 Mar 2021 23:20:32 +0800</pubDate><guid>https://tom0727.github.io/post/029-cf-165e/</guid><description>题目链接 https://codeforces.com/contest/165/problem/E 题意 给定 $n$ 个数 $a_1,a_2,&amp;hellip;,a_n$，对于每一个 $a_i$，找出是否存在 $a_j$ 使得 $a_i$ &amp;amp; $a_j = 0$？ 其中 $1 \leq n \leq 10^6, 1</description></item><item><title>CF 1188B（枚举优化）</title><link>https://tom0727.github.io/post/028-cf-1188b/</link><pubDate>Thu, 11 Mar 2021 14:37:13 +0800</pubDate><guid>https://tom0727.github.io/post/028-cf-1188b/</guid><description>题目链接 https://codeforces.com/contest/1188/problem/B 题意 给定 $n$ 个正整数 $a_1,a_2,&amp;hellip;,a_n$，和一个非负整数 $k$，求满足以下条件的 $(i,j)$ 数量： $1\leq i &amp;lt; j \leq n$ $(a_i+a_j)(a_i^2+a_j^2) \equiv k \text{</description></item><item><title>数论分块</title><link>https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/</link><pubDate>Wed, 10 Mar 2021 15:49:46 +0800</pubDate><guid>https://tom0727.github.io/post/027-%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/</guid><description>介绍 数论分块一般用于解决 含有 $\lfloor \frac{N}{i} \rfloor$ 的求和问题。 数论分块主要利用了 $\lfloor \frac{N}{i} \rfloor$ 的取值范围相当有限的特点，所以有 $$i \leq j, ~\lfloor \frac{N}{i} \rfloor = \lfloor \frac{N}{j} \rfloor$$ 这样一些求和问题就</description></item><item><title>CF1243E 题解（图论，状压dp）</title><link>https://tom0727.github.io/post/026-cf-1243e/</link><pubDate>Tue, 09 Mar 2021 12:34:01 +0800</pubDate><guid>https://tom0727.github.io/post/026-cf-1243e/</guid><description>题目链接 https://codeforces.com/contest/1243/problem/E 题意 给定 $k$ 个 box，每个 box $i$ 里有 $n_i$ 个整数，所有整数均不同。 现在我们需要执行 Exactly Once 以下操作： 从每一个box中拿一个数出来，然后以per</description></item><item><title>CF1154G 题解（gcd/lcm的枚举优化）</title><link>https://tom0727.github.io/post/025-cf-1154g/</link><pubDate>Mon, 08 Mar 2021 21:36:22 +0800</pubDate><guid>https://tom0727.github.io/post/025-cf-1154g/</guid><description>题目链接 https://codeforces.com/contest/1154/problem/G 题意 给定 $n$ 个正整数 $a_1,a_2,&amp;hellip;,a_n$，求 $i \neq j$ 使得 $\text{lcm}(a_i, a_j)$ 最小？ 其中 $2 \leq n \leq 10^6, 1 \leq a_i \leq 10^7$ 题解 一般和 $gcd, lcm$ 相关的</description></item><item><title>莫队</title><link>https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/</link><pubDate>Sun, 07 Mar 2021 21:50:41 +0800</pubDate><guid>https://tom0727.github.io/post/024-%E8%8E%AB%E9%98%9F/</guid><description>介绍 莫队算法是一种基于分块思想的暴力算法，一般应用于同时满足以下条件的区间问题中： 已知 $[L,R]$ 之间的答案，能在 $O(1)$ 时间内转移到 $[L+1,R], [L-1,R], [L,R+1], [L,R-1]$ 的答案。 所有询</description></item><item><title>Atcoder ABC 194F（数位DP，进制处理）</title><link>https://tom0727.github.io/post/023-at-abc194f/</link><pubDate>Sat, 06 Mar 2021 22:16:46 +0800</pubDate><guid>https://tom0727.github.io/post/023-at-abc194f/</guid><description>题目链接 https://atcoder.jp/contests/abc194/tasks/abc194_f 题意 给定一个数 $1\leq N \leq 16^{2\times10^5}$，求： 在 16进制 下，满足以下条件的整数 $x$ 数量： 拥有 Exactly $K$ 个不同的digit （例</description></item><item><title>树链剖分</title><link>https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</link><pubDate>Sat, 06 Mar 2021 15:58:27 +0800</pubDate><guid>https://tom0727.github.io/post/022-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</guid><description>介绍 树链剖分主要用于将 树上修改/查询 通过 DFS序 变成 区间修改/查询，然后利用 线段树 进行修改/查询。 我们可以用模版来举个例子： 题意 已知一棵包含</description></item><item><title>最近公共祖先 LCA</title><link>https://tom0727.github.io/post/021-lca/</link><pubDate>Sat, 06 Mar 2021 11:57:25 +0800</pubDate><guid>https://tom0727.github.io/post/021-lca/</guid><description>介绍 给定一棵有根树（不一定为binary tree），求两个节点的最近公共祖先？ 算法 LCA的思路和ST表比较相似，都是利用了倍增思想，大概流程</description></item><item><title>三分法</title><link>https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/</link><pubDate>Fri, 05 Mar 2021 22:20:54 +0800</pubDate><guid>https://tom0727.github.io/post/020-%E4%B8%89%E5%88%86%E6%B3%95/</guid><description>介绍 三分法 (tenary search) 和 二分法(binary search) 类似，只不过三分法可以用于搜索一个 二次函数 的最值。 以搜索二次函数最值为例，假如有一个二次函数存在最大值</description></item><item><title>Luogu P5664 Emiya家今天的饭（计数，dp）</title><link>https://tom0727.github.io/post/019-luogu-p5664/</link><pubDate>Fri, 05 Mar 2021 14:58:19 +0800</pubDate><guid>https://tom0727.github.io/post/019-luogu-p5664/</guid><description>题目链接 https://www.luogu.com.cn/problem/P5664 题意 有 $n$ 种烹饪方法，$m$ 种主要食材。每道菜都只用 恰好一种 烹饪方法和主要食材，同时对于 每种烹饪方法 $i$ 和 主要食材 $j$，有 $a_{ij}$ 种不同的</description></item><item><title>Luogu P1450 硬币购物（计数，容斥）</title><link>https://tom0727.github.io/post/018-luogu-p1450/</link><pubDate>Thu, 04 Mar 2021 23:29:54 +0800</pubDate><guid>https://tom0727.github.io/post/018-luogu-p1450/</guid><description>题目链接 https://www.luogu.com.cn/problem/P1450 题意 共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$ 某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚的 第 $i$ 种硬币，想购买价值为 $s$ 东西（不设找零）。请</description></item><item><title>组合数学</title><link>https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link><pubDate>Tue, 02 Mar 2021 18:35:43 +0800</pubDate><guid>https://tom0727.github.io/post/017-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid><description>记录一些组合数学的公式。 公式 组合数 $C(n,m)$ $C_n^0 = C_n^n = 1$ $C_n^k = C_{n-1}^k + C_{n-1}^{k-1}$ $C_n^k = \frac{n!}{k!(n-k)!}$ 注：$0! = 1, (0!)^{-1} = 1$ 证明公式2 $n$ 个中选 $k$ 个， 考虑 $n$ 个元素中的第一个元素： 如果它</description></item><item><title>Atcoder ABC 127F（对顶堆动态维护中位数）</title><link>https://tom0727.github.io/post/016-at-abc127f/</link><pubDate>Mon, 01 Mar 2021 21:35:11 +0800</pubDate><guid>https://tom0727.github.io/post/016-at-abc127f/</guid><description>题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_f 题意 初始时有个函数 $f(x) = 0$，现在有 $Q$ 个询问，询问有两种： 1 a b：令 $f(x) = f(x) + |x-a| + b$ 2：求 $x$ 使得 $f(x)$ 最小，并求出这个 $f(x)$ 的最小值 题解 $f(x)$ 必然</description></item><item><title>Atcoder ABC 127E（数学，计数，概率）</title><link>https://tom0727.github.io/post/015-at-abc127e/</link><pubDate>Sun, 28 Feb 2021 23:20:51 +0800</pubDate><guid>https://tom0727.github.io/post/015-at-abc127e/</guid><description>题目链接 https://atcoder.jp/contests/abc127/tasks/abc127_e 题意 给定一个矩阵，包含 $N \times M$ 个格子，现在从中选出 $K \leq N \times M$ 个不同的格子，记为 $(x_1,y_1), (x_2, y_2), &amp;hellip; , (x_K, y_K)$ ，记 $cost = \sum\limits_{i=1}^{K-1}\sum\limits_{j=i+1}^{K}(|x_i-x_j| + |y_i-y_j|)$ 求：对于所有不同的 $K$ 个格子</description></item><item><title>Atcoder ABC 162E（数学，计数）</title><link>https://tom0727.github.io/post/014-at-abc162e/</link><pubDate>Sat, 27 Feb 2021 14:59:58 +0800</pubDate><guid>https://tom0727.github.io/post/014-at-abc162e/</guid><description>题目链接 https://atcoder.jp/contests/abc162/tasks/abc162_e 题意 给定 $2 \leq N \leq 10^5, 2 \leq K \leq 10^5$，现有长度为 $N$ 的序列 $\{ a_1, a_2, &amp;hellip;, a_N \}$，其中 $1 \leq a_i \leq K$ 这样的序列总共有 $K^N$ 个，求所有这些序列的 $\sum \</description></item><item><title>最小环</title><link>https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/</link><pubDate>Thu, 25 Feb 2021 23:41:02 +0800</pubDate><guid>https://tom0727.github.io/post/013-%E6%9C%80%E5%B0%8F%E7%8E%AF/</guid><description>定义 最小环：指图中的一个环，它不包含任何更小的环。 在无向图中，最小的最小环为3个节点。在有向图中，最小的最小环为2个节点。（不考虑self-</description></item><item><title>CF 1395E(集合哈希)</title><link>https://tom0727.github.io/post/012-cf-1395e/</link><pubDate>Thu, 25 Feb 2021 15:25:22 +0800</pubDate><guid>https://tom0727.github.io/post/012-cf-1395e/</guid><description>题目链接 https://codeforces.com/contest/1395/problem/E 题意 给定一个 directed and weighted graph，$2 \leq n \leq 2\cdot10^5, 2 \leq m \leq \min(2\cdot10^5, n(n-1))$，每个vertex的 out-degree 最多为 $1\leq k \leq 9$，每个edge的weig</description></item><item><title>CF 1492E(暴搜)</title><link>https://tom0727.github.io/post/011-cf-1492e/</link><pubDate>Wed, 24 Feb 2021 22:27:41 +0800</pubDate><guid>https://tom0727.github.io/post/011-cf-1492e/</guid><description>题目链接 https://codeforces.com/contest/1492/problem/E 题意 给定 $n$ 个长度为 $m$ 的正整数array，其中 $n \geq 2, m \geq 1, n \times m \leq 250000$ 问是否存在一个array，使得这个array 与 其他每个array</description></item><item><title>HTML/CSS/JS笔记</title><link>https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/</link><pubDate>Sun, 21 Feb 2021 23:39:36 +0800</pubDate><guid>https://tom0727.github.io/post/010-%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/</guid><description>这篇博客主要收录一些关于HTML,CSS,JS的知识点 CSS 当前页面的selector 假设我们有一个nav bar，有很多个link，我们希望检测</description></item><item><title>vim笔记</title><link>https://tom0727.github.io/post/009-vim/</link><pubDate>Sat, 20 Feb 2021 23:15:28 +0800</pubDate><guid>https://tom0727.github.io/post/009-vim/</guid><description>这篇博客主要收录一些关于vim的知识点 HTML Match Tags 我们想要显示opening/closing tag的matching情况，并且从一个opening</description></item><item><title>树形dp</title><link>https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/</link><pubDate>Thu, 18 Feb 2021 15:42:09 +0800</pubDate><guid>https://tom0727.github.io/post/008-%E6%A0%91%E5%BD%A2dp/</guid><description>介绍 树形dp就是在树上进行dp，常用于 &amp;ldquo;树上选一组点/边，满足某些条件，且使得某些权值和最大&amp;rdquo; 的问题。 树形dp实现过</description></item><item><title>01分数规划</title><link>https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</link><pubDate>Wed, 17 Feb 2021 17:20:49 +0800</pubDate><guid>https://tom0727.github.io/post/007-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</guid><description>介绍 01分数规划用于 求一个分式的极值 例如： 给定 $a_i, b_i$，选出一组$i$， 使得 $\frac{\sum a_i}{\sum b_i}$ 最大/最小？ 方法 (二分) 一般使用二分答案的方法进行求解，</description></item><item><title>CF1159B 题解(枚举优化)</title><link>https://tom0727.github.io/post/006-cf-1159b/</link><pubDate>Wed, 17 Feb 2021 15:19:54 +0800</pubDate><guid>https://tom0727.github.io/post/006-cf-1159b/</guid><description>题目链接 https://codeforces.com/contest/1159/problem/B 题意 给定 $n$ 个非负整数 $a_1,a_2,&amp;hellip;,a_n$，求 $\frac{\min(a_i, a_j)}{|i-j|}$ ？其中 $i, j \in [1,n], i \neq j$ 题解 对于这类的枚举问题，一般套路都是 &amp;</description></item><item><title>爬虫笔记</title><link>https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 10 Feb 2021 22:52:26 +0800</pubDate><guid>https://tom0727.github.io/post/005-%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</guid><description>这篇博客主要收录一些爬虫相关的知识点： 分段下载 如果我们需要设定下载的timeout怎么办？ 直接指定 requests.get() 中的 timeout 是不行的！因为这里的timeout</description></item><item><title>欧拉函数</title><link>https://tom0727.github.io/post/004-euler-function/</link><pubDate>Sat, 06 Feb 2021 17:23:34 +0800</pubDate><guid>https://tom0727.github.io/post/004-euler-function/</guid><description>定义 给定正整数$n$，求$\varphi(n)$， 即 小于等于$n$ 且 与$n$互质 的正整数个数。 性质 $\varphi(p) = p-1, ~\forall \text{prime } p$ $\varphi(mn) = \varphi(m)\varphi(n) \iff \gcd(m,n) = 1$ $\varphi(p^k) = p^k - p^{k-1} = p^k(1-\frac{1}{p})$</description></item><item><title>中国剩余定理介绍</title><link>https://tom0727.github.io/post/003-crt/</link><pubDate>Sat, 06 Feb 2021 10:46:42 +0800</pubDate><guid>https://tom0727.github.io/post/003-crt/</guid><description>中国剩余定理 (crt) 定义 给定方程组： $$\begin{cases} x\equiv a_1 (\text{mod }m_1) \\ x\equiv a_2 (\text{mod }m_2) \\ &amp;hellip; \\ x\equiv a_k (\text{mod }m_k) \\ \end{cases}$$ 其中 $a_i \geq 0, m_i &amp;gt; 0, a_i,m_i \in \mathbb{Z}$, 且 $m_i$ 之间两两互质。 求满足条件的最小非负整数解 $x$ ？ 结</description></item><item><title>初学爬虫小记</title><link>https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/</link><pubDate>Mon, 01 Feb 2021 22:45:03 +0800</pubDate><guid>https://tom0727.github.io/post/002-%E7%88%AC%E8%99%AB/</guid><description>写博客好累啊，是我太久没有写作了吗 这次来记录一下我第一次学习爬虫的经历 起因 补完とにかくかわいい的番，感觉真好看啊，漫画也不错，就打算补补とに</description></item><item><title>Hugo博客搭建小记</title><link>https://tom0727.github.io/post/001-hugo-tutorial/</link><pubDate>Mon, 01 Feb 2021 21:21:41 +0800</pubDate><guid>https://tom0727.github.io/post/001-hugo-tutorial/</guid><description>起因 在几天前折腾了爬虫，成功爬下来とにかくかわいい的漫画以后，我发现我折腾似乎上瘾了。聊天时无意提到”要是我有个人网站就好了“，于是就决定动</description></item><item><title>About</title><link>https://tom0727.github.io/about/</link><pubDate>Sun, 31 Jan 2021 22:57:58 +0800</pubDate><guid>https://tom0727.github.io/about/</guid><description>Hello, this is Tom from China! If you have trouble visiting this site (especially for mainland China users), please try visit
https://tom0727.gitee.io/
About me Year 3 Undergraduate student @ HKU (The University of Hong Kong), 2018-2022 Major in Computer Science Competitive programming as hobby Resume Resume (in English): https://github.com/tom0727/Resume/blob/master/Zhenwei%20Hu.pdf Resume (in Chinese): https://github.com/tom0727/Resume/blob/master/%E8%83%A1%E6%8C%AF%E4%B8%BA.pdf Contact Email: huzhenweitom@gmail.com QQ/Wechat: 980409152 Links Codeforces: Leetcode: tom0727</description></item><item><title>搜索</title><link>https://tom0727.github.io/search/</link><pubDate>Fri, 07 Feb 2020 17:43:21 +0800</pubDate><guid>https://tom0727.github.io/search/</guid><description/></item></channel></rss>