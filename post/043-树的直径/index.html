<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>树的直径 - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。 树的直径有以下性质：（以下，我们假设所有边上的权值均 $\geq 0$）。 直" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/043-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="树的直径" />
<meta property="og:description" content="定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。 树的直径有以下性质：（以下，我们假设所有边上的权值均 $\geq 0$）。 直" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/043-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/" />
<meta property="article:published_time" content="2021-04-18T15:34:17+08:00" />
<meta property="article:modified_time" content="2022-07-30T00:31:13+00:00" />
<meta itemprop="name" content="树的直径">
<meta itemprop="description" content="定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。 树的直径有以下性质：（以下，我们假设所有边上的权值均 $\geq 0$）。 直">
<meta itemprop="datePublished" content="2021-04-18T15:34:17&#43;08:00" />
<meta itemprop="dateModified" content="2022-07-30T00:31:13&#43;00:00" />
<meta itemprop="wordCount" content="6459">



<meta itemprop="keywords" content="树论,树的直径," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="树的直径"/>
<meta name="twitter:description" content="定义 树的直径是指：在一棵有权/无权树中，所有简单路径中，权值和最大的那一条。 树的直径有以下性质：（以下，我们假设所有边上的权值均 $\geq 0$）。 直"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">树的直径</h1>

      <div class="post-meta">
        <span class="post-time" title="2021-04-18 15:34:17 &#43;0800 &#43;0800"> 2021-04-18 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#定义">定义</a></li>
        <li><a href="#求树的直径">求树的直径</a>
          <ul>
            <li><a href="#法一两次dfs推荐">法一：两次DFS（推荐）</a></li>
            <li><a href="#法二树形dp">法二：树形DP</a></li>
          </ul>
        </li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-cf911f-tree-destructionhttpscodeforcescomcontest911problemf">例1 <a href="https://codeforces.com/contest/911/problem/F">CF911F Tree Destruction</a></a></li>
            <li><a href="#例2-cf1192b-dynamic-diameterhttpcodeforcescomproblemsetproblem1192b">例2 <a href="http://codeforces.com/problemset/problem/1192/B">CF1192B Dynamic Diameter</a></a></li>
            <li><a href="#例3-lightning-routing-ihttpsnantijisuankecomt41398">例3 <a href="https://nanti.jisuanke.com/t/41398">Lightning Routing I</a></a></li>
          </ul>
        </li>
        <li><a href="#参考链接">参考链接</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="定义">定义</h2>
<p>树的直径是指：在一棵有权/无权树中，所有简单路径中，<strong>权值和最大的那一条</strong>。</p>
<p>树的直径有以下性质：（以下，我们假设所有边上的权值均 $\geq 0$）。</p>
<ol>
<li>
<p>直径一定是由两个 leaf 组成</p>
</li>
<li>
<p>对于任意一个节点 $u$，距离它最远的一个节点，必然为直径的其中一端。</p>
</li>
<li>
<p>在一棵树上，任取两个点集 $S_1, S_2$，设 $S_1$ 这个点集的直径是 $(u_1,v_1)$，设 $S_2$ 这个点集的直径是 $(u_2, v_2)$，那么令 $S = S_1 \cup S_2$。则点集 $S$ 的直径只可能为以下 $6$ 种的之一：</p>
<p>$$(u_1, v_1), (u_2, v_2), (u_1, u_2), (u_1, v_2), (v_1, u_2), (v_2, u_2)$$</p>
<p>即，新的直径一定由原先 $4$ 个端点组成。</p>
</li>
</ol>
<details class="admonition note"><summary class="admonition-title">证明：第二个性质</summary>
<p>我们设直径是 $(s,t)$，并且设节点 $a$ 距离最远的节点是 $b$，其中 $b \neq s, b \neq t$。</p>
<p>Case1：$a$ 位于直径 $(s,t)$ 上：</p>
<p><img src="/images/043/1.png" alt="img"></p>
<p>如上，有 $L_1 &gt; L_2$，$L_1 &gt; L_3$。且 $L_2 + L_3$ 为直径。</p>
<p>那么 $L_1 + L_3 &gt; L_2 + L_3$，$L_1 + L_2 &gt; L_2 + L_3$。</p>
<p>所以 $L_1 + L_3$ 或者 $L_1 + L_2$ 才是直径。contradiction。</p>
<hr>
<p>Case2：$(a,b)$ 之间的路径横穿了 $(s,t)$，交点为 $x$。</p>
<p><img src="/images/043/2.png" alt="img"></p>
<p>如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 &gt; L_1 + L_3$，$L_1 + L_2 &gt; L_1 + L_3$。</p>
<p>那么 $L_2 &gt; L_3$，$L_2 &gt; L_4$。</p>
<p>所以 $L_2 + L_3 &gt; L_3 + L_4$，$L_2 + L_4 &gt; L_3 + L_4$。</p>
<p>所以 $L_2 + L_3$ 或者 $L_2 + L_4$ 才是直径。contradiction。</p>
<hr>
<p>Case3：$(a,b)$ 之间的路径没有穿过 $(s,t)$，但是 $(a,b)$ 路径上，有一个距离 $(s,t)$ 最短的点 $x$，并且这个 $x$ 通过 $y$ 与 $(s,t)$ 相交。</p>
<p><img src="/images/043/3.png" alt="img"></p>
<p>如上，因为距离 $a$ 最远的是 $b$，所以有 $L_1 + L_2 &gt; L_1 + L_5 + L_4$，$L_1 + L_2 &gt; L_1 + L_5 + L_3$。</p>
<p>所以有 $L_2 &gt; L_5 + L_4$，$L_2 &gt; L_5 + L_3$。</p>
<p>所以 $L_3 + L_5 + L_2 &gt; L_3 + L_4$，$L_4 + L_5 + L_2 &gt; L_3 + L_4$。</p>
<p>所以 $L_3 + L_5 + L_2$ 或者 $L_4 + L_5 + L_2$ 才是直径。contradiction。</p>
</details>
<p>• 第三个性质的证明不会，先咕着</p>
<h2 id="求树的直径">求树的直径</h2>
<p>求树的直径有两种方法：两次DFS 和 DP。</p>
<h3 id="法一两次dfs推荐">法一：两次DFS（推荐）</h3>
<p>由性质 $2$，我们可以以任意节点为根，进行DFS。得到一个距离最远的点 $u$ （这个节点的深度最深）。</p>
<p>然后再以 $u$ 为根，进行第二次DFS。得到距离最远的点 $v$。那么 $(u,v)$ 就是直径了。</p>
<details class="admonition note"><summary class="admonition-title">两次DFS：代码</summary>
<pre><code class="language-cpp">int n, dep[maxn], d1, d2;  // d1: 直径一端，d2: 直径另外一端
void dfs1(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dep[to] = dep[u] + 1;
        dfs1(to, u);
    }
}
int main() {
    dep[1] = 0; dfs1(1, 0);  // 第一次 DFS (以 1 为根)
 
    d1 = 1;
    for (int u = 1; u &lt;= n; u++) {
        if (dep[u] &gt; dep[d1]) {
            d1 = u;
        }
    }
    dep[d1] = 0; dfs1(d1, 0);  // 第二次 DFS (以直径端点 d1 为根)
 
    d2 = d1;
    for (int u = 1; u &lt;= n; u++) {
        if (dep[u] &gt; dep[d2]) {
            d2 = u;
        }
    }
}
</code></pre>
</details>
<h3 id="法二树形dp">法二：树形DP</h3>
<p>固定 $1$ 为根。记录每个节点向下，最远能延伸的两个节点的距离 $d_1,d_2$，那么直径就是所有 $d_1+d_2$ 的最大值。</p>
<details class="admonition note"><summary class="admonition-title">树形DP：代码</summary>
<pre><code class="language-cpp">int d1[maxn], d2[maxn], d;  // d 是直径的值
void dfs(int u, int p) {
    d1[u] = d2[u] = 0;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs(to, u);
        int t = d1[v] + 1;
        if (t &gt; d1[u])
        d2[u] = d1[u], d1[u] = t;
        else if (t &gt; d2[u])
        d2[u] = t;
    }
    d = max(d, d1[u] + d2[u]);
}

int main() {
    dfs(1, 0);
}
</code></pre>
</details>
<h2 id="例题">例题</h2>
<h3 id="例1-cf911f-tree-destructionhttpscodeforcescomcontest911problemf">例1 <a href="https://codeforces.com/contest/911/problem/F" target="_blank">CF911F Tree Destruction</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一棵 $n$ 个节点的无权树，然后进行 $(n-1)$ 次以下操作，每次操作分以下三步：</p>
<ol>
<li>选择两个leaf</li>
<li>将这两个leaf之间的距离，加到 <code>ans</code> 中。</li>
<li>将这两个leaf其中之一，删掉。</li>
</ol>
<p>初始状态下，<code>ans = 0</code>。求 <code>ans</code> 的最大值，并且输出方案。</p>
<p>其中，$2 \leq n \leq 2 \times 10^5$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>利用树的直径的第二个性质：任意一个节点 $u$，<strong>距离最远的一定是直径的一端</strong>。</p>
<p>所以我们要最大化最终答案，我们可以最大化每个节点的贡献。所以我们只要保留直径，先将剩下的叶子删掉就行了。</p>
<p>思路如下：</p>
<ol>
<li>找到直径 $(u,v)$</li>
<li>使用类似于拓扑排序的方法，维护所有 <code>deg = 1</code> 的节点（除了直径两端的两个节点 $u,v$），将它们删去。这个过程，本质上是将直径看作树干，然后逐一拔掉所有的树枝。</li>
<li>最后只剩下一条直径了，从任意一端开始删除即可。</li>
</ol>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5+5; 
 
struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1, n, dep[maxn], d1, d2;  // d1: 直径一端，d2: 直径另外一端
 
void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    edges[ecnt] = e;
    head[u] = ecnt++;
}
 
void dfs1(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dep[to] = dep[u] + 1;
        dfs1(to, u);
    }
}
 
ll ans = 0;
struct node {
    int u,v,r;
} path[maxn];
int tail = 0;
 
int deg[maxn];
vector&lt;int&gt; leaf;
 
int dis1[maxn], dis2[maxn];
// 初始化：找出每个节点到 d1, d2的距离
void init() {
    dep[d1] = 0; dfs1(d1, 0);
    memcpy(dis1, dep, sizeof(dep));
    dep[d2] = 0; dfs1(d2, 0);
    memcpy(dis2, dep, sizeof(dep));
}
 
// 第一步：拔掉所有除了 d1, d2 以外的叶子
void solve1() {
    for (int i = 1; i &lt;= n; i++) {
        if (deg[i] == 1 &amp;&amp; i != d1 &amp;&amp; i != d2) leaf.push_back(i);
    }
    while (leaf.size()) {
        int u = leaf.back(); leaf.pop_back();
        for (int e = head[u]; e; e = edges[e].nxt) {
            int to = edges[e].to;
            deg[to]--;
            if (deg[to] == 1) {
                leaf.push_back(to);
            }
        }
        int t;
        if (dis1[u] &gt; dis2[u]) t = d1, ans += (ll)dis1[u];
        else t = d2, ans += (ll)dis2[u];
        path[++tail] = {u,t,u};
    }
}
 
// 第二步：拔掉直径
void solve2() {
    leaf.push_back(d2);
    while (leaf.size()) {
        int u = leaf.back(); leaf.pop_back();
        for (int e = head[u]; e; e = edges[e].nxt) {
            int to = edges[e].to;
            deg[to]--;
            if (deg[to] == 1) {
                leaf.push_back(to);
            }
        }
        ans += (ll)(dis1[u]);
        path[++tail] = {u, d1, u};
    }
}
  
int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v; cin &gt;&gt; u &gt;&gt; v;
        addEdge(u,v); addEdge(v,u);
        deg[u]++, deg[v]++;
    }
    dep[1] = 0; dfs1(1, 0);
 
    d1 = 1;
    for (int u = 1; u &lt;= n; u++) {
        if (dep[u] &gt; dep[d1]) {
            d1 = u;
        }
    }
 
    dep[d1] = 0; dfs1(d1, 0);
 
    d2 = d1;
    for (int u = 1; u &lt;= n; u++) {
        if (dep[u] &gt; dep[d2]) {
            d2 = u;
        }
    }
 
    init();
    solve1();
    solve2();
 
    cout &lt;&lt; ans &lt;&lt; endl;
    for (int i = 1; i &lt;= n-1; i++) {
        cout &lt;&lt; path[i].u &lt;&lt; &quot; &quot; &lt;&lt; path[i].v &lt;&lt; &quot; &quot; &lt;&lt; path[i].r &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
</details>
<h3 id="例2-cf1192b-dynamic-diameterhttpcodeforcescomproblemsetproblem1192b">例2 <a href="http://codeforces.com/problemset/problem/1192/B" target="_blank">CF1192B Dynamic Diameter</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的有权树，和 $q$ 次询问。</p>
<p>每次询问格式为 $d ~ e$：将第 $d$ 条边的权值改为 $e$。</p>
<p>在每次询问之后，回答：此时树中直径的长度。</p>
<p>其中，$2 \leq n \leq 10^5, 1 \leq q \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">欧拉序介绍</summary>
<p>欧拉序和DFS序不同的地方在于：</p>
<p>在一个节点 $u$ 访问完它的一个child $v$ 之后，<strong>回溯到 $u$ 时，也会将 $u$ 记录进序列中</strong>。</p>
<p><img src="/images/043/4.png" alt="img"></p>
<p>如上图，访问的顺序如果是 $1 \rightarrow 2 \rightarrow 4 \rightarrow 5 \rightarrow 6 \rightarrow 3$ 的话，得到的欧拉序就是：</p>
<p>$[1,2,4,5,4,2,6,2,1,3,1]$。</p>
<p>欧拉序有以下性质：</p>
<ol>
<li>对于 $n$ 个节点的树，欧拉序的长度一定为 $2n-1$。</li>
<li>在欧拉序中任取两个index $i,j$，它分别对应的节点是 $u,v$ 的话。在 $[i,j]$ 这段欧拉序中，<code>depth</code> 最小的index 所对应的节点 $x$ 就是 $LCA(u,v)$。</li>
</ol>
<p>• 例如，我们把上述欧拉序按照 <code>depth</code> 重新写一下，就会得到：<code>[0,1,2,3,2,1,2,1,0,1,0]</code>。</p>
<p>我们任取其中一段，比如：<code>[0,1,2,</code><strong><code>3,2,1,2</code></strong><code>,1,0,1,0]</code>，那么对应的就是 $5,4,2,6$ 这几个节点。可以发现这一段中，<code>depth</code> <strong>最小值</strong>为 $1$，对应的节点是 $2$。而这一段的<strong>两端</strong>，对应的就是节点 $5,6$。这说明 节点 $5,6$ 的 LCA 就是 节点 $2$。</p>
<hr>
<p>证明性质 $1$：易知，每条 edge 会在欧拉序中贡献 $2$ 个位置。而根节点 $1$ 又会额外贡献一个。所以总共是 $2 \times (n-1) + 1 = 2n-1$。</p>
<p>证明性质 $2$：设一段欧拉序的两端，对应的节点分别为 $u,v$。令 $x = LCA(u,v)$。那么这一段欧拉序，一定会经过 $x$，且一定是完全在 $x$ 所在的子树内的，不可能出现在子树外的节点。所以 $x$ 一定是这一段 depth 最小的那个节点。</p>
</details>
<details class="admonition note"><summary class="admonition-title">法一 欧拉序 题解</summary>
<p>有两种方法，一种是 <strong>欧拉序</strong>，复杂度 $O(n\log n)$。还有一种是 <strong>DFS序</strong>，时间复杂度 $O(n\log^2 n)$。</p>
<p>这里介绍一下 法一欧拉序。</p>
<hr>
<p>我们固定 $1$ 为根。求出每个节点的 <code>depth</code>。然后求出欧拉序。</p>
<p>有了欧拉序以后，我们可以用线段树维护这个欧拉序序列。我们设这个序列为 $a[]$。</p>
<p>然后询问两个节点 $u,v$ 之间的距离，就可以先找到 $u$ 对应在欧拉序中的位置 $l$（可能对应多个位置，任选一个即可），$v$ 对应在欧拉序中的位置 $r$。由树上差分，可知 $u,v$ 的距离等于 $d_u + d_v - 2 \times d_x$，则有：</p>
<p>$$dist(u,v) = a[l] + a[r] - 2 \times \min\limits_{l \leq k \leq r}a[k]$$</p>
<hr>
<p>所以整个问题可以转化为一个序列上的问题：给定一个数组 $a[]$，求：</p>
<p>$$a[l] + a[r] - 2 \times \min\limits_{l \leq k \leq r}a[k]$$</p>
<p>的<strong>最大值</strong>？（其中 $l,r$ 任选）</p>
<p>这个式子有 $2$ 个变量，$l,r$，我们需要用线段树来维护一些额外信息，来将其转化为一个变量的问题。</p>
<p>设</p>
<p>$$D[L,R] = \max\limits_{l \leq r, l,r \in [L,R]} \{a[l] + a[r] - 2 \times \min\limits_{l \leq k \leq r}a[k]\}$$</p>
<p>我们考虑固定其中一个变量（比如 $l$），那么剩下的变量就只有 $r$ 了，我们就可以考虑 $a[r] - 2 \times \min\limits_{l \leq k \leq r}a[k]$。</p>
<p>设</p>
<p>$$rmax[L,R] = \max\limits_{l \leq r, l,r \in [L,R]} \{a[r] - 2 \times \min\limits_{l \leq k \leq r}a[k] \}$$</p>
<p>$$lmax[L,R] = \max\limits_{l \leq r, l,r \in [L,R]} \{a[l] - 2 \times \min\limits_{l \leq k \leq r}a[k] \}$$</p>
<p>则，我们有以下转移方程：</p>
<p>$$rmax[L,R] = \max \begin{cases}
rmax[L, mid] \\<br>
rmax[mid+1, R] \\<br>
max[mid+1,R] - 2\times min[L, mid]
\end{cases}
$$</p>
<p>$$lmax[L,R] = \max \begin{cases}
lmax[L, mid] \\<br>
lmax[mid+1, R] \\<br>
max[L, mid] - 2\times min[mid+1, R]
\end{cases}
$$</p>
<p>$$D[L,R] = \max \begin{cases}
D[L, mid] \\<br>
D[mid+1, R] \\<br>
max[L, mid] + rmax[mid+1, R]  \\<br>
lmax[L, mid] + max[mid+1, R]
\end{cases}
$$</p>
<p>最后，答案就是 $D[1,2n-1]$。</p>
<hr>
<p>上述转移方程有几个点需要注意：</p>
<p>Q1. 为什么 $D[L,R]$ 可以由 $max[L, mid] + rmax[mid+1, R]$ 转移而来？$rmax[mid+1, R]$ 并没有考虑到 $[L,mid]$ 这一段中的最小值啊？</p>
<p>A1. 如果最终答案需要考虑到 $[L,mid]$ 这一段的最小值，那么说明 $D[L,R]$ 应该由 $lmax[L, mid] + max[mid+1, R]$ 或者 $D[L, mid]$ 转移而来。这也说明了为什么我们需要使用 $lmax, rmax$ 进行两次转移。</p>
<p>• 另外，$rmax[L,R]$ 和 $lmax[L,R]$ 的转移过程同理。</p>
<hr>
<p>最后一个问题：修改边的权值，怎么处理？</p>
<p>因为我们所有的距离都是基于 <code>depth</code> 的，所以，把修改边的权值改为修改 <code>depth</code> 即可。</p>
<p>假设有一个边 $(u,v)$，令 $v$ 为 child。设原来的权值为 $e_1$，现在改为 $e_2$，那么就相当于给 $v$ 的 subtree 中的所有节点的 <code>depth</code> 加上 $(e_2 - e_1)$。</p>
</details>
<details class="admonition note"><summary class="admonition-title">法二 DFS序 题解</summary>
<p>根据树的直径的性质 $3$，我们可以求出整棵树的欧拉序，然后用线段树维护点集的直径。比如 $[5,8]$ 这个区间，维护的就是欧拉序为 $[5,6,7,8]$ 的点集的直径。</p>
<p>可得，$[1,n]$ 这个点集的直径就是整棵树的直径。</p>
<p>然后在合并区间 $[L, mid]$ 和 $[mid+1, R]$ 时，就可以枚举 $6$ 种情况的直径长度，得到 $[L,R]$ 对应点集的直径。</p>
<hr>
<p>有几个问题：</p>
<p>Q1. 怎么得到每种情况的直径长度？</p>
<p>A1. 和上一个方法一样，固定 $1$ 为根，然后两个节点 $(u,v)$ 之间的距离就可以利用 $d_u + d_v - 2 \times d_{LCA(u,v)}$ 来求出。</p>
<p>Q2. 修改权值时，直径会受到影响吗？</p>
<p>A2. 会的。但是如果我们修改了权值，影响了一个 subtree（在DFS序上就是一段连续区间），则如果一个点集完全存在于这个 subtree 之内，就不会受到影响。我们只需要考虑 点集 与 subtree 拥有相交区间，且点集没有被完全覆盖的情况。这实际上就是线段树 update 过程中正常的 lazy tag 和 <code>push_up()</code> 操作。所以不需要特殊处理，该怎么写怎么写就行。</p>
<hr>
<p>注：本题没有用法二来写，因为本题不需要求出直径具体的节点，只要长度。下一题会使用到法二，代码可以参见下一个例题。</p>
</details>
<details class="admonition note"><summary class="admonition-title">法一 欧拉序 代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
const int maxm = 1e6;

struct Edge {
    int from, to, nxt;
    ll w;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 2, n, q;
ll W;
void addEdge(int u, int v, ll w) {
    Edge e = {u, v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll dep[maxn&lt;&lt;1];  // 欧拉序的 dep
int in[maxn], out[maxn];  // in[u]: 节点 u 在欧拉序中的起点
int ori_dep[maxn];  // 原本在树中的depth(不算weight)
int id = 0;

void dfs(int u, int p, ll d) {
    dep[++id] = d;
    in[u] = out[u] = id;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ll w = edges[e].w;
        ori_dep[to] = ori_dep[u] + 1;
        dfs(to, u, d + w);
        dep[++id] = d;
        out[u] = id;
    }
}

int m;
struct tree_node {
    ll mini, maxi, lmax, rmax, ans;
    ll lazy = 0;
} tr[maxn&lt;&lt;3];

void push_up(int cur) {
    int l = cur&lt;&lt;1, r = l+1;
    tr[cur].mini = min(tr[l].mini, tr[r].mini);
    tr[cur].maxi = max(tr[l].maxi, tr[r].maxi);
    tr[cur].lmax = max(max(tr[l].lmax, tr[r].lmax), tr[l].maxi - 2LL * tr[r].mini);
    tr[cur].rmax = max(max(tr[l].rmax, tr[r].rmax), tr[r].maxi - 2LL * tr[l].mini);
    tr[cur].ans = max(max(tr[l].ans, tr[r].ans), max(tr[l].maxi + tr[r].rmax, tr[r].maxi + tr[l].lmax));
}

void push_down(int cur) {
    if (!tr[cur].lazy) return;
    ll lazy = tr[cur].lazy;
    int l = cur&lt;&lt;1, r = l|1;
    tr[cur].lazy = 0; 
    tr[l].lazy += lazy; tr[r].lazy += lazy;
    tr[l].maxi += lazy; tr[r].maxi += lazy;
    tr[l].mini += lazy; tr[r].mini += lazy;
    tr[l].lmax -= lazy; tr[r].lmax -= lazy;
    tr[l].rmax -= lazy; tr[r].rmax -= lazy;
}

void build(int cur, int l, int r) {
    if (l == r) {
        tr[cur].mini = tr[cur].maxi = dep[l];
        tr[cur].lmax = tr[cur].rmax = -dep[l];
        tr[cur].ans = 0;
        return;
    }
    int mid = (l+r) &gt;&gt; 1;
    build(cur&lt;&lt;1, l, mid);
    build(cur&lt;&lt;1|1, mid+1, r);
    push_up(cur);
}

void update(int cur, int l, int r, int L, int R, ll x) {
    if (l &gt;= L &amp;&amp; r &lt;= R) {
        tr[cur].lazy += x;
        tr[cur].maxi += x;
        tr[cur].mini += x;
        tr[cur].lmax -= x;
        tr[cur].rmax -= x;
        return;
    }
    push_down(cur);
    int mid = (l+r) &gt;&gt; 1;
    if (L &lt;= mid) update(cur&lt;&lt;1, l, mid, L, R, x);
    if (R &gt; mid) update(cur&lt;&lt;1|1, mid+1, r, L, R, x);
    push_up(cur);
}

ll query(int cur, int l, int r, int L, int R) {
    if (l &gt;= L &amp;&amp; r &lt;= R) {
        return tr[cur].ans;
    }
    push_down(cur);
    int mid = (l+r) &gt;&gt; 1;
    ll res = 0;
    if (L &lt;= mid) res += query(cur&lt;&lt;1, l, mid, L, R);
    if (R &gt; mid) res += query(cur&lt;&lt;1|1, mid+1, r, L, R);
    push_up(cur);
    return res;
}

ll last = 0;
int main() {
    cin &gt;&gt; n &gt;&gt; q &gt;&gt; W;
    for (int i = 1; i &lt; n; i++) {
        int u,v; ll w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    dfs(1, 0, 0);
    m = 2*n - 1;
    build(1, 1, m);

    while (q--) {
        ll d,e; cin &gt;&gt; d &gt;&gt; e;
        d = (d + last) % (n-1) + 1;
        d &lt;&lt;= 1;  // 编号从 2 开始
        e = (e + last) % W;
        ll x = e - edges[d].w;
        edges[d].w = edges[d^1].w = e;
        int u = edges[d].from, v = edges[d].to;
        if (ori_dep[u] &gt; ori_dep[v]) swap(u,v);
        update(1, 1, m, in[v], out[v], x);
        last = query(1, 1, m, 1, m);
        cout &lt;&lt; last &lt;&lt; &quot;\n&quot;;
        // 将第 d 条边的 weight 改为 e
    }
}
</code></pre>
</details>
<h3 id="例3-lightning-routing-ihttpsnantijisuankecomt41398">例3 <a href="https://nanti.jisuanke.com/t/41398" target="_blank">Lightning Routing I</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的有权树，和 $q$ 次询问。</p>
<p>每次询问有 $2$ 种：</p>
<p>$C ~ e_i ~ w_i$：将第 $e_i$ 条边的权值改为 $w_i$</p>
<p>$Q ~ v_i$：询问距离 $v_i$ 最远的节点的距离。</p>
<p>其中，$1 \leq n \leq 10^5, 1 \leq q \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>和上一题完全一样。</p>
<p>需要注意的是 $Q ~ v_i$ 这个询问。由树直径的基本性质，对于任意一个节点 $v$，距离最远的节点一定是直径的其中一端。那么问题可以转化为：</p>
<p>先求出直径的两端，然后判断一下哪一端距离 $v$ 最远。</p>
<p>• 这样的话，法一欧拉序就需要在线段树区间合并的时候，加一些额外的信息来 track 具体是哪些index被用到了转移中。</p>
</details>
<details class="admonition note"><summary class="admonition-title">法一（欧拉序）代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
const int maxm = 1e6;

struct Edge {
    int from, to, nxt;
    ll w;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 2, n, q;
ll W;
void addEdge(int u, int v, ll w) {
    Edge e = {u, v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll dep[maxn&lt;&lt;1];  // 欧拉序的 dep
int in[maxn], out[maxn];  // in[u]: 节点 u 在欧拉序中的起点
int ori_dep[maxn];  // 原本在树中的depth(不算weight)
int id = 0;

void dfs(int u, int p, ll d) {
    dep[++id] = d;
    in[u] = out[u] = id;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ll w = edges[e].w;
        ori_dep[to] = ori_dep[u] + 1;
        dfs(to, u, d + w);
        dep[++id] = d;
        out[u] = id;
    }
}

int m;
struct tree_node {
    ll mini, maxi, lmax, rmax, ans;
    ll lazy = 0;
    int mini_idx, maxi_idx, lmax_idx, rmax_idx, L, R;
} tr[maxn&lt;&lt;3];

void push_up(int cur) {
    int l = cur&lt;&lt;1, r = l+1;
    if (tr[l].mini &lt; tr[r].mini) {
        tr[cur].mini = tr[l].mini;
        tr[cur].mini_idx = tr[l].mini_idx;
    } else {
        tr[cur].mini = tr[r].mini;
        tr[cur].mini_idx = tr[r].mini_idx;
    }

    if (tr[l].maxi &gt; tr[r].maxi) {
        tr[cur].maxi = tr[l].maxi;
        tr[cur].maxi_idx = tr[l].maxi_idx;
    } else {
        tr[cur].maxi = tr[r].maxi;
        tr[cur].maxi_idx = tr[r].maxi_idx;
    }

    if (tr[l].lmax &gt; tr[r].lmax) {
        tr[cur].lmax = tr[l].lmax;
        tr[cur].lmax_idx = tr[l].lmax_idx;
    } else {
        tr[cur].lmax = tr[r].lmax;
        tr[cur].lmax_idx = tr[r].lmax_idx;
    }
    if (tr[l].maxi - 2LL * tr[r].mini &gt; tr[cur].lmax) {
        tr[cur].lmax = tr[l].maxi - 2LL * tr[r].mini;
        tr[cur].lmax_idx = tr[l].maxi_idx;
    }

    if (tr[l].rmax &gt; tr[r].rmax) {
        tr[cur].rmax = tr[l].rmax;
        tr[cur].rmax_idx = tr[l].rmax_idx;
    } else {
        tr[cur].rmax = tr[r].rmax;
        tr[cur].rmax_idx = tr[r].rmax_idx;
    }
    if (tr[r].maxi - 2LL * tr[l].mini &gt; tr[cur].rmax) {
        tr[cur].rmax = tr[r].maxi - 2LL * tr[l].mini;
        tr[cur].rmax_idx = tr[r].maxi_idx;
    }

    if (tr[l].ans &gt; tr[r].ans) {
        tr[cur].L = tr[l].L;
        tr[cur].R = tr[l].R;
        tr[cur].ans = tr[l].ans;
    } else {
        tr[cur].L = tr[r].L;
        tr[cur].R = tr[r].R;
        tr[cur].ans = tr[r].ans;
    }
    if (tr[l].maxi + tr[r].rmax &gt; tr[cur].ans) {
        tr[cur].ans = tr[l].maxi + tr[r].rmax;
        tr[cur].L = tr[l].maxi_idx;
        tr[cur].R = tr[r].rmax_idx;
    } 
    if (tr[r].maxi + tr[l].lmax &gt; tr[cur].ans) {
        tr[cur].ans = tr[r].maxi + tr[l].lmax;
        tr[cur].L = tr[l].lmax_idx;
        tr[cur].R = tr[r].maxi_idx;
    }
}

void push_down(int cur) {
    if (!tr[cur].lazy) return;
    ll lazy = tr[cur].lazy;
    int l = cur&lt;&lt;1, r = l|1;
    tr[cur].lazy = 0; 
    tr[l].lazy += lazy; tr[r].lazy += lazy;
    tr[l].maxi += lazy; tr[r].maxi += lazy;
    tr[l].mini += lazy; tr[r].mini += lazy;
    tr[l].lmax -= lazy; tr[r].lmax -= lazy;
    tr[l].rmax -= lazy; tr[r].rmax -= lazy;
}

void build(int cur, int l, int r) {
    if (l == r) {
        tr[cur].mini = tr[cur].maxi = dep[l];
        tr[cur].lmax = tr[cur].rmax = -dep[l];
        tr[cur].ans = 0;
        tr[cur].mini_idx = tr[cur].maxi_idx = tr[cur].lmax_idx = tr[cur].rmax_idx = tr[cur].L = tr[cur].R = l;
        return;
    }
    int mid = (l+r) &gt;&gt; 1;
    build(cur&lt;&lt;1, l, mid);
    build(cur&lt;&lt;1|1, mid+1, r);
    push_up(cur);
}

void update(int cur, int l, int r, int L, int R, ll x) {
    if (l &gt;= L &amp;&amp; r &lt;= R) {
        tr[cur].lazy += x;
        tr[cur].maxi += x;
        tr[cur].mini += x;
        tr[cur].lmax -= x;
        tr[cur].rmax -= x;
        return;
    }
    push_down(cur);
    int mid = (l+r) &gt;&gt; 1;
    if (L &lt;= mid) update(cur&lt;&lt;1, l, mid, L, R, x);
    if (R &gt; mid) update(cur&lt;&lt;1|1, mid+1, r, L, R, x);
    push_up(cur);
}

ll query(int cur, int l, int r, int L, int R) {
    if (l &gt;= L &amp;&amp; r &lt;= R) {
        return tr[cur].ans;
    }
    push_down(cur);
    int mid = (l+r) &gt;&gt; 1;
    ll res = 0;
    if (L &lt;= mid) res += query(cur&lt;&lt;1, l, mid, L, R);
    if (R &gt; mid) res += query(cur&lt;&lt;1|1, mid+1, r, L, R);
    push_up(cur);
    return res;
}

ll query_min(int cur, int l, int r, int L, int R) {
    if (l &gt;= L &amp;&amp; r &lt;= R) {
        return tr[cur].mini;
    }
    push_down(cur);
    int mid = (l+r) &gt;&gt; 1;
    ll r1 = 1e18, r2 = 1e18;
    if (L &lt;= mid) r1 = query_min(cur&lt;&lt;1, l, mid, L, R);
    if (R &gt; mid) r2 = query_min(cur&lt;&lt;1|1, mid+1, r, L, R);
    push_up(cur);
    return min(r1, r2);
}

ll dis(int l, int r) {
    if (l &gt; r) swap(l,r);
    ll al = query_min(1, 1, m, l, l), ar = query_min(1, 1, m, r, r);
    ll mi = query_min(1, 1, m, l, r);
    return al + ar - 2LL * mi;
}

int main() {
    fastio;
    cin &gt;&gt; n;
    for (int i = 1; i &lt; n; i++) {
        int u,v; ll w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    dfs(1, 0, 0);
    m = 2*n - 1;
    assert(id == m);
    build(1, 1, m);

    cin &gt;&gt; q;
    while (q--) {
        char op;
        cin &gt;&gt; op;
        if (op == 'C') {
            // 将第 d 条边的 weight 改为 e
            ll d,e; cin &gt;&gt; d &gt;&gt; e;
            d &lt;&lt;= 1;  // 编号从 2 开始
            ll x = e - edges[d].w;
            edges[d].w = edges[d^1].w = e;
            int u = edges[d].from, v = edges[d].to;
            if (ori_dep[u] &gt; ori_dep[v]) swap(u,v);
            update(1, 1, m, in[v], out[v], x);
        } else {
            int v; cin &gt;&gt; v;
            v = in[v];
            int L = tr[1].L, R = tr[1].R;
            ll dis1 = dis(L, v);
            ll dis2 = dis(v, R);
            cout &lt;&lt; max(dis1, dis2) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
</details>
<details class="admonition note"><summary class="admonition-title">法二（DFS序）代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e5+5;
const int maxm = 1e6;

struct Edge {
    int from, to, nxt;
    ll w;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 2, n, q;
void addEdge(int u, int v, ll w) {
    Edge e = {u, v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll dep[maxn];
int par[maxn][19], idcnt = 0, in[maxn], out[maxn], ver[maxn];  // in[u] ..., ver[id]: the id which corresponds to u
int ori_dep[maxn];  // 原本在树中的depth(不算weight)

void dfs(int u, int p) {
    in[u] = ++idcnt;
    ver[idcnt] = u;
    par[u][0] = p;
    for (int j = 1; j &lt;= 18; j++) par[u][j] = par[par[u][j-1]][j-1];
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        ll w = edges[e].w;
        if (to == p) continue;
        ori_dep[to] = ori_dep[u] + 1;
        dep[to] = dep[u] + w;
        dfs(to, u);
    }
    out[u] = idcnt;
}

int jump(int u, int d) {
    for (int j = 0; j &lt;= 18; j++) {
        if (d &amp; (1&lt;&lt;j)) u = par[u][j];
    }
    return u;
}

int lca(int u, int v) {
    if (ori_dep[u] &lt; ori_dep[v]) swap(u,v);
    u = jump(u, ori_dep[u] - ori_dep[v]);
    for (int j = 18; j &gt;= 0; j--) {
        if (par[u][j] != par[v][j]) u = par[u][j], v = par[v][j];
    }
    if (u == v) return u;
    return par[u][0];
}

struct tree_1 {
    struct tree_node_1 {
        ll d = 0, lazy = 0;
    };
    tree_node_1 tr[maxn&lt;&lt;2];
    void build(int cur, int l, int r) {
        if (l == r) {
            tr[cur].d = dep[ver[l]];
            return;
        }
        int mid = (l+r) &gt;&gt; 1;
        build(cur&lt;&lt;1, l, mid);
        build(cur&lt;&lt;1|1, mid+1, r);
    }
    void push_down(int cur) {
        if (!tr[cur].lazy) return;
        int l = cur&lt;&lt;1, r = l|1;
        ll lazy = tr[cur].lazy;
        tr[l].lazy += lazy, tr[r].lazy += lazy;
        tr[l].d += lazy, tr[r].d += lazy;
        tr[cur].lazy = 0;
    }
    void update(int cur, int l, int r, int L, int R, ll delta) {
        if (l &gt;= L &amp;&amp; r &lt;= R) {
            tr[cur].lazy += delta;
            tr[cur].d += delta;
            return;
        }
        push_down(cur);
        int mid = (l+r) &gt;&gt; 1;
        if (L &lt;= mid) update(cur&lt;&lt;1, l, mid, L, R, delta);
        if (R &gt; mid) update(cur&lt;&lt;1|1, mid+1, r, L, R, delta);
    }
    ll query(int cur, int l, int r, int p) {
        if (l == r) return tr[cur].d;
        push_down(cur);
        int mid = (l+r) &gt;&gt; 1;
        if (p &lt;= mid) return query(cur&lt;&lt;1, l, mid, p);
        return query(cur&lt;&lt;1|1, mid+1, r, p);
    }
    ll query_dis(int id1, int id2) {
        ll d1 = query(1, 1, n, id1), d2 = query(1, 1, n, id2);
        ll u1 = ver[id1], u2 = ver[id2];
        ll x = lca(u1, u2);
        int idx = in[x];
        ll dx = query(1, 1, n, idx);
        return d1 + d2 - 2LL * dx;
    }
} tr1;

struct tree_2 {
    struct tree_node_2 {
        int id1, id2;  // 直径的 id
    };
    tree_node_2 tr[maxn&lt;&lt;2];
    void push_up(int cur) {
        int l = cur&lt;&lt;1, r = cur&lt;&lt;1|1;
        int l_id1 = tr[l].id1, l_id2 = tr[l].id2, r_id1 = tr[r].id1, r_id2 = tr[r].id2;
        ll len = -1;
        ll dis1 = tr1.query_dis(l_id1, r_id1);
        ll dis2 = tr1.query_dis(l_id1, r_id2);
        ll dis3 = tr1.query_dis(l_id2, r_id1);
        ll dis4 = tr1.query_dis(l_id2, r_id2);
        ll dis5 = tr1.query_dis(l_id1, l_id2);
        ll dis6 = tr1.query_dis(r_id1, r_id2);
        if (dis1 &gt; len) tr[cur] = {l_id1, r_id1}, len = dis1;
        if (dis2 &gt; len) tr[cur] = {l_id1, r_id2}, len = dis2;
        if (dis3 &gt; len) tr[cur] = {l_id2, r_id1}, len = dis3;
        if (dis4 &gt; len) tr[cur] = {l_id2, r_id2}, len = dis4;
        if (dis5 &gt; len) tr[cur] = {l_id1, l_id2}, len = dis5;
        if (dis6 &gt; len) tr[cur] = {r_id1, r_id2}, len = dis6;
    }
    void build(int cur, int l, int r) {
        if (l == r) {
            tr[cur].id1 = tr[cur].id2 = l;
            return;
        }
        int mid = (l+r) &gt;&gt; 1;
        build(cur&lt;&lt;1, l, mid);
        build(cur&lt;&lt;1|1, mid+1, r);
        push_up(cur);
    }
    void update(int cur, int l, int r, int L, int R) {
        if (l &gt;= L &amp;&amp; r &lt;= R) return;  // 完全覆盖不用更新
        int mid = (l+r) &gt;&gt; 1;
        if (L &lt;= mid) update(cur&lt;&lt;1, l, mid, L, R);
        if (R &gt; mid) update(cur&lt;&lt;1|1, mid+1, r, L, R);
        push_up(cur);
    }
} tr2;

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt; n; i++) {
        int u,v; ll w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    dfs(1, 0);
    tr1.build(1, 1, n);
    tr2.build(1, 1, n);

    cin &gt;&gt; q;
    while (q--) {
        char op;
        cin &gt;&gt; op;
        if (op == 'C') {
            // 将第 d 条边的 weight 改为 e
            ll d,e; cin &gt;&gt; d &gt;&gt; e;
            d &lt;&lt;= 1;  // 编号从 2 开始
            ll x = e - edges[d].w;
            edges[d].w = edges[d^1].w = e;
            int u = edges[d].from, v = edges[d].to;
            if (ori_dep[u] &gt; ori_dep[v]) swap(u,v);
            tr1.update(1, 1, n, in[v], out[v], x);
            tr2.update(1, 1, n, in[v], out[v]);
        } else {
            int v; cin &gt;&gt; v;
            v = in[v];  // v 的 id 编号
            int id1 = tr2.tr[1].id1, id2 = tr2.tr[1].id2;
            ll dis1 = tr1.query_dis(id1, v);
            ll dis2 = tr1.query_dis(v, id2);
            cout &lt;&lt; max(dis1, dis2) &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
</details>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://www.luogu.com.cn/problem/solution/P6845">https://www.luogu.com.cn/problem/solution/P6845</a></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2022-07-30 00:31:13 &#43;0000 UTC">2022-07-30</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/7e888bffca80331b5d08b27235e8b59d5a8d132e" title="chore: update CF Problems" target="_blank">(7e888bf)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/043-%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%A0%91%E8%AE%BA/">树论</a>
          <a href="/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/">树的直径</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/044-cf1516-tutorial/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Codeforces Round #717 (Div.2) 解题报告</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/042-%E5%88%86%E5%B1%82%E5%9B%BE/">
            <span class="next-text nav-default">分层图最短路</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/tomorrow.min.css" rel="stylesheet">
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
