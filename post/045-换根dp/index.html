<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>换根DP - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。 第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/045-%E6%8D%A2%E6%A0%B9dp/" />
<link rel="manifest" href="/manifest.json">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="换根DP" />
<meta property="og:description" content="介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。 第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/045-%E6%8D%A2%E6%A0%B9dp/" />
<meta property="article:published_time" content="2021-04-22T21:49:20+08:00" />
<meta property="article:modified_time" content="2023-02-03T00:34:03+00:00" />
<meta itemprop="name" content="换根DP">
<meta itemprop="description" content="介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。 第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考">
<meta itemprop="datePublished" content="2021-04-22T21:49:20&#43;08:00" />
<meta itemprop="dateModified" content="2023-02-03T00:34:03&#43;00:00" />
<meta itemprop="wordCount" content="8424">



<meta itemprop="keywords" content="树形DP,换根DP," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="换根DP"/>
<meta name="twitter:description" content="介绍 换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。 第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，仅考"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">换根DP</h1>

      <div class="post-meta">
        <span class="post-time" title="2021-04-22 21:49:20 &#43;0800 &#43;0800"> 2021-04-22 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#套路">套路</a></li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-洛谷p3478-poi2008sta-stationhttpswwwluogucomcnproblemp3478">例1 <a href="https://www.luogu.com.cn/problem/P3478">洛谷P3478 [POI2008]STA-Station</a></a></li>
            <li><a href="#例2-cf1324f-maximum-white-subtreehttpscodeforcescomcontest1324problemf">例2 <a href="https://codeforces.com/contest/1324/problem/F">CF1324F Maximum White Subtree</a></a></li>
            <li><a href="#例3-洛谷p6419-coci2014-20151-kamphttpswwwluogucomcnproblemp6419">例3 <a href="https://www.luogu.com.cn/problem/P6419">洛谷P6419 [COCI2014-2015#1] Kamp</a></a></li>
            <li><a href="#例4-cf708c-centroidshttpswwwluogucomcnproblemcf708c">例4 <a href="https://www.luogu.com.cn/problem/CF708C">CF708C Centroids</a></a></li>
            <li><a href="#例5-洛谷p3647-apio2014连珠线httpswwwluogucomcnproblemp3647">例5 <a href="https://www.luogu.com.cn/problem/P3647">洛谷P3647 [APIO2014]连珠线</a></a></li>
            <li><a href="#例6-cf1725j-journeyhttpscodeforcescomcontest1725problemj">例6 CF1725J <a href="https://codeforces.com/contest/1725/problem/J">Journey</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="介绍">介绍</h2>
<p>换根DP是一种特殊的树形DP。主要特点在于需要进行两次DFS。</p>
<p>第一次DFS：固定任意节点（一般为 $1$）为根。对于每一个节点 $u$，<strong>仅考虑 $u$ 的subtree</strong>，求出这样的答案 $dp[u]$。</p>
<p>第二次DFS：令最终答案为 $ans[u]$，则可知 $ans[1] = dp[1]$。然后我们需要通过已知的 $ans[u]$，来推出它的child $ans[to]$ 的值。一般我们由 $ans[u]$ 来推导 $ans[to]$ 时，需要考虑到换根时 $to$ <strong>子树内的贡献，和子树外的贡献</strong> 变化。</p>
<h2 id="套路">套路</h2>
<p>我们考虑一下一种general的情况：<strong>从 $u$ 换根到 $v$</strong>。</p>
<p>此时我们一定位于 <code>dfs(u)</code> 中，并且已经求出了 $ans[u]$。现在要求 $ans[v]$。（注：这里的 $ans[u]$ 是广义的，代表 $u$ 相关的信息。不一定真的是最终的 $ans$，比如例4）</p>
<p>那么换根前是这样：</p>
<p><img src="/images/045/2.png" alt="img"></p>
<p>换根后，是这样：</p>
<p><img src="/images/045/3.png" alt="img"></p>
<p>步骤如下：</p>
<ol>
<li>基于 $ans[u]$，将 $u$ 的child $v$ 所带来的贡献删掉，得到 $dp2[u]$。</li>
<li>基于 $dp[v]$，将 $u$ 作为一个新的child 加给 $v$（实际上，就是将 $dp2[u]$ 的贡献加给 $dp[v]$），得到 $ans[v]$。</li>
</ol>
<p>• 注意，这里的 $dp2[u]$ 实际上是一个临时的变量。对于每一个 $v$ 而言，$dp2[u]$ 互不相同。</p>
<h2 id="例题">例题</h2>
<h3 id="例1-洛谷p3478-poi2008sta-stationhttpswwwluogucomcnproblemp3478">例1 <a href="https://www.luogu.com.cn/problem/P3478" target="_blank">洛谷P3478 [POI2008]STA-Station</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的树，求一个节点 $u$ 使得 $u$ 到其他节点的距离和最大。</p>
<p>即，求出 $u$，使得 $\sum\limits_v d(u,v)$ 最大。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先固定 $1$ 为根，进行一次DFS。</p>
<p>令 <code>dp[u]</code> 为第一次DFS，只考虑 $u$ 的子树内的答案。（考虑深度和即可）</p>
<p>令 <code>ans[u]</code> 为最终答案，那么有 <code>ans[1] = dp[1]</code>。</p>
<hr>
<p>现在我们要从 $1$ 开始换根。</p>
<p>比如说，我们已知了 $u$ 的答案 $ans[u]$，我们就可以理解成：整棵树，以 $u$ 作为root的答案已经求出来了，怎么求出 $to$ 的答案？</p>
<p><img src="/images/045/1.jpg" alt="img"></p>
<p>换根的过程是一个旋转的过程。我们把 $to$ 的子树向上旋转，将 $to$ 外面的部分（$u$ 和其他的子树）向下旋转。</p>
<p>则，向上旋转的部分，对于答案贡献了 <code>-sz[to]</code>（因为深度减少了），而向下旋转的部分，对于答案贡献了 <code>(n-sz[to])</code>。</p>
<p>所以，$ans[to] = ans[u] - sz[to] + (n - sz[to]);$</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6+5;

struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
int n, head[maxn], ecnt = 1;

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

ll sz[maxn], dp[maxn];
void dfs1(int u, int p) {
    sz[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        sz[u] += sz[to];
        dp[u] += dp[to] + sz[to];
    }
}

ll ans[maxn];
void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ans[to] = ans[u] - sz[to] + ((ll)n - sz[to]);
        dfs2(to, u);
    }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v; cin &gt;&gt; u &gt;&gt; v;
        addEdge(u,v); addEdge(v,u);
    }
    dfs1(1, 0);
    ans[1] = dp[1];
    dfs2(1, 0);

    ll maxans = 0, idx = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (ans[i] &gt; maxans) {
            maxans = ans[i];
            idx = i;
        }
    }
    cout &lt;&lt; idx &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例2-cf1324f-maximum-white-subtreehttpscodeforcescomcontest1324problemf">例2 <a href="https://codeforces.com/contest/1324/problem/F" target="_blank">CF1324F Maximum White Subtree</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的树，每个节点有一个值 $1$ 或者 $-1$。</p>
<p>对于每一个节点 $i$，求 $i$ 所在的连通块中，最大的节点权值和？</p>
<p>其中，$2 \leq n \leq 2 \times 10^5$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先固定 $1$ 为 root，进行一次DFS。</p>
<p>这样可以求出一个 <code>dp[u]</code>：代表以 $1$ 为root时，每个节点仅考虑其subtree，得到的最大值。</p>
<p>在第一次DFS的过程中，再维护一个数组 <code>bool used[]</code>，其中 <code>used[u] = 1</code> 代表 $u$ 的parent $p$ 的答案用到了 $u$ 的这个subtree。</p>
<hr>
<p>然后进行第二次DFS，计算出最终答案 <code>ans[]</code>。</p>
<p>首先有，<code>ans[1] = dp[1]</code>。</p>
<p>当我们在 <code>dfs2(u)</code> 时，在求一个child <code>to</code> 的答案 <code>ans[to]</code> 时，我们有两种选择：</p>
<ol>
<li>
<p><code>to</code> 不使用外面的节点：$ans[to] = \max(ans[to], dp[to])$</p>
</li>
<li>
<p><code>to</code> 使用外面的节点：分两种情况讨论</p>
<ol>
<li>如果 <code>to</code> 已经被包含在 $u$ 的答案中了（<code>used[to] = 1</code>），则 $ans[to] = \max(ans[to], ans[u])$</li>
<li>如果 <code>to</code> 并没有被包含在 $u$ 的答案中，（<code>used[to] = 0</code>），那么 <code>to</code> 的最终答案，就是由 $to$ 的subtree 和 外面节点的合并而来。即 $ans[to] = \max(ans[to], ans[u] + dp[to])$</li>
</ol>
</li>
</ol>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5+5;

struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
int n, head[maxn], ecnt = 1, val[maxn];

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

int dp[maxn];
bool used[maxn];  // when calculating answer, whether used[u] is taken into consideration
void dfs1(int u, int p) {
    dp[u] = val[u];
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        if (dp[to] &gt; 0) dp[u] += dp[to], used[to] = 1;
    }
}

int ans[maxn];
void dfs2(int u, int p) {
    ans[u] = max(ans[u], dp[u]);
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        if (used[to]) ans[to] = max(ans[to], ans[u]);
        else ans[to] = max(ans[to], ans[u] + dp[to]);
        dfs2(to, u);
    }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; val[i];
        if (val[i] == 0) val[i] = -1;
    }
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v; cin &gt;&gt; u &gt;&gt; v;
        addEdge(u,v); addEdge(v,u);
    }
    fill(ans, ans+maxn, -1e9);
    dfs1(1,0);
    dfs2(1,0);
    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例3-洛谷p6419-coci2014-20151-kamphttpswwwluogucomcnproblemp6419">例3 <a href="https://www.luogu.com.cn/problem/P6419" target="_blank">洛谷P6419 [COCI2014-2015#1] Kamp</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的树。经过每条边都需要时间 $w_i$。</p>
<p>有 $K$ 个人，初始在 $K$ 个不同的点，他们要集中在一个点聚会。</p>
<p>聚会结束后，一辆车从聚会点出发（装上所有人），把这 $K$ 个人分别送回去。</p>
<p>求：如果聚会点在 $i$，则将这些人都送回去，所需最少的时间？</p>
<p>输出对于所有 $i = 1$ ~ $n$ 的结果。</p>
<p>其中，$1 \leq K \leq n \leq 5 \times 10^5, 1 \leq w \leq 10^8$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>换根DP首先考虑：如果以 $1$ 作为根，怎么求出 $1$ 的答案？</p>
<p>• 以下，所有初始点我们都打上标记。</p>
<p>令 $sz[u]$ 为：$u$ 的 subtree（以 $1$ 为根的版本）中，标记点的数量。</p>
<p>令 $dp[u]$ 为：从 $u$ 出发，<strong>经过 $u$ 的 subtree（以 $1$ 为根的版本） 所有标记点</strong>，<strong>再回到 $u$</strong>，所需的最少时间（如果子树内无标记，则为0）。</p>
<p>那么通过第一次DFS，我们可以求出整个dp数组。</p>
<pre><code class="language-cpp">if (sz[to])
    dp[u] += dp[to] + 2*w;
</code></pre>
<hr>
<p>有了 $dp[1]$，我们还需要一个 $d[u]$，代表以 $u$ 为根的子树（以 $1$ 为根的版本）<strong>最长的链的长度</strong>。</p>
<p>同时我们再记录 $f[u]$：代表以u为根，包含了最长链的直接child $to$ 的编号。</p>
<p>最后 $1$ 对应的答案是：$dp[1] - d[1]$。（因为送到最长链，就不用再回到 $1$ 了）。</p>
<hr>
<p>现在问题是，已知 $1$ 的答案，我们需要求出其他点的答案。</p>
<p>令 $ans[u]$ 为：从 $u$ 出发，<strong>经过整棵树的所有标记点</strong>，<strong>再回到 $u$</strong>，所需的最少时间。</p>
<p>易证 $ans[1] = dp[1]$。</p>
<p>然后进行第二次DFS，我们需要改变 $d[u]$ 的意义：此时 $d[u]$ 代表从 $u$ 出发的最长链的长度（<strong>以整棵树而言</strong>）。</p>
<p>同时，我们再维护一个数组 $s[u]$，代表从 $u$ 出发的<strong>第二长链的长度</strong>（<strong>以整棵树而言</strong>），并且第二长链必须和最长链 <strong>不在同一个子树内</strong>（这里的子树指，以 $u$ 为根的判断标准）。</p>
<p>我们在从 $u$ 转移到 $to$ 的时候，就有以下的几种情况：</p>
<ol>
<li>
<p>$to$ 内无标记：</p>
<p>先从 $to$ 走到 $u$，访问所有的点，再从 $u$ 回到 $to$。</p>
<pre><code class="language-cpp">ans[to] = ans[u] + 2LL * w;
d[to] = d[u] + w;  // 现在，d[] 表示全局的链
</code></pre>
</li>
<li>
<p>$to$ 里面包含了整棵树的所有标记点：</p>
<p>最终答案就 等于 以 $to$ 为根，subtree的答案。</p>
<pre><code class="language-cpp">ans[to] = dp[to];
</code></pre>
</li>
<li>
<p>$to$ 里面包含了标记，外面也包含了标记：</p>
<p>那么对于整棵树而言，从 $to$ 出发，还是从 $u$ 出发都一样。所以 <code>ans[to] = ans[u]</code>。</p>
<p>但是我们需要更新最长链和次长链。这个时候，我们就要分类讨论 <code>f[u] = to</code> 与否。</p>
<p>如果 $u$ 原本的最长链就不在 $to$ 的子树内，那么换根以后（旋转），$to$ 的最长链必然是 $to \rightarrow u \rightarrow f[u]$。</p>
<p>如果 $u$ 原本用到的最长链是 $to$，而旋转后，$to$ 的最长链就有可能用到 $u$ 的其他子树（除了 $to$ 以外的子树），所以我们需要维护次长链 $s[u]$，并且进行比较。</p>
<p>相应的，换根过程中，我们也要更新次长链 $s[to]$。</p>
<pre><code class="language-cpp"> ans[to] = ans[u];
 if (f[u] != to) {  // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然继承 u 原来的最长链
     s[to] = d[to];
     d[to] = w + d[u];
     f[to] = u;
 } else {
     if (s[u] + w &gt;= d[to]) {
         s[to] = d[to];
         d[to] = s[u] + w;
         f[to] = u;
     } else if (s[u] + w &gt; s[to]) {
         s[to] = s[u] + w;
     }
 }

</code></pre>
</li>
</ol>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 5e5+5;

int n, K, head[maxn], ecnt = 1;
bool tag[maxn];
struct Edge {
    int to, nxt, w;
} edges[maxn&lt;&lt;1];

void addEdge(int u, int v, int w) {
    Edge e = {v, head[u], w};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

ll dp[maxn];  // dp[u]: 从u出发，只考虑其subtree中有标记的点，再回到u，得到的答案（如果子树内无标记，则为0）
ll ans[maxn];  // 从u出发，送完所有人，再回到u得到的答案
ll d[maxn];  // d[u]: 以u为根的子树内，最长的链的长度
ll s[maxn];  // s[u]: 以u为根的子树内，次长的链的长度 (不能和d所在的子树相同)
ll f[maxn];  // f[u]: 以u为根，包含了最深的有标记节点的to编号
int sz[maxn];  // sz[u]: 以u为根的subtree里的标记点数量

void chmax(int u, ll val) {
    if (val &gt; d[u]) {
        s[u] = d[u];
        d[u] = val;
    } else {
        if (val &gt; s[u]) s[u] = val;
    }
}

void dfs1(int u, int p) {
    if (tag[u]) {
        sz[u] = 1;
        d[u] = 0;
        s[u] = -1e15;
    } else {
        d[u] = s[u] = -1e15;
    }
    
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        ll w = edges[e].w;

        dfs1(to, u);
        if (!sz[to]) continue;  // 子树内无标记

        dp[u] += dp[to] + 2LL*w;
        sz[u] += sz[to];

        if (d[to] + w &gt;= d[u]) {
            s[u] = d[u];
            d[u] = d[to] + w;
            f[u] = to;
        } else if (d[to] + w &gt; s[u]) {
            s[u] = d[to] + w;
        }
    }
}

void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        ll w = edges[e].w;
        if (to == p) continue;
        if (!sz[to]) {  // to 里面没有标记点
            ans[to] = ans[u] + 2LL * w;
            d[to] = d[u] + w;  // 现在，d[] 表示全局的链
        } else if (K - sz[to] == 0) {  // to 里面全是标记点
            ans[to] = dp[to];
            // 无需更新最长/次长链
        } else {  // 里外都有标记
            ans[to] = ans[u];
            if (f[u] != to) {  // 原本 to 不是最长，那么现在也必不可能是最长，所以 to 起点的最长链必然出现在 u 所在的子树里
                s[to] = d[to];
                d[to] = w + d[u];
                f[to] = u;
            } else {
                if (s[u] + w &gt;= d[to]) {
                    s[to] = d[to];
                    d[to] = s[u] + w;
                    f[to] = u;
                } else if (s[u] + w &gt; s[to]) {
                    s[to] = s[u] + w;
                }
            }
        }
        dfs2(to, u);
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; K;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    for (int i = 1; i &lt;= K; i++) {
        int a; cin &gt;&gt; a;
        tag[a] = 1;
    }
    dfs1(1,0);
    ans[1] = dp[1];
    dfs2(1,0);

    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] - d[i] &lt;&lt; &quot;\n&quot;;
}
</code></pre>
</details>
<h3 id="例4-cf708c-centroidshttpswwwluogucomcnproblemcf708c">例4 <a href="https://www.luogu.com.cn/problem/CF708C" target="_blank">CF708C Centroids</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个 $n$ 个节点的树，定义树的重心 $u$ 为：如果以 $u$ 为根，每个子树的大小都 $\leq \frac{n}{2}$。</p>
<p>现在，对于每个点 $u$，我们需要判断：</p>
<p>以 $u$ 为根时，能否在这棵树内，删去一条边，再添加一条边（不能加入已有的边），使得 $u$ 是重心？</p>
<p>其中，$2 \leq n \leq 4 \times 10^5$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先，如果一个节点本来就是重心，那么它的答案就是 $1$。</p>
<p>现在考虑，如果一个节点 $u$ 现在不是重心，怎么删边和加边，使得它成为重心？</p>
<p>我们会发现，如果以 $u$ 为根，对于 $u$ 的所有 neighbor $v$，有且仅有一个 $v$，使得 $v$ 所在的 subtree 的大小 $&gt; \frac{n}{2}$，
那么我们就从这个 subtree $S_v$ 中，找到一个更小的subtree $S$，满足：</p>
<ol>
<li>$S$ 的大小 $\leq \frac{n}{2}$。</li>
<li>$S$ 是 $S_v$ 内，所有满足条件中，最大的subtree。</li>
</ol>
<p>然后我们把这个 subtree $S$ 断开，然后接到 $u$ 上，然后再判断一下 $u$ 此时是否为重心即可。</p>
<hr>
<p>我们会发现，如果以 $u$ 为根，这样的 $S$ 其实很容易找到。现在要考虑换根的问题。</p>
<hr>
<p>对于这道题而言，如果我们仅仅维护一个节点 $u$ 作为根时，subtree的信息，那么换根时会很麻烦。</p>
<p>我们需要额外维护一个信息 <code>out[u]</code>，其中 $out[u]$ 就代表：以 $1$ 为根时，$u$ 所在子树 $S_u$ <strong>外面的信息</strong>。</p>
<p>具体定义：$out[u]$ 代表：以 $1$ 为根时，设 $u$ 的parent为 $p$。然后令 $p$ 为根，除了 $S_u$ 以外的部分，满足大小 $\leq \frac{n}{2}$ 的最大子树。</p>
<p>然后就是 <strong>套路</strong> 里所说的：</p>
<p>先删去 $to$ 对于 $u$ 的贡献，再将 $u$ 加到 $to$ 上。</p>
<pre><code class="language-cpp">void dfs2(int u, int p) {
 
    if (n - sz[u] &gt; n/2) {
        if (n - sz[u] - out[u] &gt; n/2) ok[u] = 0;
    }
 
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
 
        if (n - sz[to] &lt;= n/2) {
            out[to] = n - sz[to];
        } else {
            // 删去 to 对于 u 的贡献（维护最大值，次大值 是常见套路了）
            // 再把 u 加到 to 上去（更新 out[to]）
            if (use[u][0] == to) {
                out[to] = max(out[u], dp[u][1]);
            } else {
                out[to] = max(out[u], dp[u][0]);
            }
        }
 
        if (sz[to] &gt; n/2) {
            if (sz[to] - dp[to][0] &gt; n/2) ok[u] = 0;
        }
 
        dfs2(to, u);
    }
}
</code></pre>
<p>• 当然注意到上述代码，我们不一定要定义一个 $dp2[]$ 数组。这题的状态转移相对简单，所以直接将两步合成一步就可以了。下一题会用到较复杂的状态转移，此时就需要定义 $dp2[]$ 数组了。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 4e5+5; 
 
int sz[maxn], head[maxn], ecnt = 1, dp[maxn][2], out[maxn], use[maxn][2], n;
bool ok[maxn];
struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
 
void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    edges[ecnt] = e;
    head[u] = ecnt++;
}
 
void dfs1(int u, int p) {
    sz[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dfs1(to, u);
        sz[u] += sz[to];
        
        if (sz[to] &lt;= n/2) {
            if (sz[to] &gt; dp[u][0]) {
                dp[u][1] = dp[u][0];
                dp[u][0] = sz[to];
                use[u][0] = to;
            } else if (sz[to] &gt; dp[u][1]) {
                dp[u][1] = sz[to];
                use[u][1] = to;
            }
        } else if (dp[to][0] &gt; dp[u][0]) {
            dp[u][1] = dp[u][0];
            dp[u][0] = dp[to][0];
            use[u][0] = to;
        } else if (dp[to][0] &gt; dp[u][1]) {
            dp[u][1] = dp[to][0];
            use[u][1] = to;
        }
    }
}
 
void dfs2(int u, int p) {
 
    if (n - sz[u] &gt; n/2) {
        if (n - sz[u] - out[u] &gt; n/2) ok[u] = 0;
    }
 
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
 
        if (n - sz[to] &lt;= n/2) {
            out[to] = n - sz[to];
        } else {
            if (use[u][0] == to) {
                out[to] = max(out[u], dp[u][1]);
            } else {
                out[to] = max(out[u], dp[u][0]);
            }
        }
 
        if (sz[to] &gt; n/2) {
            if (sz[to] - dp[to][0] &gt; n/2) ok[u] = 0;
        }
 
        dfs2(to, u);
    }
}
 
 
int main() {
    fastio;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v; cin &gt;&gt; u &gt;&gt; v;
        addEdge(u,v); addEdge(v,u);
    }
    fill(ok, ok+maxn, 1);
    dfs1(1, 0);
    dfs2(1, 0);
    for (int i = 1; i &lt;= n; i++) {
        cout &lt;&lt; ok[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例5-洛谷p3647-apio2014连珠线httpswwwluogucomcnproblemp3647">例5 <a href="https://www.luogu.com.cn/problem/P3647" target="_blank">洛谷P3647 [APIO2014]连珠线</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>现在有 $n$ 个珠子。珠子之间用线链接，每个线要么是红色，要么是蓝色。</p>
<p>我们将会从其中一个珠子开始（我们不知道这个珠子是哪个），每次用如下两种方式之一，添加珠子：</p>
<ol>
<li>将一个 <strong>新的珠子</strong> $w$ 和已经添加的珠子 $v$，用红线连起来。</li>
<li>将两个已经存在的珠子 $u,v$ 之间相连的红线删掉，然后添加一个 <strong>新的珠子 $w$</strong> 使得 $(u,w)$，$(w,v)$ 用蓝线链接。</li>
</ol>
<p>每条线都具有一个长度，游戏结束后，最终得分为蓝线长度之和。</p>
<p>给定游戏结束的局面（是一棵树），我们已知 珠子和线的连接方式，以及每条线的长度。但是我们不知道线的颜色。</p>
<p>求最大可能的得分？</p>
<p>其中，$1 \leq n \leq 2 \times 10^5$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>观察一下会发现，如果 $a,b$ 之间有蓝线，$b,c$ 之间也有蓝线。那么 $b$ 就是一个中间节点。这样的节点满足两个条件：</p>
<ol>
<li>$b$ 与 $a,c$ 一定是直接的neighbor。</li>
<li>$b$ 只能作为一次中间节点（因为 $b$ 是通过第二种操作添加的新节点）</li>
<li>$a,c$ 不能均为中间节点（因为 $a,c$ 之间，必须以红线相连，然后断开才行。这说明 $a,c$ 其中一个必须是通过第一种操作，得到的新珠子）</li>
</ol>
<p>那么，在最终形成的树中，对于蓝线，有以下两种可能：</p>
<p>第一种情况：grandparent, parent, child</p>
<p><img src="/images/045/4.png" alt="img"></p>
<p>第二种情况：parent, child1, child2</p>
<p><img src="/images/045/5.png" alt="img"></p>
<p>我们发现第二种情况很复杂，因为我们需要分类讨论 $a,c$ 是否本身为中间节点。</p>
<p>但是第一种情况，就比较好处理。我们只要加一个限定条件：</p>
<p>如果 $b$ 是中间节点（用 $1$ 来标记），那么它用蓝线相连的child $c$，就<strong>不能</strong>是中间节点（用 $0$ 来标记）。</p>
<hr>
<p>等等，有两个疑问：</p>
<ol>
<li>为什么我们限定的是蓝线相连的 child $c$？为什么不是parent $a$ ？</li>
<li>那如果第二种情况的那种出现了，怎么办？</li>
</ol>
<p>这些问题都可以通过 <strong>固定</strong> 树的根来解决。</p>
<p>我们可以发现，如果我们设定树的根为： <strong>最优解</strong> 中，最开始的那个珠子（虽然我们不知道它是哪一个），这些问题就都解决了。（比如第二个问题，我们可以保证这种情况不会出现）。</p>
<hr>
<p>如上，我们只需要考虑第一种情况。那么，固定 $1$ 为根时，第一次 DFS 中，我们有：</p>
<p>设 $dp[u][0]$ 为：如果 $u$ <strong>不是</strong>一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。</p>
<p>设 $dp[u][1]$ 为：如果 $u$ <strong>是</strong>一个中间节点，那么它所在的subtree $S_u$ 中得到的蓝线长度最大和。</p>
<p>状态转移方程：</p>
<p>$$dp[u][0] = \sum\limits_{to} \max(w + dp[to][1], dp[to][0])$$</p>
<p>对于 $dp[u][1]$，因为它只能选择一个 child。它选择的那个child $v$，对它的贡献是 $w_{u,v} + dp[v][0]$，其他的child $to$ 的贡献都是 $\max(w + dp[to][1], dp[to][0])$。</p>
<p>所以只要把这个 $v$ 的贡献减去，再加上新贡献就可以了。</p>
<p>$$dp[u][1] = dp[u][0] + \max\limits_v \{ w+dp[v][0] - \max(w+dp[v][1], dp[v][0])\}$$</p>
<hr>
<p>以 $1$ 为根的情况有了，现在考虑一下换根？</p>
<p>由换根套路，首先将 $to$ 对于 $u$ 的影响删去（基于 $ans[u]$），有：</p>
<p>$$dp2[u][0] = ans[u][0] - \max(w + dp[to][1], dp[to][0])$$</p>
<p>然后，对于 $dp2[u][1]$，我们分类讨论一下 $to$ 是否为 $u$ 的最佳转移点（也就是说，$ans[u][1]$ 是否用到了 $to$，作为最大值）。</p>
<p>$$dp2[u][1] =
\begin{cases}
ans[u][1] - maxval[u][0] + maxval[u][1] &amp; \text{If to 是 u 的最佳转移点} \\<br>
ans[u][1] &amp; \text{Otherwise}
\end{cases}$$</p>
<p>然后，再基于 $dp[to]$ 的基础上，将 $dp2[u]$ 作为 child 给 $to$ 的影响加到 $to$ 上即可。</p>
<p>最后，答案就是 $\max\limits_u \{ans[u][0]\}$。（因为 $ans[u][1]$ 并没有意义，$u$ 作为根的时候是没有parent的）。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5+5;

struct Edge {
    int to, w, nxt;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1, n, dp[maxn][2], dp2[maxn][2], ans[maxn][2];  // dp: 以 1 为根, dp2: 换根后, ans: 最终答案
int use[maxn][2], maxval[maxn][2];  // use[u]: 转移时，所用的前两大的值，对应的两个vertex； maxval[u] : 转移时所用的前两大的值

void addEdge(int u, int v, int w) {
    Edge e = {v, w, head[u]};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

void dfs1(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to, w = edges[e].w;
        if (to == p) continue;

        dfs1(to, u);

        dp[u][0] += max(w + dp[to][1], dp[to][0]);  // 转移 dp[u][0]

        // 转移 dp[u][1]
        int val = w + dp[to][0] - max(w + dp[to][1], dp[to][0]);
        if (val &gt; maxval[u][0]) {
            maxval[u][1] = maxval[u][0];
            use[u][1] = use[u][0];
            maxval[u][0] = val;
            use[u][0] = to;
        } else if (val &gt; maxval[u][1]) {
            maxval[u][1] = val;
            use[u][1] = to;
        }
    }
    dp[u][1] = dp[u][0] + maxval[u][0];
}

void dfs2(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to, w = edges[e].w;
        if (to == p) continue;

        // 删去 to 对于 u 的影响，基于 ans[u]，得到 dp2[u]
        dp2[u][0] = ans[u][0] - max(w + dp[to][1], dp[to][0]);
        if (to == use[u][0]) {
            dp2[u][1] = ans[u][1] - maxval[u][0] + maxval[u][1];
        } else {
            dp2[u][1] = ans[u][1];
        }
        dp2[u][1] -= max(w + dp[to][1], dp[to][0]);

        // 将 dp2[u] 作为 child，重新加给 to(在 dp[to] 的基础上)，作为新的 child
        ans[to][0] = dp[to][0] + max(w + dp2[u][1], dp2[u][0]);
        int val = w + dp2[u][0] - max(w + dp2[u][1], dp2[u][0]);
        if (val &gt; maxval[to][0]) {
            maxval[to][1] = maxval[to][0];
            use[to][1] = use[to][0];
            maxval[to][0] = val;
            use[to][0] = u;
        } else if (val &gt; maxval[to][1]) {
            maxval[to][1] = val;
            use[to][1] = u;
        }
        ans[to][1] = ans[to][0] + maxval[to][0];
        dfs2(to, u);
    }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    for (int i = 1; i &lt;= n; i++) maxval[i][0] = maxval[i][1] = -1e9;  // 注意初始化，否则会有问题

    dfs1(1, 0);
    ans[1][0] = dp[1][0], ans[1][1] = dp[1][1];
    dfs2(1, 0);
    int maxans = 0;
    for (int i = 1; i &lt;= n; i++) maxans = max(maxans, ans[i][0]);  // 注意这里是 ans[i][0]
    cout &lt;&lt; maxans &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例6-cf1725j-journeyhttpscodeforcescomcontest1725problemj">例6 CF1725J <a href="https://codeforces.com/contest/1725/problem/J" target="_blank">Journey</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一棵树，每条边有边权，现在我们可以从任意节点出发，需要访问每个节点至少一次。</p>
<p>在访问过程中，我们拥有一次使用传送门的机会，使得我们可以从一个节点无损耗的传送到另外一个节点。</p>
<p>求访问每个节点至少一次，并且至多使用一次传送门的最小消耗？</p>
<p>其中，$n \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>先考虑一下，如果我们不能使用传送门怎么算？</p>
<p>我们假设从 $x$ 出发，可以看作树以 $x$ 为根，那么每次走完一个子树都要回到 $x$，如果我们的路径最后停留在 $y$，说明 $(x,y)$ 这条路径仅被访问一次，而其他的边都会被访问两次。</p>
<p>所以对于整棵树而言，我们希望 $(x,y)$ 这条路径尽可能长，也就是这棵树的直径。然后对于其他的边，都访问了两次。所以答案就是：设 $sum$ 为所有边权和，$D$ 为直径长度，答案为 $2 * sum - D$。</p>
<hr>
<p>好的，接下来考虑有传送门的情况。</p>
<p>有两种情况：</p>
<p><img src="/images/045/7.jpg" alt="img"></p>
<p>第一种是在 $u$ 为根的情况，从 $u$ 的其中一个子树中走一圈，然后传送到 $u$ 的另外一个子树中走一圈，每条边都至少被用过一次。</p>
<p>第二种 $u$ 不是根的情况，设 $u$ 的parent为 $p$，那么先从 $u$ 的子树中走一圈，然后传送到除了 $u$ 的子树以外的位置走一圈，这样这条边 $(p, u)$ 就没有被用到。</p>
<p>对于第一种情况，以 $u$ 为起点的四条最长链只被访问一次，剩下的都是 $2$ 次，所以只要计算当 $u$ 作为根时，它作为起点的四个最长链（并且不相交，位于不同子树内）的长度。</p>
<p>对于第二种情况，相当于把一条边割开，然后得到两个分开的子树，这就是两个子树的子问题了，相当于两个子树内走一圈，无法使用传送门，所以只要求两个子树的直径即可。</p>
<p>注意到，我们需要对每一个 $u$ 都讨论第一种情况，对于每一条边都讨论第二种情况，这可以通过换根 dp 解决。</p>
<hr>
<p>我们先明确我们需要求的内容 （以下均为 $1$ 作为根时讨论）</p>
<p><code>dia[u]</code>： $u$子树（包括u）的最长直径。</p>
<p><code>dp1[u][3]</code>： $u$子树内，以u为起点的最长链 (前 $3$ 长）长度。</p>
<p><code>dp2[u][2]</code>： $u$子树内（不包括 u），最长(前 $2$ 长）的直径长度。</p>
<p><code>len[u]</code>：  $(u, par[u])$ 的权值。</p>
<p><code>up1[u]</code>： $u$外面（整棵树去掉 $u$ 子树后），以 $par[u]$ 作为起点的最长链。</p>
<p><code>up2[u]</code>： $u$外面（整棵树去掉 $u$ 子树后）的最长直径。</p>
<p>有了这些信息，所有问题都可以解决，现在看下怎么求这些信息？</p>
<hr>
<p>首先是 <code>dia[u]</code>：</p>
<p>这是一个常规的树形 DP 问题，</p>
<p>$u$ 子树的直径有两种情况，要么经过了 $u$，要么完全位于 $u$ 的子树里面。</p>
<p>对于第一种情况，求出以 $u$ 为起点的前 $2$ 个最长链，然后相加即可，这个就是 <code>dp1[u][0] + dp1[u][1]</code>，很好求。</p>
<p>对于第二种情况，求出 <code>dp2[u][0]</code> 即可.</p>
<hr>
<p>然后是 <code>up1[]</code>，我们看下图，这是正在求 <code>up1[v]</code> 的过程。</p>
<p><img src="/images/045/8.jpg" alt="img"></p>
<p>有两种情况：</p>
<ol>
<li>$u$ 为起点的最长链经过了 $v$。</li>
<li>$u$ 为起点的最长链没有经过 $v$。</li>
</ol>
<p>第一种情况下，<code>up1[v] = max(up1[v], dp1[u][1])</code>。</p>
<p>第二种情况下，<code>up1[v] = max(up1[v], dp1[u][0])</code>。</p>
<hr>
<p>接下来是 <code>up2[]</code>，同样按照上图求 <code>up2[v]</code> 的过程进行分类讨论：</p>
<p>有两种情况：</p>
<ol>
<li>$u$ 的子树内的直径经过了 $u$。</li>
<li>$u$ 的子树内的直径没经过 $u$。</li>
</ol>
<p>第一种情况下，使用的是 <code>dp1[u][0] + dp1[u][1]</code>，所以只要判断 $v$ 贡献了 <code>dp1[u][?]</code> 即可，比如如果 $v$ 贡献了 <code>dp1[u][1]</code>，那么就让 <code>up2[v] = max(up2[v], dp1[u][0] + dp1[u][2])</code>，即贡献来自其余两个链。</p>
<p>第二种情况下，使用的子树的直径，也就是 <code>dp2[u][?]</code>，判断是否有 <code>dia[v] == dp2[u][0]</code>，如果有，就用 <code>up2[v] = max(up2[v], dp2[u][1])</code>，否则用 <code>up2[v] = max(up2[v], dp2[u][0])</code>。</p>
<hr>
<p>除此之外，我们还需要换根。也就是在更新 <code>up1[v], up2[v]</code> 之前，要先把 $u$ 看作为根，所以需要把 $u$ 的parent那条链旋转下来，然后更新 <code>dp1[u], dp2[u]</code>。</p>
<hr>
<p>上面解决了问题 $2$，切分子树，然后要解决问题一：找四条最长不相交链的问题。</p>
<p>这个只要对每个节点维护一个大小为 $4$ 的最小堆即可，在第一次 dfs 的时候找到所有子树的最长链插入堆中，然后在将 <code>up1[u] + len[u]</code> 也就是 parent 的最长链插入即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
int n;
struct Edge {
    int to, nxt;
    ll w;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1;
void addEdge(int u, int v, int w) {
    Edge e = {v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll dia[maxn];  // dia[u]: u子树（包括u）的最长直径
ll dp1[maxn][3];  // u子树内，以u为起点的最长链长度
ll dp2[maxn][2];  // u子树内（不包括 u），最长的直径长度
int len[maxn];  // len[u]: w(u, par[u])
ll up1[maxn];  // u外面（整棵树去掉 u子树后）的最长链
ll up2[maxn];  // u外面（整棵树去掉 u子树后）的最长直径
ll sum = 0;  // 所有 w 的和
priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt;&gt; chain[maxn];  // chain[u]: 记录以u为起点的前4长的链
void dfs1(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int v = edges[e].to, w = edges[e].w;
        if (v == p) continue;
        len[v] = w;
        sum += w;
        dfs1(v, u);

        // 更新 dp1[u]
        ll t = w + dp1[v][0];
        for (int j = 0; j &lt;= 2; j++) {
            if (t &gt;= dp1[u][j]) swap(t, dp1[u][j]);
        }

        // 更新 dp2[u]
        t = dia[v];
        for (int j = 0; j &lt;= 1; j++) {
            if (t &gt;= dp2[u][j]) swap(t, dp2[u][j]);
        }

        dia[u] = max({dia[u], dp1[u][0] + dp1[u][1], dp2[u][0]});


        // 最后记录 chain[u]
        chain[u].push(w + dp1[v][0]);
        if (chain[u].size() &gt; 4) chain[u].pop();
    }
}
ll ans = 0;

void dfs2(int u, int p) {
    // // 此时需要先把 u 外面的那条链转过来，更新 dp1[u]
    ll t = len[u] + up1[u];
    for (int j = 0; j &lt;= 2; j++) {
        if (t &gt;= dp1[u][j]) swap(t, dp1[u][j]);
    }
    
    // 同理更新 dp2[u]
    t = up2[u];
    for (int j = 0; j &lt;= 1; j++) {
        if (t &gt;= dp2[u][j]) swap(t, dp2[u][j]);
    }

    for (int e = head[u]; e; e = edges[e].nxt) {
        int v = edges[e].to, w = edges[e].w;
        if (v == p) continue;

        // 更新 up1[v]
        if (w + dp1[v][0] == dp1[u][0]) {  // 如果u子树内最长链用到了 v
            up1[v] = max(up1[v], dp1[u][1]);
        } else {
            up1[v] = max(up1[v], dp1[u][0]);
        }

        // 更新 up2[v]
        // Case1: 直径经过 u
        if (dp1[v][0] + w == dp1[u][0]) {
            up2[v] = max(up2[v], dp1[u][1] + dp1[u][2]);
        } else if (dp1[v][0] + w == dp1[u][1]) {
            up2[v] = max(up2[v], dp1[u][0] + dp1[u][2]);
        } else {
            up2[v] = max(up2[v], dp1[u][0] + dp1[u][1]);
        }

        // Case2: 直径没经过 u
        if (dp2[u][0] == dia[v]) {
            up2[v] = max(up2[v], dp2[u][1]);
        } else {
            up2[v] = max(up2[v], dp2[u][0]);
        }
        ans = min(ans, sum * 2 - w * 2 - dia[v] - up2[v]);

        dfs2(v, u);
    }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt; n; i++) {
        int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u, v, w); addEdge(v, u, w);
    }
    dfs1(1, 0);
    ans = sum * 2;

    dfs2(1, 0);
    for (int u = 1; u &lt;= n; u++) {
        chain[u].push(up1[u] + len[u]);
        if (chain[u].size() &gt; 4) chain[u].pop();
        ll res = 0;
        while (chain[u].size()) {
            res += chain[u].top();
            chain[u].pop();
        }
        ans = min(ans, sum * 2 - res);
    }
    
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2023-02-03 00:34:03 &#43;0000 UTC">2023-02-03</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/ab9fa900baf4c340fd31a8e80d8c43a43a0ff617" title="chore: update CF Problems" target="_blank">(ab9fa90)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/045-%e6%8d%a2%e6%a0%b9DP.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%A0%91%E5%BD%A2dp/">树形DP</a>
          <a href="/tags/%E6%8D%A2%E6%A0%B9dp/">换根DP</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/046-%E4%BA%8C%E5%88%86%E5%9B%BE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">二分图 &amp; 二分图匹配</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/044-cf1516-tutorial/">
            <span class="next-text nav-default">Codeforces Round #717 (Div.2) 解题报告</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2023
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
