<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>二分图 &amp; 二分图匹配 - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。 二分图 - 性质 二分图 $\iff$ 图中没有奇环（指节点个" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/046-%E4%BA%8C%E5%88%86%E5%9B%BE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="二分图 &amp; 二分图匹配" />
<meta property="og:description" content="二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。 二分图 - 性质 二分图 $\iff$ 图中没有奇环（指节点个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/046-%E4%BA%8C%E5%88%86%E5%9B%BE/" />
<meta property="article:published_time" content="2021-05-30T22:31:30+08:00" />
<meta property="article:modified_time" content="2022-11-01T02:35:24+00:00" />
<meta itemprop="name" content="二分图 &amp; 二分图匹配">
<meta itemprop="description" content="二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。 二分图 - 性质 二分图 $\iff$ 图中没有奇环（指节点个">
<meta itemprop="datePublished" content="2021-05-30T22:31:30&#43;08:00" />
<meta itemprop="dateModified" content="2022-11-01T02:35:24&#43;00:00" />
<meta itemprop="wordCount" content="4197">



<meta itemprop="keywords" content="二分图,二分图匹配," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二分图 &amp; 二分图匹配"/>
<meta name="twitter:description" content="二分图 - 定义 二分图是一种特殊的无向图，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。 二分图 - 性质 二分图 $\iff$ 图中没有奇环（指节点个"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">二分图 &amp; 二分图匹配</h1>

      <div class="post-meta">
        <span class="post-time" title="2021-05-30 22:31:30 &#43;0800 &#43;0800"> 2021-05-30 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#二分图---定义">二分图 - 定义</a></li>
        <li><a href="#二分图---性质">二分图 - 性质</a></li>
        <li><a href="#二分图染色">二分图染色</a></li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-cf741c-arpas-overnight-party-and-mehrdads-silent-enteringhttpswwwluogucomcnproblemcf741c">例1 <a href="https://www.luogu.com.cn/problem/CF741C">CF741C Arpa’s overnight party and Mehrdad’s silent entering</a></a></li>
            <li><a href="#例2-cf553c-love-triangleshttpscodeforcescomcontest553problemc">例2 <a href="https://codeforces.com/contest/553/problem/C">CF553C Love Triangles</a></a></li>
          </ul>
        </li>
        <li><a href="#二分图匹配---定义">二分图匹配 - 定义</a></li>
        <li><a href="#匈牙利算法求最大匹配">匈牙利算法求最大匹配</a></li>
        <li><a href="#最大匹配最小点覆盖最大独立集最小边覆盖">最大匹配，最小点覆盖，最大独立集，最小边覆盖</a></li>
        <li><a href="#例题-1">例题</a>
          <ul>
            <li><a href="#例1-洛谷p1963-noi2009-变换序列httpswwwluogucomcnproblemp1963">例1 <a href="https://www.luogu.com.cn/problem/P1963">洛谷P1963 NOI2009 变换序列</a></a></li>
            <li><a href="#例2-洛谷-p2825-heoi2016tjoi2016游戏httpswwwluogucomcnproblemp2825">例2 <a href="https://www.luogu.com.cn/problem/P2825">洛谷 P2825 [HEOI2016/TJOI2016]游戏</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="二分图---定义">二分图 - 定义</h2>
<p>二分图是一种特殊的<strong>无向图</strong>，可以将点集划分为两部分，在同一集合中的节点之间没有 edge。</p>
<h2 id="二分图---性质">二分图 - 性质</h2>
<ol>
<li>二分图 $\iff$ 图中<strong>没有奇环</strong>（指节点个数为奇数的环） $\iff$ 可以进行二分图染色</li>
</ol>
<h2 id="二分图染色">二分图染色</h2>
<p>给定一个二分图，我们可以仅用两种颜色将每个节点染上色，并且保证每个 edge 的两端颜色一定不同。</p>
<p>同理，如果一个图可以进行二分图染色，那么它就是一个二分图（这用于 <strong>判断一个图是否为二分图</strong>）</p>
<p>染色的方法：用 DFS 即可。（记得要从每个节点都开始 DFS 一次）</p>
<ol>
<li>随机选择一个点 $u$ 作为出发点，它的颜色为 $c_u = 0$。</li>
<li>看它的 neighbor $v$ 的颜色，如果等于 $c_u$ ^ $1$，或者没染色，就染成 $c_u$ ^ $1$。否则的话产生冲突，说明这不是二分图。</li>
</ol>
<h2 id="例题">例题</h2>
<h3 id="例1-cf741c-arpas-overnight-party-and-mehrdads-silent-enteringhttpswwwluogucomcnproblemcf741c">例1 <a href="https://www.luogu.com.cn/problem/CF741C" target="_blank">CF741C Arpa’s overnight party and Mehrdad’s silent entering</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 对情侣 $(a_i, b_i)$（$a_i, b_i \in [1,2n]$），总共有 $2n$ 个人，每个人的编号是从 $1$ 到 $2n$。现在有 $2$ 种食物（$1$ 或者 $2$），求一种分配方式使得：</p>
<ol>
<li>每对情侣 $(a_i, b_i)$ 不能吃同一种食物。</li>
<li>相邻的 $3$ 个编号，食物不能完全相同。（编号是环形的，这意味着 $2n, 1, 2$ 也算是相邻的 $3$ 个人）。</li>
</ol>
<p>如果无解，输出 $-1$。</p>
<p>其中，$1 \leq n \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>每对情侣 $(a_i, b_i)$ 的食物不同，让我们想到二分图。但是第二个条件怎么办？</p>
<p>直觉上来说，这个题一定是有解的。</p>
<p>所以，我们可以做一个特殊的限制，直接强制 $2i-1, 2i$ 的食物不同，这个条件就满足了。</p>
<p>接下来我们要证明，将第二个限制条件转化以后，仍然有解。</p>
<hr>
<p>对于这个模型建图，将每个人作为一个节点，每对情侣 $(a_i, b_i)$ 作为一条边连起来。然后再将 $(2i-1, 2i)$ 作为一条边连起来。</p>
<p>那么只要这个图是<strong>二分图</strong>，就有解。（因为二分图保证了每条边两端的颜色不同）</p>
<p>如果图中有环，那么必然是由 $x$ 对情侣组成的一个环。所以环的节点数量为 $2x$。所以不可能有奇环。所以这个图是二分图。</p>
<p>所以建完图以后，跑一个二分图染色即可。</p>
<p>• 注意，二分图染色的 DFS 要从每一个节点都开始一次。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5+5;
const int maxm = 1e6;

int n;
struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1;
int color[maxn];

void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    edges[ecnt] = e;
    head[u] = ecnt++;
}
int a[maxn], b[maxn];
bool vis[maxn];
void dfs(int u) {
    if (vis[u]) return;
    vis[u] = 1;
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        color[to] = color[u] ^ 1;
        dfs(to);
    }
}

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i] &gt;&gt; b[i];
        addEdge(a[i], b[i]);
        addEdge(b[i], a[i]);
    }
    for (int i = 1; i &lt;= 2*n; i+=2) {
        addEdge(i, i+1);
        addEdge(i+1, i);
    }
    vis[1] = 1;
    for (int i = 1; i &lt;= 2*n; i++) dfs(i);
    for (int i = 1; i &lt;= n; i++) {
        if (!color[a[i]]) cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;
        else cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;

        if (!color[b[i]]) cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;
        else cout &lt;&lt; 1 &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
</details>
<h3 id="例2-cf553c-love-triangleshttpscodeforcescomcontest553problemc">例2 <a href="https://codeforces.com/contest/553/problem/C" target="_blank">CF553C Love Triangles</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个人，每两个人之间，要么互相love，要么互相hate。</p>
<p>现在已知 $m$ 个关系，每个关系的格式为 $a ~ b ~ c$，代表 $a$ 和 $b$ 互相 love（$c = 1$），或者互相 hate（$c = 0$）。</p>
<p>请求出，有<strong>多少个方案</strong>使得整个关系网满足以下条件（答案对 $10^9+7$ 取模）</p>
<blockquote>
<p>对于任意三个人 $a,b,c$，要么这三个人互相 love，要么 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。</p>
</blockquote>
<p>其中，$3 \leq n \leq 10^5, 0 \leq m \leq 10^5$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先我们会发现，love是有传递性的：如果 $a,b$ 互相love，$b,c$ 互相love，那么根据定义，一定有 $a,c$ 互相love。</p>
<p>所以对于love的关系，我们可以求出一个连通块，使得这个块内每个人互相love，那就可以缩点了。（当然需要注意的是 hate 不具有传递性）。</p>
<p>于是，我们只需要考虑一下 hate 怎么处理。</p>
<hr>
<p>先放一个结论：</p>
<blockquote>
<p>如果我们把这个问题考虑为图染色问题，那么两个互相hate，说明颜色不同。而互相love，说明颜色相同。</p>
<p>如果存在一个合法的染色方式，则说明有解。（本质上是二分图染色，互相love的在同一侧，互相hate的在两侧）</p>
</blockquote>
<p>证明：存在染色方式 $\rightarrow$ 有解：</p>
<p>任取三个节点 $a,b,c$，有两种情况：</p>
<ol>
<li>$a,b,c$ 在同一侧，所以满足 $a,b,c$ 互相love。</li>
<li>$a,b$ 在同一侧，$c$ 在另外一侧。这也刚好满足了 $a,b$ 互相love，而 $a,c$ 和 $b,c$ 互相hate。</li>
</ol>
<p>证明：有解 $\rightarrow$ 存在染色方式：</p>
<p>根据定义染色即可，我们会发现没有冲突情况。</p>
<hr>
<p>方案数怎么计算？</p>
<p>我们先进行 DFS，求出图中的连通块。</p>
<p>如果每个连通块内，都没有冲突情况（也就是说，每个连通块都可以做二分图染色）的话，说明有解，否则无解（$ans = 0$）。</p>
<p>同时我们发现，对于任何一个连通块，我们只要给其中一个节点染上色，这个连通块内的其他所有节点的颜色也都确定了。</p>
<p>所以我们只需要给每个连通块染色即可。</p>
<p>设连通块的数量为 $c$，那么答案就是 $2^{c-1}$。</p>
<p>• 为什么不是 $2^c$？我们只要确定了第一个块的颜色，剩下的 $(c-1)$ 个块随便选颜色。我们答案是否合法，实际上与第一个块的颜色无关。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;

int n,m;
int head[maxn], ecnt = 1, color[maxn];

struct Edge {
    int to, nxt, w;
} edges[maxn&lt;&lt;1];

void addEdge(int u, int v, int w) {
    Edge e = {v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}

ll ans = 1;
void dfs(int u) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to, w = edges[e].w;
        if (color[to] &gt;= 0) {
            if (color[to] != (color[u] ^ w ^ 1)) ans = 0;
        } else {
            color[to] = (color[u] ^ w ^ 1);
            dfs(to);
        }
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; i++) {
        int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    fill(color, color+maxn, -1);
    int cnt = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (color[i] == -1) {
            cnt++;
            color[i] = 0;
            dfs(i);
        }
    }
    cnt--;
    for (int i = 1; i &lt;= cnt; i++) {
        ans = ans * 2LL % mod;
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
</details>
<hr>
<h2 id="二分图匹配---定义">二分图匹配 - 定义</h2>
<p>一个 <strong>匹配</strong> 的定义是一个 <strong>边集</strong>，并且这个边集中，每两个边之间没有共同的顶点。二分图的最大匹配是指 边的数量 最多的一个匹配。</p>
<p>二分图匹配常用的算法是 <strong>匈牙利算法</strong> $O(nm)$，或者 <strong>最大流</strong>（dinic的复杂度为 $O(\sqrt n m)$。</p>
<h2 id="匈牙利算法求最大匹配">匈牙利算法求最大匹配</h2>
<p>匈牙利算法本质上是一个个求增广路（增广路指的是 <strong>从左开始，到右结束的路径</strong>，其中 左 $\rightarrow$ 右都是未匹配边，右 $\rightarrow$ 左都是匹配边）的过程。</p>
<p>如果我们以男女配对为例子：</p>
<p>对于每一个男生 $i$（$i$ 在二分图的 <strong>左侧点集</strong> 中），遍历他每一个心仪的女生 $j$ （$j$ 在二分图的 <strong>右侧点集</strong> 中）（这说明 $(i,j)$ 是一条边）。那么有两种情况：</p>
<ol>
<li>女生 $j$ 未配对，那么他们两个就配对在一起，<code>match[j] = i</code>。</li>
<li>女生 $j$ 已配对，那么就让女生 $j$ 去问一下她当前的男朋友 <code>match[j]</code>，让她男朋友尝试再换一个新的女朋友（所以就变成一个新的男生尝试配对，那么这就是一个递归的过程）。如果她男朋友成功换掉了女朋友，那么这个男生 $i$ 就可以和 女生 $j$ 配对了。否则 $i$ 就只能单着。</li>
</ol>
<p>代码片段如下：</p>
<pre><code class="language-cpp">int n, m, adj[maxn][maxn];
int match[maxn], vis[maxn], id = 0;
// match[j] 代表女生j 当前的男朋友 i, vis[j] 代表这个女生在当前男生 i 的配对过程中，是否访问过了

bool dfs(int i) {
    for (int j = 1; j &lt;= m; j++) {
        if (!adj[i][j] || vis[j] == id) continue;

        vis[j] = id;
        if (!match[j] || dfs(match[j])) {
            match[j] = i;
            return 1;
        }
    }
    return 0;
}

int main() {
    int ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        id++;
        ans += dfs(i);
    }
}
</code></pre>
<p>有几个需要注意的点：</p>
<ol>
<li>利用 <code>int vis[]</code> 来代表这个女生 $j$ 在当前男生 $i$ 的配对过程中，是否访问过了。（因为对于每个男生 $i$ 而言，对于每个女生 $j$ 只需要问一次即可）。</li>
<li>利用 <code>id</code> 来记录这是第几次 $dfs(i)$，然后只要判断 $vis[j]$ 是否等于 $id$ 就可以判断，本次 DFS 中是否询问过女生 $j$ 了。（这样就不用每次 DFS 结束都 <code>memset()</code> 一次）。</li>
</ol>
<p><strong>时间复杂度</strong>：每个男生都要询问所有女生，所以是 $O(nm)$（这里 $n$ 代表左边点集的数量，$m$ 代表右边点集）。</p>
<h2 id="最大匹配最小点覆盖最大独立集最小边覆盖">最大匹配，最小点覆盖，最大独立集，最小边覆盖</h2>
<p>TODO</p>
<h2 id="例题-1">例题</h2>
<h3 id="例1-洛谷p1963-noi2009-变换序列httpswwwluogucomcnproblemp1963">例1 <a href="https://www.luogu.com.cn/problem/P1963" target="_blank">洛谷P1963 NOI2009 变换序列</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个序列 $0,1,&hellip;,N-1$，我们需要求出一个变换序列 $T$，其中 $T$ 是 $0$ 到 $N-1$ 的一个 permutation。</p>
<p>同时，我们定义任意两个数字 $i,j$ 之间的距离 $D(i,j) = \min \{ |i-j|, N-|i-j|\}$。</p>
<p>现在给定原序列 和 变换序列 $T$ 之间，每个元素的距离 $D_i$，求出一个字典序最小的变换序列 $T$，如果无解，则输出 &ldquo;No Answer&rdquo;。</p>
<p>其中，$N \leq 10^4$。</p>
<hr>
<p>样例：</p>
<p>Input:</p>
<pre><code>5
1 1 2 2 1
</code></pre>
<p>Output:</p>
<pre><code>1 2 4 0 3
</code></pre>
<p>解释：原序列是 <code>[0,1,2,3,4]</code>，距离序列是 <code>[1,1,2,2,1]</code>，所以最终的变换序列可能是 <code>[0+1, 1+1, 2+2, 3-|5-2|, 4-1] = [1,2,4,0,3]</code>。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>将 <strong>原序列</strong> 作为二分图的左部分，<strong>变换序列</strong>作为二分图右部分。连边的方式就根据 <strong>距离序列</strong> 来。</p>
<p>例如原序列的第一个位置是 $0$，对应的距离序列第一个位置是 $1$，所以变换序列对应的值可能是 $1$ 或者 $4$。所以 $0 \rightarrow 1, 0 \rightarrow 4$ 连边即可。</p>
<p>连完边，跑一个最大匹配即可，如果最大匹配的数量等于 $N$ 说明有解，否则无解。</p>
<hr>
<p>最后考虑一下 <strong>字典序最小</strong> 怎么解决？</p>
<p>一般来说，看到 <strong>字典序最小</strong> 就想到 <strong>贪心</strong>。所以第一个贪心思路是每次匹配的时候都 <strong>从小到大</strong> 找配对点。</p>
<p>然而这样有一个问题，比如 $0 \rightarrow 1$ 以后，有可能因为后续的匹配导致 $0 \rightarrow 4$。</p>
<p>所以我们按照编号大小，<strong>从后往前</strong>进行 DFS 即可。</p>
<pre><code class="language-cpp">for (int i = n; i &gt;= 1; i--) {  // 注意这里是从 n 到 1
    id++;
    dfs(i);
}
</code></pre>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4+5;

int match[maxn], vis[maxn], id = 0, d[maxn], n;
set&lt;int&gt; adj[maxn];

bool dfs(int i) {
    for (int j : adj[i]) {
        if (vis[j] == id) continue;
        vis[j] = id;
        if (!match[j]) {
            match[j] = i;
            return 1;
        }
        if (dfs(match[j])) {
            match[j] = i;
            return 1;
        }
    }
    return 0;
}

bool ok(int i) { return i &gt;= 1 &amp;&amp; i &lt;= n; }

int ans[maxn];
int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; d[i];
    for (int i = 1; i &lt;= n; i++) {
        int j = (i - d[i]);
        if (ok(j)) adj[i].insert(j);
        j = (i + d[i]);
        if (ok(j)) adj[i].insert(j);
        j = (i + (n - d[i]));
        if (ok(j)) adj[i].insert(j);
        j = (i - (n - d[i]));
        if (ok(j)) adj[i].insert(j);
    }
    for (int i = n; i &gt;= 1; i--) {
        id++;
        dfs(i);
    }
    int cnt = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (match[i]) cnt++;
    }
    if (cnt &lt; n) {
        cout &lt;&lt; &quot;No Answer&quot; &lt;&lt; &quot;\n&quot;;
    } else {
        for (int i = 1; i &lt;= n; i++) ans[match[i]] = i;
        for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i]-1 &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}
</code></pre>
</details>
<h3 id="例2-洛谷-p2825-heoi2016tjoi2016游戏httpswwwluogucomcnproblemp2825">例2 <a href="https://www.luogu.com.cn/problem/P2825" target="_blank">洛谷 P2825 [HEOI2016/TJOI2016]游戏</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>在游戏 &ldquo;泡泡堂&rdquo; 中，给定一个 $n \times m$ 的网格，其中 <code>*</code> 代表空地，<code>x</code> 代表软石头，<code>#</code> 代表硬石头。</p>
<p>每个炸弹会影响它所在的行与列。炸弹可以穿透软石头，但是无法穿透硬石头。</p>
<p>给定一个地图，求最多放置多少个炸弹，使得每两个炸弹之间的影响范围不相交？</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>二分图匹配的一个常见套路就是应用在 <strong>网格地图</strong> 中。</p>
<p>我们把 <strong>每一行</strong> 看作一个节点，<strong>每一列</strong> 也看作一个节点，而<strong>每个网格就看作一条边</strong>。</p>
<p>如果我们不考虑硬石头的情况，那么这个题非常简单。把每个空地看作一条边，连起来以后跑一个最大匹配即可。</p>
<p>但是现在有硬石头。我们会发现一个硬石头可以 <strong>隔断纵向的和横向的</strong> 炸弹威力。那么，我们把硬石头隔断的部分，也看作是一个节点即可。</p>
<p>也就是说，现在不再是每一行/每一列作为节点，而是以 <strong>横向/纵向 线段</strong> 作为单位，每个线段是一个节点。</p>
<p>现在，每个网格里有 $3$ 种情况：</p>
<ol>
<li>空地：看作一个正常的边</li>
<li>软石头：忽略不计</li>
<li>硬石头：作为分界点，上下是两个不同的线段，左右是两个不同的线段。</li>
</ol>
<p>图建好了，再跑一个最大匹配即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 55;
const int maxm = 2505;

int n,m;
char arr[maxn][maxn];
vector&lt;int&gt; adj[maxm];

int id, lcnt, rcnt;
int l[maxn][maxn], r[maxn][maxn];
int match[maxm], vis[maxm], vis_id;

bool dfs(int i) {
    for (int j : adj[i]) {
        if (vis[j] == vis_id) continue;
        vis[j] = vis_id;
        if (!match[j] || dfs(match[j])) {
            match[j] = i;
            return 1;
        }
    }
    return 0;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            cin &gt;&gt; arr[i][j];
        }
    }
    id = 0;
    for (int i = 1; i &lt;= n; i++) {
        id++;
        for (int j = 1; j &lt;= m; j++) {
            if (arr[i][j] == '#') {
                id++;
                continue;
            }
            l[i][j] = id;
        }
    }
    lcnt = id;
    id = 0;
    for (int j = 1; j &lt;= m; j++) {
        id++;
        for (int i = 1; i &lt;= n; i++) {
            if (arr[i][j] == '#') {
                id++;
                continue;
            }
            r[i][j] = id;
        }
    }
    rcnt = id;

    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            if (arr[i][j] == '*') {
                adj[l[i][j]].push_back(r[i][j]);
            }
        }
    }
    int ans = 0;
    for (int i = 1; i &lt;= lcnt; i++) {
        vis_id++;
        ans += dfs(i);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2022-11-01 02:35:24 &#43;0000 UTC">2022-11-01</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/d6772fee1ca15edf28b1da643f00272768f6bdbe" title="chore: update clicks" target="_blank">(d6772fe)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/046-%e4%ba%8c%e5%88%86%e5%9b%be.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/">二分图</a>
          <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/047-%E7%BD%91%E7%BB%9C%E6%B5%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">网络流</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/045-%E6%8D%A2%E6%A0%B9dp/">
            <span class="next-text nav-default">换根DP</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
