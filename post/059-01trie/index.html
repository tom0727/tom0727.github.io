<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Trie 和 01 Trie - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="介绍 01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。 Trie可以解决以下问题： 给定一些数 $a_1,a_2,&amp;hellip;,a_" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/059-01trie/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="Trie 和 01 Trie" />
<meta property="og:description" content="介绍 01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。 Trie可以解决以下问题： 给定一些数 $a_1,a_2,&hellip;,a_" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/059-01trie/" />
<meta property="article:published_time" content="2021-12-17T14:23:29+08:00" />
<meta property="article:modified_time" content="2022-10-24T22:41:47-05:00" />
<meta itemprop="name" content="Trie 和 01 Trie">
<meta itemprop="description" content="介绍 01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。 Trie可以解决以下问题： 给定一些数 $a_1,a_2,&hellip;,a_">
<meta itemprop="datePublished" content="2021-12-17T14:23:29&#43;08:00" />
<meta itemprop="dateModified" content="2022-10-24T22:41:47-05:00" />
<meta itemprop="wordCount" content="7897">



<meta itemprop="keywords" content="Trie,," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Trie 和 01 Trie"/>
<meta name="twitter:description" content="介绍 01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。 Trie可以解决以下问题： 给定一些数 $a_1,a_2,&hellip;,a_"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Trie 和 01 Trie</h1>

      <div class="post-meta">
        <span class="post-time" title="2021-12-17 14:23:29 &#43;0800 &#43;0800"> 2021-12-17 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#介绍">介绍</a>
          <ul>
            <li><a href="#维护最大xor">维护最大XOR</a></li>
            <li><a href="#维护xor和">维护XOR和</a></li>
            <li><a href="#可持久化01-trie">可持久化01-Trie</a></li>
          </ul>
        </li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-洛谷p4551-最长异或路径httpswwwluogucomcnproblemp4551">例1 <a href="https://www.luogu.com.cn/problem/P4551">洛谷P4551 最长异或路径</a></a></li>
            <li><a href="#例2-cf817e-choosing-the-commanderhttpswwwluogucomcnproblemcf817e">例2 <a href="https://www.luogu.com.cn/problem/CF817E">CF817E Choosing The Commander</a></a></li>
            <li><a href="#例3-洛谷p6018-ynoi2010-fusion-treehttpswwwluogucomcnproblemp6018">例3 <a href="https://www.luogu.com.cn/problem/P6018">洛谷P6018 [Ynoi2010] Fusion tree</a></a></li>
            <li><a href="#例4-洛谷p4735-最大异或和httpswwwluogucomcnproblemp4735">例4 <a href="https://www.luogu.com.cn/problem/P4735">洛谷P4735 最大异或和</a></a></li>
            <li><a href="#例5-cf241b-friendshttpswwwluogucomcnproblemcf241b">例5 <a href="https://www.luogu.com.cn/problem/CF241B">CF241B Friends</a></a></li>
            <li><a href="#例6-cf1625d-binary-spidershttpscodeforcescomcontest1625problemd">例6 <a href="https://codeforces.com/contest/1625/problem/D">CF1625D Binary Spiders</a></a></li>
            <li><a href="#例7-cf1665e-minimizorhttpscodeforcescomcontest1665probleme">例7 CF1665E. <a href="https://codeforces.com/contest/1665/problem/E">MinimizOR</a></a></li>
          </ul>
        </li>
        <li><a href="#参考链接">参考链接</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="介绍">介绍</h2>
<p>01-Trie 指将整数拆成二进制，然后将二进制以字符串的形式储存在 Trie 中。</p>
<p><img src="/images/059/1.jpg" alt="img"></p>
<p>Trie可以解决以下问题：</p>
<ol>
<li>
<p>给定一些数 $a_1,a_2,&hellip;,a_n$，给定 $x$，求 $a_i$，使得 $a_i \text{ xor } x$ 最大。</p>
</li>
<li>
<p>维护异或和：给定一些数，支持全体加一，插入数字，删除数字，求全体异或和等操作。</p>
</li>
</ol>
<p>Trie可以将数字从低位到高位储存，也可以反过来，根据具体题目而定。</p>
<p>为了方便，我们在写 01Trie 的时候都会把每个数补成同样的位数。</p>
<p>• 注意 <code>id = 1</code> 的是 Root，所以 <code>id</code> 要从 $1$ 开始。</p>
<h3 id="维护最大xor">维护最大XOR</h3>
<p>指第一个例子，这里我们的 01Trie 将会 <strong>从高位到低位</strong> 储存。</p>
<p>在给定一个查询 $x$ 时，我们从 $x$ 的高位开始看，设当前到了第 $i$ 位，那么我们看第 $i$ 位的bit $a_i$，然后判断一下第 $i$ 位的值为 <code>a[i] ^ 1</code> 的数字是否存在即可，如果存在，往那个方向走，否则往另外一个方向走。</p>
<details class="admonition note"><summary class="admonition-title">板子</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;

int id = 1;  // 注意，从 1 开始
struct Node {
    int cnt = 0;
    int child[2];
} trie[maxn&lt;&lt;4];
void insert(int x) {
    int c = 1;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        if (!trie[c].child[k]) trie[c].child[k] = ++id;

        c = trie[c].child[k];
        trie[c].cnt++;
    }
}

int query(int x) {
    int c = 1;
    int res = 0;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        k ^= 1;
        if (trie[c].child[k]) {
            c = trie[c].child[k];
            res |= (1&lt;&lt;j);
        } else {
            c = trie[c].child[k^1];
        }
    }
    return res;
}
</code></pre>
</details>
<h3 id="维护xor和">维护XOR和</h3>
<p>指第二个例子，这里我们的 01Trie <strong>从低位到高位</strong>储存。</p>
<p>要维护异或和，我们只需要知道每一位上 $0$ 和 $1$ 个数的奇偶性即可。</p>
<p>对于每一个节点，我们记录三个量：</p>
<ol>
<li>两个子节点的编号</li>
<li><code>w</code>：指当前这个节点，到它的parent这条边 $(p,u)$ 上，被经过的次数。每有一个数字在插入过程中经过这个边，这个 <code>w</code> 就会加一。</li>
<li><code>val</code>：指以当前节点为根，它子树内包含的所有数字的 <strong>XOR和</strong>。</li>
</ol>
<p>所以维护信息的时候就有：</p>
<pre><code class="language-cpp">void push_up(int cur) {
    trie[cur].val = trie[cur].w = 0;  // 先清空
    int c0 = trie[cur].child[0], c1 = trie[cur].child[1];

    // 更新 w
    if (c0) trie[cur].w += trie[c0].w;
    if (c1) trie[cur].w += trie[c1].w;

    // 更新 val

    if (c0) {
        trie[cur].val ^= (trie[c0].val &lt;&lt; 1);
    }
    if (c1) {
        trie[cur].val ^= ((trie[c1].val &lt;&lt; 1) | (trie[c1].w &amp; 1));  // 如果 c1 的 w 为奇数，就提供了 1 的贡献
    }
}
</code></pre>
<p>解释: 注意是从低位到高位储存的，所以子树内储存的只是数字的二进制的一部分。</p>
<p>所以要把 <code>val</code> 进行左移。</p>
<p>也就是说，实际上只有 <strong>根节点</strong> 的 <code>val</code> 是真正有意义的，因为只有根节点才记录的是完整的数字的 XOR和。</p>
<hr>
<p>插入和删除就不提了，看代码即可。注意插入删除合并起来，可以达成单点修改的效果。</p>
<p>最后说一下全局加一。</p>
<p>全局加一指的是将整个01Trie维护的所有数字都加一。</p>
<p>在二进制下的加一，相当于从低位到高位找第一个出现的 $0$，然后将其变成 $1$。</p>
<p>最后，比这一位低的所有位都将会从 $1$ 变成 $0$。</p>
<pre><code class="language-cpp">// add 1 to all numbers maintained by cur
void addall(int cur) {
    swap(trie[cur].child[0], trie[cur].child[1]);
    if (trie[cur].child[0]) {
        addall(trie[cur].child[0]);
    }
    push_up(cur);
}
</code></pre>
<details class="admonition note"><summary class="admonition-title">板子</summary>
<pre><code class="language-cpp">const int M = 21;  // 最大深度
int id = 0;
struct Node {
    int w;  // 到 parent 这条边上的个数
    int val;  // subtree 内的XOR和
    int child[2];
} trie[maxn*(M+1)];

void push_up(int cur) {
    trie[cur].val = trie[cur].w = 0;  // 先清空
    int c0 = trie[cur].child[0], c1 = trie[cur].child[1];

    // 更新 w
    if (c0) trie[cur].w += trie[c0].w;
    if (c1) trie[cur].w += trie[c1].w;

    // 更新 val

    if (c0) {
        trie[cur].val ^= (trie[c0].val &lt;&lt; 1);
    }
    if (c1) {
        trie[cur].val ^= ((trie[c1].val &lt;&lt; 1) | (trie[c1].w &amp; 1));  // 如果 c1 的 w 为奇数，就提供了 1 的贡献
    }
}

// cur: index, x: 当前的数字, dep: 深度
void insert(int&amp; cur, int x, int dep) {
    if (!cur) cur = ++id;
    if (dep &gt;= M) {
        trie[cur].w++;  // w += 1
        return;
    }
    int c = x &amp; 1;
    insert(trie[cur].child[c], (x&gt;&gt;1), dep+1);
    push_up(cur);
}

void del(int&amp; cur, int x, int dep) {
    if (!cur) cur = ++id;
    if (dep &gt;= M) {
        trie[cur].w--;  // w -= 1
        return;
    }
    int c = x &amp; 1;
    insert(trie[cur].child[c], (x&gt;&gt;1), dep+1);
    push_up(cur);
}

// add 1 to all numbers maintained by cur
void addall(int cur) {
    swap(trie[cur].child[0], trie[cur].child[1]);
    if (trie[cur].child[0]) {
        addall(trie[cur].child[0]);
    }
    push_up(cur);
}
</code></pre>
</details>
<h3 id="可持久化01-trie">可持久化01-Trie</h3>
<p>和主席树相似，可持久化01-Trie主要是为了让我们获得任何一个区间 $[L,R]$ 内组成的 01-Trie。</p>
<p>使用 Node 的 <code>cnt</code> 来决定 01-Trie 的内容。</p>
<details class="admonition note"><summary class="admonition-title">板子</summary>
<pre><code class="language-cpp">const int maxn = 6e5+5;
const int M = 28;
struct Node {
    int cnt;
    int child[2];
} trie[maxn * (M+3)];
int n, q, root[maxn], a[maxn], id;

void insert(int pre, int cur, int x) {
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        trie[cur].cnt = trie[pre].cnt + 1;  // cnt 加一
        if (!trie[cur].child[c]) trie[cur].child[c] = ++id;  // 新建节点
        trie[cur].child[c^1] = trie[pre].child[c^1];  // 复制另外一个子节点
        cur = trie[cur].child[c];
        pre = trie[pre].child[c];
    }
    trie[cur].cnt = trie[pre].cnt + 1;
}

// find the maximum value for a ^ x (a is in [pre, cur])
int query(int pre, int cur, int x) {
    int res = 0;
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        c ^= 1;
        if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) {  // cnt &gt; 0
            cur = trie[cur].child[c];
            pre = trie[pre].child[c];
            res |= (1&lt;&lt;i);
        } else {
            cur = trie[cur].child[c^1];
            pre = trie[pre].child[c^1];
        }
    }
    return res;
}
int main() {
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i]; sum[i] = sum[i-1] ^ a[i];
        if (!root[i]) root[i] = ++id;
        insert(root[i-1], root[i], sum[i]);
    }
    // 查询 [L,R] -&gt; (l-1,r)
    int res = query(root[max(0,l-1)], root[r], x);
}
</code></pre>
</details>
<h2 id="例题">例题</h2>
<h3 id="例1-洛谷p4551-最长异或路径httpswwwluogucomcnproblemp4551">例1 <a href="https://www.luogu.com.cn/problem/P4551" target="_blank">洛谷P4551 最长异或路径</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个 $n$ 个节点的树，边上有权值。</p>
<p>寻找树上的两个节点，使得路径上的边权 XOR和 最大，输出这个最大值。</p>
<p>其中，$n \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>常见套路：设 $f_x$ 为从 $1$（根节点）到 $x$ 的路径上的 XOR和。</p>
<p>那么 $(u,v)$ 路径上的 XOR和 就等于 $f_u \text{ xor } f_v$。因为 $1$ 到 $LCA(u,v)$ 的部分被抵消掉了。</p>
<p>所以就相当于建立一个 01Trie，储存所有的 $f_u$，然后对于每个 $u$，都询问一下最大的XOR即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const ll mod = 1e9+7;
const int maxn = 1e5+5;
const int maxm = 30;

struct Edge {
    int to, nxt, w;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1, n;
void addEdge(int u, int v, int w) {
    Edge e = {v, head[u], w};
    edges[ecnt] = e;
    head[u] = ecnt++;
}
int dp[maxn];
void dfs(int u, int p) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == p) continue;
        dp[to] = dp[u] ^ edges[e].w;
        dfs(to, u);
    }
}

int id = 1;
struct Node {
    int cnt = 0;
    int child[2];
} trie[maxn&lt;&lt;4];
void insert(int x) {
    int c = 1;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        if (!trie[c].child[k]) trie[c].child[k] = ++id;

        c = trie[c].child[k];
        trie[c].cnt++;
    }
}

int query(int x) {
    int c = 1;
    int res = 0;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        k ^= 1;
        if (trie[c].child[k]) {
            c = trie[c].child[k];
            res |= (1&lt;&lt;j);
        } else {
            c = trie[c].child[k^1];
        }
    }
    return res;
}


int main() {
    fastio;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n-1; i++)     {
        int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u,v,w); addEdge(v,u,w);
    }
    dfs(1, 0);
    for (int i = 1; i &lt;= n; i++) insert(dp[i]);
    int ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        ans = max(ans, query(dp[i]));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例2-cf817e-choosing-the-commanderhttpswwwluogucomcnproblemcf817e">例2 <a href="https://www.luogu.com.cn/problem/CF817E" target="_blank">CF817E Choosing The Commander</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $q$ 个询问，共有3种：</p>
<p>$1 ~ p$：将 $p$ 加入集合。</p>
<p>$2 ~ p$：将 $p$ 从集合中删除。</p>
<p>$3 ~ p ~ l$：询问集合中有多少个元素在 XOR $p$ 之后小于 $l$。</p>
<p>其中，$q \leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>在 01-Trie 每个节点处加上一个 count 就可以了。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5+5;
const int maxm = 27;
 
int Q, id = 1;
struct Node {
    int child[2];
    int cnt = 0;
} trie[maxn&lt;&lt;3];
void insert(int x) {
    int c = 1;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        if (!trie[c].child[k]) trie[c].child[k] = ++id;
        c = trie[c].child[k];
        trie[c].cnt++;
    }
}
void del(int x) {
    int c = 1;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        if (!trie[c].child[k]) trie[c].child[k] = ++id;
        c = trie[c].child[k];
        trie[c].cnt--;
    }
}
 
int query(int p, int l) {
    int c = 1;
    int res = 0;
    for (int j = maxm; j &gt;= 0; j--) {
        if (l &amp; (1&lt;&lt;j)) {  // 如果这一位有，说明要往这一位为 1 的方向走
            int k = ((p &amp; (1&lt;&lt;j)) &gt; 0);
            res += trie[trie[c].child[k]].cnt;
            if (trie[trie[c].child[k^1]].cnt) c = trie[c].child[k^1];
            else break;
        } else {  // 如果这一位没有，就往 0 的方向走
            int k = ((p &amp; (1&lt;&lt;j)) &gt; 0);
            if (trie[trie[c].child[k]].cnt) c = trie[c].child[k];
            else break;
        }
    }
    return res;
}
 
int main() {
    fastio;
    cin &gt;&gt; Q;
    while (Q--) {
        int op, p, l;
        cin &gt;&gt; op &gt;&gt; p;
        if (op == 1) {
            insert(p);
        } else if (op == 2) {
            del(p);
        } else {
            cin &gt;&gt; l;
            int res = query(p,l);
            cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
</details>
<h3 id="例3-洛谷p6018-ynoi2010-fusion-treehttpswwwluogucomcnproblemp6018">例3 <a href="https://www.luogu.com.cn/problem/P6018" target="_blank">洛谷P6018 [Ynoi2010] Fusion tree</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一棵 $n$ 个节点的树，每个节点 $i$ 上有权值，初始权值为 $a_i$。</p>
<p>给出 $m$ 个询问，询问的类型有3种：</p>
<p>$1 ~ x$：将所有与节点 $x$ 距离为 $1$ 的节点的权值加一。</p>
<p>$2 ~ x ~ v$：将节点 $x$ 的权值减去 $v$。</p>
<p>$3 ~ x$：询问所有与节点 $x$ 距离为 $1$ 的节点权值的XOR和。</p>
<p>其中，$n,m \leq 5 \times 10^5$，初始权值 $\leq 10^5$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>这里是 01-Trie 用来维护XOR和。</p>
<p>我们可以对于<strong>每一个节点</strong>，都把它的孩子（距离为 $1$）的XOR和 维护在一个 01Trie里面。</p>
<p>因为 01-Trie 是动态开点的，所以总共复杂度也就 $n\log(10^5)$。</p>
<p>然后因为每个节点都只有一个 parent，就单独维护即可。</p>
<p>然后对于操作 $1 ~ x$，我们需要做的几件事：</p>
<ol>
<li>单独更新 $x$ 的parent。</li>
<li>给 $x$ 打上一个懒标记，代表它要给它的孩子加上 $lazy$ 的值。</li>
<li>在 $x$ 维护的 01-Trie 上进行全体加一操作。</li>
</ol>
<p>然后在每次操作之前，都先检查一下 $parent$ 的懒标记，将其下放。</p>
<p>当然这里的下放不太一样，一个节点可能有非常多个孩子，所以我们选择给每一个节点 $x$ 都定义一个值 <code>add[x]</code>，代表它已经从parent那里得到了多少下放的懒标记。</p>
<p>然后就给 $x$ 的权值加上 <code>(lazy[p] - add[x])</code>。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 5e5+5;
const int M = 21;  // 最大深度

int id = 0;
struct Node {
    int w;  // 到 parent 这条边上的个数
    int val;  // subtree 内的XOR和
    int child[2];
} trie[maxn*(M+1)];
int root[maxn], lazy[maxn], add[maxn];

void push_up(int cur) {
    trie[cur].val = trie[cur].w = 0;  // 先清空
    int c0 = trie[cur].child[0], c1 = trie[cur].child[1];

    // 更新 w
    if (c0) trie[cur].w += trie[c0].w;
    if (c1) trie[cur].w += trie[c1].w;

    // 更新 val

    if (c0) {
        trie[cur].val ^= (trie[c0].val &lt;&lt; 1);
    }
    if (c1) {
        trie[cur].val ^= ((trie[c1].val &lt;&lt; 1) | (trie[c1].w &amp; 1));  // 如果 c1 的 w 为奇数，就提供了 1 的贡献
    }
}

// cur: index, x: 当前的数字, dep: 深度
void insert(int&amp; cur, int x, int dep) {
    if (!cur) cur = ++id;
    if (dep &gt;= M) {
        trie[cur].w++;
        return;
    }
    int c = x &amp; 1;
    insert(trie[cur].child[c], (x&gt;&gt;1), dep+1);
    push_up(cur);
}

void del(int&amp; cur, int x, int dep) {
    if (!cur) cur = ++id;
    if (dep &gt;= M) {
        trie[cur].w--;
        return;
    }
    int c = x &amp; 1;
    insert(trie[cur].child[c], (x&gt;&gt;1), dep+1);
    push_up(cur);
}

// add 1 to all numbers maintained by cur
void addall(int cur) {
    swap(trie[cur].child[0], trie[cur].child[1]);
    if (trie[cur].child[0]) {
        addall(trie[cur].child[0]);
    }
    push_up(cur);
}

int n, m, a[maxn], par[maxn];
struct Edge {
    int to, nxt;
} edges[maxn&lt;&lt;1];
int head[maxn], ecnt = 1;
void addEdge(int u, int v) {
    Edge e = {v, head[u]};
    head[u] = ecnt;
    edges[ecnt++] = e;
}

void dfs(int u) {
    for (int e = head[u]; e; e = edges[e].nxt) {
        int to = edges[e].to;
        if (to == par[u]) continue;
        par[to] = u;
        insert(root[u], a[to], 0);
        dfs(to);
    }
}

// modify u to have the value val
void modify(int u, int val) {
    // a[u] is previous value
    int p = par[u];
    if (p) {
        del(root[p], a[u], 0);
        insert(root[p], val, 0);
    }
    a[u] = val;
}

int main() {
    fastio;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n-1; i++) {
        int u,v; cin &gt;&gt; u &gt;&gt; v;
        addEdge(u,v); addEdge(v,u);
    }
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }
    dfs(1);

    while (m--) {
        int op, x; cin &gt;&gt; op &gt;&gt; x;
        if (op == 1) {
            addall(root[x]);
            int p = par[x];
            if (p) {
                a[p] = a[p] + lazy[par[p]] - add[p];
                add[p] = lazy[par[p]];
                modify(par[x], a[p] + 1);
            }
            lazy[x]++;
        }
        if (op == 2) {
            int v; cin &gt;&gt; v;
            a[x] = a[x] + lazy[par[x]] - add[x];
            add[x] = lazy[par[x]];
            modify(x, a[x] - v);
        }
        if (op == 3) {
            int res = trie[root[x]].val;
            int p = par[x];
            if (p) {
                a[p] = a[p] + lazy[par[p]] - add[p];
                add[p] = lazy[par[p]];
                res ^= a[p];
            }
            cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
</details>
<h3 id="例4-洛谷p4735-最大异或和httpswwwluogucomcnproblemp4735">例4 <a href="https://www.luogu.com.cn/problem/P4735" target="_blank">洛谷P4735 最大异或和</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个非负整数序列 $a_1,a_2,&hellip;,a_n$。</p>
<p>现给定 $m$ 个操作，有以下两种操作类型：</p>
<p>$A ~ x$：在序列末尾添加一个数 $x$。</p>
<p>$Q ~ L ~ R ~ x$：输出一个位置 $p$，满足 $p \in [L,R]$，使得 $a_p \bigoplus a_{p+1} \bigoplus &hellip; \bigoplus a_n \bigoplus x$ 最大。</p>
<p>其中，$n,m \leq 3 \times 10^5, a_i \in [0,10^7]$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>可持久化 01-Trie 的模版题。</p>
<p>首先，先考虑前缀XOR数组 $s_i = a_1 \bigoplus a_2 \bigoplus &hellip; \bigoplus a_i$。</p>
<p>那么</p>
<p>$$a_p \bigoplus a_{p+1} \bigoplus &hellip; \bigoplus a_n \bigoplus x = (s_n \bigoplus s_{p-1}) \bigoplus x$$</p>
<p>所以现在问题就变成：</p>
<p>每次询问 $Q ~ L ~ R ~ x$，输出一个位置 $p$，满足 $p \in [L-1,R-1]$，使得 $(s_n \bigoplus s_{p-1}) \bigoplus x$ 最大。</p>
<p>那就很简单了，令 $y = s_n \bigoplus x$，剩下的就是在一个区间 $[L-1,R-1]$ 内找出一个元素 $s_p$ 使得 $s_p \bigoplus y$ 最大。</p>
<p>对于每一个区间都可以用 01-Trie 解决的问题，就是可持久化 01-Trie了。</p>
<hr>
<p>最后需要注意一下这个样例：</p>
<pre><code>4 1
2 4 8 16
Q 1 4 1
</code></pre>
<p>答案应为 $31$，但我输出 $29$。</p>
<p>这是因为我们要单独处理一下 $s_0$ 的情况。换而言之我们要将 $s_0 = 0$ 插入到 <code>root[1]</code> 当中。</p>
<p>所以 <code>root[1]</code> 需要包含 $2$ 个元素：$s_0,s_1$。</p>
<p>对于一个版本插入 $2$ 个元素，只要在第二次插入时使用 <code>insert(root[1], root[1], 0)</code> 即可。</p>
<p>最后再注意一下一些边界条件如 $[L-1,R-1]=[0,0]$ 即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 6e5+5;
const int M = 28;

struct Node {
    int cnt;
    int child[2];
} trie[maxn * (M+1)];
int sum[maxn];  // sum[n] 代表 a[1] ^ a[2] ... ^ a[n]
int n, q, root[maxn], a[maxn], id;

void insert(int pre, int cur, int x) {
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        trie[cur].cnt = trie[pre].cnt + 1;  // cnt 加一
        if (!trie[cur].child[c]) trie[cur].child[c] = ++id;  // 新建节点
        trie[cur].child[c^1] = trie[pre].child[c^1];  // 复制另外一个子节点
        cur = trie[cur].child[c];
        pre = trie[pre].child[c];
    }
    trie[cur].cnt = trie[pre].cnt + 1;
}

// find the maximum value for a ^ x (a is in [pre, cur])
int query(int pre, int cur, int x) {
    int res = 0;
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        c ^= 1;
        if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) {  // cnt &gt; 0
            cur = trie[cur].child[c];
            pre = trie[pre].child[c];
            res |= (1&lt;&lt;i);
        } else {
            cur = trie[cur].child[c^1];
            pre = trie[pre].child[c^1];
        }
    }
    return res;
}


int main() {
    fastio;
    cin &gt;&gt; n &gt;&gt; q;

    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i]; sum[i] = sum[i-1] ^ a[i];
        if (!root[i]) root[i] = ++id;
        insert(root[i-1], root[i], sum[i]);
        if (i == 1) insert(root[1], root[1], 0);
    }
    while (q--) {
        char op; cin &gt;&gt; op;
        if (op == 'A') {
            int x; cin &gt;&gt; x;
            a[++n] = x;
            sum[n] = sum[n-1] ^ a[n];
            if (!root[n]) root[n] = ++id;
            insert(root[n-1], root[n], sum[n]);
        } else {
            int l,r,x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            l--; r--;
            x ^= (sum[n]);
            if (l == 0 &amp;&amp; r == 0) {
                cout &lt;&lt; x &lt;&lt; &quot;\n&quot;; continue;
            }
            int res = query(root[max(0,l-1)], root[r], x);
            cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
        }
    }
}
</code></pre>
</details>
<h3 id="例5-cf241b-friendshttpswwwluogucomcnproblemcf241b">例5 <a href="https://www.luogu.com.cn/problem/CF241B" target="_blank">CF241B Friends</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个长度为 $n$ 的非负整数数组 $a_1,a_2,&hellip;,a_n$。</p>
<p>现在选择 $m$ 个pair $(i,j)$，使得这 $m$ 个pair 对应的 $a_i \text{ xor } a_j$ 值的 sum 最大。</p>
<p>其中，$n \leq 5 \times 10^4, a_i \leq 10^9$，答案对 $10^9+7$ 取模。</p>
<p>• $(i,j)$ 和 $(j,i)$ 算作一个 pair。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>神仙题。</p>
<p>本题要求的是前 $m$ 大的XOR pair的和。</p>
<p>我们先列出本题的过程：</p>
<ol>
<li>求出第 $m$ 大。</li>
<li>求出 XOR 小于等于 $x$ 的所有pair的和。</li>
<li>对于一个区间 $[L,R]$，在 $O(1)$ 求出 $\sum\limits_{i=L}^R y \text{ xor } a_i$。</li>
</ol>
<hr>
<p>第一步：求第 $m$ 大</p>
<p>• 虽然 $(i,j)$ 和 $(j,i)$ 算作一个 pair，但我们只要把所有东西都乘以 $2$ 就行了。所以我们求第 $2m$ 大。</p>
<p>最简单粗暴的方法当然是二分最终的结果 $x$，然后对于每一个 $a_i$，判断一下在 Trie 中有多少个数字和它 XOR 起来 $\geq x$，把这些 count 累加起来然后查看 <code>count &gt;= 2m</code> 与否，来调整 $x$ 的值。</p>
<p>这样的时间复杂度是 $O(n\log^2 10^9)$，本题可过，但是<a href="https://www.luogu.com.cn/problem/P5283" target="_blank">另外一个版本</a>不可过。</p>
<p>于是我们思考一下能不能直接在 Trie 上模拟这个二分的过程来构建最终的结果 $x$。</p>
<p>发现是可以的，我们从高位到低位，枚举每一位取 $1$ 还是 取 $0$。</p>
<p>然后我们对于每一个 $a_i$ 都判断一下 count 的总和，如果 <code>count &gt;= 2m</code>，则说明这一位可以取 $1$。否则的话需要取 $0$，同时问题变成寻找第 $2m - count$ 大（有点类似于主席树寻找第 $k$ 大的思路）。</p>
<p>• 这个过程是在所有 $a_i$ 上进行的，所以我们维护 $n$ 个指针 <code>ptr[]</code> 代表 $a_i$ 目前在 Trie 的什么位置。</p>
<p>复杂度为 $O(n\log 10^9)$。</p>
<hr>
<p>第二步：求出 XOR 小于等于 $x$ 的所有pair的和</p>
<p>如果这个问题不是求出和，而是求出个数的话，就是例 $2$ 的问题了。</p>
<p>可惜不是，那怎么处理？</p>
<p>一样，我们从每个 $a_i$ 开始进行 check，对于每一个 Trie 上的节点，我们可以维护一个 <code>cnt[31]</code>，其中 <code>cnt[j]</code> 代表当前Trie节点的子树里有多少个数字满足第 $j$ 位为 $1$。</p>
<p>这样当然可以算，但是空间复杂度 $O(n\log^2 10^9)$，本题或许可过，但另外一个版本仍然不可过。</p>
<p>我们这里给出一个非常优秀的结论：</p>
<blockquote>
<p>如果 $a_i$ 是 <strong>sorted</strong> 的，那么 Trie 上任意一个节点的子树 对应 $a_i$ 上的一段连续区间。</p>
</blockquote>
<p>这个也不难理解，因为 Trie 的一个子树对应的是拥有一个 &ldquo;特定前缀&rdquo; （如 &ldquo;1101&rdquo;）的所有数字的集合。</p>
<p>有了这个结论以后，我们在枚举 $a_i$ 时，假设我们目前到了第 $j$ 位，就分两种情况：</p>
<ol>
<li>$x$ 的第 $j$ 位为 $1$：那么我们就往 $1$ 的方向走。</li>
<li>$x$ 的第 $j$ 位为 $0$：我们把 $a_i$ XOR 上 $1$ 的那个子树，求出sum，给答案加上，然后往 $0$ 的方向走。</li>
</ol>
<p>注意到 $a_i$ XOR 上一个子树的 sum，可以转化成一个区间上的问题，那么就有第三步：</p>
<hr>
<p>第三步：对于一个区间 $[L,R]$，在 $O(1)$ 求出 $\sum\limits_{i=L}^R y \text{ xor } a_i$。</p>
<p>由于 $a_i$ 总共有 $n$ 个，所以不能直接求前缀和。</p>
<p>但我们可以把区间内的每个数都 <strong>拆成二进制</strong>。</p>
<p>然后对于拆开的二进制，每一位分别 XOR 上 $0$ 和 $1$，然后都进行一个前缀和。</p>
<p>这样给定一个数字 $y$，就可以把 $y$ 拆成二进制，然后对于每一位 $j$，把 $[L,R]$ 内对应的和用 $O(1)$ 时间内求出来即可。</p>
<p>• 所以我们要做的事就是先 sort 一下整个 $a_i$ 数组，然后在构建 Trie 的时候记录一下每个子树对应哪个区间即可。</p>
<hr>
<p>最后要注意，由于第 $2m$ 大有可能 <strong>等于</strong> 第 $2m+1, 2m+2 &hellip;$ 大，所以要处理掉额外加上的部分。</p>
<p>答案除以 $2$ 即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const ll mod = 1e9+7;
const int maxn = 5e4+5;
const int M = 31;
struct Node {
    int cnt = 0;
    int child[2];
    int L = 1e9, R = -1;  // left and right segments
} trie[maxn * (M+1)];
int id = 1;
void insert(int idx, ll x) {
    int c = 1;
    for (int i = M; i &gt;= 0; i--) {
        int k = ((x &amp; (1LL&lt;&lt;i)) ? 1 : 0);
        if (!trie[c].child[k]) trie[c].child[k] = ++id;
        c = trie[c].child[k];
        trie[c].cnt++;
        trie[c].L = min(trie[c].L, idx);  // 维护子树对应的区间
        trie[c].R = max(trie[c].R, idx);
    }
}

ll a[maxn];
ll n,m;

// 寻找第 k 大 (本题是找到第 2m 大)
int ptr[maxn];  // 每一个 ai 对应的 Trie 上的 ptr
ll find_kmax(ll t) {
    ll res = 0;
    fill(ptr+1, ptr+n+1, 1);  // 开始都在 1
    for (int j = M; j &gt;= 0; j--) {
        ll cnt = 0;
        // 找这一位 &gt;= 1 的有多少个
        for (int i = 1; i &lt;= n; i++) {
            int k = ((a[i] &amp; (1LL&lt;&lt;j)) ? 1 : 0);
            k ^= 1;
            cnt += trie[trie[ptr[i]].child[k]].cnt;
        }
        int nxt;
        if (cnt &gt;= t) {
            res |= (1LL&lt;&lt;j);
            nxt = 1;
        } else {
            t -= cnt;
            nxt = 0;
        }

        for (int i = 1; i &lt;= n; i++) {
            int k = ((a[i] &amp; (1LL&lt;&lt;j)) ? 1 : 0);
            k ^= nxt;  // 由这一步决定的哪一个来判断每一个 ptr 的更新位置
            ptr[i] = trie[ptr[i]].child[k];
        }
    }
    return res;
}


int sum[maxn][M+1][2];
// 计算 a[L,R] ^ x 之和
ll sum_range(ll l, ll r, ll x) {
    ll ans = 0;
    for (int j = M; j &gt;= 0; j--) {
        int k = ((x &amp; (1LL&lt;&lt;j)) ? 1 : 0);
        ll s = sum[r][j][k] - sum[l-1][j][k];
        ans += s * (1LL &lt;&lt; j);
        ans %= mod;
    }
    return ans;
}

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

// 获得 ai ^ aj &gt;= x 的所有数之和
ll get_sum(ll x) {
    // 先把每个数拆成二进制，做前缀和
    for (int j = M; j &gt;= 0; j--) {
        for (int i = 1; i &lt;= n; i++) {
            for (int k = 0; k &lt;= 1; k++) {
                int c = ((a[i] &amp; (1LL&lt;&lt;j)) ? 1 : 0);
                c ^= k;
                sum[i][j][k] = sum[i-1][j][k] + c;
            }
        }
    }

    ll ans = 2 * x % mod;
    ll cnt = 0;  // 使用的对数
    for (int i = 1; i &lt;= n; i++) {
        int c = 1;
        for (int j = M; j &gt;= 0; j--) {
            int k = ((a[i] &amp; (1LL&lt;&lt;j)) ? 1 : 0);
            int d = ((x &amp; (1LL&lt;&lt;j)) ? 1 : 0);

            if (d == 0) {
                // 加上所有 xor 起来为 1 的部分, 然后走到 0
                int p = trie[c].child[k^1];
                if (p) {
                    ans += sum_range(trie[p].L, trie[p].R, a[i]);
                    cnt += (trie[p].R - trie[p].L + 1);
                    ans %= mod;
                }
                c = trie[c].child[k];
            } else {
                c = trie[c].child[k^1];
            }
        }
    }
    cnt += 2;
    ans = (ans - ((cnt - 2 * m) % mod * x % mod) + mod) % mod;  // 减去重复的部分

    ans = ans * qpow(2, mod-2) % mod;
    return ans;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    if (!m) {
        cout &lt;&lt; 0 &lt;&lt; endl;
        return 0;
    }

    sort(a+1, a+n+1);
    for (int i = 1; i &lt;= n; i++) insert(i, a[i]);

    ll x = find_kmax(2 * m);
    ll ans = get_sum(x);
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例6-cf1625d-binary-spidershttpscodeforcescomcontest1625problemd">例6 <a href="https://codeforces.com/contest/1625/problem/D" target="_blank">CF1625D Binary Spiders</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个非负整数，和一个非整数 $k$。</p>
<p>求 $n$ 个非负整数的一个 subset，使得这个 subset 最大，并且 subset内 每两个数之间的 XOR $\geq k$。</p>
<p>其中，$n \leq 3 \times 10^5, k,a_i \in [0,2^{30}-1]$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先我们设 $k$ 的最高位为 $j$。</p>
<p>那么我们将所有的 $a_i$ 分成三个部分：</p>
<ol>
<li>最高位 $\geq j+1$ 的。</li>
<li>最高位 $= j$ 的。</li>
<li>最高位 $\leq j-1$ 的。</li>
</ol>
<p>那么我们可以发现，对于 Case 2, Case 3，各只能最多选出 $1$ 个数来。</p>
<p>那么对于 Case 1 呢？</p>
<p>不如我们只考虑它们 bitmask的 prefix，即 $[j+1,30]$ 的这一部分。</p>
<p>我们注意到，如果两个 prefix 不同的数，一定是可以共存的。</p>
<p>如果两个数的 prefix 相同呢？是 <strong>有可能</strong> 可以共存的！</p>
<p>更准确的来说，如果两个数的 prefix 相同，我们可以把这部分抵消掉，那么问题就变成了最高位 $\leq j$ 的一些数可以最多选多少个出来共存。</p>
<p>这实际上就是 Case 2 和 Case 3 的并集，我们很容易发现这个并集内，最多可以选 $2$ 个数。</p>
<p>所以问题就简化了，我们只要根据 prefix 分类这些数，然后在每个分类中，选出最多两个数来即可。</p>
<p>而选择最多两个数判断是否 $\geq k$，用 01-Trie 可以轻松解决。</p>
<hr>
<p>实现的过程：</p>
<ol>
<li>先找出 $k$ 的最高位 $j$。</li>
<li>将所有的数字按照 $[j+1,30]$ 这一部分的prefix分类。</li>
<li>对于每一类，都构建 01-Trie 判断是否存在两个数的 XOR $\geq k$，存在就选择这两个数，否则只选一个。</li>
</ol>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 3e5+5;
const int maxm = 30;

int id = 1;  // 注意，从 1 开始
struct Node {
    int cnt = 0;
    int child[2];
} trie[maxn&lt;&lt;4];
void insert(int x, int delta) {
    int c = 1;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        if (!trie[c].child[k]) trie[c].child[k] = ++id;

        c = trie[c].child[k];
        trie[c].cnt += delta;
    }
}

// maximum query
int query(int x) {
    int c = 1;
    int res = 0;
    for (int j = maxm; j &gt;= 0; j--) {
        int k = 0;
        if (x &amp; (1&lt;&lt;j)) k = 1;
        k ^= 1;
        if (trie[trie[c].child[k]].cnt) {
            c = trie[c].child[k];
            res |= (1&lt;&lt;j);
        } else {
            c = trie[c].child[k^1];
            // res |= (1&lt;&lt;j);
        }
    }
    return res;
}

int n,k;
struct Nd {
    int val, id;
} a[maxn];
int b[maxn];

vector&lt;int&gt; ans;
vector&lt;pii&gt; vec[maxn];
int main() {
    fastio;
    cin &gt;&gt; n &gt;&gt; k;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].val, a[i].id = i;
    sort(a+1, a+n+1, [](auto a, auto b) {
        return a.val &gt; b.val;
    });

    if (k == 0) {
        cout &lt;&lt; n &lt;&lt; endl;
        for (int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
        return 0;
    }
    int p = 0;
    for (int j = 0; j &lt;= 30; j++) {
        if (k &amp; (1&lt;&lt;j)) p = j;
    }

    int ptr = 0;
    for (int i = 1; i &lt;= n; i++) {
        b[i] = a[i].val;
        for (int j = 0; j &lt;= p; j++) {
            if (b[i] &amp; (1&lt;&lt;j)) b[i] ^= (1&lt;&lt;j);
        }
        if (!(i &gt; 1 &amp;&amp; b[i] == b[i-1])) {
            ++ptr;
        }
        vec[ptr].push_back({a[i].val, a[i].id});
    }

    for (int i = 1; i &lt;= ptr; i++) {
        if (vec[i].size() &gt;= 2) {
            bool ok = 0;
            for (int j = 0; j &lt; vec[i].size(); j++) {
                if (!ok &amp;&amp; query(vec[i][j].first) &gt;= k) {
                    for (int a = 0; a &lt; j; a++) {
                        if ((vec[i][j].first ^ vec[i][a].first) &gt;= k) {
                            ans.push_back(vec[i][j].second);
                            ans.push_back(vec[i][a].second);
                            ok = 1;
                            break;
                        }
                    }
                }
                insert(vec[i][j].first, 1);
            }
            if (!ok) {
                ans.push_back(vec[i][0].second);
            }
            for (int j = 0; j &lt; vec[i].size(); j++) {
                insert(vec[i][j].first, -1);
            }
        } else if (vec[i].size() == 1) {
            ans.push_back(vec[i][0].second);
        }
    }


    if (ans.size() &lt;= 1) cout &lt;&lt; -1 &lt;&lt; endl;
    else {
        cout &lt;&lt; ans.size() &lt;&lt; endl;
        for (int j : ans) cout &lt;&lt; j &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}
</code></pre>
</details>
<h3 id="例7-cf1665e-minimizorhttpscodeforcescomcontest1665probleme">例7 CF1665E. <a href="https://codeforces.com/contest/1665/problem/E" target="_blank">MinimizOR</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个非负整数 $a_1,a_2,&hellip;,a_n$ 和 $q$ 个询问，每次询问 $[l_i, r_i]$ 之间，选出两个index $j \neq k$，使得 $j,k \in [l_i, r_i]$ 且 $a_j | a_k$ 最小，求最小值。</p>
<p>其中，$n \in [2, 10^5], a_i \in [0, 2^{30}), q \in [1, 10^5], 1 \leq l_i &lt; r_i \leq n$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>可持久化01-trie。</p>
<p>可持久化保证了我们可以对于每一个区间找 $a_j | a_k$ 最小值。</p>
<p>怎么找呢？</p>
<p>考虑从 01-trie 上开始 dfs，如果发现 $0$ 对应的子树中有 $\geq 2$ 个数字，那么说明这一位可以取 $0$，否则只能取 $1$。</p>
<p>但有的情况下，$0$ 对应的子树中只有 $1$ 个数字 $a$，此时我们只能取 $1$，但是这个数字 $a$ 也是要拿出来的，因为它有可能在下一层被用到，所以我们单独用一个 <code>vector&lt;int&gt; tmp</code> 来储存这些 $a$。</p>
<p>最后注意一下，当我们在某一层取了 $0$ 时，要重新判断一下 <code>tmp</code> 中的数字 $a$ 在这一位是否为 $1$，如果是，说明最终答案中一定不可能考虑到这个数字 $a$，扔掉即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
const int M = 30;
struct Node {
    int cnt;
    int child[2];
} trie[maxn * (M+1)];
int n, root[maxn], id;
void insert(int pre, int cur, int x) {
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        trie[cur].cnt = trie[pre].cnt + 1;  // cnt 加一
        if (!trie[cur].child[c]) trie[cur].child[c] = ++id;  // 新建节点
        trie[cur].child[c^1] = trie[pre].child[c^1];  // 复制另外一个子节点
        cur = trie[cur].child[c];
        pre = trie[pre].child[c];
    }
    trie[cur].cnt = trie[pre].cnt + 1;
}
// find the maximum value for a ^ x (a is in [pre, cur])
int query(int pre, int cur, int x) {
    int res = 0;
    for (int i = M; i &gt;= 0; i--) {
        int c = 0;
        if (x &amp; (1 &lt;&lt; i)) c = 1;
        c ^= 1;
        if (trie[trie[cur].child[c]].cnt - trie[trie[pre].child[c]].cnt) {  // cnt &gt; 0
            cur = trie[cur].child[c];
            pre = trie[pre].child[c];
            res |= (1&lt;&lt;i);
        } else {
            cur = trie[cur].child[c^1];
            pre = trie[pre].child[c^1];
        }
    }
    return res;
}
 
int ans = 0;
vector&lt;int&gt; tmp, tmp2;
void dfs(int pre, int cur, int d) {
    if (d &lt; 0) return;
    int cnt0 = 0, cnt1 = 0;
    cnt0 = trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt;
    cnt1 = trie[trie[cur].child[1]].cnt - trie[trie[pre].child[1]].cnt;
    for (int j : tmp) {
        if (!(j &amp; (1&lt;&lt;d))) cnt0++;
    }
 
    if (cnt0 &gt;= 2) {
        tmp2.clear();  // 如果为0，这里只能保留这一位为0的！
        for (int j : tmp) {
            if (!(j &amp; (1&lt;&lt;d))) tmp2.push_back(j);
        }
        tmp = tmp2;
        dfs(trie[pre].child[0], trie[cur].child[0], d-1);
    } else {
        if (trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt) {
            assert(trie[trie[cur].child[0]].cnt - trie[trie[pre].child[0]].cnt == 1);
 
            int tcur = trie[cur].child[0], tpre = trie[pre].child[0], tx = ans;
            for (int j = d-1; j &gt;= 0; j--) {
                if (trie[trie[tcur].child[0]].cnt - trie[trie[tpre].child[0]].cnt) {
                    tcur = trie[tcur].child[0];
                    tpre = trie[tpre].child[0];
                } else {
                    tcur = trie[tcur].child[1];
                    tpre = trie[tpre].child[1];
                    tx |= (1&lt;&lt;j);
                }
            }
            tmp.push_back(tx);
        }
        ans |= (1&lt;&lt;d);
        dfs(trie[pre].child[1], trie[cur].child[1], d-1);
    }
}
 
void clear(int cur) {
    for (int c = 0; c &lt;= 1; c++) {
        if (trie[cur].child[c]) clear(trie[cur].child[c]);
    }
    memset(&amp;trie[cur], 0, sizeof(trie[cur]));
}
void clearall() {
    id = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (root[i]) clear(root[i]), root[i] = 0;
    }
}
 
void Query(int l, int r) {
    ans = 0;
    tmp.clear();
    dfs(root[l-1], root[r], M);
    cout &lt;&lt; ans &lt;&lt; endl;
}
 
int T, a[maxn];
int main() {
    cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; i++) {
            cin &gt;&gt; a[i];
            if (!root[i]) root[i] = ++id;
            insert(root[i-1], root[i], a[i]);
        }
        int q; cin &gt;&gt; q;
        while (q--) {
            int l, r; cin &gt;&gt; l &gt;&gt; r;
            Query(l, r);
        }
        clearall();
    }
}

</code></pre>
</details>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://oi-wiki.org/string/trie/#_6">https://oi-wiki.org/string/trie/#_6</a></li>
<li><a href="https://oi-wiki.org/ds/persistent-trie/">https://oi-wiki.org/ds/persistent-trie/</a></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2022-10-24 22:41:47 -0500 -0500">2022-10-24</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/9cd44d43ae956930660def846f7d0cb1a590bbfa" title="fix cf-problem.js C1,C2,D1,D2 rendering problems" target="_blank">(9cd44d4)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/059-01trie.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/trie/">Trie</a>
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/060-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">最小生成树</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/058-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">
            <span class="next-text nav-default">单调栈/队列</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
