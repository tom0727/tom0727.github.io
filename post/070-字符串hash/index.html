<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>字符串Hash - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="介绍 字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。 一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3&amp;hellip;a_n$ 的哈希值为： $$a_1 p^{n-1} &#43;" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/070-%E5%AD%97%E7%AC%A6%E4%B8%B2hash/" />
<link rel="manifest" href="/manifest.json">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="字符串Hash" />
<meta property="og:description" content="介绍 字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。 一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3&hellip;a_n$ 的哈希值为： $$a_1 p^{n-1} &#43;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/070-%E5%AD%97%E7%AC%A6%E4%B8%B2hash/" />
<meta property="article:published_time" content="2022-08-28T23:23:53-05:00" />
<meta property="article:modified_time" content="2024-01-07T00:32:57+00:00" />
<meta itemprop="name" content="字符串Hash">
<meta itemprop="description" content="介绍 字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。 一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3&hellip;a_n$ 的哈希值为： $$a_1 p^{n-1} &#43;">
<meta itemprop="datePublished" content="2022-08-28T23:23:53-05:00" />
<meta itemprop="dateModified" content="2024-01-07T00:32:57&#43;00:00" />
<meta itemprop="wordCount" content="4913">



<meta itemprop="keywords" content="字符串,Hash," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字符串Hash"/>
<meta name="twitter:description" content="介绍 字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。 一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3&hellip;a_n$ 的哈希值为： $$a_1 p^{n-1} &#43;"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">字符串Hash</h1>

      <div class="post-meta">
        <span class="post-time" title="2022-08-28 23:23:53 -0500 -0500"> 2022-08-28 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#应用">应用</a>
          <ul>
            <li><a href="#o1-判断回文串">O(1) 判断回文串</a></li>
            <li><a href="#最长回文子串-on">最长回文子串 $O(n)$</a></li>
          </ul>
        </li>
        <li><a href="#模版-取模双哈希">模版 (取模双哈希)</a></li>
        <li><a href="#模版-自然溢出哈希">模版 (自然溢出哈希)</a></li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-cf1721ehttpscodeforcescomcontest1721probleme">例1 <a href="https://codeforces.com/contest/1721/problem/E">CF1721E</a></a></li>
            <li><a href="#例2-洛谷p4287-shoi2011双倍回文httpswwwluogucomcnproblemp4287">例2 <a href="https://www.luogu.com.cn/problem/P4287">洛谷P4287 [SHOI2011]双倍回文</a></a></li>
            <li><a href="#例3-icpc2018南京m-mediocre-string-problemhttpscodeforcescomgym101981attachmentsdownload789120182019-acmicpc-asia-nanjing-regional-contest-enpdf">例3 <a href="https://codeforces.com/gym/101981/attachments/download/7891/20182019-acmicpc-asia-nanjing-regional-contest-en.pdf">ICPC2018南京M Mediocre String Problem</a></a></li>
            <li><a href="#例4-atcoder-abc135f-strings-of-eternityhttpsatcoderjpcontestsabc135tasksabc135_f">例4 Atcoder ABC135F. <a href="https://atcoder.jp/contests/abc135/tasks/abc135_f">Strings of Eternity</a></a></li>
            <li><a href="#例5-cf710f-string-set-querieshttpscodeforcescomcontest710problemf">例5 CF710F. <a href="https://codeforces.com/contest/710/problem/F">String Set Queries</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="介绍">介绍</h2>
<p>字符串哈希可以在 $O(n)$ 时间内预处理一个字符串，然后在 $O(1)$ 的时间内查询任何字串的哈希值。</p>
<p>一般来讲我们从左往右 build 哈希值，一个 string $a_1a_2a_3&hellip;a_n$ 的哈希值为：</p>
<p>$$a_1 p^{n-1} + a_2 p^{n-2} + a_3 p^{n-3} + &hellip; + a_n p^0$$</p>
<p>其中 $a_i$ 为该字符的 ASCII值。</p>
<p>build 方法如下：</p>
<pre><code class="language-cpp">ll p[maxn];
int base = 31;
const int MOD = 1e9 + 7;
void p_init() {
    p[0] = 1;
    for (int i = 1; i &lt;= maxn-1; i++) {
        p[i] = p[i-1] * base % MOD;
    }
}
</code></pre>
<p>求一个子串 $s[L,R]$ 的哈希值：只需要维护一个前缀和 $sum$，其中 $sum[R]$ 代表 $s[1&hellip;R]$ 的哈希值。</p>
<p>$$sum[R] = (a_1 p^{R-1} + a_2 p^{R-2} + &hellip; + a_{L-1} p^{R-L+1}) + (a_{L} p^{R-L} + &hellip; + a_R p^0)$$</p>
<p>$$sum[L-1] = a_1 p^{L-2} + a_2 p^{L-3} + &hellip; + a_{L-1} p^0$$</p>
<p>然后就有：</p>
<p>$$sum[R]-(sum[L] * p^{R-L+1}) = (a_{L} p^{R-L} + &hellip; + a_R p^0) = HASH(s[L&hellip;R])$$</p>
<p>总结：<code>hash[L...R] = sum[R] - sum[L] * p[R-L+1]</code></p>
<h2 id="应用">应用</h2>
<h3 id="o1-判断回文串">O(1) 判断回文串</h3>
<p>对于原字符串进行一次预处理，反过来再预处理一次，然后判断 $s[L,R]$ 正过来和反过来的哈希值是否相等即可。</p>
<h3 id="最长回文子串-on">最长回文子串 $O(n)$</h3>
<p>利用 <strong>DP</strong>：设 $R_i$ 为以 $i$ 结尾的最长回文的长度，那么答案为 $\max_{i=1}^n R_i$。</p>
<p>注意到 $R_i \leq R_{i-1} + 2$，所以每次暴力从 $R_{i-1} + 2$ 开始递减，找到第一个回文串为止。</p>
<p>复杂度：每次 $i$ 增大时，$R_{i}$ 增加 $2$，每次循环减少 $1$，所以复杂度为 $O(2n)$。</p>
<h2 id="模版-取模双哈希">模版 (取模双哈希)</h2>
<pre><code class="language-cpp">const int maxn = 5e5+5;
const int NUM = 2;
ll base[2] = {131, 137};
int MOD[2] = {(int)(1e9+7), (int)(1e9+9)};
ll p[maxn][NUM];

void p_init() {
    for (int j = 0; j &lt; NUM; j++) {
        p[0][j] = 1;
        for (int i = 1; i &lt;= maxn-1; i++) {
            p[i][j] = p[i-1][j] * base[j] % MOD[j];
        }
    }
}

struct StringHash {
    ll hs[maxn][NUM];
    int n;
    void init(string&amp; s) {
        n = s.size();
        for (int j = 0; j &lt; NUM; j++) {
            for (int i = 1; i &lt;= n; i++) {
                hs[i][j] = (hs[i-1][j] * base[j] % MOD[j] + (ll)s[i-1]) % MOD[j];
            }
        }
    }
    // get the hash of j-th HASH function
    int gethash(int l, int r, int j) {
        return (hs[r][j] - hs[l-1][j] * p[r-l+1][j] % MOD[j] + MOD[j]) % MOD[j];
    }
    array&lt;int, NUM&gt; gethash(int l, int r) {
        array&lt;int, NUM&gt; res;
        for (int j = 0; j &lt; NUM; j++) {
            res[j] = gethash(l, r, j);
        }
        return res;
    }
};

int n;
string s;
StringHash hs, rev_hs;
bool isPalindrome(int l, int r) {
    return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1);
}

int main() {
    p_init();  // 先 init 所有p 的次方
    cin &gt;&gt; s &gt;&gt; t;
    n = s.size();
    hs.init(s);
    reverse(s.begin(), s.end());
    rev_hs.init(s);

    isPalindrome(1, n);  // 测试
}
</code></pre>
<h2 id="模版-自然溢出哈希">模版 (自然溢出哈希)</h2>
<details class="admonition note"><summary class="admonition-title">自然溢出</summary>
<p>没有 MOD 操作，依靠 <code>unsigned long long</code> 的 $2^{64}$ 自然溢出取模，速度快很多。</p>
<p>不是特别推荐这种方法，无论双哈希或者如何选择 base 都会被卡，卡自然溢出哈希的方法见 <a href="https://notes.sshwy.name/Math/Rolling-Hash-and-Hack/" target="_blank">这里</a></p>
<p>• 注意需要用 <code>ull (unsigned long long)</code></p>
<pre><code class="language-cpp">const int maxn = 5e5+5;
const int NUM = 1;
ull base[2] = {131, 137};
ull p[maxn][NUM];  // 注意这里换成了 ull

void p_init() {
    for (int j = 0; j &lt; NUM; j++) {
        p[0][j] = 1;
        for (int i = 1; i &lt;= maxn-1; i++) {
            p[i][j] = p[i-1][j] * base[j];
        }
    }
}
 
struct StringHash {
    ull hs[maxn][NUM];
    string s;
    int n;
    void init() {
        n = s.size();
        for (int j = 0; j &lt; NUM; j++) {
            for (int i = 1; i &lt;= n; i++) {
                hs[i][j] = hs[i-1][j] * base[j] + s[i-1];
            }
        }
    }
    // get the hash of j-th HASH function
    ull gethash(int l, int r, int j) {
        return hs[r][j] - hs[l-1][j] * p[r-l+1][j];
    }
    array&lt;ull, NUM&gt; gethash(int l, int r) {
        array&lt;ull, NUM&gt; res;
        for (int j = 0; j &lt; NUM; j++) {
            res[j] = gethash(l, r, j);
        }
        return res;
    }
};


int n;
string s;
StringHash hs, rev_hs;
bool isPalindrome(int l, int r) {
    return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1);
}

int main() {
    p_init();  // 先 init 所有p 的次方
    cin &gt;&gt; s &gt;&gt; t;
    n = s.size();
    hs.s = s; rev_hs.s = s;;
    reverse(rev_hs.s.begin(), rev_hs.s.end());
    hs.init(); rev_hs.init();

    isPalindrome(1, n);  // 测试
}
</code></pre>
</details>
<h2 id="例题">例题</h2>
<h3 id="例1-cf1721ehttpscodeforcescomcontest1721probleme">例1 <a href="https://codeforces.com/contest/1721/problem/E" target="_blank">CF1721E</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定一个 string $s$，并且给定 $q$ 次询问，每次询问一个 string $t$，并且进行如下操作：</p>
<ol>
<li>将 $t$ 连在 $s$ 后面。</li>
<li>询问 $|s|+1, |s|+2, &hellip;, |s|+|t|$ 位置的 prefix function</li>
<li>将字符串恢复为 $s$。</li>
</ol>
<p>定义一个string $a$ 的 prefix function为：$p_1, p_2, &hellip;, p_{|a|}$，其中 $p_i$ 是最大的 $k$ 使得：</p>
<ol>
<li>$k &lt; i$ 且</li>
<li>$a[1&hellip;k] = a[i-k+1 &hellip; i]$</li>
</ol>
<p>即最长的 $k$ 使得前缀等于后缀。</p>
<p>其中，$|s| \leq 10^6, q \leq 10^5, |t| \leq 10$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先我们可以发现，在 $t$ 连在 $s$ 后面时，我们可以很简单的处理哈希值。</p>
<p>现在考虑怎么计算 prefix function？</p>
<p>我们不能用哈希 + 二分，因为它不具有单调性，例如 <code>abab</code>，对于 $k=1$ 不成立，但是 $k=2$ 成立。</p>
<hr>
<p>考虑另外一个方法：</p>
<p>如果前缀等于后缀，那么它应该是：</p>
<p>$$s_1 s_2 &hellip; s_k = s_{x} s_{x+1} &hellip; s_n t_1 t_2 &hellip; t_m$$</p>
<p>注意到我们可以拆成两段：</p>
<p>$$s_1 s_2 &hellip; s_{k-m} = s_{x} s_{x+1} &hellip; s_n$$</p>
<p>$$s_{k-m+1} &hellip; s_k = t_1 t_2 &hellip; t_m$$</p>
<p>前面一段实际上是 $s$ 本身的前缀后缀 matching，可以预处理。</p>
<p>后面一段是 $t$ 在 $s$ 里面的一个匹配。</p>
<p>所以问题转变成：</p>
<p>只要 $t$ 在 $s$ 中有一个匹配 $t = s[i &hellip; i+m-1]$，并且 $s[1&hellip;i-1] = s[n-i &hellip; n]$ 即可。</p>
<p>就剩下一个问题：如果要将 $t$ 在 $s$ 中匹配很多次，复杂度会爆炸。</p>
<p>鉴于 $|t| \leq 10$，我们可以对于每个位置 $i$ 都判断一下是否有前缀等于后缀，如果有，那么提前储存 $s[i&hellip;i], s[i&hellip;i+1] &hellip; s[i&hellip;i+m-1]$ 这些子串的哈希值，然后匹配即可。</p>
<p>最后注意一些边界情况：在一个位置的prefix function $&gt; |s|$ 时没有考虑到，暴力枚举一下即可。</p>
<p>• 为了防止 map 爆炸，所以根据子串长度分开几个 map 来储存。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int qpow(ll a, ll b, ll P) {
    ll res = 1;
    while (b) {
        if (b &amp; 1)
            res = res * a % P;
        a = a * a % P;
        b &gt;&gt;= 1;
    }
    return res;
}
 
const int NUM = 2;
struct StringHash {
    int hs[maxn][NUM];
    int MOD[NUM] = {(ll)1e9+7, (ll)1e9+9};
    int p[NUM] = {131, 137};
    int inv[maxn][NUM];
 
    string s;
    int n;
 
    void init() {
        n = s.size();
        for (int j = 0; j &lt; NUM; j++) {
            int P = 1, invP = qpow(p[j], MOD[j]-2, MOD[j]);
            inv[0][j] = 1;
            for (int i = 1; i &lt;= n; i++) {
                P = (ll)P * p[j] % MOD[j];
                inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j];
                hs[i][j] = (hs[i-1][j] + (ll)s[i-1] * P % MOD[j]) % MOD[j];
            }
        }
    }
 
    void concat(string t) {
        int m = t.size();
        for (int j = 0; j &lt; NUM; j++) {
            for (int i = n+1; i &lt;= n+m; i++) inv[i][j] = hs[i][j] = 0;
            int P = qpow(p[j], n, MOD[j]), invP = qpow(p[j], MOD[j]-2, MOD[j]);
            for (int i = n+1; i &lt;= n+m; i++) {
                P = (ll)P * p[j] % MOD[j];
                inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j];
                hs[i][j] = (hs[i-1][j] + (ll)t[i-n-1] * P % MOD[j]) % MOD[j];
            }
        }
    }
 
    // get the hash of j-th HASH function
    int gethash(int l, int r, int j) {
        ll sum = (hs[r][j] - hs[l-1][j] + MOD[j]) % MOD[j];
        return sum * inv[l-1][j] % MOD[j];
    }
 
    array&lt;int, NUM&gt; gethash(int l, int r) {
        array&lt;int, NUM&gt; res;
        for (int j = 0; j &lt; NUM; j++) {
            res[j] = gethash(l, r, j);
        }
        return res;
    }
} hs;
 
map&lt;array&lt;int, NUM&gt;, int&gt; mp[11];
int n,m;
int main() {
    cin &gt;&gt; hs.s;
    hs.init();
    n = hs.s.size();
    int Q; cin &gt;&gt; Q;
 
    for (int i = 1; i &lt;= n-1; i++) {
        if (hs.gethash(1, i) == hs.gethash(n-i+1, n)) {
            for (int j = 1; j &lt;= 10; j++) {
                if (i+j &gt; n) break;
                array&lt;int, NUM&gt; h = hs.gethash(i+1, i+j);
                mp[j][h] = i;
            }
        }
    }
 
    while (Q--) {
        string t; cin &gt;&gt; t;
        hs.concat(t);
        m = t.size();

        for (int i = 1; i &lt;= m; i++) {
            int ans = 0;
            int r = n+i;
            for (int j = 1; j &lt;= min(2*m, n+i-1); j++) {
                if (hs.gethash(1, j) == hs.gethash(r-j+1, r)) ans = j;
            }
 
            auto h = hs.gethash(n+1, n+i);
            if (mp[i].count(h)) {
                ans = max(ans, i + mp[i][h]);
            }
 
            for (int j = n+i-1; j &gt;= n; j--) {
                if (hs.gethash(1, j) == hs.gethash(n+i+1-j, n+i)) {
                    ans = max(ans, j);
                }
            }
 
            cout &lt;&lt; ans &lt;&lt; &quot; &quot;;
        }
 
        cout &lt;&lt; &quot;\n&quot;;
    }
}

</code></pre>
</details>
<h3 id="例2-洛谷p4287-shoi2011双倍回文httpswwwluogucomcnproblemp4287">例2 <a href="https://www.luogu.com.cn/problem/P4287" target="_blank">洛谷P4287 [SHOI2011]双倍回文</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>如果一个字符串能写成 $ss^{-1}ss^{-1}$ 的形式，那么它是一个双倍回文。</p>
<p>给定一个字符串，求它的最长双倍回文子串长度。</p>
<p>其中，$n \leq 5 \times 10^5$。</p>
</div>
<div class="admonition info">
  <p class="admonition-title">回文串性质</p>
<p>首先明确一个性质：</p>
<blockquote>
<p>对于一个长度为 $n$ 的字符串 $s$，它的本质不同的回文子串数量最多只有 $n$ 个。</p>
</blockquote>
<p>证明：利用归纳。</p>
<p>对于 $n=1$ 显然成立，设对于 $n-1$ 都成立，那么当长度为 $n$ 时：</p>
<p>设 $s = tc$，其中 $t$ 为长度为 $(n-1)$ 的字符串，$c$ 是新加的字符，根据假设 $t$ 符合上述规则。</p>
<p>考虑以 $c$ 结尾的回文子串，假设它们的左端点从小到大排序为 $l_1, l_2, &hellip;, l_k$，则我们可以知道仅有 $s[l_1 &hellip; n]$ 可能为新增的回文串，因为对于任何 $l_j, j &gt; 2$，$s[l_j &hellip; n] = s[l_1 &hellip; n + l_1 - l_j]$ 一定出现过了。</p>
<p><img src="/images/070/1.jpg" alt="img"></p>
<p>• 也就是说，在每次新增一个字符时，只用考虑以它为结尾的<strong>最长回文子串</strong>即可。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先我们知道，一个双倍回文子串一定是一个回文子串，所以它也遵循如上性质。</p>
<p>既然本质不同的回文子串数量只有 $n$ 个，那我们只要每一个都check一下是否符合双倍回文即可。</p>
<p>那么按照 $O(n)$ 的最长回文子串的做法，就是考虑了所有不同的回文子串。</p>
<hr>
<p>如何在 $O(1)$ 时间内判断一个字符串是否为回文串/双倍回文串？</p>
<p>把原字符串 $s$ 反过来，复制一份为 $t$，然后在 $t$ 上再预处理一次hashing即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod = 998244353;
const int maxn = 5e5+5;
const int maxm = 3e5+50;

int qpow(ll a, ll b, ll P) {
    ll res = 1;
    while (b) {
        if (b &amp; 1)
            res = res * a % P;
        a = a * a % P;
        b &gt;&gt;= 1;
    }
    return res;
}

const int NUM = 2;
struct StringHash {
    int hs[maxn][NUM];
    int MOD[NUM] = {(ll)1e9+7, (ll)1e9+9};
    int p[NUM] = {131, 137};
    int inv[maxn][NUM];

    string s;
    int n;

    void init() {
        n = s.size();
        for (int j = 0; j &lt; NUM; j++) {
            int P = 1, invP = qpow(p[j], MOD[j]-2, MOD[j]);
            inv[0][j] = 1;
            for (int i = 1; i &lt;= n; i++) {
                P = (ll)P * p[j] % MOD[j];
                inv[i][j] = (ll)inv[i-1][j] * invP % MOD[j];
                hs[i][j] = (hs[i-1][j] + (ll)s[i-1] * P % MOD[j]) % MOD[j];
            }
        }
    }

    // get the hash of j-th HASH function
    int gethash(int l, int r, int j) {
        ll sum = (hs[r][j] - hs[l-1][j] + MOD[j]) % MOD[j];
        return sum * inv[l-1][j] % MOD[j];
    }

    array&lt;int, NUM&gt; gethash(int l, int r) {
        array&lt;int, NUM&gt; res;
        for (int j = 0; j &lt; NUM; j++) {
            res[j] = gethash(l, r, j);
        }
        return res;
    }
} hs, hs2;

int n;
int dp[maxn];  // 以 i 结尾的回文串长度
bool isPalindrome(int l, int r) {
	return hs.gethash(l, r) == hs2.gethash(n-r+1, n-l+1);
}
bool check(int l, int r) {
    int len = r-l+1;
    if (len % 4) return 0;
    if (!isPalindrome(l,r)) return 0;
    if (!isPalindrome(r-len/2+1, r)) return 0;
    return 1;
}

int main() {
    cin &gt;&gt; n;
    cin &gt;&gt; hs.s;
    hs.init();
    hs2.s = hs.s;
    reverse(hs2.s.begin(), hs2.s.end());
    hs2.init();
    int ans = 0;

    for (int i = 1; i &lt;= n; i++) {
        for (int len = min(i, dp[i-1]+2); len &gt;= 1; len--) {
            if (check(i-len+1, i)) ans = max(ans, len);
            if (isPalindrome(i-len+1, i)) {
                dp[i] = len;
                break;
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例3-icpc2018南京m-mediocre-string-problemhttpscodeforcescomgym101981attachmentsdownload789120182019-acmicpc-asia-nanjing-regional-contest-enpdf">例3 <a href="https://codeforces.com/gym/101981/attachments/download/7891/20182019-acmicpc-asia-nanjing-regional-contest-en.pdf" target="_blank">ICPC2018南京M Mediocre String Problem</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定两个string $s,t$，求满足以下条件的三元组 $(i,j,k)$ 的数量：</p>
<ol>
<li>$1 \leq i \leq j \leq |s|$</li>
<li>$1 \leq k \leq |t|$</li>
<li>$j-i+1 &gt; k$</li>
<li>$s[i&hellip;j] + t[1&hellip;k]$ 是一个回文串。</li>
</ol>
<p>其中 $s \in [2, 10^6], t \in [1, |s|)$</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>我们看第四条：如果 $s[i&hellip;j] + t[1&hellip;k]$ 是一个回文串，因为第三条规定了 $s[i&hellip;j]$ 是比 $t[1&hellip;k]$ 长的，所以我们可以把 $s[i&hellip;j]$ 分成两个部分：</p>
<p>$s[i&hellip;i+k-1]$ 和 $s[i+k&hellip;j]$，其中：</p>
<ol>
<li>$s[i&hellip;i+k-1]$ 反过来和 $t[1&hellip;k]$ 完全一样。</li>
<li>$s[i+k&hellip;j]$ 是一个回文串。</li>
</ol>
<p><img src="/images/070/2.jpg" alt="img"></p>
<p>并且假如我们固定 $i+k-1$ 这个位置，并且让 $i$ 逐渐增大，$k$ 随之减小，那么 $(i,j,k)$ 仍然是一个回文串。</p>
<p>我们需要知道：以 $i+k-1$ 开头的回文串有多少个？这个值乘上 $k$ 就是固定了这个 $i+k-1$ 的值对答案的贡献了。</p>
<hr>
<p>考虑如下问题：以 $i$ 开头的回文串有几个？</p>
<p>一般对于这种问题，我们需要考虑固定一个点来哈希+二分，这里固定开头或者结尾是不行的，那固定<strong>对称中心</strong>呢？是可行的。</p>
<p>所以我们枚举对称中心，然后利用哈希+二分求出最长的回文半径，用差分数组进行区间加即可。</p>
<p>• 注意枚举奇数和偶数两种情况。</p>
<hr>
<p>有了上述信息，我们只要枚举 $i+k-1$ 的值，然后将 $t$ 先反转过来得到 $t_r$，那么每次要找的就是</p>
<p>$s[1&hellip;i+k-1]$ 与 $t_r[1&hellip;|t|]$ 的最长后缀，同样用哈希+二分即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6+5;
ull base = 131;
ull p[maxn];
 
void p_init() {
    p[0] = 1;
    for (int i = 1; i &lt;= maxn-1; i++) {
        p[i] = p[i-1] * base;
    }
}
 
struct StringHash {
    ull hs[maxn];
    string s;
    int n;
    void init() {
        n = s.size();
        for (int i = 1; i &lt;= n; i++) {
            hs[i] = hs[i-1] * base + s[i-1];
        }
    }
    ull gethash(int l, int r) {
        return hs[r] - hs[l-1] * p[r-l+1];
    }
};
 
int n,m;
int st[maxn];  // st[i]: the number of palindromes index starts with i (in s)
 
string s,t;
StringHash hs, rev_hs, rev_ht;
bool isPalindrome(int l, int r) {
    return hs.gethash(l, r) == rev_hs.gethash(n-r+1, n-l+1);
}
void init_st() {
    // 枚举奇数长度的回文串
    for (int mid = 1; mid &lt;= n; mid++) {
        int l = 0, r = min(mid-1, n-mid);
        int res = 0;
        while (l &lt;= r) {
            int c = (l+r) &gt;&gt; 1;
            int L = mid-c, R = mid+c;
            if (isPalindrome(L, R)) {
                res = c;
                l = c + 1;
            } else r = c - 1;
        }
        st[mid-res]++;
        st[mid+1]--;
    }
 
    // 偶数长度的回文串
    for (int mid = 1; mid &lt; n; mid++) {
        if (s[mid-1] != s[mid]) continue;  // 这里特判一下
        int l = 0, r = min(mid-1, n-mid-1);
        int res = 0;
        while (l &lt;= r) {
            int c = (l+r) &gt;&gt; 1;
            int L = mid-c, R = mid+1+c;
            if (isPalindrome(L, R)) {
                res = c;
                l = c + 1;
            } else r = c - 1;
        }
        st[mid-res]++;
        st[mid+1]--;
    }
 
    for (int i = 1; i &lt;= n; i++) st[i] = st[i] + st[i-1];
}
 
 
int main() {
    p_init();
    cin &gt;&gt; s &gt;&gt; t;
    n = s.size(), m = t.size();
    hs.s = s; rev_hs.s = s; rev_ht.s = t;
    reverse(rev_hs.s.begin(), rev_hs.s.end());
    reverse(rev_ht.s.begin(), rev_ht.s.end());
    hs.init(); rev_hs.init(); rev_ht.init();
 
    init_st();  // init the start array
 
    ll ans = 0;
    for (int x = 1; x &lt;= n-1; x++) {
        // 匹配 s[1...x] 与 rev_t[] 的最长后缀
        int l = 1, r = min(x, m);
        int res = 0;
        while (l &lt;= r) {
            int mid = (l + r) &gt;&gt; 1;
            if (hs.gethash(x-mid+1, x) == rev_ht.gethash(m-mid+1, m)) {
                res = mid;
                l = mid + 1;
            } else r = mid - 1;
        }
        ans += (ll)st[x+1] * (ll)res;
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
}
</code></pre>
</details>
<h3 id="例4-atcoder-abc135f-strings-of-eternityhttpsatcoderjpcontestsabc135tasksabc135_f">例4 Atcoder ABC135F. <a href="https://atcoder.jp/contests/abc135/tasks/abc135_f" target="_blank">Strings of Eternity</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定两个string $s,t$，求一个最大的 $i$，使得存在一个 $j \geq 0$，使得 $t$ 的 $i$ 个copy是 $s$ 的 $j$ 个copy的一个substring。</p>
<p>如果这个 $i$ 可能是无穷大，输出 $-1$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>思路巧妙的图论题。</p>
<p>我们先考虑 $i=1$ 的情况，这说明 $t$ 从 $s$ 的一个后缀开始，经过 $s$ 的一些copy，然后到 $s$ 的某一个前缀结束。</p>
<p>所以可以看作是从 $s$ 的一个index $u$ 到了另外一个index $v$。</p>
<p>于是我们连边 $(u,v+1)$。</p>
<p>那么 $i &gt; 1$ 的情况就可以递推得到：也就是顺着这些边走 $i$ 次。</p>
<p>所以如果最后图中有环，就是 $-1$，没有环的话，只要看在图中最深能走多远即可。</p>
<p>• 我们用字符串哈希来 $O(1)$ 找出每一个 $u$ 出发，能走到哪个 $v$。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
StringHash hs, ht;
vector&lt;int&gt; adj[maxn];
int dp[maxn], vis[maxn];
bool ok = 1;
int ID = 0;
void dfs(int u, int p) {
    dp[u] = 0;
    vis[u] = ID;
    for (int v : adj[u]) {
        if (dp[v] != -1 &amp;&amp; vis[v] == ID) {
            ok = 0;
            return;
        }
        dfs(v, p);
        dp[u] = dp[v] + 1;
    }
}

int main() {
    p_init();
    string s, t;
    cin &gt;&gt; s &gt;&gt; t;
    int n = s.size(), m = t.size();
    while (s.size() &lt; 1e6) s += s;
    hs.s = s;
    ht.s = t;
    hs.init();
    ht.init();
    for (int i = 1; i &lt;= n; i++) {
        if (hs.gethash(i, i+m-1) == ht.gethash(1, m)) {
            int R = i + m;  // [1...n], [n+1...2n]
            R %= n;
            if (!R) R = n;
            adj[i].push_back(R);
        }
    }
    memset(dp, -1, sizeof(dp));
    memset(vis, -1, sizeof(vis));
    int ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (dp[i] == -1) {
            dfs(i, ++ID);
            ans = max(ans, dp[i]);
        }
    }
    if (ok) cout &lt;&lt; ans &lt;&lt; endl;
    else cout &lt;&lt; -1 &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例5-cf710f-string-set-querieshttpscodeforcescomcontest710problemf">例5 CF710F. <a href="https://codeforces.com/contest/710/problem/F" target="_blank">String Set Queries</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>初始状态下给定一个空的集合 $D$，给定 $m$ 个询问，询问有 3 种：</p>
<ol>
<li>将一个 string $s$ 加入集合 $D$。</li>
<li>将一个 string $s$ 从集合 $D$ 中删除。</li>
<li>给定一个字符串 $s$，回答 $D$ 中的所有字符串，在 $s$ 中出现的次数之和。</li>
</ol>
<p>例如：<code>D = {&quot;a&quot;, &quot;abc&quot;}</code>, <code>s = &quot;aabc&quot;</code>，那么 <code>&quot;a&quot;</code> 出现了 $2$ 次，而 <code>&quot;abc&quot;</code> 出现了 $1$ 次，所以本次询问答案为 $3$。</p>
<p>其中，$m \leq 3 \times 10^5$，所有询问中的所有字符串的长度和不超过 $3 \times 10^5$，询问强制在线。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>经典套路：注意到字符串的不同长度只有 $\sqrt {3 \times 10^5}$ 种。</p>
<p>我们直接将所有 $D$ 中的字符串哈希一下，然后将其哈希值根据字符串长度放在相应的 set 里面。</p>
<p>在询问 $3$ 出现时，直接哈希这个字符串 $s$，并且暴力枚举 $s$ 的每一个开头，并查询当前 $D$ 中存在的所有长度（最多 $\sqrt {3 \times 10^5}$ 种）中的 set，询问其对应长度的哈希值是否存在。</p>
<p>最终复杂度 $m \sqrt m$，用单哈希（取模）勉强能卡过去。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int NUM = 1;
ll base[2] = {131, 137};
int MOD[2] = {(int)(1e9+7), (int)(1e9+9)};
ll p[maxn][NUM];

void p_init() {
    for (int j = 0; j &lt; NUM; j++) {
        p[0][j] = 1;
        for (int i = 1; i &lt;= maxn-1; i++) {
            p[i][j] = p[i-1][j] * base[j] % MOD[j];
        }
    }
}

ll tmp[maxn][NUM];
void cal_hash(string&amp; s) {
    int n = s.size();
    for (int j = 0; j &lt; NUM; j++) {
        for (int i = 1; i &lt;= n; i++) {
            tmp[i][j] = (tmp[i-1][j] * base[j] % MOD[j] + (ll)s[i-1]) % MOD[j];
        }
    }
}

struct StringHash {
    ll hs[maxn][NUM];
    int n;
    void init(string&amp; s) {
        n = s.size();
        for (int j = 0; j &lt; NUM; j++) {
            for (int i = 1; i &lt;= n; i++) {
                hs[i][j] = (hs[i-1][j] * base[j] % MOD[j] + (ll)s[i-1]) % MOD[j];
            }
        }
    }
    // get the hash of j-th HASH function
    int gethash(int l, int r, int j) {
        return (hs[r][j] - hs[l-1][j] * p[r-l+1][j] % MOD[j] + MOD[j]) % MOD[j];
    }
    array&lt;int, NUM&gt; gethash(int l, int r) {
        array&lt;int, NUM&gt; res;
        for (int j = 0; j &lt; NUM; j++) {
            res[j] = gethash(l, r, j);
        }
        return res;
    }
} hs;

set&lt;string&gt; se[maxn];
int cnt[maxn];
unordered_set&lt;int&gt; have;
unordered_set&lt;ll&gt; hashset[maxn];

int main() {
    p_init();
    int M; cin &gt;&gt; M;
    while (M--) {
        int t; string s; cin &gt;&gt; t &gt;&gt; s;
        int n = s.size();
        if (t == 1) {
            se[n].insert(s);
            cnt[n]++;
            if (cnt[n] == 1) have.insert(n);
            cal_hash(s);
            ll val = tmp[n][0];
            hashset[n].insert(val);
        } else if (t == 2) {
            se[n].erase(s);
            cnt[n]--;
            if (cnt[n] == 0) have.erase(n);
            cal_hash(s);
            ll val = tmp[n][0];
            hashset[n].erase(val);
        } else {
            hs.init(s);
            int res = 0;
            for (int i = 1; i &lt;= n; i++) {
                for (int len : have) {
                    if (i + len - 1 &lt;= n) {
                        ll val = hs.gethash(i, i+len-1, 0);
                        if (hashset[len].count(val)) res++;
                    }
                }
            }
            cout &lt;&lt; res &lt;&lt; endl;
        }
    }
}
</code></pre>
</details>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2024-01-07 00:32:57 &#43;0000 UTC">2024-01-07</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/0127ee2ee4c087dd157e1f21499b610ec4bd6c31" title="chore: update CF Problems" target="_blank">(0127ee2)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/070-%e5%ad%97%e7%ac%a6%e4%b8%b2hash.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          <a href="/tags/hash/">Hash</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/071-icpc2020mid-central/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">ICPC2020 Mid Central USA</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/069-icpc2020%E6%BE%B3%E9%97%A8/">
            <span class="next-text nav-default">ICPC2020澳门</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2024
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
