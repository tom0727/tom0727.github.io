<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[置顶]竞赛注意事项/通用模版 - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="注意事项 Set中的Comparator定义 在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如： • 注意这里" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/072-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E9%80%9A%E7%94%A8%E6%A8%A1%E7%89%88/" />
<link rel="manifest" href="/manifest.json">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="[置顶]竞赛注意事项/通用模版" />
<meta property="og:description" content="注意事项 Set中的Comparator定义 在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如： • 注意这里" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/072-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E9%80%9A%E7%94%A8%E6%A8%A1%E7%89%88/" />
<meta property="article:published_time" content="2022-09-19T10:26:35-05:00" />
<meta property="article:modified_time" content="2024-06-11T00:31:26+00:00" />
<meta itemprop="name" content="[置顶]竞赛注意事项/通用模版">
<meta itemprop="description" content="注意事项 Set中的Comparator定义 在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如： • 注意这里">
<meta itemprop="datePublished" content="2022-09-19T10:26:35-05:00" />
<meta itemprop="dateModified" content="2024-06-11T00:31:26&#43;00:00" />
<meta itemprop="wordCount" content="6456">



<meta itemprop="keywords" content=",," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[置顶]竞赛注意事项/通用模版"/>
<meta name="twitter:description" content="注意事项 Set中的Comparator定义 在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如： • 注意这里"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[置顶]竞赛注意事项/通用模版</h1>

      <div class="post-meta">
        <span class="post-time" title="2022-09-19 10:26:35 -0500 -0500"> 2022-09-19 </span>
        <div class="post-category">
            <a href="/categories//">  </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#注意事项">注意事项</a>
          <ul>
            <li><a href="#set中的comparator定义">Set中的Comparator定义</a></li>
            <li><a href="#swap函数的时间复杂度">swap函数的时间复杂度</a></li>
            <li><a href="#vector的unique--resize写法">vector的unique + resize写法</a></li>
            <li><a href="#compile-error-的一些解决方案">Compile Error 的一些解决方案</a></li>
          </ul>
        </li>
        <li><a href="#通用模版">通用模版</a>
          <ul>
            <li><a href="#z自动取模整数">Z自动取模整数</a></li>
            <li><a href="#树状数组">树状数组</a></li>
            <li><a href="#st表">ST表</a></li>
            <li><a href="#线段树">线段树</a></li>
            <li><a href="#dijkstra">dijkstra</a></li>
          </ul>
        </li>
        <li><a href="#计时程序">计时程序</a></li>
        <li><a href="#几何模版">几何模版</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="注意事项">注意事项</h2>
<h3 id="set中的comparator定义">Set中的Comparator定义</h3>
<p>在定义Set的Comparator时，一定要小心保证元素不会因为定义被判定为重复，例如：</p>
<p>• 注意这里用了更精简的写法，利用 <code>tuple</code> 可以直接快速比较多个元素。</p>
<pre><code class="language-cpp">int cnt[maxn];
struct Cmp {
    bool operator()(int i, int j) const {
		return tuple {cnt[i], i} &lt; tuple {cnt[j], j};  // 一定要加上 i,j!
    }
};
set&lt;int, Cmp&gt; s;
</code></pre>
<p>这里 <code>if (cnt[i] == cnt[j]) return i &lt; j;</code> 非常关键，如果不加的话，那么 <code>cnt[i] == cnt[j]</code> 将会被判定为重复元素，导致 <code>i,j</code> 只能加入一个。</p>
<h3 id="swap函数的时间复杂度">swap函数的时间复杂度</h3>
<p>注意如果 $f,g$ 是两个数组，那么 <code>swap(f,g)</code> 的时间复杂度是 $O(n)$ 级别的！</p>
<h3 id="vector的unique--resize写法">vector的unique + resize写法</h3>
<pre><code class="language-cpp">vector&lt;int&gt; a {...};
sort(a.begin(), a.end());  // unique 之前需要sort
a.resize(unique(a.begin(), a.end()) - a.begin());
</code></pre>
<h3 id="compile-error-的一些解决方案">Compile Error 的一些解决方案</h3>
<p>除了syntax error以外，一些compile error也有可能是 <code>Compiler Memory Limit Exceeded</code> 导致的。</p>
<p>一些解决这个错误的方法：</p>
<ol>
<li>数组开小一些。</li>
<li>不要在 struct 内使用初始化。</li>
</ol>
<pre><code class="language-cpp">struct Node {
	int mx = -1e9, tag = 0;
};
</code></pre>
<p>比如这个，就可以把初始化去掉，在代码里手动初始化。</p>
<h2 id="通用模版">通用模版</h2>
<h3 id="z自动取模整数">Z自动取模整数</h3>
<details class="admonition note"><summary class="admonition-title">Z自动取模整数</summary>
<pre><code class="language-cpp">const int mod = 998244353;
 
template&lt;class T&gt;
T qpow(T a, int b) {
    T res = 1;
    while (b) {
        if (b &amp; 1) res *= a;
        a *= a;
        b &gt;&gt;= 1;
    }
    return res;
}
int norm(int x) {
    if (x &lt; 0) {
        x += mod;
    }
    if (x &gt;= mod) {
        x -= mod;
    }
    return x;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    Z(ll x) : x(norm((int)(x % mod))) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(mod - x));
    }
    Z inv() const {
        assert(x != 0);
        return qpow(*this, mod - 2);
    }
    Z &amp;operator*=(const Z &amp;rhs) {
        x = (ll)(x) * rhs.x % mod;
        return *this;
    }
    Z &amp;operator+=(const Z &amp;rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &amp;operator-=(const Z &amp;rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &amp;operator/=(const Z &amp;rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;a) {
        ll v;
        is &gt;&gt; v;
        a = Z(v);
        return is;
    }
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;a) {
        return os &lt;&lt; a.val();
    }
};
</code></pre>
</details>
<h3 id="树状数组">树状数组</h3>
<details class="admonition note"><summary class="admonition-title">树状数组</summary>
<pre><code class="language-cpp">struct BIT {
    ll tr[maxn];
    inline int lowbit(int x) { return x &amp; -x; }
    void update(int p, int val) {
        while (p &lt;= n) {
            tr[p] += val;
            p += lowbit(p);
        }
    }
    // return sum[1...p]
	ll query(int p) {
        ll ans = 0;
        while (p &gt; 0) {
            ans += tr[p];
            p -= lowbit(p);
        }
        return ans;
    }
};
</code></pre>
</details>
<h3 id="st表">ST表</h3>
<details class="admonition note"><summary class="admonition-title">ST表</summary>
<pre><code class="language-cpp">struct SparseTable {
	vector&lt;int&gt; a;  // 长度应至少为 n+1
    int st[maxn][18], bin[maxn];
    int ask_st(int l, int r) {
        int len = r-l+1;
        int k = bin[len];
        return min(st[l][k], st[r-(1&lt;&lt;k)+1][k]);
    }
 
    void build_st() {
        bin[1] = 0; bin[2] = 1;
        for (int i = 3; i &lt; maxn; i++) bin[i] = bin[i&gt;&gt;1] + 1;
        for (int i = 1; i &lt;= n; i++) st[i][0] = a[i];
        for (int k = 1; k &lt; 18; k++) {
            for (int i = 1; i + (1&lt;&lt;k) - 1 &lt;= n; i++)
                st[i][k] = min(st[i][k-1], st[i+(1&lt;&lt;(k-1))][k-1]);
        }
    }
};
</code></pre>
</details>
<h3 id="线段树">线段树</h3>
<details class="admonition note"><summary class="admonition-title">线段树</summary>
<pre><code class="language-cpp">int n, m, a[maxn];

struct Node {
    ll sum, tag;
};

struct SegmentTree {
    Node tr[maxn&lt;&lt;2];
    void push_up(int cur) {
        tr[cur].sum = tr[cur&lt;&lt;1].sum + tr[cur&lt;&lt;1|1].sum;
    }
    void push_down(int cur, int l, int r) {
        if (!tr[cur].tag) return;
        ll tag = tr[cur].tag;
        tr[cur].tag = 0;
        int lc = cur&lt;&lt;1, rc = lc + 1;
        int mid = (l+r) &gt;&gt; 1;
        tr[lc].sum += tag * (mid-l+1);
        tr[rc].sum += tag * (r-mid);
        tr[lc].tag += tag;
        tr[rc].tag += tag;
    }
    void update(int cur, int l, int r, int L, int R, ll x) {
        if (L &lt;= l &amp;&amp; R &gt;= r) {
            tr[cur].tag += x;
            tr[cur].sum += x * (r-l+1);
            return;
        }
        push_down(cur, l, r);
        int mid = (l+r) &gt;&gt; 1;
        if (L &lt;= mid) update(cur&lt;&lt;1, l, mid, L, R, x);
        if (R &gt; mid) update(cur&lt;&lt;1|1, mid+1, r, L, R, x);
        push_up(cur);
    }
    void update(int cur, int l, int r, int p, ll x) {
        if (l == r) {
            tr[cur].sum += x; return;
        }
        push_down(cur, l, r);
        int mid = (l+r) &gt;&gt; 1;
        if (p &lt;= mid) update(cur&lt;&lt;1, l, mid, p, x);
        else update(cur&lt;&lt;1|1, mid+1, r, p, x);
        push_up(cur);
    } 
    ll query(int cur, int l, int r, int L, int R) {
        if (l &gt;= L &amp;&amp; r &lt;= R) return tr[cur].sum;
        push_down(cur, l, r);
        int mid = (l+r) &gt;&gt; 1;
        ll res = 0;
        if (L &lt;= mid) res += query(cur&lt;&lt;1, l, mid, L, R);
        if (R &gt; mid) res += query(cur&lt;&lt;1|1, mid+1, r, L, R);
        push_up(cur);
        return res;
    }
    void build(int cur, int l, int r) {
        if (l == r) {
            tr[cur].sum = a[l];
            return;
        }
        int mid = (l+r) &gt;&gt; 1;
        build(cur&lt;&lt;1, l, mid);
        build(cur&lt;&lt;1|1, mid+1, r);
        push_up(cur);
    }
} tr;
</code></pre>
</details>
<h3 id="dijkstra">dijkstra</h3>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">struct Edge {
    int u, v, w;
};
vector&lt;Edge&gt; adj[maxn];
struct Node {
    int v; ll d;
    bool operator&lt;(const Node&amp; other) const {
        return d &gt; other.d;
    }
};
struct Dijkstra {
    bool vis[maxn];
    ll dis[maxn];
    priority_queue&lt;Node&gt; pq;
    void run(int x) {
        memset(dis, -1, sizeof(dis));
        memset(vis, 0, sizeof(vis));
        pq.push({x, 0});
        dis[x] = 0;
        while (pq.size()) {
            auto [u, d] = pq.top(); pq.pop();
            if (vis[u]) continue;
            vis[u] = 1;
            for (auto [_, v, w] : adj[u]) {
                if (dis[v] == -1 || dis[v] &gt; dis[u] + w) {
                    dis[v] = dis[u] + w;
                    pq.push({v, dis[v]});
                }
            }
        }
    }
};
</code></pre>
</details>
<h2 id="计时程序">计时程序</h2>
<p>• <code>clock() / CLOCKS_PER_SEC</code> 可以返回程序运行的 <code>ms</code> 数。</p>
<pre><code class="language-cpp">const int MAX_TIME = 950;  // 950 ms
while ((double)clock() / CLOCKS_PER_SEC &lt; MAX_TIME) doSomething();
</code></pre>
<!-- ## 计算全局变量的Memory Usage -->
<h2 id="几何模版">几何模版</h2>
<p>kuangbin的板子：</p>
<p>链接：<a href="https://kuangbin.github.io/2019/04/28/20190428/" target="_blank">https://kuangbin.github.io/2019/04/28/20190428/</a></p>
<details class="admonition note"><summary class="admonition-title">kuangbin</summary>
<pre><code class="language-cpp">// `计算几何模板`
const double eps = 1e-8;
const double inf = 1e20;
const double pi = acos(-1.0);
const int maxp = 1010;
//`Compares a double to zero`
int sgn(double x){
	if(fabs(x) &lt; eps)return 0;
	if(x &lt; 0)return -1;
	else return 1;
}
//square of a double
inline double sqr(double x){return x*x;}
/*
 * Point
 * Point()               - Empty constructor
 * Point(double _x,double _y)  - constructor
 * input()             - double input
 * output()            - %.2f output
 * operator ==         - compares x and y
 * operator &lt;          - compares first by x, then by y
 * operator -          - return new Point after subtracting curresponging x and y
 * operator ^          - cross product of 2d points
 * operator *          - dot product
 * len()               - gives length from origin
 * len2()              - gives square of length from origin
 * distance(Point p)   - gives distance from p
 * operator + Point b  - returns new Point after adding curresponging x and y
 * operator * double k - returns new Point after multiplieing x and y by k
 * operator / double k - returns new Point after divideing x and y by k
 * rad(Point a,Point b)- returns the angle of Point a and Point b from this Point
 * trunc(double r)     - return Point that if truncated the distance from center to r
 * rotleft()           - returns 90 degree ccw rotated point
 * rotright()          - returns 90 degree cw rotated point
 * rotate(Point p,double angle) - returns Point after rotateing the Point centering at p by angle radian ccw
 */
struct Point{
	double x,y;
	Point(){}
	Point(double _x,double _y){
		x = _x;
		y = _y;
	}
	void input(){
		scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);
	}
	void output(){
		printf(&quot;%.2f %.2f\n&quot;,x,y);
	}
	bool operator == (Point b)const{
		return sgn(x-b.x) == 0 &amp;&amp; sgn(y-b.y) == 0;
	}
	bool operator &lt; (Point b)const{
		return sgn(x-b.x)== 0?sgn(y-b.y)&lt;0:x&lt;b.x;
	}
	Point operator -(const Point &amp;b)const{
		return Point(x-b.x,y-b.y);
	}
	//叉积
	double operator ^(const Point &amp;b)const{
		return x*b.y - y*b.x;
	}
	//点积
	double operator *(const Point &amp;b)const{
		return x*b.x + y*b.y;
	}
	//返回长度
	double len(){
		return hypot(x,y);//库函数
	}
	//返回长度的平方
	double len2(){
		return x*x + y*y;
	}
	//返回两点的距离
	double distance(Point p){
		return hypot(x-p.x,y-p.y);
	}
	Point operator +(const Point &amp;b)const{
		return Point(x+b.x,y+b.y);
	}
	Point operator *(const double &amp;k)const{
		return Point(x*k,y*k);
	}
	Point operator /(const double &amp;k)const{
		return Point(x/k,y/k);
	}
	//`计算pa  和  pb 的夹角`
	//`就是求这个点看a,b 所成的夹角`
	//`测试 LightOJ1203`
	double rad(Point a,Point b){
		Point p = *this;
		return fabs(atan2( fabs((a-p)^(b-p)),(a-p)*(b-p) ));
	}
	//`化为长度为r的向量`
	Point trunc(double r){
		double l = len();
		if(!sgn(l))return *this;
		r /= l;
		return Point(x*r,y*r);
	}
	//`逆时针旋转90度`
	Point rotleft(){
		return Point(-y,x);
	}
	//`顺时针旋转90度`
	Point rotright(){
		return Point(y,-x);
	}
	//`绕着p点逆时针旋转angle`
	Point rotate(Point p,double angle){
		Point v = (*this) - p;
		double c = cos(angle), s = sin(angle);
		return Point(p.x + v.x*c - v.y*s,p.y + v.x*s + v.y*c);
	}
};
/*
 * Stores two points
 * Line()                         - Empty constructor
 * Line(Point _s,Point _e)        - Line through _s and _e
 * operator ==                    - checks if two points are same
 * Line(Point p,double angle)     - one end p , another end at angle degree
 * Line(double a,double b,double c) - Line of equation ax + by + c = 0
 * input()                        - inputs s and e
 * adjust()                       - orders in such a way that s &lt; e
 * length()                       - distance of se
 * angle()                        - return 0 &lt;= angle &lt; pi
 * relation(Point p)              - 3 if point is on line
 *                                  1 if point on the left of line
 *                                  2 if point on the right of line
 * pointonseg(double p)           - return true if point on segment
 * parallel(Line v)               - return true if they are parallel
 * segcrossseg(Line v)            - returns 0 if does not intersect
 *                                  returns 1 if non-standard intersection
 *                                  returns 2 if intersects
 * linecrossseg(Line v)           - line and seg
 * linecrossline(Line v)          - 0 if parallel
 *                                  1 if coincides
 *                                  2 if intersects
 * crosspoint(Line v)             - returns intersection point
 * dispointtoline(Point p)        - distance from point p to the line
 * dispointtoseg(Point p)         - distance from p to the segment
 * dissegtoseg(Line v)            - distance of two segment
 * lineprog(Point p)              - returns projected point p on se line
 * symmetrypoint(Point p)         - returns reflection point of p over se
 *
 */
struct Line{
	Point s,e;
	Line(){}
	Line(Point _s,Point _e){
		s = _s;
		e = _e;
	}
	bool operator ==(Line v){
		return (s == v.s)&amp;&amp;(e == v.e);
	}
	//`根据一个点和倾斜角angle确定直线,0&lt;=angle&lt;pi`
	Line(Point p,double angle){
		s = p;
		if(sgn(angle-pi/2) == 0){
			e = (s + Point(0,1));
		}
		else{
			e = (s + Point(1,tan(angle)));
		}
	}
	//ax+by+c=0
	Line(double a,double b,double c){
		if(sgn(a) == 0){
			s = Point(0,-c/b);
			e = Point(1,-c/b);
		}
		else if(sgn(b) == 0){
			s = Point(-c/a,0);
			e = Point(-c/a,1);
		}
		else{
			s = Point(0,-c/b);
			e = Point(1,(-c-a)/b);
		}
	}
	void input(){
		s.input();
		e.input();
	}
	void adjust(){
		if(e &lt; s)swap(s,e);
	}
	//求线段长度
	double length(){
		return s.distance(e);
	}
	//`返回直线倾斜角 0&lt;=angle&lt;pi`
	double angle(){
		double k = atan2(e.y-s.y,e.x-s.x);
		if(sgn(k) &lt; 0)k += pi;
		if(sgn(k-pi) == 0)k -= pi;
		return k;
	}
	//`点和直线关系`
	//`1  在左侧`
	//`2  在右侧`
	//`3  在直线上`
	int relation(Point p){
		int c = sgn((p-s)^(e-s));
		if(c &lt; 0)return 1;
		else if(c &gt; 0)return 2;
		else return 3;
	}
	// 点在线段上的判断
	bool pointonseg(Point p){
		return sgn((p-s)^(e-s)) == 0 &amp;&amp; sgn((p-s)*(p-e)) &lt;= 0;
	}
	//`两向量平行(对应直线平行或重合)`
	bool parallel(Line v){
		return sgn((e-s)^(v.e-v.s)) == 0;
	}
	//`两线段相交判断`
	//`2 规范相交`
	//`1 非规范相交`
	//`0 不相交`
	int segcrossseg(Line v){
		int d1 = sgn((e-s)^(v.s-s));
		int d2 = sgn((e-s)^(v.e-s));
		int d3 = sgn((v.e-v.s)^(s-v.s));
		int d4 = sgn((v.e-v.s)^(e-v.s));
		if( (d1^d2)==-2 &amp;&amp; (d3^d4)==-2 )return 2;
		return (d1==0 &amp;&amp; sgn((v.s-s)*(v.s-e))&lt;=0) ||
			(d2==0 &amp;&amp; sgn((v.e-s)*(v.e-e))&lt;=0) ||
			(d3==0 &amp;&amp; sgn((s-v.s)*(s-v.e))&lt;=0) ||
			(d4==0 &amp;&amp; sgn((e-v.s)*(e-v.e))&lt;=0);
	}
	//`直线和线段相交判断`
	//`-*this line   -v seg`
	//`2 规范相交`
	//`1 非规范相交`
	//`0 不相交`
	int linecrossseg(Line v){
		int d1 = sgn((e-s)^(v.s-s));
		int d2 = sgn((e-s)^(v.e-s));
		if((d1^d2)==-2) return 2;
		return (d1==0||d2==0);
	}
	//`两直线关系`
	//`0 平行`
	//`1 重合`
	//`2 相交`
	int linecrossline(Line v){
		if((*this).parallel(v))
			return v.relation(s)==3;
		return 2;
	}
	//`求两直线的交点`
	//`要保证两直线不平行或重合`
	Point crosspoint(Line v){
		double a1 = (v.e-v.s)^(s-v.s);
		double a2 = (v.e-v.s)^(e-v.s);
		return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));
	}
	//点到直线的距离
	double dispointtoline(Point p){
		return fabs((p-s)^(e-s))/length();
	}
	//点到线段的距离
	double dispointtoseg(Point p){
		if(sgn((p-s)*(e-s))&lt;0 || sgn((p-e)*(s-e))&lt;0)
			return min(p.distance(s),p.distance(e));
		return dispointtoline(p);
	}
	//`返回线段到线段的距离`
	//`前提是两线段不相交，相交距离就是0了`
	double dissegtoseg(Line v){
		return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e)));
	}
	//`返回点p在直线上的投影`
	Point lineprog(Point p){
		return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );
	}
	//`返回点p关于直线的对称点`
	Point symmetrypoint(Point p){
		Point q = lineprog(p);
		return Point(2*q.x-p.x,2*q.y-p.y);
	}
};
//圆
struct circle{
	Point p;//圆心
	double r;//半径
	circle(){}
	circle(Point _p,double _r){
		p = _p;
		r = _r;
	}
	circle(double x,double y,double _r){
		p = Point(x,y);
		r = _r;
	}
	//`三角形的外接圆`
	//`需要Point的+ /  rotate()  以及Line的crosspoint()`
	//`利用两条边的中垂线得到圆心`
	//`测试：UVA12304`
	circle(Point a,Point b,Point c){
		Line u = Line((a+b)/2,((a+b)/2)+((b-a).rotleft()));
		Line v = Line((b+c)/2,((b+c)/2)+((c-b).rotleft()));
		p = u.crosspoint(v);
		r = p.distance(a);
	}
	//`三角形的内切圆`
	//`参数bool t没有作用，只是为了和上面外接圆函数区别`
	//`测试：UVA12304`
	circle(Point a,Point b,Point c,bool t){
		Line u,v;
		double m = atan2(b.y-a.y,b.x-a.x), n = atan2(c.y-a.y,c.x-a.x);
		u.s = a;
		u.e = u.s + Point(cos((n+m)/2),sin((n+m)/2));
		v.s = b;
		m = atan2(a.y-b.y,a.x-b.x) , n = atan2(c.y-b.y,c.x-b.x);
		v.e = v.s + Point(cos((n+m)/2),sin((n+m)/2));
		p = u.crosspoint(v);
		r = Line(a,b).dispointtoseg(p);
	}
	//输入
	void input(){
		p.input();
		scanf(&quot;%lf&quot;,&amp;r);
	}
	//输出
	void output(){
		printf(&quot;%.2lf %.2lf %.2lf\n&quot;,p.x,p.y,r);
	}
	bool operator == (circle v){
		return (p==v.p) &amp;&amp; sgn(r-v.r)==0;
	}
	bool operator &lt; (circle v)const{
		return ((p&lt;v.p)||((p==v.p)&amp;&amp;sgn(r-v.r)&lt;0));
	}
	//面积
	double area(){
		return pi*r*r;
	}
	//周长
	double circumference(){
		return 2*pi*r;
	}
	//`点和圆的关系`
	//`0 圆外`
	//`1 圆上`
	//`2 圆内`
	int relation(Point b){
		double dst = b.distance(p);
		if(sgn(dst-r) &lt; 0)return 2;
		else if(sgn(dst-r)==0)return 1;
		return 0;
	}
	//`线段和圆的关系`
	//`比较的是圆心到线段的距离和半径的关系`
	int relationseg(Line v){
		double dst = v.dispointtoseg(p);
		if(sgn(dst-r) &lt; 0)return 2;
		else if(sgn(dst-r) == 0)return 1;
		return 0;
	}
	//`直线和圆的关系`
	//`比较的是圆心到直线的距离和半径的关系`
	int relationline(Line v){
		double dst = v.dispointtoline(p);
		if(sgn(dst-r) &lt; 0)return 2;
		else if(sgn(dst-r) == 0)return 1;
		return 0;
	}
	//`两圆的关系`
	//`5 相离`
	//`4 外切`
	//`3 相交`
	//`2 内切`
	//`1 内含`
	//`需要Point的distance`
	//`测试：UVA12304`
	int relationcircle(circle v){
		double d = p.distance(v.p);
		if(sgn(d-r-v.r) &gt; 0)return 5;
		if(sgn(d-r-v.r) == 0)return 4;
		double l = fabs(r-v.r);
		if(sgn(d-r-v.r)&lt;0 &amp;&amp; sgn(d-l)&gt;0)return 3;
		if(sgn(d-l)==0)return 2;
		if(sgn(d-l)&lt;0)return 1;
	}
	//`求两个圆的交点，返回0表示没有交点，返回1是一个交点，2是两个交点`
	//`需要relationcircle`
	//`测试：UVA12304`
	int pointcrosscircle(circle v,Point &amp;p1,Point &amp;p2){
		int rel = relationcircle(v);
		if(rel == 1 || rel == 5)return 0;
		double d = p.distance(v.p);
		double l = (d*d+r*r-v.r*v.r)/(2*d);
		double h = sqrt(r*r-l*l);
		Point tmp = p + (v.p-p).trunc(l);
		p1 = tmp + ((v.p-p).rotleft().trunc(h));
		p2 = tmp + ((v.p-p).rotright().trunc(h));
		if(rel == 2 || rel == 4)
			return 1;
		return 2;
	}
	//`求直线和圆的交点，返回交点个数`
	int pointcrossline(Line v,Point &amp;p1,Point &amp;p2){
		if(!(*this).relationline(v))return 0;
		Point a = v.lineprog(p);
		double d = v.dispointtoline(p);
		d = sqrt(r*r-d*d);
		if(sgn(d) == 0){
			p1 = a;
			p2 = a;
			return 1;
		}
		p1 = a + (v.e-v.s).trunc(d);
		p2 = a - (v.e-v.s).trunc(d);
		return 2;
	}
	//`得到过a,b两点，半径为r1的两个圆`
	int gercircle(Point a,Point b,double r1,circle &amp;c1,circle &amp;c2){
		circle x(a,r1),y(b,r1);
		int t = x.pointcrosscircle(y,c1.p,c2.p);
		if(!t)return 0;
		c1.r = c2.r = r;
		return t;
	}
	//`得到与直线u相切，过点q,半径为r1的圆`
	//`测试：UVA12304`
	int getcircle(Line u,Point q,double r1,circle &amp;c1,circle &amp;c2){
		double dis = u.dispointtoline(q);
		if(sgn(dis-r1*2)&gt;0)return 0;
		if(sgn(dis) == 0){
			c1.p = q + ((u.e-u.s).rotleft().trunc(r1));
			c2.p = q + ((u.e-u.s).rotright().trunc(r1));
			c1.r = c2.r = r1;
			return 2;
		}
		Line u1 = Line((u.s + (u.e-u.s).rotleft().trunc(r1)),(u.e + (u.e-u.s).rotleft().trunc(r1)));
		Line u2 = Line((u.s + (u.e-u.s).rotright().trunc(r1)),(u.e + (u.e-u.s).rotright().trunc(r1)));
		circle cc = circle(q,r1);
		Point p1,p2;
		if(!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2);
		c1 = circle(p1,r1);
		if(p1 == p2){
			c2 = c1;
			return 1;
		}
		c2 = circle(p2,r1);
		return 2;
	}
	//`同时与直线u,v相切，半径为r1的圆`
	//`测试：UVA12304`
	int getcircle(Line u,Line v,double r1,circle &amp;c1,circle &amp;c2,circle &amp;c3,circle &amp;c4){
		if(u.parallel(v))return 0;//两直线平行
		Line u1 = Line(u.s + (u.e-u.s).rotleft().trunc(r1),u.e + (u.e-u.s).rotleft().trunc(r1));
		Line u2 = Line(u.s + (u.e-u.s).rotright().trunc(r1),u.e + (u.e-u.s).rotright().trunc(r1));
		Line v1 = Line(v.s + (v.e-v.s).rotleft().trunc(r1),v.e + (v.e-v.s).rotleft().trunc(r1));
		Line v2 = Line(v.s + (v.e-v.s).rotright().trunc(r1),v.e + (v.e-v.s).rotright().trunc(r1));
		c1.r = c2.r = c3.r = c4.r = r1;
		c1.p = u1.crosspoint(v1);
		c2.p = u1.crosspoint(v2);
		c3.p = u2.crosspoint(v1);
		c4.p = u2.crosspoint(v2);
		return 4;
	}
	//`同时与不相交圆cx,cy相切，半径为r1的圆`
	//`测试：UVA12304`
	int getcircle(circle cx,circle cy,double r1,circle &amp;c1,circle &amp;c2){
		circle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r);
		int t = x.pointcrosscircle(y,c1.p,c2.p);
		if(!t)return 0;
		c1.r = c2.r = r1;
		return t;
	}

	//`过一点作圆的切线(先判断点和圆的关系)`
	//`测试：UVA12304`
	int tangentline(Point q,Line &amp;u,Line &amp;v){
		int x = relation(q);
		if(x == 2)return 0;
		if(x == 1){
			u = Line(q,q + (q-p).rotleft());
			v = u;
			return 1;
		}
		double d = p.distance(q);
		double l = r*r/d;
		double h = sqrt(r*r-l*l);
		u = Line(q,p + ((q-p).trunc(l) + (q-p).rotleft().trunc(h)));
		v = Line(q,p + ((q-p).trunc(l) + (q-p).rotright().trunc(h)));
		return 2;
	}
	//`求两圆相交的面积`
	double areacircle(circle v){
		int rel = relationcircle(v);
		if(rel &gt;= 4)return 0.0;
		if(rel &lt;= 2)return min(area(),v.area());
		double d = p.distance(v.p);
		double hf = (r+v.r+d)/2.0;
		double ss = 2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d));
		double a1 = acos((r*r+d*d-v.r*v.r)/(2.0*r*d));
		a1 = a1*r*r;
		double a2 = acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d));
		a2 = a2*v.r*v.r;
		return a1+a2-ss;
	}
	//`求圆和三角形pab的相交面积`
	//`测试：POJ3675 HDU3982 HDU2892`
	double areatriangle(Point a,Point b){
		if(sgn((p-a)^(p-b)) == 0)return 0.0;
		Point q[5];
		int len = 0;
		q[len++] = a;
		Line l(a,b);
		Point p1,p2;
		if(pointcrossline(l,q[1],q[2])==2){
			if(sgn((a-q[1])*(b-q[1]))&lt;0)q[len++] = q[1];
			if(sgn((a-q[2])*(b-q[2]))&lt;0)q[len++] = q[2];
		}
		q[len++] = b;
		if(len == 4 &amp;&amp; sgn((q[0]-q[1])*(q[2]-q[1]))&gt;0)swap(q[1],q[2]);
		double res = 0;
		for(int i = 0;i &lt; len-1;i++){
			if(relation(q[i])==0||relation(q[i+1])==0){
				double arg = p.rad(q[i],q[i+1]);
				res += r*r*arg/2.0;
			}
			else{
				res += fabs((q[i]-p)^(q[i+1]-p))/2.0;
			}
		}
		return res;
	}
};

/*
 * n,p  Line l for each side
 * input(int _n)                        - inputs _n size polygon
 * add(Point q)                         - adds a point at end of the list
 * getline()                            - populates line array
 * cmp                                  - comparision in convex_hull order
 * norm()                               - sorting in convex_hull order
 * getconvex(polygon &amp;convex)           - returns convex hull in convex
 * Graham(polygon &amp;convex)              - returns convex hull in convex
 * isconvex()                           - checks if convex
 * relationpoint(Point q)               - returns 3 if q is a vertex
 *                                                2 if on a side
 *                                                1 if inside
 *                                                0 if outside
 * convexcut(Line u,polygon &amp;po)        - left side of u in po
 * gercircumference()                   - returns side length
 * getarea()                            - returns area
 * getdir()                             - returns 0 for cw, 1 for ccw
 * getbarycentre()                      - returns barycenter
 *
 */
struct polygon{
	int n;
	Point p[maxp];
	Line l[maxp];
	void input(int _n){
		n = _n;
		for(int i = 0;i &lt; n;i++)
			p[i].input();
	}
	void add(Point q){
		p[n++] = q;
	}
	void getline(){
		for(int i = 0;i &lt; n;i++){
			l[i] = Line(p[i],p[(i+1)%n]);
		}
	}
	struct cmp{
		Point p;
		cmp(const Point &amp;p0){p = p0;}
		bool operator()(const Point &amp;aa,const Point &amp;bb){
			Point a = aa, b = bb;
			int d = sgn((a-p)^(b-p));
			if(d == 0){
				return sgn(a.distance(p)-b.distance(p)) &lt; 0;
			}
			return d &gt; 0;
		}
	};
	//`进行极角排序`
	//`首先需要找到最左下角的点`
	//`需要重载号好Point的 &lt; 操作符(min函数要用) `
	void norm(){
		Point mi = p[0];
		for(int i = 1;i &lt; n;i++)mi = min(mi,p[i]);
		sort(p,p+n,cmp(mi));
	}
	//`得到凸包`
	//`得到的凸包里面的点编号是0$\sim$n-1的`
	//`两种凸包的方法`
	//`注意如果有影响，要特判下所有点共点，或者共线的特殊情况`
	//`测试 LightOJ1203  LightOJ1239`
	void getconvex(polygon &amp;convex){
		sort(p,p+n);
		convex.n = n;
		for(int i = 0;i &lt; min(n,2);i++){
			convex.p[i] = p[i];
		}
		if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判
		if(n &lt;= 2)return;
		int &amp;top = convex.n;
		top = 1;
		for(int i = 2;i &lt; n;i++){
			while(top &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0)
				top--;
			convex.p[++top] = p[i];
		}
		int temp = top;
		convex.p[++top] = p[n-2];
		for(int i = n-3;i &gt;= 0;i--){
			while(top != temp &amp;&amp; sgn((convex.p[top]-p[i])^(convex.p[top-1]-p[i])) &lt;= 0)
				top--;
			convex.p[++top] = p[i];
		}
		if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判
		convex.norm();//`原来得到的是顺时针的点，排序后逆时针`
	}
	//`得到凸包的另外一种方法`
	//`测试 LightOJ1203  LightOJ1239`
	void Graham(polygon &amp;convex){
		norm();
		int &amp;top = convex.n;
		top = 0;
		if(n == 1){
			top = 1;
			convex.p[0] = p[0];
			return;
		}
		if(n == 2){
			top = 2;
			convex.p[0] = p[0];
			convex.p[1] = p[1];
			if(convex.p[0] == convex.p[1])top--;
			return;
		}
		convex.p[0] = p[0];
		convex.p[1] = p[1];
		top = 2;
		for(int i = 2;i &lt; n;i++){
			while( top &gt; 1 &amp;&amp; sgn((convex.p[top-1]-convex.p[top-2])^(p[i]-convex.p[top-2])) &lt;= 0 )
				top--;
			convex.p[top++] = p[i];
		}
		if(convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1]))convex.n--;//特判
	}
	//`判断是不是凸的`
	bool isconvex(){
		bool s[2];
		memset(s,false,sizeof(s));
		for(int i = 0;i &lt; n;i++){
			int j = (i+1)%n;
			int k = (j+1)%n;
			s[sgn((p[j]-p[i])^(p[k]-p[i]))+1] = true;
			if(s[0] &amp;&amp; s[2])return false;
		}
		return true;
	}
	//`判断点和任意多边形的关系`
	//` 3 点上`
	//` 2 边上`
	//` 1 内部`
	//` 0 外部`
	int relationpoint(Point q){
		for(int i = 0;i &lt; n;i++){
			if(p[i] == q)return 3;
		}
		getline();
		for(int i = 0;i &lt; n;i++){
			if(l[i].pointonseg(q))return 2;
		}
		int cnt = 0;
		for(int i = 0;i &lt; n;i++){
			int j = (i+1)%n;
			int k = sgn((q-p[j])^(p[i]-p[j]));
			int u = sgn(p[i].y-q.y);
			int v = sgn(p[j].y-q.y);
			if(k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)cnt++;
			if(k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0)cnt--;
		}
		return cnt != 0;
	}
	//`直线u切割凸多边形左侧`
	//`注意直线方向`
	//`测试：HDU3982`
	void convexcut(Line u,polygon &amp;po){
		int &amp;top = po.n;//注意引用
		top = 0;
		for(int i = 0;i &lt; n;i++){
			int d1 = sgn((u.e-u.s)^(p[i]-u.s));
			int d2 = sgn((u.e-u.s)^(p[(i+1)%n]-u.s));
			if(d1 &gt;= 0)po.p[top++] = p[i];
			if(d1*d2 &lt; 0)po.p[top++] = u.crosspoint(Line(p[i],p[(i+1)%n]));
		}
	}
	//`得到周长`
	//`测试 LightOJ1239`
	double getcircumference(){
		double sum = 0;
		for(int i = 0;i &lt; n;i++){
			sum += p[i].distance(p[(i+1)%n]);
		}
		return sum;
	}
	//`得到面积`
	double getarea(){
		double sum = 0;
		for(int i = 0;i &lt; n;i++){
			sum += (p[i]^p[(i+1)%n]);
		}
		return fabs(sum)/2;
	}
	//`得到方向`
	//` 1 表示逆时针，0表示顺时针`
	bool getdir(){
		double sum = 0;
		for(int i = 0;i &lt; n;i++)
			sum += (p[i]^p[(i+1)%n]);
		if(sgn(sum) &gt; 0)return 1;
		return 0;
	}
	//`得到重心`
	Point getbarycentre(){
		Point ret(0,0);
		double area = 0;
		for(int i = 1;i &lt; n-1;i++){
			double tmp = (p[i]-p[0])^(p[i+1]-p[0]);
			if(sgn(tmp) == 0)continue;
			area += tmp;
			ret.x += (p[0].x+p[i].x+p[i+1].x)/3*tmp;
			ret.y += (p[0].y+p[i].y+p[i+1].y)/3*tmp;
		}
		if(sgn(area)) ret = ret/area;
		return ret;
	}
	//`多边形和圆交的面积`
	//`测试：POJ3675 HDU3982 HDU2892`
	double areacircle(circle c){
		double ans = 0;
		for(int i = 0;i &lt; n;i++){
			int j = (i+1)%n;
			if(sgn( (p[j]-c.p)^(p[i]-c.p) ) &gt;= 0)
				ans += c.areatriangle(p[i],p[j]);
			else ans -= c.areatriangle(p[i],p[j]);
		}
		return fabs(ans);
	}
	//`多边形和圆关系`
	//` 2 圆完全在多边形内`
	//` 1 圆在多边形里面，碰到了多边形边界`
	//` 0 其它`
	int relationcircle(circle c){
		getline();
		int x = 2;
		if(relationpoint(c.p) != 1)return 0;//圆心不在内部
		for(int i = 0;i &lt; n;i++){
			if(c.relationseg(l[i])==2)return 0;
			if(c.relationseg(l[i])==1)x = 1;
		}
		return x;
	}
};
//`AB X AC`
double cross(Point A,Point B,Point C){
	return (B-A)^(C-A);
}
//`AB*AC`
double dot(Point A,Point B,Point C){
	return (B-A)*(C-A);
}
//`最小矩形面积覆盖`
//` A 必须是凸包(而且是逆时针顺序)`
//` 测试 UVA 10173`
double minRectangleCover(polygon A){
	//`要特判A.n &lt; 3的情况`
	if(A.n &lt; 3)return 0.0;
	A.p[A.n] = A.p[0];
	double ans = -1;
	int r = 1, p = 1, q;
	for(int i = 0;i &lt; A.n;i++){
		//`卡出离边A.p[i] - A.p[i+1]最远的点`
		while( sgn( cross(A.p[i],A.p[i+1],A.p[r+1]) - cross(A.p[i],A.p[i+1],A.p[r]) ) &gt;= 0 )
			r = (r+1)%A.n;
		//`卡出A.p[i] - A.p[i+1]方向上正向n最远的点`
		while(sgn( dot(A.p[i],A.p[i+1],A.p[p+1]) - dot(A.p[i],A.p[i+1],A.p[p]) ) &gt;= 0 )
			p = (p+1)%A.n;
		if(i == 0)q = p;
		//`卡出A.p[i] - A.p[i+1]方向上负向最远的点`
		while(sgn(dot(A.p[i],A.p[i+1],A.p[q+1]) - dot(A.p[i],A.p[i+1],A.p[q])) &lt;= 0)
			q = (q+1)%A.n;
		double d = (A.p[i] - A.p[i+1]).len2();
		double tmp = cross(A.p[i],A.p[i+1],A.p[r]) *
			(dot(A.p[i],A.p[i+1],A.p[p]) - dot(A.p[i],A.p[i+1],A.p[q]))/d;
		if(ans &lt; 0 || ans &gt; tmp)ans = tmp;
	}
	return ans;
}

//`直线切凸多边形`
//`多边形是逆时针的，在q1q2的左侧`
//`测试:HDU3982`
vector&lt;Point&gt; convexCut(const vector&lt;Point&gt; &amp;ps,Point q1,Point q2){
	vector&lt;Point&gt;qs;
	int n = ps.size();
	for(int i = 0;i &lt; n;i++){
		Point p1 = ps[i], p2 = ps[(i+1)%n];
		int d1 = sgn((q2-q1)^(p1-q1)), d2 = sgn((q2-q1)^(p2-q1));
		if(d1 &gt;= 0)
			qs.push_back(p1);
		if(d1 * d2 &lt; 0)
			qs.push_back(Line(p1,p2).crosspoint(Line(q1,q2)));
	}
	return qs;
}
//`半平面交`
//`测试 POJ3335 POJ1474 POJ1279`
//***************************
struct halfplane:public Line{
	double angle;
	halfplane(){}
	//`表示向量s-&gt;e逆时针(左侧)的半平面`
	halfplane(Point _s,Point _e){
		s = _s;
		e = _e;
	}
	halfplane(Line v){
		s = v.s;
		e = v.e;
	}
	void calcangle(){
		angle = atan2(e.y-s.y,e.x-s.x);
	}
	bool operator &lt;(const halfplane &amp;b)const{
		return angle &lt; b.angle;
	}
};
struct halfplanes{
	int n;
	halfplane hp[maxp];
	Point p[maxp];
	int que[maxp];
	int st,ed;
	void push(halfplane tmp){
		hp[n++] = tmp;
	}
	//去重
	void unique(){
		int m = 1;
		for(int i = 1;i &lt; n;i++){
			if(sgn(hp[i].angle-hp[i-1].angle) != 0)
				hp[m++] = hp[i];
			else if(sgn( (hp[m-1].e-hp[m-1].s)^(hp[i].s-hp[m-1].s) ) &gt; 0)
				hp[m-1] = hp[i];
		}
		n = m;
	}
	bool halfplaneinsert(){
		for(int i = 0;i &lt; n;i++)hp[i].calcangle();
		sort(hp,hp+n);
		unique();
		que[st=0] = 0;
		que[ed=1] = 1;
		p[1] = hp[0].crosspoint(hp[1]);
		for(int i = 2;i &lt; n;i++){
			while(st&lt;ed &amp;&amp; sgn((hp[i].e-hp[i].s)^(p[ed]-hp[i].s))&lt;0)ed--;
			while(st&lt;ed &amp;&amp; sgn((hp[i].e-hp[i].s)^(p[st+1]-hp[i].s))&lt;0)st++;
			que[++ed] = i;
			if(hp[i].parallel(hp[que[ed-1]]))return false;
			p[ed]=hp[i].crosspoint(hp[que[ed-1]]);
		}
		while(st&lt;ed &amp;&amp; sgn((hp[que[st]].e-hp[que[st]].s)^(p[ed]-hp[que[st]].s))&lt;0)ed--;
		while(st&lt;ed &amp;&amp; sgn((hp[que[ed]].e-hp[que[ed]].s)^(p[st+1]-hp[que[ed]].s))&lt;0)st++;
		if(st+1&gt;=ed)return false;
		return true;
	}
	//`得到最后半平面交得到的凸多边形`
	//`需要先调用halfplaneinsert() 且返回true`
	void getconvex(polygon &amp;con){
		p[st] = hp[que[st]].crosspoint(hp[que[ed]]);
		con.n = ed-st+1;
		for(int j = st,i = 0;j &lt;= ed;i++,j++)
			con.p[i] = p[j];
	}
};
//***************************

const int maxn = 1010;
struct circles{
	circle c[maxn];
	double ans[maxn];//`ans[i]表示被覆盖了i次的面积`
	double pre[maxn];
	int n;
	circles(){}
	void add(circle cc){
		c[n++] = cc;
	}
	//`x包含在y中`
	bool inner(circle x,circle y){
		if(x.relationcircle(y) != 1)return 0;
		return sgn(x.r-y.r)&lt;=0?1:0;
	}
	//圆的面积并去掉内含的圆
	void init_or(){
		bool mark[maxn] = {0};
		int i,j,k=0;
		for(i = 0;i &lt; n;i++){
			for(j = 0;j &lt; n;j++)
				if(i != j &amp;&amp; !mark[j]){
					if( (c[i]==c[j])||inner(c[i],c[j]) )break;
				}
			if(j &lt; n)mark[i] = 1;
		}
		for(i = 0;i &lt; n;i++)
			if(!mark[i])
				c[k++] = c[i];
		n = k;
	}
	//`圆的面积交去掉内含的圆`
	void init_add(){
		int i,j,k;
		bool mark[maxn] = {0};
		for(i = 0;i &lt; n;i++){
			for(j = 0;j &lt; n;j++)
				if(i != j &amp;&amp; !mark[j]){
					if( (c[i]==c[j])||inner(c[j],c[i]) )break;
				}
			if(j &lt; n)mark[i] = 1;
		}
		for(i = 0;i &lt; n;i++)
			if(!mark[i])
				c[k++] = c[i];
		n = k;
	}
	//`半径为r的圆，弧度为th对应的弓形的面积`
	double areaarc(double th,double r){
		return 0.5*r*r*(th-sin(th));
	}
	//`测试SPOJVCIRCLES SPOJCIRUT`
	//`SPOJVCIRCLES求n个圆并的面积，需要加上init\_or()去掉重复圆（否则WA）`
	//`SPOJCIRUT 是求被覆盖k次的面积，不能加init\_or()`
	//`对于求覆盖多少次面积的问题，不能解决相同圆，而且不能init\_or()`
	//`求多圆面积并，需要init\_or,其中一个目的就是去掉相同圆`
	void getarea(){
		memset(ans,0,sizeof(ans));
		vector&lt;pair&lt;double,int&gt; &gt;v;
		for(int i = 0;i &lt; n;i++){
			v.clear();
			v.push_back(make_pair(-pi,1));
			v.push_back(make_pair(pi,-1));
			for(int j = 0;j &lt; n;j++)
				if(i != j){
					Point q = (c[j].p - c[i].p);
					double ab = q.len(),ac = c[i].r, bc = c[j].r;
					if(sgn(ab+ac-bc)&lt;=0){
						v.push_back(make_pair(-pi,1));
						v.push_back(make_pair(pi,-1));
						continue;
					}
					if(sgn(ab+bc-ac)&lt;=0)continue;
					if(sgn(ab-ac-bc)&gt;0)continue;
					double th = atan2(q.y,q.x), fai = acos((ac*ac+ab*ab-bc*bc)/(2.0*ac*ab));
					double a0 = th-fai;
					if(sgn(a0+pi)&lt;0)a0+=2*pi;
					double a1 = th+fai;
					if(sgn(a1-pi)&gt;0)a1-=2*pi;
					if(sgn(a0-a1)&gt;0){
						v.push_back(make_pair(a0,1));
						v.push_back(make_pair(pi,-1));
						v.push_back(make_pair(-pi,1));
						v.push_back(make_pair(a1,-1));
					}
					else{
						v.push_back(make_pair(a0,1));
						v.push_back(make_pair(a1,-1));
					}
				}
			sort(v.begin(),v.end());
			int cur = 0;
			for(int j = 0;j &lt; v.size();j++){
				if(cur &amp;&amp; sgn(v[j].first-pre[cur])){
					ans[cur] += areaarc(v[j].first-pre[cur],c[i].r);
					ans[cur] += 0.5*(Point(c[i].p.x+c[i].r*cos(pre[cur]),c[i].p.y+c[i].r*sin(pre[cur]))^Point(c[i].p.x+c[i].r*cos(v[j].first),c[i].p.y+c[i].r*sin(v[j].first)));
				}
				cur += v[j].second;
				pre[cur] = v[j].first;
			}
		}
		for(int i = 1;i &lt; n;i++)
			ans[i] -= ans[i+1];
	}
};
</code></pre>
</details>
<p>以下记录一些用法：</p>
<details class="admonition note"><summary class="admonition-title">用法</summary>
<pre><code class="language-cpp">int main() {
    // 求凸包
    int n; cin &gt;&gt; n;
    poly2.input(n);  // 先 input 到其他的 polygon 里面去
    poly2.getconvex(poly);
    printf(&quot;%.15lf\n&quot;, poly.getarea());
}
</code></pre>
</details>
<div class="admonition info">
  <p class="admonition-title">注意事项</p>
<p>如果题目中给的点都是整数，要将板子中的 Point 的 <code>double</code> 改成 <code>ll</code>，以避免精度问题！</p>
</div>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2024-06-11 00:31:26 &#43;0000 UTC">2024-06-11</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/92771e58934a5ef7e2ab60d981ea41285140076a" title="chore: update CF Problems" target="_blank">(92771e5)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/072-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-%e9%80%9a%e7%94%a8%e6%a8%a1%e7%89%88.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/119-%E6%95%B0%E8%AE%BA%E6%80%A7%E8%B4%A8/">
            <span class="next-text nav-default">一些数论性质与方法</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2024
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
