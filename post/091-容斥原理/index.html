<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>容斥原理 - tom0727&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="tom0727" /><meta name="description" content="介绍 容斥原理用于计算集合的 union 和 intersection 的大小。 集合的 Union: $$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i &amp;lt; j} |S_i \cap S_j| &#43; \sum_{i &amp;lt; j &amp;lt; k} |S_i \cap S_j \cap S_k| - &amp;hellip; &#43; (-1)^{n-1} |S_1 \cap &amp;hellip; \cap S_n|$$ 集合的 Intersection = 全集 - 补集的并集 $$|\bigcap_{i=1}^n" /><meta name="keywords" content="tom0727, blog, huzhenwei, 胡振为" />


<meta name="baidu-site-verification" content="tom0727" />
<meta name="google-site-verification" content="tom0727" />


<meta name="generator" content="Hugo 0.69.2 with theme even" />


<link rel="canonical" href="https://tom0727.github.io/post/091-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" />
<link rel="manifest" href="/manifest.json">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.466b9061d6a0d872b257fe5635e7e3f6e730d230bc4d5573d5bf47280d758499.css" rel="stylesheet">



<meta property="og:title" content="容斥原理" />
<meta property="og:description" content="介绍 容斥原理用于计算集合的 union 和 intersection 的大小。 集合的 Union: $$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i &lt; j} |S_i \cap S_j| &#43; \sum_{i &lt; j &lt; k} |S_i \cap S_j \cap S_k| - &hellip; &#43; (-1)^{n-1} |S_1 \cap &hellip; \cap S_n|$$ 集合的 Intersection = 全集 - 补集的并集 $$|\bigcap_{i=1}^n" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tom0727.github.io/post/091-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" />
<meta property="article:published_time" content="2022-12-31T21:16:36-06:00" />
<meta property="article:modified_time" content="2024-04-01T01:19:54+00:00" />
<meta itemprop="name" content="容斥原理">
<meta itemprop="description" content="介绍 容斥原理用于计算集合的 union 和 intersection 的大小。 集合的 Union: $$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i &lt; j} |S_i \cap S_j| &#43; \sum_{i &lt; j &lt; k} |S_i \cap S_j \cap S_k| - &hellip; &#43; (-1)^{n-1} |S_1 \cap &hellip; \cap S_n|$$ 集合的 Intersection = 全集 - 补集的并集 $$|\bigcap_{i=1}^n">
<meta itemprop="datePublished" content="2022-12-31T21:16:36-06:00" />
<meta itemprop="dateModified" content="2024-04-01T01:19:54&#43;00:00" />
<meta itemprop="wordCount" content="2932">



<meta itemprop="keywords" content=",," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="容斥原理"/>
<meta name="twitter:description" content="介绍 容斥原理用于计算集合的 union 和 intersection 的大小。 集合的 Union: $$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i &lt; j} |S_i \cap S_j| &#43; \sum_{i &lt; j &lt; k} |S_i \cap S_j \cap S_k| - &hellip; &#43; (-1)^{n-1} |S_1 \cap &hellip; \cap S_n|$$ 集合的 Intersection = 全集 - 补集的并集 $$|\bigcap_{i=1}^n"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">tom0727&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Post</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/cf-problems/">
        <li class="mobile-menu-item">CF-Problems</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">tom0727&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Post</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/cf-problems/">CF-Problems</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">容斥原理</h1>

      <div class="post-meta">
        <span class="post-time" title="2022-12-31 21:16:36 -0600 -0600"> 2022-12-31 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#例题">例题</a>
          <ul>
            <li><a href="#例1-cf1425d-danger-of-mad-snakeshttpscodeforcescomcontest1425problemd">例1 CF1425D. <a href="https://codeforces.com/contest/1425/problem/D">Danger of Mad Snakes</a></a></li>
            <li><a href="#例2-cf1267k-key-storagehttpscodeforcescomcontest1267problemk">例2 CF1267K. <a href="https://codeforces.com/contest/1267/problem/K">Key Storage</a></a></li>
            <li><a href="#例3-atcoder-abc152f-tree-and-constraintshttpsatcoderjpcontestsabc152tasksabc152_f">例3 Atcoder ABC152F. <a href="https://atcoder.jp/contests/abc152/tasks/abc152_f">Tree and Constraints</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="介绍">介绍</h2>
<p>容斥原理用于计算集合的 union 和 intersection 的大小。</p>
<p>集合的 Union:</p>
<p>$$|\bigcup_{i=1}^{n} S_i| = \sum_{i} |S_i| - \sum_{i &lt; j} |S_i \cap S_j| + \sum_{i &lt; j &lt; k} |S_i \cap S_j \cap S_k| - &hellip; + (-1)^{n-1} |S_1 \cap &hellip; \cap S_n|$$</p>
<p>集合的 Intersection = 全集 - 补集的并集</p>
<p>$$|\bigcap_{i=1}^n S_i| = |U| - |\bigcup_{i=1}^n \bar S_i|$$</p>
<h2 id="例题">例题</h2>
<h3 id="例1-cf1425d-danger-of-mad-snakeshttpscodeforcescomcontest1425problemd">例1 CF1425D. <a href="https://codeforces.com/contest/1425/problem/D" target="_blank">Danger of Mad Snakes</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>一个 $1000 \times 1000$ 的矩阵里放了 $n$ 条蛇，第 $i$ 个蛇位于 $(x_i, y_i)$，价值 $b_i$。</p>
<p>现在，我们要放 $m$ 个炸弹，每个炸弹必须放在某条蛇身上（不能重叠）。炸弹会爆炸，爆炸半径为 $r$。</p>
<p>• 比如，炸弹放在 $(x,y)$ 处，那么所有 $\max(|x - x'|, |y - y'|) \leq r$ 的点 $(x&rsquo;, y&rsquo;)$ 都会受到影响。</p>
<p>每一个炸弹放置方案所带来的价值定义为：$(\sum\limits_{i} b_{i})^2$，其中 $i$ 是所有被炸弹炸到的蛇。</p>
<p>求所有炸弹放置方案的价值之和，答案对 $10^9+7$ 取模。</p>
<p>其中，$n \in [1, 2000], m \in [1, n], r \in [0, 1000), x_i, y_i \in [1, 1000], b_i \in [1, 10^6]$，蛇的位置互不相同。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>看见这种 <strong>所有方案</strong> 的和，就想到每一个元素所带来的贡献。</p>
<p>很明显总共有 $C_n^m$ 种方案，每种方案如果炸到的蛇是 $(a_1, a_2, &hellip;, a_k)$，那么价值就是</p>
<p>$$(\sum\limits_{i=1} b_{a_i})^2 = (b_{a_1} + b_{a_2} + &hellip; + b_{a_k})^2 = \sum\limits_{i=1}^k b_{a_i}^2 + \sum\limits_{i&lt;j} 2b_{a_i}b_{a_j}$$</p>
<hr>
<p>先看第一项 $\sum\limits_{i=1}^k b_{a_i}^2$，只要考虑：</p>
<blockquote>
<p>对于每一条蛇，有多少种方案能炸到它？</p>
</blockquote>
<p>这个不好算，不如考虑有多少种炸不到它。</p>
<p>我们可以预处理出炸弹放在每一条蛇，都能影响到哪些蛇。这样就可以得到有哪些蛇的位置放置炸弹，是炸不到这一条的。</p>
<p>假设有 $k$ 个位置放炸弹，炸不到它，那么能炸到它的方案数就是 $C_n^m - C_k^m$。</p>
<hr>
<p>再看第二项 $\sum\limits_{i&lt;j} 2b_{a_i}b_{a_j}$，我们要考虑：</p>
<blockquote>
<p>对于每两条蛇 $(i,j)$，有多少种方案都能炸到它们？</p>
</blockquote>
<p>我们设 $A$ 为第一条蛇被炸，$B$ 为第二条蛇被炸。</p>
<p>所以由容斥原理有：</p>
<p>$$|A \cap B| = |U| - |\bar A \cup \bar B| = |U| - |\bar A| - |\bar B| + |\bar A \cap \bar B|$$</p>
<p>易知 $|U| = C_n^m, 而 |\bar A|, |\bar B|$ 上面已经算出来了，就剩下 $|\bar A \cap \bar B|$。</p>
<p>这代表着两条蛇都没被炸，所以只要找出有哪些点，使得这两条蛇都不会被炸就行。</p>
<p>没法直接找，所以找有哪些点能分别炸到这两条蛇，然后取一个并集，用 $m$ 减掉这个并集的大小即可。</p>
<p>注意到，能炸到一条蛇的范围是一个正方形，所以我们就取这两个正方形的并集，也就是将两个正方形相加然后减去正方形的交集。</p>
<p>我们做一个 $01$ 矩阵，$1$ 代表这个位置可以放炸弹（有蛇），然后正方形的值就是这个正方形内的和，所以用二维前缀和。</p>
<blockquote>
<p>正方形的交集怎么求？</p>
</blockquote>
<p><img src="/images/091/1.jpg" alt="img"></p>
<p>让两个正方形的：</p>
<ol>
<li>左端点 $x$ 坐标取 $\max$，右端点 $x$ 坐标取 $\min$。</li>
<li>下端点 $y$ 坐标取 $\max$，上端点 $y$ 坐标取 $\min$。</li>
</ol>
<p>然后就可以得出正方形的范围是 $[x_{lmax}, x_{rmin}] \times [y_{dmax}, y_{umin}]$。</p>
<p>• 当然这个题坐标系原点在左上方，所以稍微修改一下即可。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e4+5;

Z fac[maxn], inv_fac[maxn];
Z C(int a, int b) {
    if (b &gt; a) return 0;
    return fac[a] * inv_fac[b] * inv_fac[a-b];
}

int n, m, r;
int x[maxn], y[maxn];
ll b[maxn];

vector&lt;int&gt; adj[maxn];
int sum[maxn/2][maxn/2];
Z ans = 0;
struct Point {
    int x, y;
};
struct Matrix {
    Point ul, ur, dl, dr;  // upper left, upper right, down left, down right
} mat[maxn];

// 两个矩阵相交里面的元素数量
int intersect(Matrix a, Matrix b) {
    int xmin = min(a.dr.x, b.dr.x);
    int xmax = max(a.dl.x, b.dl.x);
    int ymin = max(a.ul.y, b.ul.y);
    int ymax = min(a.dl.y, b.dl.y);
    if (xmin &lt; xmax || ymin &gt; ymax) return 0;

    // [xmax, xmin] * [ymin, ymax]
    return sum[xmin][ymax] - sum[xmin][ymin-1] - sum[xmax-1][ymax] + sum[xmax-1][ymin-1];
}

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;

    fac[0] = 1;
    for (int i = 1; i &lt;= 2000; i++) fac[i] = fac[i-1] * i;
    inv_fac[2000] = fac[2000].inv();
    for (int i = 1999; i &gt;= 1; i--) inv_fac[i] = inv_fac[i+1] * (i+1);
    inv_fac[0] = 1;

    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; b[i];
        sum[x[i]][y[i]] = 1;
        mat[i].ul.x = max(1, x[i] - r);
        mat[i].ul.y = max(1, y[i] - r);
        mat[i].ur.x = min(1000, x[i] + r);
        mat[i].ur.y = max(1, y[i] - r);

        mat[i].dl.x = max(1, x[i] - r);
        mat[i].dl.y = min(1000, y[i] + r);
        mat[i].dr.x = min(1000, x[i] + r);
        mat[i].dr.y = min(1000, y[i] + r);
    }

    for (int i = 1; i &lt;= 1e3; i++) {
        for (int j = 1; j &lt;= 1e3; j++) {
            sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];
        }
    }

    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (max(abs(x[i] - x[j]), abs(y[i] - y[j])) &lt;= r) {
                adj[i].push_back(j);
            }
        }
    }

    for (int i = 1; i &lt;= n; i++) {
        Z r = b[i] * b[i] % mod;  // 贡献
        Z s = C(n, m) - C(n - adj[i].size(), m);  // 方案
        ans += r * s;
    }
    for (int i = 1; i &lt;= n; i++) {
        for (int j = i+1; j &lt;= n; j++) {
            // 计算方案数
            Z s = C(n, m);
            int x = adj[i].size() + adj[j].size() - intersect(mat[i], mat[j]);
            s += C(n - x, m);
            s -= C(n - adj[i].size(), m);
            s -= C(n - adj[j].size(), m);

            Z r = 2LL * b[i] * b[j] % mod;

            ans += r * s;
        }
    }
    cout &lt;&lt; ans.val() &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="例2-cf1267k-key-storagehttpscodeforcescomcontest1267problemk">例2 CF1267K. <a href="https://codeforces.com/contest/1267/problem/K" target="_blank">Key Storage</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>对于一个整数 $n$，我们定义它的一个multiset $f(n)$ 为：</p>
<p>初始序列为空，将 <code>n % 2</code> 放入multiset中，然后让 <code>n /= 2</code>，如果此时 $n &gt; 0$，那么继续将 <code>n % 3</code> 放入multiset中，然后 <code>n /= 3</code>，以此类推。</p>
<p>持续执行这个操作直到 $n=0$。</p>
<p>给定一个正整数 $n$，求有多少个其他的正整数 $m$ 使得 $f(n)=f(m)$？</p>
<p>其中，$n \leq 10^{18}$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>首先我们可以计算出 $n$ 对应的 $f(n)$。</p>
<p>那么对于 $f(n)$，我们从小到大来看这个 multiset，第一个位置是 <code>% 2</code> 的结果，所以值必须 $&lt;2$，第二个位置是 <code>% 3</code> 的结果，所以必须 $&lt;3$，以此类推。</p>
<p>• 最后一个位置不能为 $0$，因为除以最后一个数以后，$n$ 变成了 $0$，所以余数是不可能为 $0$ 的。</p>
<p>所以实际上，计算 $f(m)$ 的数量，也就是计算给每个位置填上 multiset 中的元素的方案数，这个方案数要满足以下条件：</p>
<ol>
<li>第 $i$ 个位置的数 $&lt;i+1$。</li>
<li>最后一个位置的数不能为 $0$。</li>
</ol>
<p>先考虑第二种，我们不妨固定最后一位为 $0$，然后用无限制的方案数减去它即可。</p>
<p>现在只剩下第一个条件了，这其实是乘法原理，我们从小到大枚举位置，枚举到第 $i$ 位的时候，就将 $\leq i$ 的数加入选项中。</p>
<p>• 最后需要注意，我们计算的是 multiset 的数量，所以相同元素之间的顺序是无所谓的，所以还要把每个元素的数量的阶乘从答案里除掉。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
ll cnt[30], fac[18];
int T;
int main() {
    cin &gt;&gt; T;
    fac[0] = 1;
    for (int i = 1; i &lt; 18; i++) fac[i] = fac[i-1] * i;
    while (T--) {
        ll n; cin &gt;&gt; n;
        int m = 0;
        for (int i = 2; ; i++) {
            cnt[n % i]++;
            n /= i;
            m++;
            if (!n) break;
        }
        ll sum = cnt[0], ans = 1;
        for (int i = 1; i &lt;= m; i++) {
            // 第 i 个：&lt;= i 的
            sum += cnt[i];
            ans = ans * (sum - i + 1);
        }

        ll tmp = 0;
        if (cnt[0]) {
            tmp = cnt[0];  // 最后一位固定为0，可以有 cnt[0] 种选法
            sum = cnt[0] - 1;  // 预设最后一个为 0
            for (int i = 1; i &lt; m; i++) {
                sum += cnt[i];
                tmp = tmp * (sum - i + 1);
            }
        }

        ans -= tmp;
        for (int i = 0; i &lt; 18; i++) {
            ans /= fac[cnt[i]];
        }

        ans--;
        cout &lt;&lt; ans &lt;&lt; endl;
        memset(cnt, 0, sizeof(cnt));
    }
}
</code></pre>
</details>
<h3 id="例3-atcoder-abc152f-tree-and-constraintshttpsatcoderjpcontestsabc152tasksabc152_f">例3 Atcoder ABC152F. <a href="https://atcoder.jp/contests/abc152/tasks/abc152_f" target="_blank">Tree and Constraints</a></h3>
<div class="admonition question">
  <p class="admonition-title">题意</p>
<p>给定 $n$ 个节点的树，每个边可以被涂成黑色或者白色。</p>
<p>给定 $m$ 个constraint $(u_i,v_i)$，代表 $(u_i,v_i)$ 的路径上至少有一个黑色边？</p>
<p>求有多少钟涂色方案，使得所有constraint都被满足？</p>
<p>其中，$2 \leq n \leq 50, 1 \leq m \leq 20$。</p>
</div>
<details class="admonition note"><summary class="admonition-title">题解</summary>
<p>$m\leq 20$，一眼暴力。</p>
<p>这个至少有一条黑色边很不好处理，但它的补集是<strong>路径上所有都是白色边</strong>。这个就好办了。</p>
<p>所以令 $S_i$ 为：第 $i$ 个constraint没有被满足。</p>
<p>要求的是 $|S_1 \cup S_2 &hellip; \cup S_m|$，即至少有一个constraint没有被满足的方案数量。</p>
<p>根据容斥原理，就是 +1个不满足 - 2个不满足 + 3个不满足 &hellip;</p>
<p>所以我们直接bitmask枚举所有的情况，对于不满足的constraint，它们路径上的所有边只能涂白，剩下的所有边随便涂。然后根据奇偶性判断符号即可。</p>
<p>• 处理constraint的时候用树上差分。</p>
</details>
<details class="admonition note"><summary class="admonition-title">代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 500+5;
const int maxm = 2e6+5;

int n, m;
vector&lt;int&gt; adj[maxn];
ll ans = 1;
pii p[maxn];
int count_bits(ll x) {
    int res = 0;
    while (x) {
        if (x&amp;1) res++;
        x &gt;&gt;= 1;
    }
    return res;
}
int lca[maxn][maxn], par[maxn], dep[maxn], val[maxn];
void dfs(int u, int p) {
    dep[u] = dep[p] + 1;
    for (int v : adj[u]) {
        if (v == p) continue;
        par[v] = u;
        dfs(v, u);
    }
}
void init_lca(int u, int v) {
    int tu = u, tv = v;
    if (u == v) {
        lca[u][v] = lca[v][u] = u;
        return;
    }
    if (dep[u] &lt; dep[v]) swap(u,v);
    while (dep[u] &gt; dep[v]) u = par[u];
    assert(dep[u] == dep[v]);
    while (u != v) {
        u = par[u], v = par[v];
    }
    lca[tu][tv] = lca[tv][tu] = u;
}
ll cnt = 0;
void dfs2(int u, int p) {
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs2(v, u);
        val[u] += val[v];
        if (val[v] &gt; 0) cnt++;  // (u,v) must be white
    }
}
ll p2[maxn];

int main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt; n; i++) {
        int u, v; cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(1, 0);

    p2[0] = 1;
    for (int i = 1; i &lt;= n; i++) p2[i] = p2[i-1] * 2;
    ans = p2[n-1];

    cin &gt;&gt; m;
    for (int i = 1; i &lt;= m; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = i; j &lt;= n; j++) {
            init_lca(i,j);
        }
    }


    for (int mask = 1; mask &lt; (1&lt;&lt;m); mask++) {
        int f = ((count_bits(mask) &amp; 1) ? -1 : 1);
        memset(val, 0, sizeof(val));
        cnt = 0;
        for (int j = 0; j &lt; m; j++) {
            if (mask&amp;(1&lt;&lt;j)) {  // j+1
                int u = p[j+1].first, v = p[j+1].second;
                val[u]++;
                val[v]++;
                val[lca[u][v]] -= 2;
            }
        }
        dfs2(1, 0);
        ans += f * p2[n-1-cnt];
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
</details>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">tom0727</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        <span title="2024-04-01 01:19:54 &#43;0000 UTC">2024-04-01</span>
        <a href="https://github.com/tom0727/hugo-blog/commit/a001fca0dc54488d95cb1d6de4ad6c7db3a0b067" title="chore: update clicks" target="_blank">(a001fca)</a>
        ，<a href="https://github.com/tom0727/hugo-blog/commits/master/content/post/091-%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86.md" target="_blank">更新历史</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/092-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">二进制枚举子集</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/090-%E7%82%B9%E5%88%86%E6%B2%BB/">
            <span class="next-text nav-default">点分治</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="tom0727/tom0727.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huzhenweitom@gmail.com" class="iconfont icon-email" title="email" target="_blank"></a>
      <a href="https://github.com/tom0727" class="iconfont icon-github" title="github" target="_blank"></a>
  <a href="https://tom0727.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io" target="_blank">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ouuan/hugo-theme-even" target="_blank">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2024
    <span class="heart">
      <a class="iconfont icon-github" title="source code" href="https://github.com/tom0727/hugo-blog" target="_blank"></a>
    </span> 
    <span class="author">tom0727</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/base16/tomorrow.min.css" rel="stylesheet">
  
  <script>hljs.configure({tabReplace: '    '});</script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.a97b46e8f6940a9e5434ee4f7eed6f78b15e5336792de56b4ca3b0fb338610ac.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-tom0727', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
