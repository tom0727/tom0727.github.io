<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SCC on tom0727's blog</title><link>https://tom0727.github.io/tags/scc/</link><description>Recent content in SCC on tom0727's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 12 Apr 2021 22:02:41 +0800</lastBuildDate><atom:link href="https://tom0727.github.io/tags/scc/index.xml" rel="self" type="application/rss+xml"/><item><title>强连通分量（SCC）</title><link>https://tom0727.github.io/post/040-tarjan/</link><pubDate>Mon, 12 Apr 2021 22:02:41 +0800</pubDate><guid>https://tom0727.github.io/post/040-tarjan/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;p>在一个 &lt;strong>有向图&lt;/strong> 中，任意取两个节点 $(u,v)$，$u \rightarrow v, v \rightarrow u$ 均有路径，这样的图叫做强连通。&lt;/p>
&lt;p>&lt;strong>SCC（强连通分量）&lt;/strong>：一个极大的强连通子图。&lt;/p>
&lt;p>&lt;strong>缩点&lt;/strong>：当我们求出一个图中的所有 SCC 后，我们可以将每一个 SCC 缩成一个点。缩点过后，我们可以得到一个新的图，我们遍历所有 &lt;strong>原图中的边&lt;/strong>，将原图中的边加到新图中（注意判断 &lt;strong>自环&lt;/strong>，并且一般会出现&lt;strong>重复边&lt;/strong>）。&lt;/p>
&lt;p>• 缩点后得到的图一定是一个 &lt;strong>DAG（有向无环图）&lt;/strong>。&lt;/p>
&lt;p>• DAG 有着很多优秀的性质，比如可以进行 &lt;strong>拓扑排序&lt;/strong>，可以利用 拓扑排序进行 &lt;strong>DP&lt;/strong> 等。&lt;/p>
&lt;p>求一个有向图中的强连通分量，有两种算法，Tarjan 与 kosaraju 算法（复杂度均为 $O(n+m)$）。&lt;/p>
&lt;h2 id="tarjan-求有向图的-scc">Tarjan 求有向图的 SCC&lt;/h2>
&lt;h3 id="算法流程">算法流程&lt;/h3>
&lt;p>定义 $DFS$ 树为：从任意节点出发，形成的一条从上往下的生成树。&lt;/p>
&lt;p>当我们从 $u$ 访问到 direct neighbor $v$ 时，如果 $v$ 尚未被访问过，那么 $(u,v)$ 是一条 &lt;strong>树边&lt;/strong>。否则 $(u,v)$ 是一条 &lt;strong>非树边&lt;/strong>。&lt;/p>
&lt;hr>
&lt;p>我们先维护一个栈 &lt;code>st[]&lt;/code>，里面储存的是我们当前正在处理的 SCC。&lt;/p>
&lt;p>定义两个数组 $dfn[u], low[u]$。&lt;/p>
&lt;ol>
&lt;li>$dfn[u]$ ：DFS过程中，节点 $u$ 的编号（前序编号）。&lt;/li>
&lt;li>$low[u]$ ：当前，在&lt;strong>栈中的所有节点&lt;/strong>，以下两者的最小值：
&lt;ol>
&lt;li>$u$ 的子树中，所有节点 $v$ 的 $low[v]$ 最小值。&lt;/li>
&lt;li>从 $u$ 出发，经过一条 &lt;strong>非树边&lt;/strong> 达到节点 $v$ 的 $dfn[v]$ 的最小值。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-cpp">void dfs(int u) {
// ....
in[u] = 1; // u 进栈
st[++tail] = u; // 进栈
dfn[u] = low[u] = ++id; // 前序编号
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]); // 需要在栈内
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
// ....
&lt;/code>&lt;/pre>
&lt;p>经过 DFS 后，我们可以发现，在 &lt;strong>栈内&lt;/strong>，&lt;strong>有且仅有一个节点&lt;/strong> $u$ 使得 $dfn[u] = low[u]$。这个节点就代表 SCC 在DFS树中的根节点。&lt;/p>
&lt;p>所以，当我们进行DFS回溯的时候，检查一下当前节点 $u$ 是否满足 $dfn[u] = low[u]$。如果满足，将栈中所有的节点（直到 $u$ 为止）全部拿出来，就是一个新的 SCC 了。&lt;/p>
&lt;pre>&lt;code class="language-cpp">// from[u] 代表 u 所在的SCC编号，scc代表scc编号，sz[scc] 代表对应scc的大小
int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn];
bool in[maxn]; // instack or not
int st[maxn], tail = -1;
void dfs(int u) {
in[u] = 1;
st[++tail] = u;
dfn[u] = low[u] = ++id;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]);
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (tail &amp;gt;= 0 &amp;amp;&amp;amp; st[tail] != u) {
int cur = st[tail];
from[cur] = from[u];
sz[scc]++;
tail--;
in[cur] = 0; // 记得这里，将在栈中的标记去掉
}
tail--;
in[u] = 0; // 记得这里，将在栈中的标记去掉
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="例题-洛谷p2341-usaco03fallhaoi2006受欢迎的牛-ghttpswwwluogucomcnproblemp2341">例题 &lt;a href="https://www.luogu.com.cn/problem/P2341" target="_blank">洛谷P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定一个 $N$ 个节点，$M$ 条边的有向图。&lt;/p>
&lt;p>定义一个节点 $u$ 为明星，当且仅当：&lt;/p>
&lt;p>对于 &lt;strong>任意节点&lt;/strong> $v$ ，均有至少一条到 $u$ 的路径。&lt;/p>
&lt;p>问，图中有多少个节点是明星？&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>对原图跑一次tarjan求SCC，然后缩点。&lt;/p>
&lt;p>缩点后，我们会发现 &lt;strong>新图中只有一个明星&lt;/strong>。&lt;/p>
&lt;p>• 如果新图中有 $2$ 个明星，那么 明星 $1$ 存在到 明星 $2$ 的边，反之亦然。那么明星 $1,2$ 就属于同一个SCC，contradiction。&lt;/p>
&lt;p>并且我们会发现，明星的 &lt;strong>out-degree&lt;/strong> 一定为 $0$，否则，明星指向的节点也是一个明星。&lt;/p>
&lt;p>所以，如果缩点后，新图满足：&lt;strong>存在 且 仅存在&lt;/strong> $1$ 个节点，使得它的 &lt;strong>out-degree&lt;/strong> 为 $0$，那么有解，输出这个SCC对应的大小即可。&lt;/p>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">const int maxn = 1e4+5;
const int maxm = 5e4+10;
struct Edge {
int to, nxt;
} edges[maxm];
int head[maxn], ecnt = 1, n,m;
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
int dfn[maxn], low[maxn], id, from[maxn], scc = 0, sz[maxn];
bool in[maxn]; // instack or not
int st[maxn], tail = -1;
void dfs(int u) {
in[u] = 1;
st[++tail] = u;
dfn[u] = low[u] = ++id;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) low[u] = min(low[u], dfn[to]);
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (tail &amp;gt;= 0 &amp;amp;&amp;amp; st[tail] != u) {
int cur = st[tail];
from[cur] = from[u];
sz[scc]++;
tail--;
in[cur] = 0;
}
tail--;
in[u] = 0;
}
}
int deg[maxn];
void build() {
for (int u = 1; u &amp;lt;= n; u++) {
for (int e = head[u]; e; e = edges[e].nxt) {
int v = edges[e].to;
int fu = from[u], fv = from[v];
if (fv == fu) continue; // 记得去掉自环
deg[fu]++;
}
}
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i);
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
int cnt = 0, ans;
for (int i = 1; i &amp;lt;= scc; i++) {
if (!deg[i]) cnt++, ans = i;
}
if (cnt &amp;gt; 1) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
else cout &amp;lt;&amp;lt; sz[ans] &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h2 id="kosaraju-算法">kosaraju 算法&lt;/h2>
&lt;p>kosaraju 算法本质上利用了 &lt;strong>正反 $2$ 次DFS&lt;/strong> 求出一个图中的强连通分量。&lt;/p>
&lt;h3 id="算法流程-1">算法流程&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>建立原图 $G$，和一个反图 $G'$（将所有的边反过来）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在原图 $G$ 上跑 DFS，&lt;strong>回溯&lt;/strong> 的时候记录 ID。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在反图 $G'$ 上跑 DFS，起始节点的顺序是 &lt;strong>ID从大到小&lt;/strong>。每次 DFS 的 &lt;strong>起始节点&lt;/strong> 就代表了一个新的SCC，DFS访问到的所有节点就是这个SCC。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="感性理解">感性理解&lt;/h3>
&lt;p>如果将原图进行一个缩点操作，那么我们可以得到一个DAG：&lt;/p>
&lt;p>&lt;img src="https://tom0727.github.io/images/040/1.jpg" alt="img">&lt;/p>
&lt;p>如上图，可以看出 节点 $1$ 拥有 &lt;strong>支配地位&lt;/strong>（它能到达别的点，但是别的点无法到达它）。&lt;/p>
&lt;p>也可以说，节点 $1$ 在&lt;strong>拓扑序&lt;/strong>中，位置最靠前。&lt;/p>
&lt;p>由于我们是 &lt;strong>回溯&lt;/strong> 的时候才记录 ID，所以节点 $1$ 的 ID 是&lt;strong>最大&lt;/strong>的。&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://tom0727.github.io/images/040/2.jpg" alt="img">&lt;/p>
&lt;p>那么，在反图 $G'$ 中，所有节点的地位反转了，节点 $1$ 的地位最低，且它在拓扑序中，位置最靠后。&lt;/p>
&lt;p>为了找到 SCC，我们希望的就是找到一个节点，使得它无法到达任何其他节点。那么节点 $1$ 就是我们想要的。&lt;/p>
&lt;p>这解释了为什么我们要 &lt;strong>ID从大到小&lt;/strong> 进行反图的 DFS。&lt;/p>
&lt;hr>
&lt;p>注：原图不一定连通，DFS的时候要注意。&lt;/p>
&lt;h3 id="模版题">模版题&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P2863" target="_blank">洛谷P2863 [USACO06JAN]The Cow Prom S&lt;/a>&lt;/p>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定 $n$ 个节点，$m$ 条边的有向图。&lt;/p>
&lt;p>求点数大于 $1$ 的SCC个数。&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码&lt;/summary>
&lt;pre>&lt;code class="language-cpp">const int maxn = 1e4+5;
const int maxm = 5e4+5;
struct Edge {
int to, nxt;
} edges[maxm], redges[maxm];
int head[maxn], rhead[maxn], ecnt = 1, recnt = 1;
void addEdge(int u, int v) {
Edge e = {v, head[u]};
head[u] = ecnt;
edges[ecnt++] = e;
}
void rev_addEdge(int u, int v) {
Edge e = {v, rhead[u]};
rhead[u] = recnt;
redges[recnt++] = e;
}
int id[maxn], idcnt = 0;
bool vis[maxn];
void dfs(int u) {
vis[u] = 1;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (vis[to]) continue; // 已经访问过了，忽略
dfs(to);
}
id[++idcnt] = u; // 回溯的时候更新ID
}
int sz[maxn];
void dfs2(int u) {
sz[u] = 1;
for (int e = rhead[u]; e; e = redges[e].nxt) {
int to = redges[e].to;
if (sz[to]) continue; // 已经访问过，忽略
dfs2(to);
sz[u] += sz[to];
}
}
int main() {
int n,m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
rev_addEdge(v,u);
}
for (int i = 1; i &amp;lt;= n; i++) {
if (!vis[i]) dfs(i);
}
int ans = 0;
for (int i = n; i &amp;gt;= 1; i--) {
if (!sz[id[i]]) { // 还没dfs过，说明这是一个新的SCC
dfs2(id[i]);
if (sz[id[i]] &amp;gt; 1)
ans++;
}
}
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;h2 id="例题">例题&lt;/h2>
&lt;h3 id="例1-洛谷p3119-usaco15jangrass-cownoisseur-ghttpswwwluogucomcnproblemp3119">例1 &lt;a href="https://www.luogu.com.cn/problem/P3119" target="_blank">洛谷P3119 [USACO15JAN]Grass Cownoisseur G&lt;/a>&lt;/h3>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意&lt;/p>
&lt;p>给定一个 $n$ 个节点，$m$ 条边的&lt;strong>有向图&lt;/strong>。&lt;/p>
&lt;p>现在我们需要从 $1$ 号节点出发，走一条路径，再返回到 $1$ 号节点。（每个节点可以被通过多次）。&lt;/p>
&lt;p>我们允许反向穿过一条边，但是只能反向一次。&lt;/p>
&lt;p>输出我们能够访问的 distinct 节点的最大数量。&lt;/p>
&lt;p>其中，$1 \leq n,m \leq 10^5$&lt;/p>
&lt;/div>
&lt;details class="admonition note">&lt;summary class="admonition-title">题解&lt;/summary>
&lt;p>看到 &lt;strong>每个节点可以被穿过多次&lt;/strong>，首先想到缩点。&lt;/p>
&lt;p>缩点后，假设我们去掉 &lt;strong>可以反向一次&lt;/strong> 的这个条件，那么答案就是 $1$ 所属的SCC的大小。&lt;/p>
&lt;hr>
&lt;p>因为我们只能反向一次，我们可以想到利用 &lt;strong>分层图&lt;/strong> 的思想。&lt;/p>
&lt;p>我们先缩点，得到一个新图 $G_1$，然后将缩点后的图 &lt;strong>复制一份&lt;/strong>，得到 $G_2$。&lt;/p>
&lt;p>对于 $G_1$ 中的每条边 $(u_1,v_1)$，我们建一条新边 $(v_1, u_2)$，从 $G_1 \rightarrow G_2$。&lt;/p>
&lt;hr>
&lt;p>观察到我们只能由 $G_1 \rightarrow G_2$，又因为 $G_1 = G_2$ 且 $G_1,G_2$ 均为 DAG，所以整个图中满足以下条件：&lt;/p>
&lt;ol>
&lt;li>无环（仍然是一个DAG）&lt;/li>
&lt;li>$G_1 \rightarrow G_2$ 只能发生一次。（从 $G_2$ 无法返回 $G_1$）&lt;/li>
&lt;/ol>
&lt;p>所以问题就转化为：&lt;/p>
&lt;blockquote>
&lt;p>在这个新图中，从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$，最多能经过多少个节点？&lt;/p>
&lt;/blockquote>
&lt;p>将 $G_1,G_2$（包括$G_1 \rightarrow G_2$）中，所有边 $(u,v)$ 赋上权值 $size[v]$。那么我们只要求&lt;/p>
&lt;p>从 $G_1$ 的 $s_1$（$1$ 所属的SCC）出发，到 $G_2$ 的 $s_1$ 的&lt;strong>最长路&lt;/strong> 即可。&lt;/p>
&lt;hr>
&lt;p>• 注：最长路不能用 dijkstra，只能用 &lt;strong>SPFA&lt;/strong>。复杂度最坏 $O(nm)$&lt;/p>
&lt;p>• 注2：对于 &lt;strong>DAG&lt;/strong> 而言，求最长路也可以直接用 &lt;strong>拓扑排序 + DP&lt;/strong>。复杂度 $O(n+m)$，在DAG中，可以完美替代 SPFA&lt;/p>
&lt;p>• 注3：需要&lt;strong>特判一下原图是不是一个SCC&lt;/strong>（一般这种题都要特判一下）。如果是，直接输出答案 $n$。&lt;/p>
&lt;hr>
&lt;p>正确性证明：我们为什么不需要考虑 &lt;strong>重复经过某个节点&lt;/strong>，然后多算了的情况？&lt;/p>
&lt;p>答：因为我们不可能重复经过某个节点。&lt;/p>
&lt;p>证：如果我们在 $G_1$ 中经过了某个节点 $u$，说明 $1$ 是可以到达 $u$ 的。&lt;/p>
&lt;p>那么，如果在 $G_2$ 中经过了同样的节点 $u$，然后由 $u$ 又返回了 $1$。这说明 $1 \rightarrow u \rightarrow 1$ 是一个环。然而缩点后的图不可能有环，contradiction。&lt;/p>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码（SPFA）&lt;/summary>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 1e5+5;
struct Edge {
int to,nxt;
} edges[maxn];
int head[maxn], ecnt = 1, id = 0, scc = 0, from[maxn], sz[maxn], st[maxn], tail = -1, n, m, dfn[maxn], low[maxn];
bool in[maxn];
void addEdge(int u, int v) {
Edge e = {v, head[u]};
edges[ecnt] = e;
head[u] = ecnt++;
}
void dfs(int u) {
dfn[u] = low[u] = ++id;
in[u] = 1;
st[++tail] = u;
for (int e = head[u]; e; e = edges[e].nxt) {
int to = edges[e].to;
if (dfn[to] &amp;amp;&amp;amp; in[to]) {
low[u] = min(low[u], dfn[to]);
}
if (!dfn[to]) {
dfs(to);
low[u] = min(low[u], low[to]);
}
}
if (dfn[u] == low[u]) {
from[u] = ++scc;
sz[scc] = 1;
while (st[tail] != u) {
int cur = st[tail--];
from[cur] = from[u];
sz[scc]++;
in[cur] = 0;
}
tail--;
in[u] = 0;
}
}
void tarjan() {
for (int i = 1; i &amp;lt;= n; i++) {
if (!dfn[i]) dfs(i);
}
}
struct New_Edge {
int to, nxt, w;
} new_edges[maxn&amp;lt;&amp;lt;2];
int new_head[maxn&amp;lt;&amp;lt;1], new_ecnt = 1;
void new_addEdge(int u, int v, int w) {
New_Edge e = {v, new_head[u], w};
new_head[u] = new_ecnt;
new_edges[new_ecnt++] = e;
}
void build() {
for (int u = 1; u &amp;lt;= n; u++) {
for (int e = head[u]; e; e = edges[e].nxt) {
int v = edges[e].to;
int fu = from[u], fv = from[v];
if (fu == fv) continue; // 注意判重
new_addEdge(fu, fv, sz[fv]); // 原边
new_addEdge(fu+scc, fv+scc, sz[fv]); // 复制
new_addEdge(fv, fu+scc, sz[fu]); // 反向边
}
}
}
int d[maxn&amp;lt;&amp;lt;1], q[maxn&amp;lt;&amp;lt;1]; // 因为复制了一份，记得开2倍大小
bool inq[maxn&amp;lt;&amp;lt;1];
void spfa() {
tail = -1;
q[++tail] = from[1];
inq[from[1]] = 1; // 注意是 from[1]
while (tail &amp;gt;= 0) {
int cur = q[tail--];
for (int e = new_head[cur]; e; e = new_edges[e].nxt) {
int to = new_edges[e].to, w = new_edges[e].w;
if (d[cur] + w &amp;gt; d[to]) { // 无论是否 inq[] 都要更新
d[to] = d[cur] + w;
if (!inq[to])
q[++tail] = to;
inq[to] = 1;
}
}
inq[cur] = 0;
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
spfa();
int ans = d[from[1] + scc]; // 注意是 from[1]
if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;details class="admonition note">&lt;summary class="admonition-title">代码（拓扑排序 &amp;#43; DP）&lt;/summary>
&lt;p>因为其他部分完全一样，这里就省略，只保留 &lt;code>main()&lt;/code> 和 &lt;code>DP&lt;/code> 部分。&lt;/p>
&lt;pre>&lt;code class="language-cpp">
void solve() {
tail = -1;
fill(dp, dp+2*scc+1, -1e9); // 注意赋值为 -inf，因为我们只关心从 from[1] 出发的部分
dp[from[1]] = 0;
for (int u = 1; u &amp;lt;= 2*scc; u++) {
if (!ind[u]) st[++tail] = u;
}
while (tail &amp;gt;= 0) {
int cur = st[tail--];
for (int e = new_head[cur]; e; e = new_edges[e].nxt) {
int to = new_edges[e].to, w = new_edges[e].w;
dp[to] = max(dp[to], dp[cur] + w);
ind[to]--;
if (!ind[to]) st[++tail] = to;
}
}
}
int main() {
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
for (int i = 1; i &amp;lt;= m; i++) {
int u,v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
addEdge(u,v);
}
tarjan();
build();
solve();
int ans = dp[from[1] + scc]; // 注意是 from[1]
if (scc == 1) ans = n; // 需要特判一下整个图是否为强连通分量
cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
}
&lt;/code>&lt;/pre>
&lt;/details></description></item></channel></rss>